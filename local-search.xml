<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Feign服务间调用请求头丢失问题</title>
    <link href="/2022/09/29/java/Feign%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%B0%83%E7%94%A8%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/29/java/Feign%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%B0%83%E7%94%A8%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>客户端带请求头请求接口–&gt;接口调用其他服务的接口会导致请求头丢失问题</p><p>例子：有两个服务A和B，都加了认证拦截器，客户端调用服务A接口时会携带<code>cookie</code>请求头信息，经过服务A认证拦截器后调用服务B接口，在经过服务B拦截器时会发现请求头<code>cookie</code>丢失问题</p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>Feign 远程调用时会生成代理对象，代理对象调用时会经过一些逻辑判断和一系列的拦截器，构造出新的Request对象，Request默认为空，所以导致请求头丢失问题</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>如果生成代理对象后再经过我们定义的拦截器，将请求头加上去再调用远程服务就可以解决这个问题；</p><p><img src="img.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> feign.RequestInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.context.request.RequestContextHolder;<br><span class="hljs-keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Feign 配置类，解决Feign调用请求头丢失问题</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeignConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean(&quot;requestInterceptor&quot;)</span><br>    <span class="hljs-keyword">public</span> RequestInterceptor <span class="hljs-title function_">requestInterceptor</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-type">RequestInterceptor</span> <span class="hljs-variable">requestInterceptor</span> <span class="hljs-operator">=</span> template -&gt; &#123;<br>            <span class="hljs-comment">//1、使用RequestContextHolder拿到刚进来的请求数据（原理：通过ThreadLocal存取）</span><br>            <span class="hljs-type">ServletRequestAttributes</span> <span class="hljs-variable">requestAttributes</span> <span class="hljs-operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();<br><br>            <span class="hljs-keyword">if</span> (requestAttributes != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> requestAttributes.getRequest();<br>                <span class="hljs-comment">//2、同步请求头的数据（例如把cookie放到新的请求头中）</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;token&quot;</span>);<br>                template.header(<span class="hljs-string">&quot;token&quot;</span>, token);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">return</span> requestInterceptor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><img src="img_1.png"></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://codeantenna.com/a/nWgdG0MWx7">Feign服务间调用请求头丢失问题（整理）</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>feign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解 OpenFeign 远程调用的架构原理</title>
    <link href="/2022/09/27/java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20OpenFeign%20%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E7%9A%84%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/"/>
    <url>/2022/09/27/java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20OpenFeign%20%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E7%9A%84%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6aa8ace980894507aef8610253e4528a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://juejin.cn/post/7114293942014869540">深入理解 OpenFeign 远程调用的架构原理</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>OpenFeign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大白话聊 Web3——终将到来的时代，会如我们所想吗</title>
    <link href="/2022/09/26/web3/%E5%A4%A7%E7%99%BD%E8%AF%9D%E8%81%8A%20Web3%E2%80%94%E2%80%94%E7%BB%88%E5%B0%86%E5%88%B0%E6%9D%A5%E7%9A%84%E6%97%B6%E4%BB%A3%EF%BC%8C%E4%BC%9A%E5%A6%82%E6%88%91%E4%BB%AC%E6%89%80%E6%83%B3%E5%90%97/"/>
    <url>/2022/09/26/web3/%E5%A4%A7%E7%99%BD%E8%AF%9D%E8%81%8A%20Web3%E2%80%94%E2%80%94%E7%BB%88%E5%B0%86%E5%88%B0%E6%9D%A5%E7%9A%84%E6%97%B6%E4%BB%A3%EF%BC%8C%E4%BC%9A%E5%A6%82%E6%88%91%E4%BB%AC%E6%89%80%E6%83%B3%E5%90%97/</url>
    
    <content type="html"><![CDATA[<ul><li>web和web3之间的关系就是雷锋和雷峰塔之间的关系——也就是没有关系</li><li>web3跟web2比，你会发现方方面面都是退步（比如区块链的传输交易可能需要几十分钟，区块链的存储需要钱还很贵）。这时候八成是你看错了这个东西的本质——你不能拿着皮鞋当筷子用，然后抱怨这个筷子不好用</li><li>互联网是把很多已有网络连起来了，连成了一张全球唯一共同的一张大网络；区块链是一张全球所有人共享的一张数据表，table one（只能append到最后一行，不能删和改）</li><li>web3不是下一代的互联网，它是基于互联网的新东西。比如计算机是基于电力的，互联网是基于计算机的，区块链是基于互联网的</li><li>当一个新技术忽然出现了，很显然是没有（现有）应用场景的。就像互联网出现后大家没头苍蝇一样找各种应用，等浏览器出现后 web才出现。<ul><li>eg1：像微信这种1s发一条信息，在美国1s能收到，这样的需求是不存在的，大家觉得信一天能寄到已经是不可思议了。</li><li>eg2：当有了几乎是无限的带宽后，大家才想着找应用，才有了4k 8k电视这样的探索</li></ul></li><li>没有基础设施的原因是没有需求，没有需求是因为应用做不出来，应用做不出来是因为没有基础设施,这是一个死锁.所以技术的发展要有自己的节奏，需要“左脚走一步，右脚才能走一步，左脚才能再走一步”</li><li>要看一个技术实现了哪些以前没法实现的东西，越底层它可能对世界的影响就越大。（互联网初期：1 bit信息可以几乎0时间0成本传到世界任一角落）区块链创造了人类历史上从没有过的新能力：人类第一次有了一个可以共同相信的东西</li><li>大家的误区是总觉得新世界会取代旧世界。no，区块链只是在现实的世界上面又叠加了一层</li><li>（什么时候适合进入web3）当你适合进入的时候 你自然会知道的，有人告诉你一个东西你觉得挺好用的，就自然而然进入了。这个其实不是你的胜利，是整个web3的胜利，它把你赢得了</li></ul><h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><ul><li><a href="https://www.xiaoyuzhoufm.com/episode/62d93b1cfa15142e17251e05">大白话聊 Web3——终将到来的时代，会如我们所想吗？（Sarah &amp; 王建硕）</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Difference between Subarray, Subsequence, and Subset</title>
    <link href="/2022/09/26/algorithm/Difference%20between%20Subarray,%20Subsequence,%20and%20Subset/"/>
    <url>/2022/09/26/algorithm/Difference%20between%20Subarray,%20Subsequence,%20and%20Subset/</url>
    
    <content type="html"><![CDATA[<p>This post will discuss the difference between a subarray, a substring, a subsequence, and a subset.</p><h1 id="1-Subarray"><a href="#1-Subarray" class="headerlink" title="1. Subarray"></a>1. Subarray</h1><p>A subarray is a slice from a contiguous array (i.e., occupy consecutive positions) and inherently maintains the order of elements. For example, the subarrays of array {1, 2, 3} are {1}, {1, 2}, {1, 2, 3}, {2}, {2, 3}, and {3}.</p><p>Please note that there are precisely n×(n+1)/2 subarrays in an array of size n. Also, there is no such thing as a contiguous subarray. The prefix contiguous is sometimes applied to make the context more clear. So, a contiguous subarray is just another name for a subarray.</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span><br>&#123;<br>    <span class="hljs-comment">// Function to print all subarrays of the specified array</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printAllSubarrays</span><span class="hljs-params">(List&lt;Integer&gt; input)</span><br>    &#123;<br>        <span class="hljs-comment">// consider all subarrays starting from `i`</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; input.size(); i++)<br>        &#123;<br>            <span class="hljs-comment">// consider all subarrays ending at `j`</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; input.size(); j++)<br>            &#123;<br>                <span class="hljs-comment">// Function to print a subarray formed by [i, j]</span><br>                System.out.println(input.subList(i, j + <span class="hljs-number">1</span>));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        List&lt;Integer&gt; input = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>        printAllSubarrays(input);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>Output:</p><p>[1]<br>[1, 2]<br>[1, 2, 3]<br>[1, 2, 3, 4]<br>[1, 2, 3, 4, 5]<br>[2]<br>[2, 3]<br>[2, 3, 4]<br>[2, 3, 4, 5]<br>[3]<br>[3, 4]<br>[3, 4, 5]<br>[4]<br>[4, 5]<br>[5]</p><h1 id="2-Substring"><a href="#2-Substring" class="headerlink" title="2. Substring"></a>2. Substring</h1><p>A substring of a string s is a string s’ that occurs in s. A substring is almost similar to a subarray, but it is in the context of strings.</p><p>For example, the substrings of string ‘apple’ are ‘apple’, ‘appl’, ‘pple’, ‘app’, ‘ppl’, ‘ple’, ‘ap’, ‘pp’, ‘pl’, ‘le’, ‘a’, ‘p’, ‘l’, ‘e’, ‘’.</p><h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span><br>&#123;<br>    <span class="hljs-comment">// Function to print all non-empty substrings of the specified string</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printAllSubstrings</span><span class="hljs-params">(String str)</span><br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> str.length();<br> <br>        <span class="hljs-comment">// consider all substrings starting from `i`</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-comment">// consider all substrings ending at j</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; j++) &#123;<br>                System.out.print(<span class="hljs-string">&quot;&#x27;&quot;</span> + str.substring(i, j + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;&#x27;, &quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;techie&quot;</span>;<br>        printAllSubstrings(str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Output:</p><p>‘t’, ‘te’, ‘tec’, ‘tech’, ‘techi’, ‘techie’, ‘e’, ‘ec’, ‘ech’, ‘echi’, ‘echie’, ‘c’, ‘ch’, ‘chi’, ‘chie’, ‘h’, ‘hi’, ‘hie’, ‘i’, ‘ie’, ‘e’</p><h1 id="3-Subsequence"><a href="#3-Subsequence" class="headerlink" title="3. Subsequence"></a>3. Subsequence</h1><p>A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. For example, {nums, B, D} is a subsequence of sequence {nums, B, C, D, E} obtained after removing {C} and {E}.</p><p>People are often confused between a subarray/substring and a subsequence. A subarray or substring will always be contiguous, but a subsequence need not be contiguous. That is, subsequences are not required to occupy consecutive positions within the original sequences. But we can say that both contiguous subsequence and subarray are the same.</p><p>In other words, the subsequence is a generalization of a substring, or substring is a refinement of the subsequence. For example, {nums, C, E} is a subsequence of {nums, B, C, D, E}, but not a substring, and {nums, B, C} is both a subarray and a subsequence.</p><p>Please note that a subsequence can be in the context of both arrays and strings. Generating all subsequences of an array/string is equivalent to generating a power set of an array/string. For a given set, S, we can find the power set by generating all binary numbers between 0 and 2n-1, where n is the size of the given set. </p><h2 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span><br>&#123;<br>    <span class="hljs-comment">// Function to print all subsequences of the specified string</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findPowerSet</span><span class="hljs-params">(String str)</span><br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> str.length();<br> <br>        <span class="hljs-comment">// N stores the total number of subsets</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)Math.pow(<span class="hljs-number">2</span>, n);<br> <br>        List&lt;String&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br> <br>        <span class="hljs-comment">// generate each subset one by one</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++)<br>        &#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br> <br>            <span class="hljs-comment">// check every bit of `i`</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)<br>            &#123;<br>                <span class="hljs-comment">// if j&#x27;th bit of `i` is set, print S[j]</span><br>                <span class="hljs-keyword">if</span> ((i &amp; (<span class="hljs-number">1</span> &lt;&lt; j)) != <span class="hljs-number">0</span>) &#123;<br>                    sb.append(str.charAt(j));<br>                &#125;<br>            &#125;<br>            result.add(<span class="hljs-string">&quot;&#x27;&quot;</span> + sb.toString() + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        &#125;<br> <br>        System.out.println(result);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;apple&quot;</span>;<br>        findPowerSet(str);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>Output:</p><p>[‘’, ‘a’, ‘p’, ‘ap’, ‘p’, ‘ap’, ‘pp’, ‘app’, ‘l’, ‘al’, ‘pl’, ‘apl’, ‘pl’, ‘apl’, ‘ppl’, ‘appl’, ‘e’, ‘ae’, ‘pe’, ‘ape’, ‘pe’, ‘ape’, ‘ppe’, ‘appe’, ‘le’, ‘ale’, ‘ple’, ‘aple’, ‘ple’, ‘aple’, ‘pple’, ‘apple’]</p><h1 id="4-Subset"><a href="#4-Subset" class="headerlink" title="4. Subset"></a>4. Subset</h1><p>A subset is any possible combination of the original set. The term subset is often used for subsequence, but that’s not right. A subsequence always maintains the relative order of the array elements (i.e., increasing index), but there is no such restriction on a subset. For example, {3, 1} is a valid subset of {1, 2, 3, 4, 5}, but it is neither a subsequence nor a subarray.</p><p>It is worth noting that all subarrays are subsequences and all subsequences are a subset, but the reverse is not valid. For instance, a subarray {1, 2} of array {1, 2, 3, 4, 5} is also a subsequence and a subset.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://www.techiedelight.com/difference-between-subarray-subsequence-subset/">Difference between Subarray, Subsequence, and Subset</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>algorithm</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Spring配置属性管理--Environment</title>
    <link href="/2022/09/23/spring/Spring%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E7%AE%A1%E7%90%86--Environment/"/>
    <url>/2022/09/23/spring/Spring%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E7%AE%A1%E7%90%86--Environment/</url>
    
    <content type="html"><![CDATA[<p>在上一篇文章中 Spring配置属性管理—Value注解解析我们从@Value注解入手大致讲解了一下配置属性在Spring项目中应用的基本原理，本文将会围绕Spring的Environment对org.springframework.core.env包中的重要类进行进一步的解析。</p><blockquote><p>The Environment interface is an abstraction integrated in the container that models two key aspects of the application environment: profiles and properties.</p><p>A profile is a named, logical group of bean definitions to be registered with the container only if the given profile is active. Beans may be assigned to a profile whether defined in XML or with annotations. The role of the Environment object with relation to profiles is in determining which profiles (if any) are currently active, and which profiles (if any) should be active by default.</p><p>Properties play an important role in almost all applications and may originate from a variety of sources: properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc Properties objects, Map objects, and so on. The role of the Environment object with relation to properties is to provide the user with a convenient service interface for configuring property sources and resolving properties from them.</p></blockquote><p>在Spring的官方文档中我们可以得知，在Spring框架中Environment主要负责两个Profiles于Properties两个部分。这两个部分对于我们而言基本上是耳熟能详的了，Profiles通常用于应用区分环境（例如测试、预发、正式加载不同的属性配置或者是Bean配置），Properties则是Spring用于管理配置文件属性的重要组件。本文我们重点关注一下Properties相关的原理。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ApplicationContext ctx = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GenericApplicationContext()</span>;<br>Environment env = ctx.get<span class="hljs-constructor">Environment()</span>;<br>boolean containsMyProperty = env.contains<span class="hljs-constructor">Property(<span class="hljs-string">&quot;my-property&quot;</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;Does my environment contain the &#x27;my-property&#x27; property? &quot;</span> + containsMyProperty);<br></code></pre></td></tr></table></figure><p>除了在上一篇文章中提到的利用@Value注解来获取配置属性以外，我们还可以通过上面的代码片段利用Environment来获取到配置属性（通常在应用中使用的是自动注入的Environment），默认单机应用的情况下在ApplicationContext中的Environment的具体实现类是StandardEnvironment，在其中配置了两个默认的PropertySource(属性数据源)分别是JVM系统数据以及操作系统环境变量属性，在Spring Web应用中则是由StandardServletEnvironment负责具体的实现，增加了Servlet配置相关的数据源。</p><p><img src="img.png"></p><p>我们围绕这张UML类图来分析StandardEnvironment是如何为Spring应用程序提供属性配置的。</p><p>PropertyResolver定义了从属性配置源的获取属性的基本功能接口，主要包含三种类型的接口：获取字符串类型属性、获取指定类型的属性以及利用属性解析字符串中的占位符。</p><p>ConfigurablePropertyResolver进一步完善了属性相关的接口定义，提供了自定义属性解析的相关接口，例如配置属性类型转换器、占位符设置等。</p><p>而在ConfigurableEnvironment中则定义了获取属性源的相关的接口，在这个接口中我们可以注意到，默认情况下Environment一定会存在两个属性，一个是SystemProperties另一个是SystemEnvironment。</p><p>再往下则是AbstractEnvironment，在这个抽象类中实现了大部分的属性相关功能，总的来说可以分为两个部分，也是最重要的两个部分，负责属性存储管理的MutablePropertySources以及负责属性解析的ConfigurablePropertyResolver。</p><p>StandardEnvironment与StandardServletEnvironment实际上并没有实现太多的功能，而是根据自己不同的特性为AbstractEnvironment添加了默认的属性源。</p><h1 id="MutablePropertySources"><a href="#MutablePropertySources" class="headerlink" title="MutablePropertySources"></a>MutablePropertySources</h1><p>MutablePropertySources实现了PropertySources接口，PropertySources定义了属性源PropertySource容器相关的接口（例如遍历属性源、根据名称获取属性源等），PropertySource与Java中常用的Properties类似，不同的是除了定义了查询属性的方法外，每个属性源还包含一个属性源的名称。</p><p>在MutablePropertySources中，使用一个CopyOnWriteArrayList来存储PropertySource，为什么用的不是Map来保存呢？因为不同的属性源是有优先级区别的，高优先级属性会覆盖低优先级的属性（MutablePropertySources提供了addFirst、addLast属性）。那为什么用的不是普通的List而需要用的是CopyOnWriteArrayList呢，因为CopyOnWriteArrayList提供了更加稳定的遍历功能，获取属性源的时候如下所示使用的是遍历的方式，而属性源的变更在应用中通常是低频的。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># org.springframework.core.env.MutablePropertySources.<span class="hljs-keyword">get</span><br><span class="hljs-built_in">public</span> PropertySource&lt;?&gt; <span class="hljs-keyword">get</span>(String <span class="hljs-type">name</span>) &#123;<br><span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = this.propertySourceList.indexOf(PropertySource.named(<span class="hljs-type">name</span>));<br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">index</span> != <span class="hljs-number">-1</span> ? this.propertySourceList.<span class="hljs-keyword">get</span>(<span class="hljs-keyword">index</span>) : <span class="hljs-keyword">null</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在spring-core的env包下提供了两种比较常用的PropertySource的具体实现类，分别是以Properties作为数据源的PropertiesPropertySource、以Map对象作为数据源的MapPropertySource，以存储系统环境变量的SystemEnvironmentPropertySource为例，继承了MapPropertySource，将System.getenv()返回的属性转换为Map作为数据源，默认的属性源的名称是systemEnvironment。</p><p>在前面提到默认的情况下Environment中包含两个JVM系统属性与操作系统属性，那是在什么时候被添加到AbstractEnvironment中的MutablePropertySources的呢，回到StandardEnvironment的customizePropertySources中，这个函数主要是用于不同的Environment来添加自定义的属性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># org.springframework.core.env.StandardEnvironment.customizePropertySources</span><br><br>@<span class="hljs-function">Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-type">void</span> <span class="hljs-title">customizePropertySources</span><span class="hljs-params">(MutablePropertySources propertySources)</span> </span>&#123;<br>propertySources.<span class="hljs-built_in">addLast</span>(<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">PropertiesPropertySource</span>(SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, <span class="hljs-built_in">getSystemProperties</span>()));<br>propertySources.<span class="hljs-built_in">addLast</span>(<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">SystemEnvironmentPropertySource</span>(SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, <span class="hljs-built_in">getSystemEnvironment</span>()));<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="ConfigurablePropertyResolver"><a href="#ConfigurablePropertyResolver" class="headerlink" title="ConfigurablePropertyResolver"></a>ConfigurablePropertyResolver</h1><p>在上一篇文章中我们提到了无论是AbstractEnvironment还是PropertySourcesPlaceholderConfigurer中，真正负责属性解析的都是PropertySourcesPropertyResolver。PropertySourcesPropertyResolver继承自AbstractPropertyResolver，AbstractPropertyResolver实现了属性解析的大部分的功能模版，例如使用PropertyPlaceholderHelper解析占位符，利用ConfigurableConversionService完成属性到目标类型的转换等，而PropertySourcesPropertyResolver负责数据源的存储以及实现属性获取的基本功能。以下面的函数为例，PropertySourcesPropertyResolver在查找属性时，会遍历所有的PropertySource，首先直接通过key获取属性，当属性不存在的时在解析占位符，最后利用ConversionService完成属性转换。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"># org.springframework.core.env.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PropertySourcesPropertyResolver</span>.</span></span>get<span class="hljs-constructor">Property(<span class="hljs-params">java</span>.<span class="hljs-params">lang</span>.String, <span class="hljs-params">java</span>.<span class="hljs-params">lang</span>.Class&lt;T&gt;, <span class="hljs-params">boolean</span>)</span><br><br>@Nullable<br>protected &lt;T&gt; T get<span class="hljs-constructor">Property(String <span class="hljs-params">key</span>, Class&lt;T&gt; <span class="hljs-params">targetValueType</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">resolveNestedPlaceholders</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (this.propertySources != null) &#123;<br><span class="hljs-keyword">for</span> (PropertySource&lt;?&gt; propertySource : this.propertySources) &#123;<br><span class="hljs-keyword">if</span> (logger.is<span class="hljs-constructor">TraceEnabled()</span>) &#123;<br>logger.trace(<span class="hljs-string">&quot;Searching for key &#x27;&quot;</span> + key + <span class="hljs-string">&quot;&#x27; in PropertySource &#x27;&quot;</span> +<br>propertySource.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>&#125;<br>Object value = propertySource.get<span class="hljs-constructor">Property(<span class="hljs-params">key</span>)</span>;<br><span class="hljs-keyword">if</span> (value != null) &#123;<br><span class="hljs-keyword">if</span> (resolveNestedPlaceholders<span class="hljs-operator"> &amp;&amp; </span>value instanceof String) &#123;<br>value = resolve<span class="hljs-constructor">NestedPlaceholders((String)</span> value);<br>&#125;<br>log<span class="hljs-constructor">KeyFound(<span class="hljs-params">key</span>, <span class="hljs-params">propertySource</span>, <span class="hljs-params">value</span>)</span>;<br>return convert<span class="hljs-constructor">ValueIfNecessary(<span class="hljs-params">value</span>, <span class="hljs-params">targetValueType</span>)</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (logger.is<span class="hljs-constructor">TraceEnabled()</span>) &#123;<br>logger.trace(<span class="hljs-string">&quot;Could not find key &#x27;&quot;</span> + key + <span class="hljs-string">&quot;&#x27; in any property source&quot;</span>);<br>&#125;<br>return null;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="自定义属性数据源"><a href="#自定义属性数据源" class="headerlink" title="自定义属性数据源"></a>自定义属性数据源</h1><p>在上一篇文章中我们知道通过配置PropertySourcesPlaceholderConfigurer可以自动的加载本地的Resource文件，与Environment中的属性组合成一个新的PropertySources，在BeanFactory注入ValueResolver中来使得自定义属性添加到属性解析的流程中。然而通过这种方式注入的属性是无法直接通过Environment获取的，通过上面的简单分析，我们可以得知如果想要在应用中加入自定义的属性源只需要获取到Environment中的MutablePropertySources，将属性源添加到其中即可。那么注入的时间点就非常的重要，如果应用启动后再去注入自定义的属性源的话，那么初始化过程中的@Value注解等就无法获取到自定义的属性数据源。</p><p>对于纯原生的Spring项目而言，我们可以在创建ApplicationContext时获取到Environment来完成自定义属性源的注入。当然也可以利用BeanPostProcessor结合EnvironmentAware来获取到Environment完成，但这种方式只受益于Bean，对于在其之前执行的BeanPostProcessor则不生肖。</p><p>对于Spring Boot项目而言实际上是有比较明确的注入点的，我们来看下SpringBoot启动的代码片段。首先会根据SPI获取到项目中所有的SpringApplicationRunListeners，然后创建Environment，在prepareEnvironment函数中创建完Environment后会调用listeners.environmentPrepared通过EventPublishingRunListener广播ApplicationEnvironmentPreparedEvent事件，EnvironmentPostProcessorApplicationListener在收到事件后会获取到应用中的EnvironmentPostProcessor调用postProcessEnvironment来自定义处理Environment。在这个监听器中处理自定义数据源的注入是最早的一个注入点（在后续Nacos-spring-boot的项目中我们也会提到）。ConfigDataEnvironmentPostProcessor即是利用了这一机制来完成application.properties配置的加载与注入。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta"># org.springframework.boot.SpringApplication.run(java.lang.String...)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Run the Spring application, creating and refreshing a new</span><br><span class="hljs-comment"> * &#123;@link ApplicationContext&#125;.</span><br><span class="hljs-comment"> * @param args the application arguments (usually passed from a Java main method)</span><br><span class="hljs-comment"> * @return a running &#123;@link ApplicationContext&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> ConfigurableApplicationContext run(<span class="hljs-keyword">String</span>... args) &#123;<br>StopWatch stopWatch = <span class="hljs-keyword">new</span> <span class="hljs-type">StopWatch</span>();<br>stopWatch.start();<br>ConfigurableApplicationContext context = <span class="hljs-literal">null</span>;<br>Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>configureHeadlessProperty();<br>SpringApplicationRunListeners listeners = getRunListeners(args);<br>listeners.starting();<br><span class="hljs-keyword">try</span> &#123;<br>ApplicationArguments applicationArguments = <span class="hljs-keyword">new</span> <span class="hljs-type">DefaultApplicationArguments</span>(args);<br>ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);<br>configureIgnoreBeanInfo(environment);<br>Banner printedBanner = printBanner(environment);<br>context = createApplicationContext();<br>exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,<br><span class="hljs-keyword">new</span> <span class="hljs-type">Class</span>[] &#123; ConfigurableApplicationContext.<span class="hljs-class"><span class="hljs-keyword">class</span> &#125;, <span class="hljs-title">context</span>);</span><br><span class="hljs-class"><span class="hljs-title">prepareContext</span>(<span class="hljs-title">context</span>, <span class="hljs-title">environment</span>, <span class="hljs-title">listeners</span>, <span class="hljs-title">applicationArguments</span>, <span class="hljs-title">printedBanner</span>);</span><br><span class="hljs-class"><span class="hljs-title">refreshContext</span>(<span class="hljs-title">context</span>);</span><br><span class="hljs-class"><span class="hljs-title">afterRefresh</span>(<span class="hljs-title">context</span>, <span class="hljs-title">applicationArguments</span>);</span><br><span class="hljs-class"><span class="hljs-title">stopWatch</span>.<span class="hljs-title">stop</span>();</span><br><span class="hljs-class"><span class="hljs-title">if</span> (<span class="hljs-title">this</span>.<span class="hljs-title">logStartupInfo</span>) </span>&#123;<br><span class="hljs-keyword">new</span> <span class="hljs-type">StartupInfoLogger</span>(<span class="hljs-built_in">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);<br>&#125;<br>listeners.started(context);<br>callRunners(context, applicationArguments);<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>handleRunFailure(context, ex, exceptionReporters, listeners);<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalStateException</span>(ex);<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br>listeners.running(context);<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>handleRunFailure(context, ex, exceptionReporters, <span class="hljs-literal">null</span>);<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalStateException</span>(ex);<br>&#125;<br><span class="hljs-keyword">return</span> context;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://juejin.cn/post/6992866279061356551/">Spring配置属性管理（二）— Environment</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>Value</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring配置属性管理(一)-Value注解解析</title>
    <link href="/2022/09/23/spring/Spring%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E7%AE%A1%E7%90%86%E2%80%94%20@Value%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/09/23/spring/Spring%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E7%AE%A1%E7%90%86%E2%80%94%20@Value%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>为了能够更好的说明nacos-spring-project的设计原理，我们将首先介绍一下在Spring框架中是如何管理系统属性以及用户的配置属性的。本文将从一个项目中常用的属性使用例子入手，简要的分析属性解析注入的过程，在后续的文章中将从Environment的角度分析Spring是如何进行全局的属性管理的（# Spring配置属性管理（二）— Environment）</p><h1 id="Value注解"><a href="#Value注解" class="headerlink" title="@Value注解"></a>@Value注解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;test&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String test;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在项目中，如上面的代码片段所示，我们通常会在Service Bean中利用@Value注解来注入配置文件（例如application.properties）中的某些自定义配置属性，这些属性实际上都是由Spring Environment负责进行统一管理与解析的，而由AutowiredAnnotationBeanPostProcessor负责在Bean中对@Value注解进行解析注入属性的。</p><p>AutowiredAnnotationBeanPostProcessor实现了SmartInstantiationAwareBeanPostProcessor以及MergedBeanDefinitionPostProcessor接口，在程序初始化时主要完成了两件事：</p><ul><li>在postProcessMergedBeanDefinition接口中解析每个Bean的BeanDefinition，查找Bean中所有被定义的@Value以及@Autowired(本文不作细致分析)，并解析成InjectionMetadata</li><li>在postProcessProperties接口中找到Bean以及对应属性的InjectionMetadata，由InjectionMetadata来负责对PropertyValues进行注入</li></ul><h1 id="postProcessMergedBeanDefinition"><a href="#postProcessMergedBeanDefinition" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h1><p>在postProcessMergedBeanDefinition中最重要的任务就是从BeanDefinition中构造出InjectionMetadata，InjectionMetadata顾名思义即表示了每个Bean注入的元信息。AutowiredAnnotationBeanPostProcessor中的injectionMetadataCache缓存了所有Bean的InjectionMetadata，而InjectionMetadata中每个需要被注入的点都用一个InjectedElement来表示。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"># org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.buildAutowiringMetadata<br><br><span class="hljs-keyword">private</span> InjectionMetadata buildAutowiringMetadata(<span class="hljs-keyword">final</span> <span class="hljs-keyword">Class</span>&lt;?&gt; clazz) <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">if (!AnnotationUtils.isCandidateClass(clazz, this.autowiredAnnotationTypes)) &#123;</span><br><span class="hljs-comment">return InjectionMetadata.EMPTY;</span><br><span class="hljs-comment">&#125;</span><br><br>List&lt;InjectionMetadata.InjectedElement&gt; elements = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;()<span class="hljs-punctuation">;</span><br><span class="hljs-keyword">Class</span>&lt;?&gt; targetClass = clazz<span class="hljs-punctuation">;</span><br><br><span class="hljs-keyword">do</span> <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">final List&lt;InjectionMetadata.InjectedElement&gt; currElements = new ArrayList&lt;&gt;();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">ReflectionUtils.doWithLocalFields(targetClass, field -&gt; &#123;</span><br><span class="hljs-comment"> //获取Field上的@Value或@Autowired注解</span><br><span class="hljs-comment">MergedAnnotation&lt;?&gt; ann = findAutowiredAnnotation(field);</span><br><span class="hljs-comment">if (ann != null) &#123;</span><br><span class="hljs-comment">//忽略静态属性</span><br><span class="hljs-comment">if (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="hljs-comment">if (logger.isInfoEnabled()) &#123;</span><br><span class="hljs-comment">logger.info(&quot;Autowired annotation is not supported on static fields: &quot; + field);</span><br><span class="hljs-comment">&#125;</span><br>return<span class="hljs-punctuation">;</span><br>&#125;<br>   <span class="hljs-comment">//判断属性上的required参数</span><br>boolean required = determineRequiredStatus(ann)<span class="hljs-punctuation">;</span><br>currElements.add(<span class="hljs-keyword">new</span> AutowiredFieldElement(field, required))<span class="hljs-punctuation">;</span><br>&#125;<br>&#125;)<span class="hljs-punctuation">;</span><br><br>ReflectionUtils.doWithLocalMethods(targetClass, <span class="hljs-keyword">method</span> -&gt; <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="hljs-comment">if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</span><br><span class="hljs-comment">return;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-title function_">MergedAnnotation</span>&lt;?&gt; <span class="hljs-title function_">ann</span> = <span class="hljs-title function_">findAutowiredAnnotation</span><span class="hljs-params">(bridgedMethod)</span>;<br><span class="hljs-keyword">if</span> (ann != null &amp;&amp; <span class="hljs-keyword">method</span>.equals(ClassUtils.getMostSpecificMethod(<span class="hljs-keyword">method</span>, <span class="hljs-title function_">clazz</span>))) <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">if (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="hljs-comment">if (logger.isInfoEnabled()) &#123;</span><br><span class="hljs-comment">logger.info(&quot;Autowired annotation is not supported on static methods: &quot; + method);</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-title function_">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">method</span>.getParameterCount() == <span class="hljs-number">0</span>) <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">if (logger.isInfoEnabled()) &#123;</span><br><span class="hljs-comment">logger.info(&quot;Autowired annotation should only be used on methods with parameters: &quot; +</span><br><span class="hljs-comment">method);</span><br><span class="hljs-comment">&#125;</span><br>&#125;<br>boolean required = determineRequiredStatus(ann)<span class="hljs-punctuation">;</span><br>PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz)<span class="hljs-punctuation">;</span><br>currElements.add(<span class="hljs-keyword">new</span> AutowiredMethodElement(<span class="hljs-keyword">method</span>, <span class="hljs-title function_">required</span>, <span class="hljs-title function_">pd</span>));<br>&#125;<br>&#125;)<span class="hljs-punctuation">;</span><br><br>elements.addAll(<span class="hljs-number">0</span>, currElements)<span class="hljs-punctuation">;</span><br>targetClass = targetClass.getSuperclass()<span class="hljs-punctuation">;</span><br>&#125;<br><span class="hljs-keyword">while</span> (targetClass != null &amp;&amp; targetClass != Object.class)<span class="hljs-punctuation">;</span><br><br>return InjectionMetadata.forElements(elements, clazz)<span class="hljs-punctuation">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="postProcessProperties"><a href="#postProcessProperties" class="headerlink" title="postProcessProperties"></a>postProcessProperties</h1><p>在postProcessProperties函数中首先会根据当前的Bean找到解析过的InjectionMetadata，然后利用InjectionMetadata的inject函数完成注入，inject函数中会遍历所有的InjectionElement并调用其Inject方法来完成每个注入点的注入，这里我们以AutowiredFieldElement为例，重点看一下配置属性是如解析并注入到Bean当中的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"># org.springframework.beans.factory.<span class="hljs-keyword">annotation</span>.AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement.inject<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> void inject(Object bean, <span class="hljs-meta">@Nullable</span> String beanName, <span class="hljs-meta">@Nullable</span> PropertyValues pvs) throws Throwable &#123;<br>Field field = (Field) <span class="hljs-keyword">this</span>.member;<br>Object value;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cached) &#123;<br>value = resolvedCachedArgument(beanName, <span class="hljs-keyword">this</span>.cachedFieldValue);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>DependencyDescriptor desc = new DependencyDescriptor(field, <span class="hljs-keyword">this</span>.required);<br>desc.setContainingClass(bean.getClass());<br>Set&lt;String&gt; autowiredBeanNames = new LinkedHashSet&lt;&gt;(<span class="hljs-number">1</span>);<br>Assert.state(beanFactory != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;No BeanFactory available&quot;</span>);<br>TypeConverter typeConverter = beanFactory.getTypeConverter();<br><span class="hljs-keyword">try</span> &#123;<br>value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);<br>&#125;<br><span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br><span class="hljs-keyword">throw</span> new UnsatisfiedDependencyException(<span class="hljs-literal">null</span>, beanName, new InjectionPoint(field), ex);<br>&#125;<br>synchronized (<span class="hljs-keyword">this</span>) &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.cached) &#123;<br><span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span> || <span class="hljs-keyword">this</span>.required) &#123;<br><span class="hljs-keyword">this</span>.cachedFieldValue = desc;<br>registerDependentBeans(beanName, autowiredBeanNames);<br><span class="hljs-keyword">if</span> (autowiredBeanNames.size() == <span class="hljs-number">1</span>) &#123;<br>String autowiredBeanName = autowiredBeanNames.iterator().next();<br><span class="hljs-keyword">if</span> (beanFactory.containsBean(autowiredBeanName) &amp;&amp;<br>beanFactory.isTypeMatch(autowiredBeanName, field.getType())) &#123;<br><span class="hljs-keyword">this</span>.cachedFieldValue = new ShortcutDependencyDescriptor(<br>desc, autowiredBeanName, field.getType());<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">this</span>.cachedFieldValue = <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">this</span>.cached = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) &#123;<br>ReflectionUtils.makeAccessible(field);<br>field.<span class="hljs-keyword">set</span>(bean, value);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在InjectionElement的inject函数中利用resolveFieldValue来解析出Field当前的值，然后同样是利用反射机制将其注入到Bean中。在resolveFieldValue最终会调用DefaultListableBeanFactory的doResolveDependency来完成属性的解析。</p><p>在doResolveDependency函数中首先会调用 resolveEmbeddedValue 来对@Value注解上的value属性进行解析，如果解析出来是SpEL的表达式的话会利用evaluateBeanDefinitionString函数进行二次解析。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs dart"># org.springframework.beans.<span class="hljs-keyword">factory</span>.support.DefaultListableBeanFactory.doResolveDependency<br><br><span class="hljs-meta">@Nullable</span><br>public <span class="hljs-built_in">Object</span> doResolveDependency(DependencyDescriptor descriptor, <span class="hljs-meta">@Nullable</span> <span class="hljs-built_in">String</span> beanName,<br><span class="hljs-meta">@Nullable</span> <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; autowiredBeanNames, <span class="hljs-meta">@Nullable</span> TypeConverter typeConverter) throws BeansException &#123;<br><br>InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-built_in">Object</span> shortcut = descriptor.resolveShortcut(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">if</span> (shortcut != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> shortcut;<br>&#125;<br><br>Class&lt;?&gt; type = descriptor.getDependencyType();<br><span class="hljs-built_in">Object</span> value = getAutowireCandidateResolver().getSuggestedValue(descriptor);<br><span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">if</span> (value instanceof <span class="hljs-built_in">String</span>) &#123;<br><span class="hljs-built_in">String</span> strVal = resolveEmbeddedValue((<span class="hljs-built_in">String</span>) value);<br>BeanDefinition bd = (beanName != <span class="hljs-keyword">null</span> &amp;&amp; containsBean(beanName) ?<br>getMergedBeanDefinition(beanName) : <span class="hljs-keyword">null</span>);<br>value = evaluateBeanDefinitionString(strVal, bd);<br>&#125;<br>TypeConverter converter = (typeConverter != <span class="hljs-keyword">null</span> ? typeConverter : getTypeConverter());<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">return</span> converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());<br>&#125;<br><span class="hljs-keyword">catch</span> (UnsupportedOperationException ex) &#123;<br><span class="hljs-comment">// A custom TypeConverter which does not support TypeDescriptor resolution...</span><br><span class="hljs-keyword">return</span> (descriptor.getField() != <span class="hljs-keyword">null</span> ?<br>converter.convertIfNecessary(value, type, descriptor.getField()) :<br>converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">Object</span> multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);<br><span class="hljs-keyword">if</span> (multipleBeans != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> multipleBeans;<br>&#125;<br><br><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);<br><span class="hljs-keyword">if</span> (matchingBeans.isEmpty()) &#123;<br><span class="hljs-keyword">if</span> (isRequired(descriptor)) &#123;<br>raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-built_in">String</span> autowiredBeanName;<br><span class="hljs-built_in">Object</span> instanceCandidate;<br><br><span class="hljs-keyword">if</span> (matchingBeans.size() &gt; <span class="hljs-number">1</span>) &#123;<br>autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);<br><span class="hljs-keyword">if</span> (autowiredBeanName == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">if</span> (isRequired(descriptor) || !indicatesMultipleBeans(type)) &#123;<br><span class="hljs-keyword">return</span> descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// In case of an optional Collection/Map, silently ignore a non-unique case:</span><br><span class="hljs-comment">// possibly it was meant to be an empty collection of multiple regular beans</span><br><span class="hljs-comment">// (before 4.3 in particular when we didn&#x27;t even look for collection beans).</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125;<br>instanceCandidate = matchingBeans.<span class="hljs-keyword">get</span>(autowiredBeanName);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// We have exactly one match.</span><br><span class="hljs-built_in">Map</span>.Entry&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; entry = matchingBeans.entrySet().iterator().next();<br>autowiredBeanName = entry.getKey();<br>instanceCandidate = entry.getValue();<br>&#125;<br><br><span class="hljs-keyword">if</span> (autowiredBeanNames != <span class="hljs-keyword">null</span>) &#123;<br>autowiredBeanNames.add(autowiredBeanName);<br>&#125;<br><span class="hljs-keyword">if</span> (instanceCandidate instanceof Class) &#123;<br>instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, <span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-built_in">Object</span> result = instanceCandidate;<br><span class="hljs-keyword">if</span> (result instanceof NullBean) &#123;<br><span class="hljs-keyword">if</span> (isRequired(descriptor)) &#123;<br>raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);<br>&#125;<br>result = <span class="hljs-keyword">null</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!ClassUtils.isAssignableValue(type, result)) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass());<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们这里重点关注的是 resolveEmbeddedValue，在这个函数中会遍历所有注册StringValueResolver来对Value注解中的值进行解析。那么StringValueResolver又是在什么地方被添加到BeanFactory中的呢，通过引用关系查找我们不难发现添加StringValueResolver的地方有两处，一处是在PlaceholderConfigurerSupport中，一处则是在AbstractApplicationContext的BeanFactory初始化结束的函数中。</p><p>当AbstractApplicationContext中没有注册StringValueResolver时，才会注入一个默认的StringValueResolver，而这个默认的StringValueResolver则是利用Environment来完成属性的解析（strVal -&gt; getEnvironment().resolvePlaceholders(strVal)）。</p><p>而在Spring Boot项目中通常会自动配置一个PropertySourcesPlaceholderConfigurer的Bean来协助解析占位符，这个Bean的一方面提供了占位符的解析，另一方面对Environment进行了二次封装，加入了用户可配置的自定义属性解析，使得属性解析的数据源更加的丰富。</p><p>实际上这两个对于属性的解析的StringValueResolver最终利用的都是 PropertySourcesPropertyResolver，PropertySourcesPropertyResolver在resolvePlaceholders函数中主要经历两个步骤，首先利用PropertyPlaceholderHelper解析出字符串中所有的占位符（例如${test})，然后使用PropertySourcesPropertyResolver中getPropertyAsRawString解析出占位符中应该被替换的属性（即查找属性源中test属性）进行替换，最后返回该值。</p><p>PropertyPlaceholderHelper是通过遍历字符串的方式递归的解析所有的占位符，逻辑相对比较简单就不做深入的分析。getPropertyAsRawString函数最终的属性查找利用的是PropertySourcesPropertyResolver中的PropertySources属性，PropertySources中包含了多个PropertySource，每个PropertySource就代表一个数据配置源，可以是系统环境变量、JVM变量、配置文件或是自定义配置的本地变量（PropertySourcesPropertyResolver中提供的功能）等等。根据前面的分析我们可以知道，PropertySourcesPropertyResolver在Spring框架的代码中有两处实例化，一个是ApplicationContext在创建Enviroment时创建的默认的PropertySourcesPropertyResolver，其中的PropertySources由Enviroment提供，一个是PropertySourcesPlaceholderConfigurer创建的PropertySourcesPropertyResolver，其中的PropertySources由Enviroment与自定义的本地属性合并而成。</p><p>经过上述过程的跟踪分析，其实我们不难发现，在Spring框架中ApplicationContext中的Environment是Spring默认的属性源管理器，每个属性源都会对应一个PropertySource，属性的获取与解析是最终是通过PropertySourcesPropertyResolver来完成的。想要自定义属性源可以有两种实现方式，一是配置PropertySourcesPlaceholderConfigurer，二是通过Environment来注入新的属性源。</p><p>最后，附上一张关于@Value注解属性解析中关键函数的调用时序图，在下一篇文章中我们将会从Environment的角度来分析Spring-core中org.springframework.core.env包中关于属性加载与解析的部分。<br><img src="img.png"></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://juejin.cn/post/6992792024231444493">Spring配置属性管理（一）— @Value注解解析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>Value</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NacosSpringProject配置管理源码分析(一)</title>
    <link href="/2022/09/22/java/nacos/NacosSpringProject%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901/"/>
    <url>/2022/09/22/java/nacos/NacosSpringProject%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901/</url>
    
    <content type="html"><![CDATA[<p>Nacos spring project主要是面向仅使用spring框架的项目，主要提供了Nacos-client中的配置管理模块与服务发现模块在spring框架中集成的相关功能。<br>从整个项目上面来看，可以大致的分为以下两个部分，Nacos相关配置Bean的解析与注入以及Nacos相关功能注解的解析与处理。<br>其中配置Bean的解析注入分为XML配置与注解配置两个部分。<br>而Nacos相关功能注解主要包含了@NacosValue、@NacosConfigListener、@NacosInjected等注解的处理，主要是利用了BeanPostProceesor的特性。</p><p>接下来的两篇文章将围绕Nacos spring project中配置管理相关的功能模块进行分析，主要包含了@EnableNacos、@EnableNacosConfig、@NacosInjected、@NacosValue、@NacosPropertySource、@NacosConfigurationProperties与@NacosConfigListener注解的基本使用以及其原理。</p><h1 id="EnableNacos-EnableNacosConfig"><a href="#EnableNacos-EnableNacosConfig" class="headerlink" title="@EnableNacos/@EnableNacosConfig"></a>@EnableNacos/@EnableNacosConfig</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableNacosConfig(globalProperties = @NacosProperties(serverAddr = &quot;127.0.0.1:8848&quot;))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NacosConfiguration</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>通常在Spring项目中我们可以利用@EnableNacos的注解开启Nacos，或是利用@EnableNacosConfig注解仅开启配置管理功能，又或者可以通过XML配置的方式开启Nacos功能。注解配置或是XML配置的原理是相似的，本文将针对项目中较为常用的注解配置来进行分析。</p><p><img src="img.png"><br><img src="img_1.png"></p><p>@EnableNacos与@EnableNacosConfig实际上都是利用了@Import注解的机制，@Import的作用主要是用于导入其他配置类。<br>被引入的NacosBeanDefinitionRegistrar与NacosConfigBeanDefinitionRegistrar都实现了ImportBeanDefinitionRegistrar接口，在这个接口中完成Bean定义的注入。</p><p>在NacosBeanDefinitionRegistrar中，首先会注册一个PropertySourcesPlaceholderConfigurer，在前面的Spring Environment解析的文章中我们提到过这个类的功能主要是用于属性中占位符的解析随后会注册一个由Nacos全局配置属性构成Properties对象的Bean；接着会注册Nacos注解处理相关的BeanDefinition，@EnableNacosConfig注解不同的地方是只会注册配置管理相关的Bean；最后会手动的调用一次NacosPropertySourcePostProcessor的postProcessBeanFactory方法，保证@NacosPropertySource注解能够被立即处理，获取到的属性能够尽快的参与到后续Spring初始化的过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># com.alibaba.nacos.spring.context.annotation.NacosBeanDefinitionRegistrar#registerBeanDefinitions</span><br><br>@<span class="hljs-function">Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata,</span></span><br><span class="hljs-params"><span class="hljs-function">BeanDefinitionRegistry registry)</span> </span>&#123;<br>BeanDefinition annotationProcessor = BeanDefinitionBuilder<br>.<span class="hljs-built_in">genericBeanDefinition</span>(PropertySourcesPlaceholderConfigurer.<span class="hljs-keyword">class</span>)<br>.<span class="hljs-built_in">getBeanDefinition</span>();<br>registry.<span class="hljs-built_in">registerBeanDefinition</span>(<br>PropertySourcesPlaceholderConfigurer.<span class="hljs-keyword">class</span>.<span class="hljs-built_in">getName</span>(),<br>annotationProcessor);<br><br>AnnotationAttributes attributes = AnnotationAttributes<br>.<span class="hljs-built_in">fromMap</span>(importingClassMetadata<br>.<span class="hljs-built_in">getAnnotationAttributes</span>(EnableNacos.<span class="hljs-keyword">class</span>.<span class="hljs-built_in">getName</span>()));<br><br><span class="hljs-comment">// Register Global Nacos Properties Bean</span><br><span class="hljs-built_in">registerGlobalNacosProperties</span>(attributes, registry, environment,<br>GLOBAL_NACOS_PROPERTIES_BEAN_NAME);<br><span class="hljs-comment">// Register Nacos Annotation Beans</span><br><span class="hljs-built_in">registerNacosAnnotationBeans</span>(registry);<br><span class="hljs-comment">// Invoke NacosPropertySourcePostProcessor immediately</span><br><span class="hljs-comment">// in order to enhance the precedence of @NacosPropertySource process</span><br><span class="hljs-built_in">invokeNacosPropertySourcePostProcessor</span>(beanFactory);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以注意到在这一系列的过程中，Nacos采用了两种注入方式，GloableProperties的注入是调用了NacosBeanUtils的registerSingleton方法，利用SingletonBeanRegistry直接注入Bean，而在registerNacosAnnotationBeans方法中注册的大部分都是调用了NacosBeanUtils中的registerInfrastructureBean方法利用BeanDefinitionRegistry注册了BeanDefinition，并且这些BeanDefinition的角色都被定义成了基础设施的Bean，由BeanFactory负责创建Bean。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs smali"><span class="hljs-comment"># com.alibaba.nacos.spring.util.NacosBeanUtils#registerSingleton</span><br><br><span class="hljs-keyword">public</span><span class="hljs-keyword"> static</span> void registerSingleton(BeanDefinitionRegistry registry, String beanName,<br>Object singletonObject) &#123;<br>SingletonBeanRegistry beanRegistry = null;<br><span class="hljs-built_in">if </span>(registry instanceof SingletonBeanRegistry) &#123;<br>beanRegistry = (SingletonBeanRegistry) registry;<br>&#125;<br>else<span class="hljs-built_in"> if </span>(registry instanceof AbstractApplicationContext) &#123;<br>// Maybe AbstractApplicationContext<span class="hljs-built_in"> or </span>its<span class="hljs-built_in"> sub-classes</span><br><span class="hljs-built_in"></span>beanRegistry = ((AbstractApplicationContext) registry).getBeanFactory();<br>&#125;<br>// Register Singleton Object<span class="hljs-built_in"> if </span>possible<br><span class="hljs-built_in">if </span>(beanRegistry != null) &#123;<br>// Determine in advance whether injected with beans<br><span class="hljs-built_in">if </span>(!beanRegistry.containsSingleton(beanName)) &#123;<br>beanRegistry.registerSingleton(beanName, singletonObject);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta"># com.alibaba.nacos.spring.util.NacosBeanUtils#registerInfrastructureBean</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">registerInfrastructureBean</span><span class="hljs-params">(BeanDefinitionRegistry registry,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">String</span> beanName, Class&lt;?&gt; beanClass, Object... constructorArgs)</span> </span>&#123;<br><span class="hljs-comment">// Build a BeanDefinition for NacosServiceFactory class</span><br>BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder<br>.<span class="hljs-built_in">rootBeanDefinition</span>(beanClass);<br><span class="hljs-keyword">for</span> (Object constructorArg : constructorArgs) &#123;<br>beanDefinitionBuilder.<span class="hljs-built_in">addConstructorArgValue</span>(constructorArg);<br>&#125;<br><span class="hljs-comment">// ROLE_INFRASTRUCTURE</span><br>beanDefinitionBuilder.<span class="hljs-built_in">setRole</span>(BeanDefinition.ROLE_INFRASTRUCTURE);<br><span class="hljs-comment">// Register</span><br>registry.<span class="hljs-built_in">registerBeanDefinition</span>(beanName,<br>beanDefinitionBuilder.<span class="hljs-built_in">getBeanDefinition</span>());<br>&#125;<br><br></code></pre></td></tr></table></figure><p>接下来我们来关注一下对于配置管理而言，Nacos需要注入哪些Bean来实现Nacos client与Spring框架的结合。Bean的注册主要是来自registerNacosCommonBeans与registerNacosConfigBeans两个方法。</p><p>在registerNacosCommonBeans中注册了配置管理与服务发现的通用的功能Bean，分别是:</p><ul><li>用于存放ApplicationContext的ApplicationContextHolder</li><li>用于处理@NacosInjected注解的AnnotationNacosInjectedBeanPostProcessor</li></ul><p>在registerNacosConfigBeans中注册了配置管理相关功能的Bean，分别是:</p><ul><li>用于处理@NacosConfigurationProperties注解的NacosConfigurationPropertiesBindingPostProcessor</li><li>用于处理@NacosConfigListener注解的NacosConfigListenerMethodProcessor</li><li>用于处理@NacosPropertySource注解的NacosPropertySourcePostProcessor</li><li>提供给NacosPropertySourcePostProcessor用于解析Bean并创建NacosPropertySource的AnnotationNacosPropertySourceBuilder</li><li>用于执行ConfigService监听器的线程池NacosConfigListenerExecutor</li><li>用于处理@NacosValue注解的NacosValueAnnotationBeanPostProcessor</li><li>用于创建ConfigService的ConfigServiceBeanBuilder</li><li>用于接收Nacos事件并记录的日志的LoggingNacosConfigMetadataEventListener</li></ul><p>接下来的小节我们会逐个对这些配置Bean进行解析。</p><h1 id="NacosInjected"><a href="#NacosInjected" class="headerlink" title="@NacosInjected"></a>@NacosInjected</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServciceImpl</span> &#123;<br><br>    <span class="hljs-meta">@NacosInjected</span><br>    <span class="hljs-keyword">private</span> ConfigService configService;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>在项目开发过程中可以使用@NacosInjected注解来注入ConfigService实例，同时还可以通过@NacosInjected中的properties来指定需要注入的配置属性项。</p><p>上一节我们提到了@NacosInjected注解主要是由AnnotationNacosInjectedBeanPostProcessor来负责处理的，AnnotationNacosInjectedBeanPostProcessor继承自AbstractAnnotationBeanPostProcessor，AbstractAnnotationBeanPostProcessor实现了Bean实例属性上自定义注解处理的基本方法，处理的思路与我们在Spring Environment解析中提到的@Value属性注入的方式类似，都是通过在MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition方法中找到所有Bean定义中的注入点，然后利用InstantiationAwareBeanPostProcessorAdapter中postProcessPropertyValues方法处理需要被注入的属性。</p><p>本文主要关注一下AnnotationNacosInjectedBeanPostProcessor是如何完成属性注入的。</p><p>首先AnnotationNacosInjectedBeanPostProcessor在初始化过程中，会利用BeanFactory找到所有的AbstractNacosServiceBeanBuilder，并且根据AbstractNacosServiceBeanBuilder中的类型存储到nacosServiceBeanBuilderMap中。</p><p>随后AnnotationNacosInjectedBeanPostProcessor实现了doGetInjectedBean方法，这个方法会在postProcessPropertyValues回调函数中被调用，用于查找目标的Bean对象，然后由AbstractAnnotationBeanPostProcessor利用反射功能设置到属性上。<br>在doGetInjectedBean利用了初始化过程中收集到的AbstractNacosServiceBeanBuilder，结合@NacosInjected上的properties注解属性，创建对应的Nacos Service。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"># com.alibaba.nacos.spring.beans.<span class="hljs-keyword">factory</span>.annotation.AnnotationNacosInjectedBeanPostProcessor#doGetInjectedBean<br><span class="hljs-meta">@Override</span><br>protected <span class="hljs-built_in">Object</span> doGetInjectedBean(AnnotationAttributes attributes, <span class="hljs-built_in">Object</span> bean,<br>      <span class="hljs-built_in">String</span> beanName, Class&lt;?&gt; injectedType,<br>      InjectionMetadata.InjectedElement injectedElement) throws Exception &#123;<br>   AbstractNacosServiceBeanBuilder serviceBeanBuilder = nacosServiceBeanBuilderMap<br>         .<span class="hljs-keyword">get</span>(injectedType);<br><br>   <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; nacosProperties = getNacosProperties(attributes);<br><br>   <span class="hljs-keyword">return</span> serviceBeanBuilder.build(nacosProperties);<br>&#125;<br></code></pre></td></tr></table></figure><p>以注入ConfigService为例，最终会找到在上一小节中注册的ConfigServiceBeanBuilder，首先会根据注解的属性解析成Properties对象，然后获取到NacosServiceFactory创建对应的ConfigService。</p><p>实际负责创建ConfigService的是CacheableEventPublishingNacosServiceFactory，在CacheableEventPublishingNacosServiceFactory中由ConfigCreateWorker负责创建，首先会根据属性从缓存中查找是否有创建过的ConfigService，如果没有会利用NacosFactory创建一个新的ConfigService，特别的是每个ConfigService被EventPublishingConfigService封装。</p><p>相对于普通的ConfigService，EventPublishingConfigService在每个ConfigService的接口上都增加了一定的事件的推送，例如在获取配置超时时会发送NacosConfigTimeoutEvent。</p><p>在EventPublishingConfigService中，推送消息所使用的ApplicationEventPublisher是DeferredApplicationEventPublisher，不同之处在于DeferredApplicationEventPublisher的消息推送当ApplicationContext处于非运行状态时，会将事件缓存在ConcurrentLinkedQueue中，当ApplicationContext发送ContextRefreshedEvent事件时再将缓存的消息进行延迟推送。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta"># com.alibaba.nacos.spring.factory.CacheableEventPublishingNacosServiceFactory.ConfigCreateWorker#run</span><br><br>@Override<br><span class="hljs-keyword">public</span> ConfigService run(Properties properties, ConfigService service)<br>throws NacosException &#123;<br><span class="hljs-keyword">String</span> cacheKey = identify(properties);<br>ConfigService configService = configServicesCache.<span class="hljs-keyword">get</span>(cacheKey);<br><br><span class="hljs-keyword">if</span> (configService == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (service == <span class="hljs-literal">null</span>) &#123;<br>service = NacosFactory.createConfigService(properties);<br>&#125;<br>configService = <span class="hljs-keyword">new</span> <span class="hljs-type">EventPublishingConfigService</span>(service, properties,<br>getSingleton().context,<br>getSingleton().nacosConfigListenerExecutor);<br>configServicesCache.put(cacheKey, configService);<br>&#125;<br><span class="hljs-keyword">return</span> configService;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://juejin.cn/post/6995861449394356261">Nacos Spring Project配置管理源码分析（一）</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华为p40pro安装google服务框架</title>
    <link href="/2022/09/22/other/%E5%8D%8E%E4%B8%BAp40pro%E5%AE%89%E8%A3%85google%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/"/>
    <url>/2022/09/22/other/%E5%8D%8E%E4%B8%BAp40pro%E5%AE%89%E8%A3%85google%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>华为p40pro安装google服务框架</p><h1 id="电脑端使用adb命令"><a href="#电脑端使用adb命令" class="headerlink" title="电脑端使用adb命令"></a>电脑端使用adb命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd c:/platform-tools                          定位至ADB文件夹<br>adb uninstall com.huawei.localBackup        卸载备份App<br>adb install c:\oldBackup.apk                  安装备份App<br></code></pre></td></tr></table></figure><h2 id="方法一-使用华谷套件apk安装"><a href="#方法一-使用华谷套件apk安装" class="headerlink" title="方法一:使用华谷套件apk安装"></a>方法一:<a href="https://bishua666.com/huagu2/#/">使用华谷套件apk安装</a></h2><blockquote><p>推荐</p></blockquote><p><img src="1.jpg"></p><h2 id="方法二-单独执行华谷套件里面的每一个步骤-不推荐"><a href="#方法二-单独执行华谷套件里面的每一个步骤-不推荐" class="headerlink" title="方法二:单独执行华谷套件里面的每一个步骤(不推荐)"></a>方法二:单独执行华谷套件里面的每一个步骤(不推荐)</h2><h1 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决:"></a>常见问题解决:</h1><h2 id="设备未获得Play保护机制认证"><a href="#设备未获得Play保护机制认证" class="headerlink" title="设备未获得Play保护机制认证"></a>设备未获得Play保护机制认证</h2><p>–<br>方法一: 直接在华谷套件里面购买服务按提示操作即可(收费)<br>方法二: </p><ul><li>下载DeviceID.APK，打开APP</li><li>复制GSF框架ID</li><li>进入网址<a href="https://www.google.com/android/uncertified/">https://www.google.com/android/uncertified/</a> 进行设备注册</li><li>注册完成后手机打开飞行模式</li><li>按顺序清除以下app数据和缓存，并停止运行（需要一直点到停止运行按钮变成灰色，再操作下一个app）<ul><li>google框架，google服务，google商店</li></ul></li><li>直接重启手机</li><li>按顺序清除以下app，并停止运行（需要一直点到停止运行按钮变成灰色，再操作下一个app）<ul><li> google服务</li></ul></li><li>直接重启手机</li><li>关闭飞行模式</li><li>正常使用Googel store(如果出现df-dferh-01,等它自行恢复)</li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://www.youtube.com/watch?v=0bMesV_en3M">华为手机鸿蒙2.0系统HarmonyOS 2.0正式版上安装谷歌服务框架GMS谷歌应用商店Google Play无需降级直接安装谷歌框架华为P50 P40 P30 Mate40 Mate30荣耀v30</a></li><li><a href="https://bit.ly/3atpvpw8">电脑端ADB工具</a></li><li><a href="https://bit.ly/3xrhujf">手机端谷歌框架安装文件</a></li><li><a href="https://www.youtube.com/watch?v=06ATErza81A">2022解决设备未获得Play保护机制认证,华为荣耀手机鸿蒙2.0系统HarmonyOS 2.0安装谷歌服务框架GMS谷歌应用商店Google Play华为P40 Mate40 Mate30荣耀30</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>google框架</tag>
      
      <tag>p40pro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>源码分析清楚AbstractQueuedSynchronizer</title>
    <link href="/2022/09/19/java/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9AAbstractQueuedSynchronizer/"/>
    <url>/2022/09/19/java/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9AAbstractQueuedSynchronizer/</url>
    
    <content type="html"><![CDATA[<p>在分析 Java 并发包 java.util.concurrent 源码的时候，少不了需要了解 AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是 Java 并发包的基础工具类，是实现 ReentrantLock、CountDownLatch、Semaphore、FutureTask 等类的基础。</p><p>Google 一下 AbstractQueuedSynchronizer，我们可以找到很多关于 AQS 的介绍，但是很多都没有介绍清楚，因为大部分文章没有把其中的一些关键的细节说清楚。</p><p>本文将从 ReentrantLock 的公平锁源码出发，分析下 AbstractQueuedSynchronizer 这个类是怎么工作的，希望能给大家提供一些简单的帮助。</p><!--more--><p>申明以下几点：</p><ol><li>本文有点长，但还是挺简单，主要面向读者对象为并发编程的初学者，或者想要阅读 Java 并发包源码的开发者。对于新手来说，可能需要花好几个小时才能完全看懂，但是这时间肯定是值得的。</li><li>源码环境 JDK1.7（1.8没啥变化），看到不懂或有疑惑的部分，最好能自己打开源码看看。Doug Lea 大神的代码写得真心不错。</li><li>本文不分析共享模式，这样可以给读者减少很多负担，<a href="/post/AbstractQueuedSynchronizer-3">第三篇文章</a>对共享模式进行了分析。而且也不分析 condition 部分，所以应该说很容易就可以看懂了。</li><li>本文大量使用我们平时用得最多的 ReentrantLock 的概念，本质上来说是不正确的，读者应该清楚，AQS 不仅仅用来实现可重入锁，只是希望读者可以用锁来联想 AQS 的使用场景，降低阅读压力。</li><li>ReentrantLock 的公平锁和非公平锁只有一点点区别，<a href="/post/AbstractQueuedSynchronizer-2">第二篇文章</a>做了介绍。</li><li>评论区有读者反馈本文直接用代码说不友好，应该多配点流程图，这篇文章确实有这个问题。但是作为过来人，我想告诉大家，对于 AQS 来说，形式真的不重要，重要的是把细节说清楚。</li></ol><h2 id="AQS-结构"><a href="#AQS-结构" class="headerlink" title="AQS 结构"></a>AQS 结构</h2><p>先来看看 AQS 有哪些属性，搞清楚这些基本就知道 AQS 是什么套路了，毕竟可以猜嘛！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;<br><br><span class="hljs-comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;<br><br><span class="hljs-comment">// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁</span><br><span class="hljs-comment">// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br><br><span class="hljs-comment">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span><br><span class="hljs-comment">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span><br><span class="hljs-comment">// if (currentThread == getExclusiveOwnerThread()) &#123;state++&#125;</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Thread exclusiveOwnerThread; <span class="hljs-comment">//继承自AbstractOwnableSynchronizer</span><br></code></pre></td></tr></table></figure><p>怎么样，看样子应该是很简单的吧，毕竟也就四个属性啊。</p><p>AbstractQueuedSynchronizer 的等待队列示意如下所示，注意了，之后分析过程中所说的 queue，也就是阻塞队列<strong>不包含 head，不包含 head，不包含 head</strong>。</p><p><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-0.png" alt="aqs-0"></p><p>等待队列中每个线程被包装成一个 Node 实例，数据结构是链表，一起看看源码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-comment">// 标识节点当前在共享模式下</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>    <span class="hljs-comment">// 标识节点当前在独占模式下</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  <br>    <span class="hljs-comment">// ======== 下面的几个int常量是给waitStatus用的 ===========</span><br>    <span class="hljs-comment">/** waitStatus value to indicate thread has cancelled */</span><br>    <span class="hljs-comment">// 代码此线程取消了争抢这个锁</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span><br>    <span class="hljs-comment">// 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">/** waitStatus value to indicate thread is waiting on condition */</span><br>    <span class="hljs-comment">// 本文不分析condition，所以略过吧，下一篇文章会介绍这个</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * waitStatus value to indicate the next acquireShared should</span><br><span class="hljs-comment">     * unconditionally propagate</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 同样的不分析，略过吧</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br>    <span class="hljs-comment">// =====================================================</span><br>  <br>  <br>    <span class="hljs-comment">// 取值为上面的1、-1、-2、-3，或者0(以后会讲到)</span><br>    <span class="hljs-comment">// 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，</span><br>    <span class="hljs-comment">//    ps: 半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的。。。</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;<br>    <span class="hljs-comment">// 前驱节点的引用</span><br>    <span class="hljs-keyword">volatile</span> Node prev;<br>    <span class="hljs-comment">// 后继节点的引用</span><br>    <span class="hljs-keyword">volatile</span> Node next;<br>    <span class="hljs-comment">// 这个就是线程本尊</span><br>    <span class="hljs-keyword">volatile</span> Thread thread;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>Node 的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已，大家先要有这个概念在心里。</p><p>上面的是基础知识，后面会多次用到，心里要时刻记着它们，心里想着这个结构图就可以了。下面，我们开始说 ReentrantLock 的公平锁。再次强调，我说的阻塞队列不包含 head 节点。</p><p><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-0.png" alt="aqs-0"></p><p>首先，我们先看下 ReentrantLock 的使用方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 我用个web开发中的service概念吧</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-comment">// 使用static，这样每个线程拿到的是同一把锁，当然，spring mvc中service默认就是单例，别纠结这个</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">reentrantLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 比如我们同一时间，只允许一个线程创建订单</span><br>        reentrantLock.lock();<br>        <span class="hljs-comment">// 通常，lock 之后紧跟着 try 语句</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 这块代码同一时间只能有一个线程进来(获取到锁的线程)，</span><br>            <span class="hljs-comment">// 其他的线程在lock()方法上阻塞，等待获取到锁，再进来</span><br>            <span class="hljs-comment">// 执行代码...</span><br>            <span class="hljs-comment">// 执行代码...</span><br>            <span class="hljs-comment">// 执行代码...</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 释放锁</span><br>            reentrantLock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ReentrantLock 在内部用了内部类 Sync 来管理锁，所以真正的获取锁和释放锁是由 Sync 的实现类来控制的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>Sync 有两个实现，分别为 NonfairSync（非公平锁）和 FairSync（公平锁），我们看 FairSync 部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程抢锁"><a href="#线程抢锁" class="headerlink" title="线程抢锁"></a>线程抢锁</h2><p>很多人肯定开始嫌弃上面废话太多了，下面跟着代码走，我就不废话了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3000897897090466540L</span>;<br>  <span class="hljs-comment">// 争锁</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>  <span class="hljs-comment">// 来自父类AQS，我直接贴过来这边，下面分析的时候同样会这样做，不会给读者带来阅读压力</span><br>    <span class="hljs-comment">// 我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。</span><br>    <span class="hljs-comment">// 否则，acquireQueued方法会将线程压到队列中</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123; <span class="hljs-comment">// 此时 arg == 1</span><br>        <span class="hljs-comment">// 首先调用tryAcquire(1)一下，名字上就知道，这个只是试一试</span><br>        <span class="hljs-comment">// 因为有可能直接就成功了呢，也就不需要进队列排队了，</span><br>        <span class="hljs-comment">// 对于公平锁的语义就是：本来就没人持有锁，根本没必要进队列等待(又是挂起，又是等待被唤醒的)</span><br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>            <span class="hljs-comment">// tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span><br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;<br>              selfInterrupt();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Fair version of tryAcquire.  Don&#x27;t grant access unless</span><br><span class="hljs-comment">     * recursive call or no waiters or is first.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span><br>    <span class="hljs-comment">// 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-comment">// state == 0 此时此刻没有线程持有锁</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span><br>            <span class="hljs-comment">// 看看有没有别人在队列中等了半天了</span><br>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                <span class="hljs-comment">// 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span><br>                <span class="hljs-comment">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span><br>                <span class="hljs-comment">// 因为刚刚还没人的，我判断过了</span><br>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>              <br>                <span class="hljs-comment">// 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁</span><br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>      <span class="hljs-comment">// 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span><br>        <span class="hljs-comment">// 这里不存在并发问题</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span><br>        <span class="hljs-comment">// 回到上面一个外层调用方法继续看:</span><br>        <span class="hljs-comment">// if (!tryAcquire(arg) </span><br>        <span class="hljs-comment">//        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span><br>        <span class="hljs-comment">//     selfInterrupt();</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 假设tryAcquire(arg) 返回false，那么代码将执行：</span><br>  <span class="hljs-comment">//acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，</span><br>    <span class="hljs-comment">// 这个方法，首先需要执行：addWaiter(Node.EXCLUSIVE)</span><br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates and enqueues node for current thread and given mode.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the new node</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 此方法的作用是把线程包装成node，同时进入到队列中</span><br>    <span class="hljs-comment">// 参数mode此时是Node.EXCLUSIVE，代表独占模式</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>        <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>        <span class="hljs-comment">// 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>      <br>        <span class="hljs-comment">// tail!=null =&gt; 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧)</span><br>        <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123; <br>            <span class="hljs-comment">// 将当前的队尾节点，设置为自己的前驱 </span><br>            node.prev = pred; <br>            <span class="hljs-comment">// 用CAS把自己设置为队尾, 如果成功后，tail == node 了，这个节点成为阻塞队列新的尾巴</span><br>            <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123; <br>                <span class="hljs-comment">// 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，</span><br>                <span class="hljs-comment">// 上面已经有 node.prev = pred，加上下面这句，也就实现了和之前的尾节点双向连接了</span><br>                pred.next = node;<br>                <span class="hljs-comment">// 线程入队了，可以返回了</span><br>                <span class="hljs-keyword">return</span> node;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 仔细看看上面的代码，如果会到这里，</span><br>        <span class="hljs-comment">// 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)</span><br>        <span class="hljs-comment">// 读者一定要跟上思路，如果没有跟上，建议先不要往下读了，往回仔细看，否则会浪费时间的</span><br>        enq(node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Inserts node into queue, initializing if necessary. See picture above.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node the node to insert</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> node&#x27;s predecessor</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 采用自旋的方式入队</span><br>    <span class="hljs-comment">// 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队，</span><br>    <span class="hljs-comment">// 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>            <span class="hljs-comment">// 之前说过，队列为空也会进来这里</span><br>            <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br>                <span class="hljs-comment">// 初始化head节点</span><br>                <span class="hljs-comment">// 细心的读者会知道原来 head 和 tail 初始化的时候都是 null 的</span><br>                <span class="hljs-comment">// 还是一步CAS，你懂的，现在可能是很多线程同时进来呢</span><br>                <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                    <span class="hljs-comment">// 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了</span><br>                  <br>                    <span class="hljs-comment">// 这个时候有了head，但是tail还是null，设置一下，</span><br>                    <span class="hljs-comment">// 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了</span><br>                    <span class="hljs-comment">// 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return</span><br>                    <span class="hljs-comment">// 所以，设置完了以后，继续for循环，下次就到下面的else分支了</span><br>                    tail = head;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 下面几行，和上一个方法 addWaiter 是一样的，</span><br>                <span class="hljs-comment">// 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排</span><br>                node.prev = t;<br>                <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                    t.next = node;<br>                    <span class="hljs-keyword">return</span> t;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>  <br>    <span class="hljs-comment">// 现在，又回到这段代码了</span><br>    <span class="hljs-comment">// if (!tryAcquire(arg) </span><br>    <span class="hljs-comment">//        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span><br>    <span class="hljs-comment">//     selfInterrupt();</span><br>    <br>    <span class="hljs-comment">// 下面这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列</span><br>    <span class="hljs-comment">// 注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，</span><br>    <span class="hljs-comment">// 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false</span><br>    <span class="hljs-comment">// 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-comment">// p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head</span><br>                <span class="hljs-comment">// 注意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列</span><br>                <span class="hljs-comment">// 所以当前节点可以去试抢一下锁</span><br>                <span class="hljs-comment">// 这里我们说一下，为什么可以去试试：</span><br>                <span class="hljs-comment">// 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，</span><br>                <span class="hljs-comment">// enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程</span><br>                <span class="hljs-comment">// 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，</span><br>                <span class="hljs-comment">// tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state</span><br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                    setHead(node);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span> interrupted;<br>                &#125;<br>                <span class="hljs-comment">// 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，</span><br>                <span class="hljs-comment">// 要么就是tryAcquire(arg)没有抢赢别人，继续往下看</span><br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt())<br>                    interrupted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 什么时候 failed 会为 true???</span><br>            <span class="hljs-comment">// tryAcquire() 方法抛异常的情况</span><br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Checks and updates status for a node that failed to acquire.</span><br><span class="hljs-comment">     * Returns true if thread should block. This is the main signal</span><br><span class="hljs-comment">     * control in all acquire loops.  Requires that pred == node.prev</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pred node&#x27;s predecessor holding status</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node the node</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if thread should block</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是：&quot;当前线程没有抢到锁，是否需要挂起当前线程？&quot;</span><br>    <span class="hljs-comment">// 第一个参数是前驱节点，第二个参数才是代表当前线程的节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>        <span class="hljs-comment">// 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span><br>        <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * This node has already set status asking a release</span><br><span class="hljs-comment">             * to signal it, so it can safely park.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-comment">// 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。</span><br>        <span class="hljs-comment">// 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。</span><br>        <span class="hljs-comment">// 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，</span><br>        <span class="hljs-comment">// 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，</span><br>        <span class="hljs-comment">// 找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的</span><br>        <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * Predecessor was cancelled. Skip over predecessors and</span><br><span class="hljs-comment">             * indicate retry.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                node.prev = pred = pred.prev;<br>            &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>            pred.next = node;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="hljs-comment">             * need a signal, but don&#x27;t park yet.  Caller will need to</span><br><span class="hljs-comment">             * retry to make sure it cannot acquire before parking.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-comment">// 仔细想想，如果进入到这个分支意味着什么</span><br>            <span class="hljs-comment">// 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3</span><br>            <span class="hljs-comment">// 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0</span><br>            <span class="hljs-comment">// 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0</span><br>            <span class="hljs-comment">// 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span><br>            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>        &#125;<br>        <span class="hljs-comment">// 这个方法返回 false，那么会再走一次 for 循序，</span><br>        <span class="hljs-comment">//     然后再次进来此方法，此时会从第一个分支返回 true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  <br>    <span class="hljs-comment">// private static boolean shouldParkAfterFailedAcquire(Node pred, Node node)</span><br>    <span class="hljs-comment">// 这个方法结束根据返回值我们简单分析下：</span><br>    <span class="hljs-comment">// 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒</span><br>    <span class="hljs-comment">//我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了</span><br>    <span class="hljs-comment">// 如果返回false, 说明当前不需要被挂起，为什么呢？往后看</span><br>  <br>    <span class="hljs-comment">// 跳回到前面是这个方法</span><br>    <span class="hljs-comment">// if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br>    <span class="hljs-comment">//                parkAndCheckInterrupt())</span><br>    <span class="hljs-comment">//                interrupted = true;</span><br>    <br>    <span class="hljs-comment">// 1. 如果shouldParkAfterFailedAcquire(p, node)返回true，</span><br>    <span class="hljs-comment">// 那么需要执行parkAndCheckInterrupt():</span><br>  <br>    <span class="hljs-comment">// 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的</span><br>    <span class="hljs-comment">// 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒=======</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>        LockSupport.park(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">return</span> Thread.interrupted();<br>    &#125;<br>  <br>    <span class="hljs-comment">// 2. 接下来说说如果shouldParkAfterFailedAcquire(p, node)返回false的情况</span><br>  <br>   <span class="hljs-comment">// 仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。</span><br>  <br>    <span class="hljs-comment">// 解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程：</span><br>    <span class="hljs-comment">// =&gt; 是为了应对在经过这个方法后，node已经是head的直接后继节点了。剩下的读者自己想想吧。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>说到这里，也就明白了，多看几遍 <code>final boolean acquireQueued(final Node node, int arg)</code> 这个方法吧。自己推演下各个分支怎么走，哪种情况下会发生什么，走到哪里。</p><h2 id="解锁操作"><a href="#解锁操作" class="headerlink" title="解锁操作"></a>解锁操作</h2><p>最后，就是还需要介绍下唤醒的动作了。我们知道，正常情况下，如果线程没获取到锁，线程会被 <code>LockSupport.park(this);</code> 挂起停止，等待被唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 唤醒的代码还是比较简单的，你如果上面加锁的都看懂了，下面都不需要看就知道怎么回事了</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    sync.release(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">// 往后看吧</span><br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 回到ReentrantLock看tryRelease方法</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-comment">// 是否完全释放锁</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 其实就是重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        free = <span class="hljs-literal">true</span>;<br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>    &#125;<br>    setState(c);<br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Wakes up node&#x27;s successor, if one exists.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node the node</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 唤醒后继节点</span><br><span class="hljs-comment">// 从上面调用处知道，参数node是head头结点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * If status is negative (i.e., possibly needing signal) try</span><br><span class="hljs-comment">     * to clear in anticipation of signalling.  It is OK if this</span><br><span class="hljs-comment">     * fails or if status is changed by waiting thread.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>    <span class="hljs-comment">// 如果head节点当前waitStatus&lt;0, 将其修改为0</span><br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Thread to unpark is held in successor, which is normally</span><br><span class="hljs-comment">     * just the next node.  But if cancelled or apparently null,</span><br><span class="hljs-comment">     * traverse backwards from tail to find the actual</span><br><span class="hljs-comment">     * non-cancelled successor.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1）</span><br>    <span class="hljs-comment">// 从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>        s = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 从后往前找，仔细看代码，不必担心中间有节点取消(waitStatus==1)的情况</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = t;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// 唤醒线程</span><br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure><p>唤醒线程以后，被唤醒的线程将从以下代码中继续往前走：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    LockSupport.park(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 刚刚线程被挂起在这里了</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br><span class="hljs-comment">// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了</span><br></code></pre></td></tr></table></figure><p>好了，后面就不分析源码了，剩下的还有问题自己去仔细看看代码吧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下吧。</p><p>在并发环境下，加锁和解锁需要以下三个部件的协调：</p><ol><li>锁状态。我们要知道锁是不是被别的线程占有了，这个就是 state 的作用，它为 0 的时候代表没有线程占有锁，可以去争抢这个锁，用 CAS 将 state 设为 1，如果 CAS 成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state进行 +1 就可以，解锁就是减 1，直到 state 又变为 0，代表释放锁，所以 lock() 和 unlock() 必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。</li><li>线程的阻塞和解除阻塞。AQS 中采用了 LockSupport.park(thread) 来挂起线程，用 unpark 来唤醒线程。</li><li>阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个 queue 来管理这些线程，AQS 用的是一个 FIFO 的队列，就是一个链表，每个 node 都持有后继节点的引用。AQS 采用了 CLH 锁的变体来实现，感兴趣的读者可以参考这篇文章<a href="http://coderbee.net/index.php/concurrent/20131115/577">关于CLH的介绍</a>，写得简单明了。</li></ol><h2 id="示例图解析"><a href="#示例图解析" class="headerlink" title="示例图解析"></a>示例图解析</h2><p>下面属于回顾环节，用简单的示例来说一遍，如果上面的有些东西没看懂，这里还有一次帮助你理解的机会。</p><p>首先，第一个线程调用 reentrantLock.lock()，翻到最前面可以发现，tryAcquire(1) 直接就返回 true 了，结束。只是设置了 state=1，连 head 都没有初始化，更谈不上什么阻塞队列了。要是线程 1 调用 unlock() 了，才有线程 2 来，那世界就太太太平了，完全没有交集嘛，那我还要 AQS 干嘛。</p><p>如果线程 1 没有调用 unlock() 之前，线程 2 调用了 lock(), 想想会发生什么？</p><p>线程 2 会初始化 head【new Node()】，同时线程 2 也会插入到阻塞队列并挂起 (注意看这里是一个 for 循环，而且设置 head 和 tail 的部分是不 return 的，只有入队成功才会跳出循环)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                tail = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node.prev = t;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，是线程 2 初始化 head 节点，此时 head==tail, waitStatus==0</p><p><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-1.png" alt="aqs-1"></p><p>然后线程 2 入队：</p><p><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-2.png" alt="aqs-2"></p><p>同时我们也要看此时节点的 waitStatus，我们知道 head 节点是线程 2 初始化的，此时的 waitStatus 没有设置， java 默认会设置为 0，但是到 shouldParkAfterFailedAcquire 这个方法的时候，线程 2 会把前驱节点，也就是 head 的waitStatus设置为 -1。</p><p>那线程 2 节点此时的 waitStatus 是多少呢，由于没有设置，所以是 0；</p><p>如果线程 3 此时再进来，直接插到线程 2 的后面就可以了，此时线程 3 的 waitStatus 是 0，到 shouldParkAfterFailedAcquire 方法的时候把前驱节点线程 2 的 waitStatus 设置为 -1。</p><p><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-3.png" alt="aqs-3"></p><p>这里可以简单说下 waitStatus 中 SIGNAL(-1) 状态的意思，Doug Lea 注释的是：代表后继节点需要被唤醒。也就是说这个 waitStatus 其实代表的不是自己的状态，而是后继节点的状态，我们知道，每个 node 在入队的时候，都会把前驱节点的状态改为 SIGNAL，然后阻塞，等待被前驱唤醒。这里涉及的是两个问题：有线程取消了排队、唤醒操作。其实本质是一样的，读者也可以顺着 “waitStatus代表后继节点的状态” 这种思路去看一遍源码。</p><p>（全文完）</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer">一行一行源码分析清楚AbstractQueuedSynchronizer</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>juc</tag>
      
      <tag>AQS</tag>
      
      <tag>ReentrantLock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHubPages+Hexo搭建个人博客网站</title>
    <link href="/2022/09/19/other/GitHubPages+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
    <url>/2022/09/19/other/GitHubPages+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<p>本文介绍如何使用GitHub Pages + Hexo搭建个人博客网站，完全免费，所有内容本人亲测，绝对可用。</p><h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><h4 id="1-GitHub账号"><a href="#1-GitHub账号" class="headerlink" title="1. GitHub账号"></a>1. GitHub账号</h4><p>需要有一个<code>GitHub</code>账号，没有的话到 <a href="https://github.com/">官网</a> 申请一个。<br>注册很简单，不懂的话可以参考 <a href="https://blog.csdn.net/yaorongke/article/details/119086305">GitHub申请账号</a></p><h4 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2. 安装Git"></a>2. 安装Git</h4><p>在自己电脑上安装好<code>Git</code>，hexo部署到<code>GitHub</code>时要用。<br>网上找篇教程或者参考 <a href="https://blog.csdn.net/yaorongke/article/details/119085413">Git安装(Windows)</a></p><h4 id="3-安装NodeJS"><a href="#3-安装NodeJS" class="headerlink" title="3. 安装NodeJS"></a>3. 安装NodeJS</h4><p>在自己电脑上安装好<code>NodeJS</code>，<code>Hexo</code>是基于<code>NodeJS</code>编写的，所以需要安装<code>NodeJS</code>和<code>npm</code>工具。<br>网上找篇教程或者参考 <a href="https://blog.csdn.net/yaorongke/article/details/119084295">NodeJS安装及配置(Windows)</a></p><h3 id="二、创建仓库"><a href="#二、创建仓库" class="headerlink" title="二、创建仓库"></a>二、创建仓库</h3><p>在<code>GitHub</code>上创建一个新的代码仓库用于保存我们的网页。</p><p>点击<code>Your repositories</code>，进入仓库页面。<br><img src="https://img-blog.csdnimg.cn/e47a4f36fcbb421a8245aefdd184423f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>点击<code>New</code>按钮，进入仓库创建页面。<br><img src="https://img-blog.csdnimg.cn/d15e47ad718d43cd98c9c4a99970a9d7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>填写仓库名，格式必须为<code>&lt;用户名&gt;.github.io</code>，然后点击<code>Create repository</code>。<br><img src="https://img-blog.csdnimg.cn/5b7236589dc8430d8b96c512e0989b23.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>点击<code>creating a new file</code>创建一个新文件，作为我们网站的主页。<br><img src="https://img-blog.csdnimg.cn/711a97234d40440aab799969b516e35b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>新文件的名字必须为<code>index.html</code>，内容先随便写一个简单的，内容示例如下，填写之后点击<code>Commit new file</code>提交。</p><pre><code class="hljs">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;yaorongke&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;yaorongke的个人主页&lt;/h1&gt;    &lt;h1&gt;Hello ~&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://img-blog.csdnimg.cn/8d314e9dc79c425ab719fc48b90ec229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>GitHub Pages中找到我们主页的地址为 <a href="https://yaorongke.github.io/">https://yaorongke.github.io/</a><br><img src="https://img-blog.csdnimg.cn/1219bd69dcbd4c5f80e49a891dca1441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>浏览器中访问，展示成功。<br><img src="https://img-blog.csdnimg.cn/1bb0b7dec1334ac88e86b12541eb1cc3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>这里创建的网页是非常简陋的，只是为了演示下<code>GitHub Pages</code>的使用方式。</p><h3 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h3><p>我们采用<code>Hexo</code>来创建我们的博客网站，<code>Hexo</code> 是一个基于<code>NodeJS</code>的静态博客网站生成器，使用<code>Hexo</code>不需开发，只要进行一些必要的配置即可生成一个个性化的博客网站，非常方便。点击进入 <a href="https://hexo.io/zh-cn/">官网</a>。</p><p>安装 <code>Hexo</code></p><pre><code class="hljs">npm install -g hexo-cli</code></pre><p>查看版本</p><pre><code class="hljs">hexo -v</code></pre><p>创建一个项目 <code>hexo-blog</code> 并初始化</p><pre><code class="hljs">hexo init hexo-blogcd hexo-blognpm install</code></pre><p>本地启动</p><pre><code class="hljs">hexo ghexo server</code></pre><p>浏览器访问 <a href="http://localhost:4000，页面默认主图风格如下">http://localhost:4000，页面默认主图风格如下</a><br><img src="https://img-blog.csdnimg.cn/656bf025f6934a35abc104b16e4dd2fc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p><h3 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a>四、更换主题</h3><p><code>Hexo</code> 默认的主题不太好看，不过官方提供了数百种主题供用户选择，可以根据个人喜好更换，官网主题点 <a href="https://hexo.io/themes/">这里</a> 查看。这里介绍两个主题的使用方法，<code>Next</code> 和 <code>Fluid</code>，个人比较喜欢<code>Fluid</code>，后面章节的功能也是以 <code>Fluid</code> 为基础进行讲解的。</p><h4 id="1-NexT-主题"><a href="#1-NexT-主题" class="headerlink" title="1. NexT 主题"></a>1. NexT 主题</h4><p><strong>安装主题</strong></p><pre><code class="hljs">cd hexo-bloggit clone https://github.com/iissnan/hexo-theme-next themes/next</code></pre><p><strong>使用 NexT 主题</strong></p><p>打开 _config.yml 文件，该文件为站点配置文件<br><img src="https://img-blog.csdnimg.cn/f5cc3400d5b64a6ca75ce6cedd34ec41.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>将主题修改为 next</p><pre><code class="hljs">theme: next</code></pre><p><strong>本地启动</strong></p><pre><code class="hljs">hexo g -dhexo s</code></pre><h4 id="2-Fluid主题"><a href="#2-Fluid主题" class="headerlink" title="2. Fluid主题"></a>2. Fluid主题</h4><p>以下安装步骤摘自 <a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid官网</a></p><p><strong>安装主题</strong></p><p>下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新 release 版本</a> 解压到 <code>themes</code> 目录，并将解压出的文件夹重命名为 <code>fluid</code>。</p><p><strong>指定主题</strong></p><p>如下修改 <code>Hexo</code> 博客目录中的 <code>_config.yml</code>：</p><pre><code class="hljs">theme: fluid  # 指定主题language: zh-CN  # 指定语言，会影响主题显示的语言，按需修改</code></pre><p><strong>创建「关于页」</strong></p><p>首次使用主题的「关于页」需要手动创建：</p><pre><code class="hljs">hexo new page about</code></pre><p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。</p><p>修改后的文件示例如下：</p><pre><code class="hljs">---title: aboutdate: 2020-02-23 19:20:33layout: about---这里写关于页的正文，支持 Markdown, HTML</code></pre><p><strong>本地启动</strong></p><pre><code class="hljs">hexo g -dhexo s</code></pre><p>浏览器访问 <a href="http://localhost:4000，`Fluid`主题风格页面如下">http://localhost:4000，`Fluid`主题风格页面如下</a><br><img src="https://img-blog.csdnimg.cn/b02a3408a62040bdac07bb71435c710e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p><h3 id="五、创建文章"><a href="#五、创建文章" class="headerlink" title="五、创建文章"></a>五、创建文章</h3><p>如下修改 Hexo 博客目录中的 <code>_config.yml</code>，打开这个配置是为了在生成文章的时候生成一个同名的资源目录用于存放图片文件。</p><pre><code class="hljs">post_asset_folder: true</code></pre><p>执行如下命令创建一篇新文章，名为《测试文章》</p><pre><code class="hljs">hexo new post 测试文章</code></pre><p>执行完成后在<code>source\_posts</code>目录下生成了一个md文件和一个同名的资源目录(用于存放图片)<br><img src="https://img-blog.csdnimg.cn/4d471824356e476e8c8e092caa453f8a.png" alt="请添加图片描述"><br>在资源目录<code>测试文章</code>中放一张图片 <code>test.png</code><br><img src="https://img-blog.csdnimg.cn/96a7534cb7a743438c553298b216b8b0.png" alt="请添加图片描述"><br>在<code>测试文章.md</code>中添加内容如下，演示了图片的三种引用方式。第一种为官方推荐用法，第二种为markdown语法，第三种和前两种图片存放位置不一样，是将图片放在<code>\source\images</code>目录下。这三种写法在md文件中图片是无法显示的，但是在页面上能正常显示。</p><p>图片的引入方式可参考官方文档 <a href="https://hexo.io/zh-cn/docs/asset-folders.html">https://hexo.io/zh-cn/docs/asset-folders.html</a>，有详细介绍。</p><pre><code class="hljs">---title: 测试文章date: 2021-06-10 16:35:20tags:- 原创categories:- Java---这是一篇测试文章&#123;% asset_img test.png 图片引用方法一 %&#125;![图片引用方法二](test.png)![图片引用方法三](/images/test.png)</code></pre><p><strong>本地启动</strong></p><pre><code class="hljs">hexo g -dhexo s</code></pre><p>浏览器访问 <a href="http://localhost:4000，页面如下，文章添加成功">http://localhost:4000，页面如下，文章添加成功</a><br><img src="https://img-blog.csdnimg.cn/69a79d245c854c719696160a4ef409d4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p><h3 id="六、个性化页面展示"><a href="#六、个性化页面展示" class="headerlink" title="六、个性化页面展示"></a>六、个性化页面展示</h3><p>页面的标题等位置显示默认的文字，可以改下显示一些个性化的信息。</p><h4 id="1-浏览器tab页名称"><a href="#1-浏览器tab页名称" class="headerlink" title="1. 浏览器tab页名称"></a>1. 浏览器tab页名称</h4><p>修改根目录下 <code>_config.yml</code> 中的 <code>title</code> 字段。<br><img src="https://img-blog.csdnimg.cn/39ee292aaa8c4c1faeedceb184a3c01c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p><h4 id="2-博客标题"><a href="#2-博客标题" class="headerlink" title="2. 博客标题"></a>2. 博客标题</h4><p>主题目录 <code>themes\fluid</code> 下 <code>_config.yml</code> 中的 <code>blog_title</code> 字段。</p><p><img src="https://img-blog.csdnimg.cn/42c777e342ed4c8baee84d4d21cb6310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p><h4 id="3-主页正中间的文字"><a href="#3-主页正中间的文字" class="headerlink" title="3. 主页正中间的文字"></a>3. 主页正中间的文字</h4><p>主题目录 <code>themes\fluid</code> 下 <code>_config.yml</code> 中的 <code>text</code> 字段。<br><img src="https://img-blog.csdnimg.cn/449f76f0e322400abbe136bd8d9bf13d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>修改好配置后，页面效果如下，可以看到现在显示的内容变成了我们的个人信息。<br><img src="https://img-blog.csdnimg.cn/35f5961e0d744ba69fc00c346ed372c4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p><h3 id="七、添加阅读量统计"><a href="#七、添加阅读量统计" class="headerlink" title="七、添加阅读量统计"></a>七、添加阅读量统计</h3><p><code>Fluid</code> 主题写好了统计阅读量的代码，但是缺少相应配置所以没有开启，需要借助三方服务来统计阅读量，这里是有 <code>Leancloud</code> 的免费服务来进行统计。</p><h4 id="1-申请LeanCloud账号并创建应用"><a href="#1-申请LeanCloud账号并创建应用" class="headerlink" title="1. 申请LeanCloud账号并创建应用"></a>1. 申请LeanCloud账号并创建应用</h4><p>进入 <a href="https://console.leancloud.cn/">官网</a> 注册账号<br><img src="https://img-blog.csdnimg.cn/688c0b7aca6447db836d7c7ae183b70a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>需实名认证，完成后才能使用各项服务<br><img src="https://img-blog.csdnimg.cn/a79900336e394a9d93d5fd5c590d3c3a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>验证邮箱<br><img src="https://img-blog.csdnimg.cn/ae9d5224f9af41008489b2006c06bbd1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>创建应用，选择<code>开发版</code>即可，免费的<br><img src="https://img-blog.csdnimg.cn/60d49bcc50e34a908fccf4a544e12d03.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>进入该应用的 <code>设置-&gt;应用凭证</code>，找到 <code>AppID</code> 和 <code>AppKey</code>，记录下来后面配置要用<br><img src="https://img-blog.csdnimg.cn/ae58b27419584dc3bd0da78aa7b6a90b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p><h4 id="2-修改Fluid配置"><a href="#2-修改Fluid配置" class="headerlink" title="2. 修改Fluid配置"></a>2. 修改Fluid配置</h4><p>打开主题目录 <code>themes\fluid</code>下的 <code>_config.yml</code> 文件，修改如下配置</p><h5 id="单篇文章阅读量计数"><a href="#单篇文章阅读量计数" class="headerlink" title="单篇文章阅读量计数"></a>单篇文章阅读量计数</h5><p>打开统计开关<br><img src="https://img-blog.csdnimg.cn/281c1db597dc4751a9fe4be660476045.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>配置 <code>leancloud</code>的 <code>app_id</code> 和 <code>app_key</code><br><img src="https://img-blog.csdnimg.cn/c707838cfa334702803b2ab9fc06501a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>打开计数功能，统计来源改为 <code>leancloud</code><br><img src="https://img-blog.csdnimg.cn/08292cdb1d754d9b86c0a80416281ec5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>页面效果<br><img src="https://img-blog.csdnimg.cn/5e8932a5f55b4bbab8659fdb6665e4da.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p><h5 id="页面底部展示网站的-PV、UV-统计数"><a href="#页面底部展示网站的-PV、UV-统计数" class="headerlink" title="页面底部展示网站的 PV、UV 统计数"></a>页面底部展示网站的 PV、UV 统计数</h5><p><img src="https://img-blog.csdnimg.cn/a285eab4997a4b9db2e575b966abb3d1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>页面效果<br><img src="https://img-blog.csdnimg.cn/2693096de407498fb19d5ed760241191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p><h3 id="八、添加评论功能"><a href="#八、添加评论功能" class="headerlink" title="八、添加评论功能"></a>八、添加评论功能</h3><p>评论功能的代码已经写好了，只不过没有开启，需要修改一些配置</p><p>打开主题目录 <code>themes\fluid</code>下的 <code>_config.yml</code> 文件，修改如下配置</p><p>启用评论插件<br><img src="https://img-blog.csdnimg.cn/1cafa579015843df8e4d5ff2d7b413a6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>配置 <code>LeanCloud</code> 的 <code>appId</code> 和 <code>appkey</code><br><img src="https://img-blog.csdnimg.cn/ed068b6c0e1a486f8efcd46de70cec24.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>重新部署后，查看页面效果，评论功能已开启<br><img src="https://img-blog.csdnimg.cn/74b51bf3f94e4c9b9f6229733cba2eeb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>部署在本地时评论无法提交，会报跨域问题，发布到 <code>GitHub Pages</code> 上之后课正常提交评论</p><h3 id="九、发布到GitHub-Pages"><a href="#九、发布到GitHub-Pages" class="headerlink" title="九、发布到GitHub Pages"></a>九、发布到GitHub Pages</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>安装hexo-deployer-git</p><pre><code class="hljs">npm install hexo-deployer-git --save</code></pre><p>修改根目录下的 <code>_config.yml</code>，配置 <code>GitHub</code> 相关信息</p><pre><code class="hljs">deploy:  type: git  repo: https://github.com/yaorongke/yaorongke.github.io.git  branch: main  token: ghp_3KakcaPHerunNRyMerofcFd9pblU282FSbsY</code></pre><p>其中 <code>token</code> 为 <code>GitHub</code> 的 <code>Personal access tokens</code>，获取方式如下图<br><img src="https://img-blog.csdnimg.cn/2350558a10d94c8ab4959b04771d2bcc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>部署到GitHub</p><pre><code class="hljs">hexo g -d</code></pre><p>浏览器访问 <a href="https://yaorongke.github.io/%EF%BC%8C%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F">https://yaorongke.github.io/，部署成功</a><br><img src="https://img-blog.csdnimg.cn/8a1b2c92b27a4026bdb22401a4460902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>直接将 <code>public</code> 目录中的文件和目录推送至 <code>GitHub</code> 仓库和分支中。<br><img src="https://img-blog.csdnimg.cn/efdfd2d6cf5d4551af0eabfa565f4a1e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p><h3 id="十、发布到自己服务器，Nginx代理"><a href="#十、发布到自己服务器，Nginx代理" class="headerlink" title="十、发布到自己服务器，Nginx代理"></a>十、发布到自己服务器，Nginx代理</h3><p>如果自己有服务器的话，也可以不使用 <code>GitHub Pages</code>，直接部署的自己的服务器上，通过 <code>Nginx</code> 进行代理，我这里有一个阿里云上的 <code>CentOS 7</code> 版的 <code>Linux</code> 服务器，演示下如何部署，步骤如下。</p><p>打开 <code>hexo-blog</code> 根目录下的 <code>_config.yml</code>，增加如下配置，这是因为把网站存放在了子目录中，要和 <code>Nginx</code> 配置中的 <code>location /blog</code> 路径一致。</p><pre><code class="hljs">root: /blog</code></pre><p><code>hexo-blog</code> 根目录下执行打包命令，打包好的文件在 <code>public</code> 目录下</p><pre><code class="hljs">hexo g</code></pre><p>将<code>public</code> 目录下的文件复制到 <code>Linux</code> 服务器上的某个目录下，我的存放目录为</p><pre><code class="hljs">/opt/rkyao/fronted/hexo-blog</code></pre><p>修改 <code>Nginx</code> 配置文件，我的 <code>Nginx</code> 安装路径为 <code>/usr/local</code>，大家根据自己实际情况调整</p><pre><code class="hljs">cd /usr/local/nginx/confvim nginx.conf# server节点下添加如下配置location /blog &#123;    alias  /opt/rkyao/fronted/hexo-blog;    index  index.html index.htm;&#125;</code></pre><p>重启 <code>Nginx</code></p><pre><code class="hljs">cd /usr/local/nginx/sbin./nginx -s reload</code></pre><p>访问博客</p><pre><code class="hljs">http://82.157.70.28/</code></pre><h3 id="十一、最终效果展示"><a href="#十一、最终效果展示" class="headerlink" title="十一、最终效果展示"></a>十一、最终效果展示</h3><p>可访问如下地址查看<br><a href="https://baymax55.github.io/">https://baymax55.github.io/</a></p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://blog.csdn.net/yaorongke/article/details/119089190">GitHub Pages + Hexo搭建个人博客网站，史上最全教程</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub Pages</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xxl-Job执行器原理解析</title>
    <link href="/2022/09/19/java/Xxl-Job%E6%89%A7%E8%A1%8C%E5%99%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/09/19/java/Xxl-Job%E6%89%A7%E8%A1%8C%E5%99%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>项目解析源码地址：<a href="https://gitee.com/lidishan/xxl-job-code-analysis">xxl-job</a><br>xxl-job版本：2.3.0<br>Xxl-Job分为执行器、调度器。而我们平时的客户端就属于一个执行器，执行器启动的时候会自动注册到调度器上，然后调度器进行远程调度。</p></blockquote><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b32956275e1a464992be32767fbcdbf3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="image.png"></p><h2 id="执行器初始化过程步骤如下"><a href="#执行器初始化过程步骤如下" class="headerlink" title="执行器初始化过程步骤如下"></a>执行器初始化过程步骤如下</h2><blockquote><p>1 通过加了@Conguration注解的XxlJobConfig初始化，并生成beanName=xxlJobExecutor的Bean<br>2 注册的BeanName=XxlJobConfig，会进行初始化，步骤如下：  </p><blockquote><ul><li>  扫描所有bean，加载加了@XxlJob注解类，并记录在jobHandlerRepository</li><li>  选择工厂类：GlueFactory 或 SpringGlueFactory</li></ul><blockquote><p>-- SpringGlueFactory会拦截当前实例属性 判断是否加了@Resource或@Autowired注解，如果存在就获取当前对应的bean实例，然后通过反射注入成员中</p></blockquote><ul><li>  启动，其步骤如下：</li></ul><blockquote><p>-– 1 初始化存放执行日志目录文件 — 2 初始化执行者，管理客户端 — 3 初始化日志清除线程，一天执行一次，默认清除N天(可配置)前数据 — 4 初始化回调触发器线程，线程执行完会把数据回调调度器接口告诉他结果 — 5 初始化执行服务器，初始化netty服务器，并发客户端信息注册到调度器上</p></blockquote></blockquote></blockquote><hr><h2 id="接下来对各个源码进行一定的解析"><a href="#接下来对各个源码进行一定的解析" class="headerlink" title="接下来对各个源码进行一定的解析"></a>接下来对各个源码进行一定的解析</h2><h3 id="1-通过加了-Conguration注解的XxlJobConfig初始化，并生成beanName-xxlJobExecutor的Bean"><a href="#1-通过加了-Conguration注解的XxlJobConfig初始化，并生成beanName-xxlJobExecutor的Bean" class="headerlink" title="1     通过加了@Conguration注解的XxlJobConfig初始化，并生成beanName=xxlJobExecutor的Bean"></a>1     通过加了@Conguration注解的XxlJobConfig初始化，并生成beanName=xxlJobExecutor的Bean</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XxlJobConfig</span> &#123;<span class="hljs-comment">//     注入XxlJob相关的配置信息，并生成Bean     xxlJobExecutor</span><br>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">&quot;$&#123;xxl.job.admin.addresses&#125;&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> adminAddresses;<br>    <span class="hljs-comment">//省略</span><br>    <span class="hljs-meta">@Bean</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">XxlJobSpringExecutor</span> <span class="hljs-title function_">xxlJobExecutor</span>(<span class="hljs-params"></span>) &#123;<br>        logger.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;</span>);<br>        <span class="hljs-title class_">XxlJobSpringExecutor</span> xxlJobSpringExecutor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XxlJobSpringExecutor</span>();<br>        <span class="hljs-comment">//省略</span><br>        <span class="hljs-keyword">return</span> xxlJobSpringExecutor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-注册的BeanName-XxlJobConfig，会进行初始化，步骤如下"><a href="#2-注册的BeanName-XxlJobConfig，会进行初始化，步骤如下" class="headerlink" title="2     注册的BeanName=XxlJobConfig，会进行初始化，步骤如下"></a>2     注册的BeanName=XxlJobConfig，会进行初始化，步骤如下</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XxlJobSpringExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">XxlJobExecutor</span> <span class="hljs-title">implements</span> <span class="hljs-title">ApplicationContextAware</span>, <span class="hljs-title">SmartInitializingSingleton</span>, <span class="hljs-title">DisposableBean</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> logger = <span class="hljs-type">LoggerFactory</span>.getLogger(<span class="hljs-type">XxlJobSpringExecutor</span>.<span class="hljs-keyword">class</span>);<br><br>    <span class="hljs-comment">// start</span><br>    <span class="hljs-meta">@Override</span><br>    public void afterSingletonsInstantiated() &#123;<br>        <span class="hljs-comment">// init JobHandler Repository</span><br>        <span class="hljs-comment">/*initJobHandlerRepository(applicationContext);*/</span><br>        <span class="hljs-comment">// 扫描所有bean，加载加了@XxlJob注解类，并记录在jobHandlerRepository                init JobHandler Repository (for method)</span><br>        initJobHandlerMethodRepository(applicationContext);<br>        <span class="hljs-comment">// 选择工厂类：GlueFactory 或 SpringGlueFactory               选择工厂类：GlueFactory 或 SpringGlueFactory               refresh GlueFactory</span><br>        <span class="hljs-type">GlueFactory</span>.refreshInstance(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 启动，其步骤如下：</span><br>        <span class="hljs-comment">//--- 1 初始化存放执行日志目录文件</span><br>        <span class="hljs-comment">//--- 2 初始化执行者，管理客户端</span><br>        <span class="hljs-comment">//--- 3 初始化日志清除线程</span><br>        <span class="hljs-comment">//--- 4 初始化回调触发器线程</span><br>        <span class="hljs-comment">//--- 5 初始化执行服务器</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">super</span>.start();<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-type">Exception</span> e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="上面我们对启动super-start-步骤来做具体的分析，其分析代码如下："><a href="#上面我们对启动super-start-步骤来做具体的分析，其分析代码如下：" class="headerlink" title="上面我们对启动super.start()步骤来做具体的分析，其分析代码如下："></a>上面我们对启动super.start()步骤来做具体的分析，其分析代码如下：</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void start<span class="hljs-literal">()</span> throws Exception &#123;<br>    <span class="hljs-comment">// 1 初始化存放执行日志目录文件 init logpath</span><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">XxlJobFileAppender</span>.</span></span>init<span class="hljs-constructor">LogPath(<span class="hljs-params">logPath</span>)</span>;<br>    <span class="hljs-comment">// 2 初始化执行者，管理客户端 init invoker, admin-client</span><br>    init<span class="hljs-constructor">AdminBizList(<span class="hljs-params">adminAddresses</span>, <span class="hljs-params">accessToken</span>)</span>;<br>    <span class="hljs-comment">// 3 初始化日志清除线程 init JobLogFileCleanThread</span><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JobLogFileCleanThread</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.start(logRetentionDays);<br>    <span class="hljs-comment">// 4 初始化回调触发器线程 init TriggerCallbackThread</span><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TriggerCallbackThread</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.start<span class="hljs-literal">()</span>;<br>    <span class="hljs-comment">// 5 初始化执行服务器 init executor-server</span><br>    init<span class="hljs-constructor">EmbedServer(<span class="hljs-params">address</span>, <span class="hljs-params">ip</span>, <span class="hljs-params">port</span>, <span class="hljs-params">appname</span>, <span class="hljs-params">accessToken</span>)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="启动super-start-gt-初始化存放执行日志目录文件"><a href="#启动super-start-gt-初始化存放执行日志目录文件" class="headerlink" title="启动super.start() -&gt;          初始化存放执行日志目录文件"></a>启动super.start() -&gt;          初始化存放执行日志目录文件</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">String</span> logBasePath = <span class="hljs-string">&quot;/data/applogs/xxl-job/jobhandler&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">String</span> glueSrcPath = logBasePath.<span class="hljs-built_in">concat</span>(<span class="hljs-string">&quot;/gluesource&quot;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">initLogPath</span><span class="hljs-params">(<span class="hljs-type">String</span> logPath)</span> </span>&#123;<br>    <span class="hljs-comment">// init 判断有没有自定义目录</span><br>    <span class="hljs-keyword">if</span> (logPath != null &amp;&amp; logPath.<span class="hljs-built_in">trim</span>().<span class="hljs-built_in">length</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>        logBasePath = logPath;<br>    &#125;<br>    <span class="hljs-comment">// mk base dir 如果当前目录为空，就创建一个</span><br>    <span class="hljs-built_in">File</span> logPathDir = <span class="hljs-keyword">new</span> <span class="hljs-built_in">File</span>(logBasePath);<br>    <span class="hljs-keyword">if</span> (!logPathDir.<span class="hljs-built_in">exists</span>()) &#123;<br>        logPathDir.<span class="hljs-built_in">mkdirs</span>();<br>    &#125;<br>    logBasePath = logPathDir.<span class="hljs-built_in">getPath</span>();<span class="hljs-comment">// 获取创建的目录路径</span><br><br>    <span class="hljs-comment">// mk glue dir 创建glue目录路径，没有就创建然后获取</span><br>    <span class="hljs-built_in">File</span> glueBaseDir = <span class="hljs-keyword">new</span> <span class="hljs-built_in">File</span>(logPathDir, <span class="hljs-string">&quot;gluesource&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!glueBaseDir.<span class="hljs-built_in">exists</span>()) &#123;<br>        glueBaseDir.<span class="hljs-built_in">mkdirs</span>();<br>    &#125;<br>    glueSrcPath = glueBaseDir.<span class="hljs-built_in">getPath</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="启动super-start-gt-初始化执行者，管理客户端"><a href="#启动super-start-gt-初始化执行者，管理客户端" class="headerlink" title="启动super.start() -&gt; 初始化执行者，管理客户端"></a>启动super.start() -&gt; 初始化执行者，管理客户端</h4><blockquote><p>-- 把调度管理器的地址写入adminBizList中<br>-- 启动super.start() -&gt; 初始化日志清除线程</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">long</span> logRetentionDays)</span>&#123;<br><br>    <span class="hljs-comment">// 日志最多也只能清除三天前的 limit min value</span><br>    <span class="hljs-keyword">if</span> (logRetentionDays &lt; <span class="hljs-number">3</span> ) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 启动一个本地线程，用于处理日志清除</span><br>    localThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (!toStop) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 清除日志目录中超过logRetentionDays天的日志文件 clean log dir, over logRetentionDays</span><br>                    File[] childDirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(XxlJobFileAppender.getLogPath()).listFiles();<br>                    <span class="hljs-keyword">if</span> (childDirs!=<span class="hljs-literal">null</span> &amp;&amp; childDirs.length&gt;<span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// today</span><br>                    <span class="hljs-type">Calendar</span> <span class="hljs-variable">todayCal</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>                    todayCal.set(Calendar.HOUR_OF_DAY,<span class="hljs-number">0</span>);<br>                    todayCal.set(Calendar.MINUTE,<span class="hljs-number">0</span>);<br>                    todayCal.set(Calendar.SECOND,<span class="hljs-number">0</span>);<br>                    todayCal.set(Calendar.MILLISECOND,<span class="hljs-number">0</span>);<br>                    <span class="hljs-type">Date</span> <span class="hljs-variable">todayDate</span> <span class="hljs-operator">=</span> todayCal.getTime();<br>                    <span class="hljs-keyword">for</span> (File childFile: childDirs) &#123;<br>                        <span class="hljs-comment">// valid</span><br>                        <span class="hljs-keyword">if</span> (!childFile.isDirectory()) &#123;<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (childFile.getName().indexOf(<span class="hljs-string">&quot;-&quot;</span>) == -<span class="hljs-number">1</span>) &#123;<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                        <span class="hljs-comment">// file create date</span><br>                        <span class="hljs-type">Date</span> <span class="hljs-variable">logFileCreateDate</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-comment">// 将日志文件名转为时间</span><br>                            <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">simpleDateFormat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>                            logFileCreateDate = simpleDateFormat.parse(childFile.getName());<br>                        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>                            logger.error(e.getMessage(), e);<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (logFileCreateDate == <span class="hljs-literal">null</span>) &#123;<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                        <span class="hljs-comment">// 如果文件时间超过logRetentionDays天，就进行删除</span><br>                        <span class="hljs-keyword">if</span> ((todayDate.getTime(<br></code></pre></td></tr></table></figure><h4 id="启动super-start-gt-初始化回调触发器线程"><a href="#启动super-start-gt-初始化回调触发器线程" class="headerlink" title="启动super.start() -&gt; 初始化回调触发器线程"></a>启动super.start() -&gt; 初始化回调触发器线程</h4><blockquote><p>回调job执行结果给调度器，告诉调度器已执行完</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 启动执行结果回调线程</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span>()</span> &#123;<br>    <span class="hljs-comment">// 判断是否合法的admin地址 valid</span><br>    <span class="hljs-keyword">if</span> (XxlJobExecutor.getAdminBizList() == <span class="hljs-literal">null</span>) &#123;<br>        logger.warn(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, executor callback config fail, adminAddresses is null.&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 启动回调触发线程 callback</span><br>    triggerCallbackThread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        @Override<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>            <span class="hljs-comment">// 进入回调循环处理中 normal callback</span><br>            <span class="hljs-keyword">while</span>(!toStop)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 任务执行完，会把执行结果塞入 LinkedBlockingQueue 中，然后LinkedBlockingQueue.tack()是阻塞形的，会阻塞等待执行结果</span><br>                    HandleCallbackParam callback = getInstance().callBackQueue.take();<br>                    <span class="hljs-keyword">if</span> (callback != <span class="hljs-literal">null</span>) &#123;<br><br>                        <span class="hljs-comment">// 把执行结果全部搞出来，然后塞入callbackParamList，然后批量回调处理 callback list param</span><br>                        List&lt;HandleCallbackParam&gt; callbackParamList = <span class="hljs-keyword">new</span> ArrayList&lt;HandleCallbackParam&gt;();<br>                        <span class="hljs-built_in">int</span> drainToNum = getInstance().callBackQueue.drainTo(callbackParamList);<br>                        callbackParamList.<span class="hljs-keyword">add</span>(callback);<br>                        <span class="hljs-comment">// callback, will retry if error</span><br>                        <span class="hljs-keyword">if</span> (callbackParamList!=<span class="hljs-literal">null</span> &amp;&amp; callbackParamList.size()&gt;<span class="hljs-number">0</span>) &#123;<br>                            doCallback(callbackParamList);<span class="hljs-comment">// 回调执行结果，告诉admin，请求的结果是 addressUrl+&quot;api/callback&quot;</span><br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;......&#125;<br>                    <span class="hljs-comment">// 进行回到后的回归操作 last callback</span><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        List&lt;HandleCallbackParam&gt; callbackParamList = <span class="hljs-keyword">new</span> ArrayList&lt;HandleCallbackParam&gt;();<br>                        <span class="hljs-built_in">int</span> drainToNum = getInstance().callBackQueue.drainTo(callbackParamList);<br>                        <span class="hljs-keyword">if</span> (callbackParamList!=<span class="hljs-literal">null</span> &amp;&amp; callbackParamList.size()&gt;<span class="hljs-number">0</span>) &#123;<br>                            doCallback(callbackParamList);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;..........&#125;<br>                    logger.info(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, executor callback thread destory.&quot;</span>);<br>                &#125;<br></code></pre></td></tr></table></figure><h4 id="启动super-start-gt-初始化执行服务器"><a href="#启动super-start-gt-初始化执行服务器" class="headerlink" title="启动super.start() -&gt;初始化执行服务器"></a>启动super.start() -&gt;初始化执行服务器</h4><blockquote><p>初始化netty服务器，并发客户端信息注册到调度器上</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化执行服务器</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initEmbedServer</span><span class="hljs-params">(String address, String ip, <span class="hljs-type">int</span> port, String appname, String accessToken)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 填充ip和端口号 fill ip port</span><br>    port = port&gt;<span class="hljs-number">0</span>?port: NetUtil.findAvailablePort(<span class="hljs-number">9999</span>);<br>    ip = (ip!=<span class="hljs-literal">null</span>&amp;&amp;ip.trim().length()&gt;<span class="hljs-number">0</span>)?ip: IpUtil.getIp();<br>    <span class="hljs-comment">// 地址为空，就根据ip:port生成新的地址 generate address</span><br>    <span class="hljs-keyword">if</span> (address==<span class="hljs-literal">null</span> || address.trim().length()==<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ip_port_address</span> <span class="hljs-operator">=</span> IpUtil.getIpPort(ip, port); <span class="hljs-comment">// registry-address：default use address to registry , otherwise use         ip:port if address is null</span><br>        address = <span class="hljs-string">&quot;http://&#123;ip_port&#125;/&quot;</span>.replace(<span class="hljs-string">&quot;&#123;ip_port&#125;&quot;</span>, ip_port_address);<br>    &#125;<br>    <span class="hljs-comment">// accessToken</span><br>    <span class="hljs-keyword">if</span> (accessToken==<span class="hljs-literal">null</span> || accessToken.trim().length()==<span class="hljs-number">0</span>) &#123;<br>        logger.warn(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job accessToken is empty. To ensure system security, please set the accessToken.&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 实例化一个网络server start</span><br>    embedServer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmbedServer</span>();<br>    embedServer.start(address, port, appname, accessToken);<span class="hljs-comment">// 启动server，基于netty</span><br>&#125;<br><span class="hljs-comment">// embedServer.start 调用的就是以下方法，启动nettyServer服务器，然后请求注册到调度器上，调度器会通过netty通知来调度job</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String address, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> port, <span class="hljs-keyword">final</span> String appname, <span class="hljs-keyword">final</span> String accessToken)</span> &#123;<br>    executorBiz = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutorBizImpl</span>();<br>    thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// param</span><br>            <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>            <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>            <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">bizThreadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">200</span>, <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="hljs-number">2000</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>() &#123;xxxxx&#125;);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// start server</span><br>                <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>                bootstrap.group(bossGroup, workerGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    ............省略.................<br>                    .addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EmbedHttpServerHandler</span>(executorBiz, accessToken, bizThre<br></code></pre></td></tr></table></figure><p>上面启动了nettyServer，并且对应的实现handler为EmbedHttpServerHandler，通过监听，最终调用如下代码：</p><p>-- 路径为：EmbedHttpServerHandler-&gt;channelRead0-&gt;process()-&gt;executorBiz.run(triggerParam)-&gt;ExecutorBizImpl#run()</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 执行job任务最终会调用到这里</span><br><span class="hljs-comment">* @param triggerParam 执行参数</span><br><span class="hljs-comment">*/</span><br>@Override<br><span class="hljs-keyword">public</span> ReturnT&lt;<span class="hljs-keyword">String</span>&gt; run(TriggerParam triggerParam) &#123;<br>    <span class="hljs-comment">// 加载出对应的jobHandler + jobThread load old：jobHandler + jobThread</span><br>    JobThread jobThread = XxlJobExecutor.loadJobThread(triggerParam.getJobId());<br>    IJobHandler jobHandler = jobThread!=<span class="hljs-literal">null</span>?jobThread.getHandler():<span class="hljs-type">null</span>;<br>    <span class="hljs-keyword">String</span> removeOldReason = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// valid：jobHandler + jobThread</span><br>    GlueTypeEnum glueTypeEnum = GlueTypeEnum.match(triggerParam.getGlueType());<br>    <span class="hljs-keyword">if</span> (GlueTypeEnum.BEAN == glueTypeEnum) &#123;<span class="hljs-comment">// bean的方式调用，现在一般都是这个方式，其他方式是怎么处理的就不解析了</span><br>        <span class="hljs-comment">// new jobhandler</span><br>        IJobHandler <span class="hljs-keyword">new</span><span class="hljs-type">JobHandler</span> = XxlJobExecutor.loadJobHandler(triggerParam.getExecutorHandler());<br>        <span class="hljs-comment">// 验证旧的任务处理器，如果不相等，就创建一个新的 valid old jobThread</span><br>        <span class="hljs-keyword">if</span> (jobThread!=<span class="hljs-literal">null</span> &amp;&amp; jobHandler != <span class="hljs-keyword">new</span><span class="hljs-type">JobHandler</span>) &#123;<br>            <span class="hljs-comment">// change handler, need kill old thread</span><br>            removeOldReason = <span class="hljs-string">&quot;change jobhandler or glue type, and terminate the old job thread.&quot;</span>;<br>            jobThread = <span class="hljs-literal">null</span>;<span class="hljs-comment">// 任务线程</span><br>            jobHandler = <span class="hljs-literal">null</span>;<span class="hljs-comment">// 任务处理器</span><br>        &#125;<br>        <span class="hljs-comment">// 验证处理器并再次赋值 valid handler</span><br>        <span class="hljs-keyword">if</span> (jobHandler == <span class="hljs-literal">null</span>) &#123;<br>            jobHandler = <span class="hljs-keyword">new</span><span class="hljs-type">JobHandler</span>;<br>            <span class="hljs-keyword">if</span> (jobHandler == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ReturnT</span>&lt;<span class="hljs-keyword">String</span>&gt;(ReturnT.FAIL_CODE, <span class="hljs-string">&quot;job handler [&quot;</span> + triggerParam.getExecutorHandler() + <span class="hljs-string">&quot;] not found.&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (GlueTypeEnum.GLUE_GROOVY == glueTypeEnum) &#123;......省略多种其他方式......&#125;<br><br>    <span class="hljs-comment">// 执行block策略 executor block strategy</span><br>    <span class="hljs-keyword">if</span> (jobThread != <span class="hljs-literal">null</span>) &#123;<br>        ExecutorBlockStrategyEnum blockStrategy = ExecutorBlockStrategyEnum.match(triggerParam.getExecutorBlockStrategy(), <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> (ExecutorBlockStrategyEnum.DISCARD_LATER == blockStrategy) &#123;<span class="hljs-comment">// 废弃后面来的</span><br>            <span class="hljs-comment">// discard when running</span><br>            <span class="hljs-keyword">if</span> (jobThread.isRunningOrHasQueue()) &#123;<span class="hljs-comment">// 如果有运行中线程，就终止当前调用</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ReturnT</span>&lt;<span class="hljs-keyword">String</span>&gt;(ReturnT.FAIL_CODE, <span class="hljs-string">&quot;block strategy effect：&quot;</span>+ExecutorBlockStrategyEnum.DISCARD_LATER.getTitle());<br>            &#125;<br>        &#125; <br>        <br></code></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://juejin.cn/post/6987409807430909966">Xxl-Job执行器原理解析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>xxl-job</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xxl-Job调度器原理解析</title>
    <link href="/2022/09/19/java/Xxl-Job%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/09/19/java/Xxl-Job%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>项目解析源码地址：<a href="https://gitee.com/lidishan/xxl-job-code-analysis">xxl-job</a><br>xxl-job版本：2.3.0<br>Xxl-Job分为执行器、调度器。而我们平时的客户端就属于一个执行器，执行器启动的时候会自动注册到调度器上，然后调度器进行远程调度。</p></blockquote><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da76545841614878a200966fda993018~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="image.png"></p><h2 id="调度器初始化过程步骤如下"><a href="#调度器初始化过程步骤如下" class="headerlink" title="调度器初始化过程步骤如下"></a>调度器初始化过程步骤如下</h2><blockquote><p>1 国际化相关  </p><blockquote><p>配置参数： xxl.job.i18n=zh_CN, 这里设置为中文简体  </p></blockquote><p>2 初始化快线程fastTriggerPool、慢线程池slowTriggerPool  </p><blockquote><p>配置参数：xxl.job.triggerpool.fast.max=200, 这里设置为fastTriggerPool的最大线程数=200, 不能小于200<br>xxl.job.triggerpool.slow.max=100, 这里设置为slowTriggerPool的最大线程数=100, 不能小于100  </p></blockquote><p>3 启动注册监听线程  </p><blockquote><p>3.1 初始化registryOrRemoveThreadPool线程池：用于注册或者移除的线程池，客户端调用api/registry或api/registryRemove接口时，会用这个线程池进行注册或注销<br>3.2 启动监听注册的线程registryMonitorThread：清除心跳超过90s的注册信息，并且刷新分组注册信息  </p></blockquote><p>4 启动失败任务监听线程(重试、告警)  </p><blockquote><p>配置参数：spring.mail.from=<a href="https://link.juejin.cn/?target=mailto:xxx@qq.com" title="mailto:xxx@qq.com">[email protected]</a>, 告警邮箱  </p></blockquote><p>5 启动监控线程  </p><blockquote><p>5.1 初始化callbackThreadPool线程池：用于callback回调的线程池，客户端调用api/callback接口时会使用这个线程池<br>5.2 启动监控线monitorThread：调度记录停留在 “运行中” 状态超过10min，且对应执行器心跳注册失败不在线，则将本地调度主动标记失败  </p></blockquote><p>6 启动日志统计和清除线程logrThread  </p><blockquote><p>-- 日志记录刷新，刷新最近三天的日志Report（即统计每天的失败、成功、运行次数等）<br>-- 每天清除一次失效过期的日志数据<br>配置参数：xxl.job.logretentiondays=30, 清除xxl-job数据库日志的过期时间, 小于7天则不清除  </p></blockquote><p>7 启动任务调度（**很重要！！**主要靠这两个线程进行塞数据到时间轮，然后时间轮取数调度任务）  </p><blockquote><p>7.1 scheduleThread线程-取待执行任务数据入时间轮（塞数据）<br>-- 第一步：用select for update 数据库作为分布式锁加锁，避免多个xxl-job admin调度器节点同时执行<br>-- 第二步：预读数据，从数据库中读取当前截止到五秒后内会执行的job信息，并且读取分页大小为preReadCount=6000条数据<br>-— preReadCount = (XxlJobAdminConfig.getAdminConfig().getTriggerPoolFastMax() + XxlJobAdminConfig.getAdminConfig().getTriggerPoolSlowMax()) * 20;<br>-- 第三步：将当前时间与下次调度时间对比，有如下三种情况<br>**** 当前时间 大于 （任务的下一次触发时间 + PRE_READ_MS（5s））：可能是查询太久了，然后下面的代码刷新了任务下次执行时间，导致超过五秒，所以就需要特殊处理<br>-——- 1、匹配过期失效的策略：DO_NOTHING=过期啥也不干，废弃；FIRE_ONCE_NOW=过期立即触发一次<br>-——- 2、刷新上一次触发 和 下一次待触发时间<br>**** 当前时间 大于 任务的下一次触发时间 并且是没有过期的：<br>-——- 1、直接触发任务执行器<br>-——- 2、刷新上一次触发 和 下一次待触发时间<br>-——- 3、如果下一次触发在五秒内，直接放进时间轮里面待调度<br>-————— 1、求当前任务下一次触发时间所处一分钟的第N秒<br>-————— 2、将当前任务ID和ringSecond放进时间轮里面<br>-————— 3、刷新上一次触发 和 下一次待触发时间<br>**** 当前时间 小于 下一次触发时间：<br>-——- 1、求当前任务下一次触发时间所处一分钟的第N秒<br>-——- 2、将当前任务ID和ringSecond放进时间轮里面<br>-——- 3、刷新上一次触发 和 下一次待触发时间<br>-- 第四步：更新数据库执行器信息，如trigger_last_time、trigger_next_time  </p><p>-- 第五步：提交数据库事务，释放数据库select for update排它锁  </p><p>7.2 ringThread线程-根据时间轮执行job任务 （取数据执行）<br>首先时间轮数据格式为：Map&lt;Integer, List&gt; ringData = new ConcurrentHashMap&lt;&gt;()<br>-- 第一步：获取当前所处的一分钟第几秒，然后for两次，第二次是为了重跑前面一个刻度没有被执行的的job list，避免前面的刻度遗漏了<br>-- 第二步：执行触发器<br>-- 第三步：清除当前刻度列表的数据<br>**** 执行的过程中还会选择对应的策略，如下：<br>-——- 阻塞策略：串行、废弃后面、覆盖前面<br>-——- 路由策略：取第一个、取最后一个、最小分发、一致性hash、快速失败、LFU最不常用、LRU最近最少使用、随机、轮询</p></blockquote></blockquote><h2 id="初始化的入口代码为-XxlJobAdminConfig如下"><a href="#初始化的入口代码为-XxlJobAdminConfig如下" class="headerlink" title="初始化的入口代码为 XxlJobAdminConfig如下"></a>初始化的入口代码为 XxlJobAdminConfig如下</h2><pre><code class="hljs">@Componentpublic class XxlJobAdminConfig implements InitializingBean, DisposableBean &#123;    private static XxlJobAdminConfig adminConfig = null;    public static XxlJobAdminConfig getAdminConfig() &#123;        return adminConfig;    &#125;    // ---------------------- XxlJobScheduler ----------------------    private XxlJobScheduler xxlJobScheduler;    @Override    public void afterPropertiesSet() throws Exception &#123;// 生命周期中的属性注入来对xxlJobScheduler初始化        adminConfig = this;        // 初始化xxl-job定时任务        xxlJobScheduler = new XxlJobScheduler();        xxlJobScheduler.init();    &#125;    @Override    public void destroy() throws Exception &#123; // 生命周期中的销毁来对xxlJobScheduler销毁        xxlJobScheduler.destroy();    &#125;    ..............省略..............&#125;     </code></pre><blockquote><p>xxlJobScheduler.init()进行初始化会执行如下过程：</p></blockquote><pre><code class="hljs">public class XxlJobScheduler &#123;    private static final Logger logger = LoggerFactory.getLogger(XxlJobScheduler.class);    public void init() throws Exception &#123;        // 1 国际化相关 init i18n        initI18n();        // 2 初始化快线程池fastTriggerPool、慢线程池slowTriggerPool admin trigger pool start        JobTriggerPoolHelper.toStart();        // 3 启动注册监听线程 admin registry monitor run        JobRegistryHelper.getInstance().start();        // 4 启动失败任务监听线程(重试、告警) admin fail-monitor run        JobFailMonitorHelper.getInstance().start();        // 5 启动监控线程（调度记录停留在 &quot;运行中&quot; 状态超过10min，且对应执行器心跳注册失败不在线，则将本地调度主动标记失败）admin lose-monitor run ( depend on JobTriggerPoolHelper )        JobCompleteHelper.getInstance().start();        // 6 启动日志统计和清除线程（日志记录刷新，刷新最近三天的日志Report（即统计每天的失败、成功、运行次数等）；每天清除一次失效过期的日志数据）admin log report start        JobLogReportHelper.getInstance().start();        // 7 启动任务调度(scheduleThread-取待执行任务数据入时间轮；ringThread-根据时间轮执行job任务) start-schedule ( depend on JobTriggerPoolHelper )        JobScheduleHelper.getInstance().start();        logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin success.&quot;);    &#125;    ................省略........................&#125;     </code></pre><hr><h2 id="上面初始化的7个步骤拆分如下"><a href="#上面初始化的7个步骤拆分如下" class="headerlink" title="上面初始化的7个步骤拆分如下"></a>上面初始化的7个步骤拆分如下</h2><h3 id="1-国际化相关"><a href="#1-国际化相关" class="headerlink" title="1 国际化相关"></a>1 国际化相关</h3><pre><code class="hljs">private void initI18n()&#123;// 根据环境设置title为中文、英文等    for (ExecutorBlockStrategyEnum item:ExecutorBlockStrategyEnum.values()) &#123;        item.setTitle(I18nUtil.getString(&quot;jobconf_block_&quot;.concat(item.name())));    &#125;&#125;     </code></pre><h3 id="2-初始化快线程fastTriggerPool、慢线程池slowTriggerPool"><a href="#2-初始化快线程fastTriggerPool、慢线程池slowTriggerPool" class="headerlink" title="2 初始化快线程fastTriggerPool、慢线程池slowTriggerPool"></a>2 初始化快线程fastTriggerPool、慢线程池slowTriggerPool</h3><blockquote><p>这个步骤初始化了两个线程池fastTriggerPool和slowTriggerPool<br>在触发调度的时候会有一个选择快慢线程池的过程，如果job在一分钟内超过超过10次，就用slowTriggerPool来处理，如下：</p></blockquote><pre><code class="hljs">ThreadPoolExecutor triggerPool_ = fastTriggerPool;AtomicInteger jobTimeoutCount = jobTimeoutCountMap.get(jobId);if (jobTimeoutCount!=null &amp;&amp; jobTimeoutCount.get() &gt; 10) &#123; // job在一分钟内超过超过10次，就用slowTriggerPool来处理 job-timeout 10 times in 1 min    triggerPool_ = slowTriggerPool;&#125;triggerPool_.execute(new Runnable() &#123;.........省略............&#125;     </code></pre><h3 id="3-启动注册监听线程"><a href="#3-启动注册监听线程" class="headerlink" title="3 启动注册监听线程"></a>3 启动注册监听线程</h3><blockquote><p>3.1 初始化registryOrRemoveThreadPool线程池：用于注册或者移除的线程池，客户端调用api/registry或api/registryRemove接口时，会用这个线程池进行注册或注销<br>3.2 启动监听注册的线程registryMonitorThread：清除心跳超过90s的注册信息，并且刷新分组注册信息</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">start</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-comment">// 用于注册或者移除的线程池，客户端调用api/registry或api/registryRemove接口时，会用这个线程池进行注册或注销    for registry or remove</span><br>   registryOrRemoveThreadPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>         <span class="hljs-number">2</span>,<br>         <span class="hljs-number">10</span>,<br>         30L,<br>         <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">SECONDS</span>,<br>         <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;<span class="hljs-title class_">Runnable</span>&gt;(<span class="hljs-number">2000</span>),<br>         <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-title class_">Thread</span> <span class="hljs-title function_">newThread</span>(<span class="hljs-params">Runnable r</span>) &#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;xxl-job, admin JobRegistryMonitorHelper-registryOrRemoveThreadPool-&quot;</span> + r.<span class="hljs-title function_">hashCode</span>());<br>            &#125;<br>         &#125;,<br>         <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionHandler</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">rejectedExecution</span>(<span class="hljs-params">Runnable r, ThreadPoolExecutor executor</span>) &#123;<br>               r.<span class="hljs-title function_">run</span>();<br>               logger.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, registry or remove too fast, match threadpool rejected handler(run now).&quot;</span>);<br>            &#125;<br>         &#125;);<br><br>   <span class="hljs-comment">// 启动监听注册的线程      for monitor</span><br>   registryMonitorThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>         <span class="hljs-keyword">while</span> (!toStop) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-comment">// 获取自动注册的执行器组（执行器地址类型：0=自动注册、1=手动录入） auto registry group</span><br>               <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">XxlJobGroup</span>&gt; groupList = <span class="hljs-title class_">XxlJobAdminConfig</span>.<span class="hljs-title function_">getAdminConfig</span>().<span class="hljs-title function_">getXxlJobGroupDao</span>().<span class="hljs-title function_">findByAddressType</span>(<span class="hljs-number">0</span>);<br>               <span class="hljs-keyword">if</span> (groupList!=<span class="hljs-literal">null</span> &amp;&amp; !groupList.<span class="hljs-title function_">isEmpty</span>()) &#123;<span class="hljs-comment">// group组集合不为空</span><br>                  <span class="hljs-comment">// 移除死掉的调用地址（心跳时间超过90秒，就当线程挂掉了。默认是30s做一次心跳）          remove dead address (admin/executor)</span><br>                  <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Integer</span>&gt; ids = <span class="hljs-title class_">XxlJobAdminConfig</span>.<span class="hljs-title function_">getAdminConfig</span>().<span class="hljs-title function_">getXxlJobRegistryDao</span>().<span class="hljs-title function_">findDead</span>(<span class="hljs-title class_">RegistryConfig</span>.<span class="hljs-property">DEAD_TIMEOUT</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>                  <span class="hljs-keyword">if</span> (ids!=<span class="hljs-literal">null</span> &amp;&amp; ids.<span class="hljs-title function_">size</span>()&gt;<span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 移除挂掉的注册地址信息</span><br>                     <span class="hljs-title class_">XxlJobAdminConfig</span>.<span class="hljs-title function_">getAdminConfig</span>().<span class="hljs-title function_">getXxlJobRegistryDao</span>().<span class="hljs-title function_">removeDead</span>(ids);<br>                  &#125;<br>   <br>                  <span class="hljs-comment">// fresh online address (admin/executor)</span><br>                  <span class="hljs-title class_">HashMap</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt;&gt; appAddressMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt;&gt;();<br>                  <span class="hljs-comment">// 找出所有正常没死掉的注册地址</span><br>                  <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">XxlJobRegistry</span>&gt; list = <span class="hljs-title class_">XxlJobAdminConfig</span>.<span class="hljs-title function_">getAdminConfig</span>().<span class="hljs-title function_">getXxlJobRegistryDao</span>().<span class="hljs-title function_">findAll</span>(<span class="hljs-title class_">RegistryConfig</span>.<span class="hljs-property">DEAD_TIMEOUT</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>                  <span class="hljs-keyword">if</span> (list != <span class="hljs-literal">null</span>) &#123;<br>                     <span class="hljs-keyword">for</span> (<span class="hljs-title class_">XxlJobRegistry</span> <span class="hljs-attr">item</span>: list) &#123;<br>                        <span class="hljs-comment">// 确保是 EXECUTOR 执行器类型</span><br>                        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">RegistryConfig</span>.<span class="hljs-property">RegistType</span>.<span class="hljs-property">EXECUTOR</span>.<span class="hljs-title function_">name</span>().<span class="hljs-title function_">equals</span>(item.<span class="hljs-title function_">getRegistryGroup</span>())) &#123;<br>                           <span class="hljs-title class_">String</span> appname = item.<span class="hljs-title function_">getRegistryKey</span>();<br>                           <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; registryList = appAddressMap.<span class="hljs-title function_">get</span>(appname);<br>                           <span class="hljs-keyword">if</span> (registryList == <span class="hljs-literal">null</span>) &#123;<br>                              registryList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-title class_">String</span>&gt;();<br>                           &#125;<br><br><br>     <br>                           <span class="hljs-keyword">if</span> (!registryList.<span class="hljs-title function_">contains</span>(item.<span class="hljs-title function_">getRegistryValue</span>())) &#123;<br>                              registryList.<span class="hljs-title function_">add</span>(item.<span class="hljs-title function_">getRegistryValue</span>());<br>                           &#125;<br>                           appAddressMap.<span class="hljs-title function_">put</span>(appname, registryList);<br>                        &#125;<br>                     &#125;<br>                  &#125;<br><br><br>     <br>                  <span class="hljs-comment">// 刷新分组注册地址信息  fresh group address</span><br>                  <span class="hljs-keyword">for</span> (<span class="hljs-title class_">XxlJobGroup</span> <span class="hljs-attr">group</span>: groupList) &#123;<br>                     <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; registryList = appAddressMap.<span class="hljs-title function_">get</span>(group.<span class="hljs-title function_">getAppname</span>());<br>                     <span class="hljs-title class_">String</span> addressListStr = <span class="hljs-literal">null</span>;<br>                     <span class="hljs-keyword">if</span> (registryList!=<span class="hljs-literal">null</span> &amp;&amp; !registryList.<span class="hljs-title function_">isEmpty</span>()) &#123;<br>                        <span class="hljs-title class_">Collections</span>.<span class="hljs-title function_">sort</span>(registryList);<br>                        <span class="hljs-title class_">StringBuilder</span> addressListSB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">String</span> <span class="hljs-attr">item</span>:registryList) &#123;<br>                           addressListSB.<span class="hljs-title function_">append</span>(item).<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;,&quot;</span>);<br>                        &#125;<br>                        addressListStr = addressListSB.<span class="hljs-title function_">toString</span>();<br>                        addressListStr = addressListStr.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, addressListStr.<span class="hljs-title function_">length</span>()-<span class="hljs-number">1</span>);<br>                     &#125;<br>                     group.<span class="hljs-title function_">setAddressList</span>(addressListStr);<br>                     group.<span class="hljs-title function_">setUpdateTime</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br><br><br><br>                     <span class="hljs-title class_">XxlJobAdminConfig</span>.<span class="hljs-title function_">getAdminConfig</span>().<span class="hljs-title function_">getXxlJobGroupDao</span>().<span class="hljs-title function_">update</span>(group);<br>                  &#125;<br>               &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br>               <span class="hljs-keyword">if</span> (!toStop) &#123;<br>                  logger.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job registry monitor thread error:&#123;&#125;&quot;</span>, e);<br>               &#125;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">SECONDS</span>.<span class="hljs-title function_">sleep</span>(<span class="hljs-title class_">RegistryConfig</span>.<span class="hljs-property">BEAT_TIMEOUT</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">InterruptedException</span> e) &#123;<br>               <span class="hljs-keyword">if</span> (!toStop) &#123;<br>                  logger.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job registry monitor thread error:&#123;&#125;&quot;</span>, e);<br>               &#125;<br>            &#125;<br>         &#125;<br>         logger.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job registry monitor thread stop&quot;</span>);<br>      &#125;     <br>   &#125;);<br>   registryMonitorThread.<span class="hljs-title function_">setDaemon</span>(<span class="hljs-literal">true</span>);<br>   registryMonitorThread.<span class="hljs-title function_">setName</span>(<span class="hljs-string">&quot;xxl-job, admin JobRegistryMonitorHelper-registryMonitorThread&quot;</span>);<br>   registryMonitorThread.<span class="hljs-title function_">start</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-启动失败任务监听线程-重试、告警"><a href="#4-启动失败任务监听线程-重试、告警" class="headerlink" title="4 启动失败任务监听线程(重试、告警)"></a>4 启动失败任务监听线程(重试、告警)</h3><blockquote><p>这部分逻辑比较简单，就是重试 + 告警，核心代码如下</p></blockquote><pre><code class="hljs">// 获取执行失败的job信息List&lt;Long&gt; failLogIds = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().findFailJobLogIds(1000);if (failLogIds!=null &amp;&amp; !failLogIds.isEmpty()) &#123;   for (long failLogId: failLogIds) &#123;      // lock log      int lockRet = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateAlarmStatus(failLogId, 0, -1);      if (lockRet &lt; 1) &#123;         continue;      &#125;      XxlJobLog log = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().load(failLogId);      XxlJobInfo info = XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().loadById(log.getJobId());      // 1、失败塞回重试       fail retry monitor      if (log.getExecutorFailRetryCount() &gt; 0) &#123;         JobTriggerPoolHelper.trigger(log.getJobId(), TriggerTypeEnum.RETRY, (log.getExecutorFailRetryCount()-1), log.getExecutorShardingParam(), log.getExecutorParam(), null);         String retryMsg = &quot;&lt;span style=\&quot;color:#F39C12;\&quot; &gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;+ I18nUtil.getString(&quot;jobconf_trigger_type_retry&quot;) +&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; &lt;/span&gt;&quot;;         log.setTriggerMsg(log.getTriggerMsg() + retryMsg);         XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateTriggerInfo(log);      &#125;      // 2、进行失败告警       fail alarm monitor      int newAlarmStatus = 0;       // 告警状态：0-默认、-1=锁定状态、1-无需告警、2-告警成功、3-告警失败      if (info!=null &amp;&amp; info.getAlarmEmail()!=null &amp;&amp; info.getAlarmEmail().trim().length()&gt;0) &#123;         boolean alarmResult = XxlJobAdminConfig.getAdminConfig().getJobAlarmer().alarm(info, log);         newAlarmStatus = alarmResult?2:3;      &#125; else &#123;         newAlarmStatus = 1;      &#125;      XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateAlarmStatus(failLogId, -1, newAlarmStatus);   &#125;&#125;     </code></pre><h3 id="5-启动监控线程"><a href="#5-启动监控线程" class="headerlink" title="5 启动监控线程"></a>5 启动监控线程</h3><blockquote><p>5.1 初始化callbackThreadPool线程池：用于callback回调的线程池，客户端调用api/callback接口时会使用这个线程池<br>5.2 启动监控线monitorThread：调度记录停留在 “运行中” 状态超过10min，且对应执行器心跳注册失败不在线，则将本地调度主动标记失败</p></blockquote><h3 id="6-启动日志统计和清除线程logrThread"><a href="#6-启动日志统计和清除线程logrThread" class="headerlink" title="6 启动日志统计和清除线程logrThread"></a>6 启动日志统计和清除线程logrThread</h3><blockquote><p>-- 日志记录刷新，刷新最近三天的日志Report（即统计每天的失败、成功、运行次数等）<br>-- 每天清除一次失效过期的日志数据<br>配置参数：xxl.job.logretentiondays=30, 清除xxl-job数据库日志的过期时间, 小于7天则不清除</p></blockquote><h3 id="7-启动任务调度（重点！！）"><a href="#7-启动任务调度（重点！！）" class="headerlink" title="7 启动任务调度（重点！！）"></a>7 启动任务调度（<strong>重点！！</strong>）</h3><blockquote><p>7.1 scheduleThread线程-取待执行任务数据入时间轮（塞数据）<br>-- 第一步：用select for update 数据库作为分布式锁加锁，避免多个xxl-job admin调度器节点同时执行<br>-- 第二步：预读数据，从数据库中读取当前截止到五秒后内会执行的job信息，并且读取分页大小为preReadCount=6000条数据<br>-— preReadCount = (XxlJobAdminConfig.getAdminConfig().getTriggerPoolFastMax() + XxlJobAdminConfig.getAdminConfig().getTriggerPoolSlowMax()) * 20;<br>-- 第三步：将当前时间与下次调度时间对比，有如下三种情况<br>**** 当前时间 大于 （任务的下一次触发时间 + PRE_READ_MS（5s））：可能是查询太久了，然后下面的代码刷新了任务下次执行时间，导致超过五秒，所以就需要特殊处理<br>-——- 1、匹配过期失效的策略：DO_NOTHING=过期啥也不干，废弃；FIRE_ONCE_NOW=过期立即触发一次<br>-——- 2、刷新上一次触发 和 下一次待触发时间<br>**** 当前时间 大于 任务的下一次触发时间 并且是没有过期的：<br>-——- 1、直接触发任务执行器<br>-——- 2、刷新上一次触发 和 下一次待触发时间<br>-——- 3、如果下一次触发在五秒内，直接放进时间轮里面待调度<br>-————— 1、求当前任务下一次触发时间所处一分钟的第N秒<br>-————— 2、将当前任务ID和ringSecond放进时间轮里面<br>-————— 3、刷新上一次触发 和 下一次待触发时间<br>**** 当前时间 小于 下一次触发时间：<br>-——- 1、求当前任务下一次触发时间所处一分钟的第N秒<br>-——- 2、将当前任务ID和ringSecond放进时间轮里面<br>-——- 3、刷新上一次触发 和 下一次待触发时间<br>-- 第四步：更新数据库执行器信息，如trigger_last_time、trigger_next_time  </p><p>-- 第五步：提交数据库事务，释放数据库select for update排它锁  </p><p>7.2 ringThread线程-根据时间轮执行job任务 （取数据执行）<br>首先时间轮数据格式为：Map&lt;Integer, List&gt; ringData = new ConcurrentHashMap&lt;&gt;()<br>-- 第一步：获取当前所处的一分钟第几秒，然后for两次，第二次是为了重跑前面一个刻度没有被执行的的job list，避免前面的刻度遗漏了<br>-- 第二步：执行触发器<br>-- 第三步：清除当前刻度列表的数据<br>**** 执行的过程中还会选择对应的策略，如下：<br>-——- 阻塞策略：串行、废弃后面、覆盖前面<br>-——- 路由策略：取第一个、取最后一个、最小分发、一致性hash、快速失败、LFU最不常用、LRU最近最少使用、随机、轮询</p></blockquote><ul><li>  启动两个线程解析的核心源码如下：<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void start<span class="hljs-literal">()</span>&#123;<br><br>    <span class="hljs-comment">// 启动调度线程，这些线程是用来取数据的 schedule thread</span><br>    scheduleThread = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(<span class="hljs-params">new</span> Runnable()</span> &#123;<br>    @Override<br>    public void run<span class="hljs-literal">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">// 不知道为啥要休眠 4-5秒 时间，然后再启动</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TimeUnit</span>.</span><span class="hljs-module"><span class="hljs-identifier">MILLISECONDS</span>.</span></span>sleep(<span class="hljs-number">5000</span> - <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>%<span class="hljs-number">1000</span> );<br>    &#125; catch (InterruptedException e) &#123;<br>        <span class="hljs-keyword">if</span> (!scheduleThreadToStop) &#123;<br>            logger.error(e.get<span class="hljs-constructor">Message()</span>, e);<br>        &#125;<br>    &#125;<br>    logger.info(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin scheduler success.&quot;</span>);<br>    <br>    <span class="hljs-comment">// 这里是预读数量 pre-read count: treadpool-size * trigger-qps (each trigger cost 50ms, qps = 1000/50 = 20)</span><br>    <span class="hljs-built_in">int</span> preReadCount = (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">XxlJobAdminConfig</span>.</span></span>get<span class="hljs-constructor">AdminConfig()</span>.get<span class="hljs-constructor">TriggerPoolFastMax()</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">XxlJobAdminConfig</span>.</span></span>get<span class="hljs-constructor">AdminConfig()</span>.get<span class="hljs-constructor">TriggerPoolSlowMax()</span>)<span class="hljs-operator"> * </span><span class="hljs-number">20</span>;<br>    <br>    <span class="hljs-keyword">while</span> (!scheduleThreadToStop) &#123;<br>    <span class="hljs-comment">// 扫描任务 Scan Job</span><br>    long start = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;<br>    Connection conn = null;<br>    Boolean connAutoCommit = null;<br>    PreparedStatement preparedStatement = null<br>    boolean preReadSuc = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        conn = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">XxlJobAdminConfig</span>.</span></span>get<span class="hljs-constructor">AdminConfig()</span>.get<span class="hljs-constructor">DataSource()</span>.get<span class="hljs-constructor">Connection()</span>;<br>        connAutoCommit = conn.get<span class="hljs-constructor">AutoCommit()</span>;<br>        conn.set<span class="hljs-constructor">AutoCommit(<span class="hljs-params">false</span>)</span>;<br>        <span class="hljs-comment">// 采用select for update，是排它锁。说白了xxl-job用一张数据库表来当分布式锁了，确保多个xxl-job admin节点下，依旧只能同时执行一个调度线程任务</span><br>        preparedStatement = conn.prepare<span class="hljs-constructor">Statement( <span class="hljs-string">&quot;select * from xxl_job_lock where lock_name = &#x27;schedule_lock&#x27; for update&quot;</span> )</span>;<br>        preparedStatement.execute<span class="hljs-literal">()</span>;<br>    <br>        <span class="hljs-comment">// tx start</span><br>    <br>        <span class="hljs-comment">// 1、预读数据 pre read</span><br>        long nowTime = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;<br>        <span class="hljs-comment">// -- 从数据库中读取截止到五秒后未执行的job，并且读取preReadCount=6000条</span><br>        List&lt;XxlJobInfo&gt; scheduleList = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">XxlJobAdminConfig</span>.</span></span>get<span class="hljs-constructor">AdminConfig()</span>.get<span class="hljs-constructor">XxlJobInfoDao()</span>.schedule<span class="hljs-constructor">JobQuery(<span class="hljs-params">nowTime</span> + PRE_READ_MS, <span class="hljs-params">preReadCount</span>)</span>;<br>        <span class="hljs-keyword">if</span> (scheduleList!=null<span class="hljs-operator"> &amp;&amp; </span>scheduleList.size<span class="hljs-literal">()</span>&gt;<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 2、push压进 时间轮 push time-ring</span><br>            <span class="hljs-keyword">for</span> (XxlJobInfo jobInfo: scheduleList) &#123;<br>    <br>                <span class="hljs-comment">// time-ring jump</span><br>                <span class="hljs-keyword">if</span> (nowTime &gt; jobInfo.get<span class="hljs-constructor">TriggerNextTime()</span> + PRE_READ_MS) &#123;<br>                    <span class="hljs-comment">// 当前时间 大于 （任务的下一次触发时间 + PRE_READ_MS（5s））,可能是查询太久了，然后下面的代码刷新了任务下次执行时间，导致超过五秒，所以就需要特殊处理</span><br>                    <span class="hljs-comment">// 2.1、trigger-expire &gt; 5s：pass &amp;&amp; make next-trigger-time</span><br>                    logger.warn(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, schedule misfire, jobId = &quot;</span> + jobInfo.get<span class="hljs-constructor">Id()</span>);<br>                    <span class="hljs-comment">// 1、匹配过期失效的策略：DO_NOTHING=过期啥也不干，废弃；FIRE_ONCE_NOW=过期立即触发一次 misfire match</span><br>                    MisfireStrategyEnum misfireStrategyEnum = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MisfireStrategyEnum</span>.</span></span><span class="hljs-keyword">match</span>(jobInfo.get<span class="hljs-constructor">MisfireStrategy()</span>, MisfireStrategyEnum.DO_NOTHING);<br>                    <span class="hljs-keyword">if</span> (MisfireStrategyEnum.FIRE_ONCE_NOW<span class="hljs-operator"> == </span>misfireStrategyEnum) &#123;<br>                        <span class="hljs-comment">// FIRE_ONCE_NOW 》 trigger</span><br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JobTriggerPoolHelper</span>.</span></span>trigger(jobInfo.get<span class="hljs-constructor">Id()</span>, TriggerTypeEnum.MISFIRE, -<span class="hljs-number">1</span>, null, null, null);<br>                        logger.debug(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, schedule push trigger : jobId = &quot;</span> + jobInfo.get<span class="hljs-constructor">Id()</span> );<br>                    &#125;<br>                    <span class="hljs-comment">// 2、刷新上一次触发 和 下一次待触发时间 fresh next</span><br>                    refresh<span class="hljs-constructor">NextValidTime(<span class="hljs-params">jobInfo</span>, <span class="hljs-params">new</span> Date()</span>);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nowTime &gt; jobInfo.get<span class="hljs-constructor">TriggerNextTime()</span>) &#123;<br>                    <span class="hljs-comment">// 当前时间 大于 任务的下一次触发时间 并且是没有过期的</span><br>                    <span class="hljs-comment">// 2.2、trigger-expire &lt; 5s：direct-trigger &amp;&amp; make next-trigger-time</span><br>                    <span class="hljs-comment">// 1、直接触发任务执行器 trigger</span><br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JobTriggerPoolHelper</span>.</span></span>trigger(jobInfo.get<span class="hljs-constructor">Id()</span>, TriggerTypeEnum.CRON, -<span class="hljs-number">1</span>, null, null, null);<br>                    logger.debug(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, schedule push trigger : jobId = &quot;</span> + jobInfo.get<span class="hljs-constructor">Id()</span> );<br>                    <span class="hljs-comment">// 2、刷新上一次触发 和 下一次待触发时间 fresh next</span><br>                    refresh<span class="hljs-constructor">NextValidTime(<span class="hljs-params">jobInfo</span>, <span class="hljs-params">new</span> Date()</span>);<br>    <br>                    <span class="hljs-comment">// 如果下一次触发在五秒内，直接放进时间轮里面待调度 next-trigger-time in 5s, pre-read again</span><br>                    <span class="hljs-keyword">if</span> (jobInfo.get<span class="hljs-constructor">TriggerStatus()</span>==<span class="hljs-number">1</span><span class="hljs-operator"> &amp;&amp; </span>nowTime + PRE_READ_MS &gt; jobInfo.get<span class="hljs-constructor">TriggerNextTime()</span>) &#123;<br>                        <span class="hljs-comment">// 1、求当前任务下一次触发时间所处一分钟的第N秒 make ring second</span><br>                        <span class="hljs-built_in">int</span> ringSecond = (<span class="hljs-built_in">int</span>)((jobInfo.get<span class="hljs-constructor">TriggerNextTime()</span>/<span class="hljs-number">1000</span>)%<span class="hljs-number">60</span>);<br>                        <span class="hljs-comment">// 2、将当前任务ID和ringSecond放进时间轮里面 push time ring</span><br>                        push<span class="hljs-constructor">TimeRing(<span class="hljs-params">ringSecond</span>, <span class="hljs-params">jobInfo</span>.<span class="hljs-params">getId</span>()</span>);<br>                        <span class="hljs-comment">// 3、刷新上一次触发 和 下一次待触发时间 fresh next</span><br>                        refresh<span class="hljs-constructor">NextValidTime(<span class="hljs-params">jobInfo</span>, <span class="hljs-params">new</span> Date(<span class="hljs-params">jobInfo</span>.<span class="hljs-params">getTriggerNextTime</span>()</span>));<br>                    &#125;<br>    <br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 当前时间 小于 下一次触发时间</span><br>                    <span class="hljs-comment">// 2.3、trigger-pre-read：time-ring trigger &amp;&amp; make next-trigger-time</span><br>                    <span class="hljs-comment">// 1、求当前任务下一次触发时间所处一分钟的第N秒 make ring second</span><br>                    <span class="hljs-built_in">int</span> ringSecond = (<span class="hljs-built_in">int</span>)((jobInfo.get<span class="hljs-constructor">TriggerNextTime()</span>/<span class="hljs-number">1000</span>)%<span class="hljs-number">60</span>);<br>                    <span class="hljs-comment">// 2、将当前任务ID和ringSecond放进时间轮里面 push time ring</span><br>                    push<span class="hljs-constructor">TimeRing(<span class="hljs-params">ringSecond</span>, <span class="hljs-params">jobInfo</span>.<span class="hljs-params">getId</span>()</span>);<br>                    <span class="hljs-comment">// 3、刷新上一次触发 和 下一次待触发时间 fresh next</span><br>                    refresh<span class="hljs-constructor">NextValidTime(<span class="hljs-params">jobInfo</span>, <span class="hljs-params">new</span> Date(<span class="hljs-params">jobInfo</span>.<span class="hljs-params">getTriggerNextTime</span>()</span>));<br>                &#125;<br>            &#125;<br>    <br>            <span class="hljs-comment">// 3、更新数据库执行器信息，如trigger_last_time、trigger_next_time update trigger info</span><br>            <span class="hljs-keyword">for</span> (XxlJobInfo jobInfo: scheduleList) &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">XxlJobAdminConfig</span>.</span></span>get<span class="hljs-constructor">AdminConfig()</span>.get<span class="hljs-constructor">XxlJobInfoDao()</span>.schedule<span class="hljs-constructor">Update(<span class="hljs-params">jobInfo</span>)</span>;<br>            &#125;<br>    <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            preReadSuc = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// tx stop</span><br>    &#125; catch (Exception e) &#123;<br>        <span class="hljs-keyword">if</span> (!scheduleThreadToStop) &#123;<br>            logger.error(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, JobScheduleHelper#scheduleThread error:&#123;&#125;&quot;</span>, e);<br>        &#125;<br>    &#125; finally &#123;<br>        <span class="hljs-comment">// 提交事务，释放数据库select for update的锁 commit</span><br>        .......................省略.............   <br>    &#125;<br>    long cost = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>-start;<br>    <br>    <span class="hljs-comment">// 如果执行太快了，就稍微sleep等待一下 Wait seconds, align second</span><br>    <span class="hljs-keyword">if</span> (cost &lt; <span class="hljs-number">1000</span>) &#123; <span class="hljs-comment">// scan-overtime, not wait</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// pre-read period: success &gt; scan each second; fail &gt; skip this period;</span><br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TimeUnit</span>.</span><span class="hljs-module"><span class="hljs-identifier">MILLISECONDS</span>.</span></span>sleep((preReadSuc?<span class="hljs-number">1000</span>:PRE_READ_MS) - <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>%<span class="hljs-number">1000</span>);<br>        &#125; catch (InterruptedException e) &#123;<br>            <span class="hljs-keyword">if</span> (!scheduleThreadToStop) &#123;<br>                logger.error(e.get<span class="hljs-constructor">Message()</span>, e);<br>            &#125;<br>        &#125;<br>    &#125;);<br>    scheduleThread.set<span class="hljs-constructor">Daemon(<span class="hljs-params">true</span>)</span>;<br>    scheduleThread.set<span class="hljs-constructor">Name(<span class="hljs-string">&quot;xxl-job, admin JobScheduleHelper#scheduleThread&quot;</span>)</span>;<br>    scheduleThread.start<span class="hljs-literal">()</span>;<br><br><br>    <span class="hljs-comment">// 时间轮线程，用于取出每秒的数据，然后处理 ring thread</span><br>    ringThread = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(<span class="hljs-params">new</span> Runnable()</span> &#123;<br>        @Override<br>        public void run<span class="hljs-literal">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (!ringThreadToStop) &#123;<br>                <span class="hljs-comment">// align second</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TimeUnit</span>.</span><span class="hljs-module"><span class="hljs-identifier">MILLISECONDS</span>.</span></span>sleep(<span class="hljs-number">1000</span> - <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span> % <span class="hljs-number">1000</span>);<br>                &#125; catch (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">if</span> (!ringThreadToStop) &#123;<br>                        logger.error(e.get<span class="hljs-constructor">Message()</span>, e);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// second data</span><br>                    List&lt;Integer&gt; ringItemData = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br>                    <span class="hljs-comment">// 获取当前所处的一分钟第几秒，然后for两次，第二次是为了重跑前面一个刻度没有被执行的的job list，避免前面的刻度遗漏了</span><br>                    <span class="hljs-built_in">int</span> nowSecond = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Calendar</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.get(Calendar.SECOND); <span class="hljs-comment">// 避免处理耗时太长，跨过刻度，向前校验一个刻度；</span><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>                        List&lt;Integer&gt; tmpData = ringData.remove( (nowSecond+<span class="hljs-number">60</span>-i)%<span class="hljs-number">60</span> );<br>                        <span class="hljs-keyword">if</span> (tmpData != null) &#123;<br>                            ringItemData.add<span class="hljs-constructor">All(<span class="hljs-params">tmpData</span>)</span>;<br>                        &#125;<br>                    &#125;<br>    <br>                    <span class="hljs-comment">// ring trigger</span><br>                    logger.debug(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, time-ring beat : &quot;</span> + nowSecond + <span class="hljs-string">&quot; = &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-params">ringItemData</span>)</span> );<br>                    <span class="hljs-keyword">if</span> (ringItemData.size<span class="hljs-literal">()</span> &gt; <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// do trigger</span><br>                        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> jobId: ringItemData) &#123;<br>                            <span class="hljs-comment">// 执行触发器 do trigger</span><br>                            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JobTriggerPoolHelper</span>.</span></span>trigger(jobId, TriggerTypeEnum.CRON, -<span class="hljs-number">1</span>, null, null, null);<br>                        &#125;<br>                        <span class="hljs-comment">// 清除当前刻度列表的数据 clear</span><br>                        ringItemData.clear<span class="hljs-literal">()</span>;<br>                    &#125;<br>                &#125; catch (Exception e) &#123;<br>                    <span class="hljs-keyword">if</span> (!ringThreadToStop) &#123;<br>                        logger.error(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, JobScheduleHelper#ringThread error:&#123;&#125;&quot;</span>, e);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            logger.info(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, JobScheduleHelper#ringThread stop&quot;</span>);<br>        &#125;<br>    &#125;);<br>    ringThread.set<span class="hljs-constructor">Daemon(<span class="hljs-params">true</span>)</span>;<br>    ringThread.set<span class="hljs-constructor">Name(<span class="hljs-string">&quot;xxl-job, admin JobScheduleHelper#ringThread&quot;</span>)</span>;<br>    ringThread.start<span class="hljs-literal">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2></li></ul><ul><li><a href="https://juejin.cn/post/6987415823690235934">Xxl-Job调度器原理解析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>xxl-job</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>modified subpath configmap mount fails when container restarts</title>
    <link href="/2022/09/13/k8s/modified%20subpath%20configmap%20mount%20fails%20when%20container%20restarts/"/>
    <url>/2022/09/13/k8s/modified%20subpath%20configmap%20mount%20fails%20when%20container%20restarts/</url>
    
    <content type="html"><![CDATA[<p>k8s 1.20 以下版本使用subpath会出现此问题</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://github.com/kubernetes/kubernetes/issues/68211">modified subpath configmap mount fails when container restarts</a></li><li><a href="https://www.cnblogs.com/cmt/p/14333247.html">【故障公告】K8s CofigMap 挂载问题引发网站故障</a></li><li><a href="https://github.com/moby/moby/issues/37083">docker run –mount creates a directory owned by root if directory is removed at a wrong time</a></li><li><a href="https://github.com/kubernetes/kubernetes/issues/96240">OCI runtime create failed: container_linux.go:349: starting container process caused “process_linux.go:449</a></li><li><a href="https://github.com/kubernetes/kubernetes/issues/68211">modified subpath configmap mount fails when container restarts </a></li><li><a href="https://github.com/kubernetes/kubernetes/pull/89629">Modified subpath configmap mount fails when container restarts </a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>configmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之设计原则</title>
    <link href="/2022/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <url>/2022/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>应该有且仅有一个原因引起类的变更</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>类的复杂性降低</li><li>可读性提高，复杂性降低</li><li>可维护性提高，可读性提高</li><li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可度量的，因项目而异，因环境而异。</p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>第一种定义，也是最正宗的定义：If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为S的对象o1，都有类型为T的对 象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变 化，那么类型S是类型T的子类型。）</li><li>第二种定义：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的 对象。）</li></ul><p>第二个定义是最清晰明确的，通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但 是，反过来就不行了，有子类出现的地方，父类未必就能适应。</p><p>里氏替换原则为良好的继承定义了一个规范，一句简单的定义包含了4层含义。</p><ul><li>1.子类必须完全实现父类的方法</li><li>2.子类可以有自己的个性</li><li>3.覆盖或实现父类的方法时输入参数可以被放大</li><li>4.覆写或实现父类的方法时输出结果可以被缩小</li></ul><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>采用里氏替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。在实际项目中，每个子类对应不同的业务 含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑，非常完美！</p><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.</p><p>翻译过来，包含三层含义:</p><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象</li><li>抽象不应该依赖细节</li><li>细节应该依赖抽象</li></ul><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。</p><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>设计是否具备稳定性，只要适当地“松松土”，观察“设计的蓝图”是否还可以茁壮地成长就可以得出结论，稳定性较高的设计，在周围环境频繁变化的时候，依然可以做到“我自岿然不动”。</p><h4 id="依赖的三种写法"><a href="#依赖的三种写法" class="headerlink" title="依赖的三种写法"></a>依赖的三种写法</h4><p>依赖是可以传递的，A对象依赖B对象，B又依赖C，C又依赖D……生生不息，依赖不止，记住一点：只要做到抽象依赖，即使是多层的依赖传递也无所畏惧！</p><p>对象的依赖关系有三种方式来传递</p><ul><li>1.构造函数传递依赖对象</li><li>2.Setter方法传递依赖对象</li><li>3.接口声明依赖对象</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合，我们怎么在项目中使用这个规则呢？只要遵循以下的几个规则就可以:</p><ul><li>每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备</li><li>变量的表面类型尽量是接口或者是抽象类</li><li>任何类都不应该从具体类派生</li><li>尽量不要覆写基类的方法</li><li>结合里氏替换原则使用</li></ul><p>依赖倒置原则是6个设计原则中最难以实现的原则，它是实现开闭原则的重要途径，依赖倒置原则没有实现，就别想实现对扩展开放，对修改关闭。在项目中，大家只要记住是“面向接口编程”就基本上抓住了依赖倒置原则的核心</p><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><ul><li>Clients should not be forced to depend upon interfaces that they don’t use.（客户端不应该依赖它不需要的接口。）</li><li>or The dependency of one class to another one should depend on the smallest possible interface. （类间的依赖关系应该建立在最小的接口上。）</li></ul><h4 id="接口隔离原则是对接口进行规范约束，其包含以下4层含义"><a href="#接口隔离原则是对接口进行规范约束，其包含以下4层含义" class="headerlink" title="接口隔离原则是对接口进行规范约束，其包含以下4层含义"></a>接口隔离原则是对接口进行规范约束，其包含以下4层含义</h4><ul><li>接口要尽量小</li><li>接口要高内聚<ul><li>什么是高内聚？高内聚就是提高接口、类、模块的处理能力，减少对外的交互。比如你告诉下属“到奥巴马的办公室偷一个×××文件”，然后听到下属用坚定的口吻回答你：“是，保证完成任务！”一个月后，你的下属还真的把×××文件放到你的办公桌上了，这种不讲任何条件、立刻完成任务的行为就是高内聚的表现。具体到接口隔离原则就是，要求在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越少，同时也有利于降低成本。</li></ul></li><li>定制服务</li><li>接口设计是有限度的</li></ul><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>接口隔离原则是对接口的定义，同时也是对类的定义，接口和类尽量使用原子接口或原子类来组装。但是，这个原子该怎么划分是设计模式中的一大难题，在实践中可以根据以下几个规则来衡量:</p><ul><li>一个接口只服务于一个子模块或业务逻辑</li><li>通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到“满身筋骨肉”，而不是“肥嘟嘟”的一大堆方法</li><li>已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理</li><li>了解环境，拒绝盲从。每个项目或产品都有特定的环境因素，别看到大师是这样做的你就照抄。千万别，环境不同，接口拆分的标准就不同。深入了解业务逻辑，最好的接口设计就出自你的手中！</li></ul><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least KnowledgePrinciple，LKP），虽然名字不同，但描述的是同一个规则：一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public方法，我就调用这么多，其他的我一概不关心<br>朋友类:<br>出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类</p><h4 id="迪米特法则对类的低耦合提出了明确的要求，其包含以下4层含义"><a href="#迪米特法则对类的低耦合提出了明确的要求，其包含以下4层含义" class="headerlink" title="迪米特法则对类的低耦合提出了明确的要求，其包含以下4层含义"></a>迪米特法则对类的低耦合提出了明确的要求，其包含以下4层含义</h4><ul><li>1.只和朋友交流</li><li>2.朋友间也是有距离的</li><li>3.是自己的就是自己的</li><li>4.谨慎使用Serializable</li></ul><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p>Software entities like classes,modules and functions should be open for extension but closed for modifications.（一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。）</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>开闭原则是一个终极目标，任何人包括大师级人物都无法百分之百做到，但朝这个方向努力，可以非常显著地改善一个系统的架构，真正做到“拥抱变化”。</p><h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>原则是尽量使用合成/聚合的方式，而不是使用继承。</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li>设计模式之禅（第2版）</li><li><a href="https://java-design-patterns.com/patterns/">Java Design Patterns</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>设计原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Template method</title>
    <link href="/2022/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/TemplateMethod/"/>
    <url>/2022/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/TemplateMethod/</url>
    
    <content type="html"><![CDATA[<p>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</p><p><img src="/img/design-patterns/img_2.png"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://java-design-patterns.com/patterns/template-method/"> Template method</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Adapter</title>
    <link href="/2022/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/adapter/"/>
    <url>/2022/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/adapter/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/design-patterns/img_1.png"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://java-design-patterns.com/patterns/adapter/">adapter</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Principles</title>
    <link href="/2022/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Principles/"/>
    <url>/2022/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Principles/</url>
    
    <content type="html"><![CDATA[<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://java-design-patterns.com/principles/">principles</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>设计原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Strategy</title>
    <link href="/2022/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Strategy/"/>
    <url>/2022/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Strategy/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/design-patterns/img.png"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://java-design-patterns.com/patterns/strategy/">Strategy</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Factory Method</title>
    <link href="/2022/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/FactoryMethod/"/>
    <url>/2022/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/FactoryMethod/</url>
    
    <content type="html"><![CDATA[<p>Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.</p><p><img src="/img/design-patterns/img_3.png"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://java-design-patterns.com/patterns/factory-method/">Factory Method</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bean与Component同时作用同一个类</title>
    <link href="/2022/09/13/spring/%E6%B3%A8%E8%A7%A3Bean%E4%B8%8E%E6%B3%A8%E8%A7%A3Component%E5%90%8C%E6%97%B6%E4%BD%9C%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E7%B1%BB,%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7/"/>
    <url>/2022/09/13/spring/%E6%B3%A8%E8%A7%A3Bean%E4%B8%8E%E6%B3%A8%E8%A7%A3Component%E5%90%8C%E6%97%B6%E4%BD%9C%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E7%B1%BB,%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.cnblogs.com/youzhibing/p/15354706.html">关于 Spring Boot 中创建对象的疑虑 → @Bean 与 @Component 同时作用同一个类，会怎么样？ </a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring事务常见错误</title>
    <link href="/2022/09/13/spring/Spring%E4%BA%8B%E5%8A%A1%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"/>
    <url>/2022/09/13/spring/Spring%E4%BA%8B%E5%8A%A1%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="unchecked异常与事务回滚"><a href="#unchecked异常与事务回滚" class="headerlink" title="unchecked异常与事务回滚"></a>unchecked异常与事务回滚</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StudentMapper studentMapper;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveStudent</span><span class="hljs-params">(String realName)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        student.setRealname(realname);<br>        studentMapper.saveStudent(student);<br>        <span class="hljs-keyword">if</span> (student.getRealName().equals(<span class="hljs-string">&quot;小明&quot;</span>)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;该学生已存在&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们通过 debug 沿着 saveStudent 继续往下跟，得到了一个这样的调用栈:<br><img src="img.png"></p><p>从这个调用栈中我们看到了熟悉的 CglibAopProxy，另外事务本质上也是一种特殊的切面，在创建的过程中，被 CglibAopProxy 代理。事务处理的拦截器是TransactionInterceptor，它支撑着整个事务功能的架构，我们来分析下这个拦截器是如何实现事务特性的。</p><p>首先，TransactionInterceptor 继承类 TransactionAspectSupport，实现了接口MethodInterceptor。当执行代理类的目标方法时，会触发 invoke()。由于我们的关注重点是在异常处理上，所以直奔主题，跳到异常处理相关的部分。当它 catch 到异常时，会调用 completeTransactionAfterThrowing 方法做进一步处理。<br><img src="img_1.png"></p><p>在 completeTransactionAfterThrowing 的代码中，有这样一个方法 rollbackOn()，这是事务的回滚的关键判断条件。当这个条件满足时，会触发 rollback 操作，事务回滚。<br><img src="img_2.png"></p><p>rollbackOn() 其实包括了两个层级，具体可参考如下代码：<br><img src="img_3.png"></p><p>1.RuleBasedTransactionAttribute 自身的 rollbackOn()</p><p>当我们在 @Transactional 中配置了 rollbackFor，这个方法就会用捕获到的异常和rollbackFor 中配置的异常做比较。如果捕获到的异常是 rollbackFor 配置的异常或其子类，就会直接 rollback。在我们的案例中，由于在事务的注解中没有加任何规则，所以这段逻辑处理其实找不到规则（即 winner == null），进而走到下一步。</p><p>2.RuleBasedTransactionAttribute 父类 DefaultTransactionAttribute 的 rollbackOn()</p><p>如果没有在 @Transactional 中配置 rollback 属性，或是捕获到的异常和所配置异常的类型不一致，就会继续调用父类的 rollbackOn() 进行处理。</p><p>而在父类的 rollbackOn() 中，我们发现了一个重要的线索，只有在异常类型为RuntimeException 或者 Error 的时候才会返回 true，此时，会触发completeTransactionAfterThrowing 方法中的 rollback 操作，事务被回滚。<br><img src="img_4.png"></p><p>查到这里，真相大白，Spring 处理事务的时候，如果没有在 @Transactional 中配置rollback 属性，那么只有捕获到 RuntimeException 或者 Error 的时候才会触发回滚操作。而我们案例抛出的异常是 Exception，又没有指定与之匹配的回滚规则，所以我们不能触发回滚。</p><h2 id="试图给private方法添加事务"><a href="#试图给private方法添加事务" class="headerlink" title="试图给private方法添加事务"></a>试图给private方法添加事务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StudentMapper studentMapper;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StudentService studentService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveStudent</span><span class="hljs-params">(String realName)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        student.setRealname(realName);<br>        studentService.doSaveStudent(student);<br>    &#125;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSaveStudent</span><span class="hljs-params">(Student student)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        studentMapper.saveStudent(student);<br>        <span class="hljs-keyword">if</span> (student.getRealname().equals(<span class="hljs-string">&quot;小明&quot;</span>)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;该用户已存在&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过debug，我们一步步寻找到了问题的根源，得到了以下调用栈。我们通过 Spring的源码来解析一下完整的过程。</p><p><img src="https://static001.geekbang.org/resource/image/d8/ce/d87ef9769456803c6d9db35c8d7503ce.png"></p><p>前一段是 Spring 创建 Bean 的过程。当 Bean 初始化之后，开始尝试代理操作，这个过程是从 AbstractAutoProxyCreator 里的 postProcessAfterInitialization 方法开始处理的：</p><p><img src="img_6.png"></p><p>我们一路往下找，暂且略过那些非关键要素的代码，直到到了 AopUtils 的 canApply 方法。这个方法就是针对切面定义里的条件，确定这个方法是否可以被应用创建成代理。其中有一段 methodMatcher.matches(method, targetClass) 是用来判断这个方法是否符合这样的条件：</p><p><img src="img_7.png"></p><p>从 matches() 调用到了 AbstractFallbackTransactionAttributeSource的getTransactionAttribute：<br><img src="img_8.png"></p><p>其中，getTransactionAttribute 这个方法是用来获取注解中的事务属性，根据属性确定事务采用什么样的策略。<br><img src="img_9.png"></p><p>接着调用到 computeTransactionAttribute 这个方法，其主要功能是根据方法和类的类型确定是否返回事务属性，执行代码如下：<br><img src="img_10.png"></p><p>这里有这样一个判断 allowPublicMethodsOnly() &amp;&amp;!Modifier.isPublic(method.getModifiers()) ，当这个判断结果为 true 的时候返回 null，也就意味着这个方法不会被代理，从而导致事务的注解不会生效。那此处的判断值到底是不是 true 呢？我们可以分别看一下。</p><h3 id="条件-1：allowPublicMethodsOnly"><a href="#条件-1：allowPublicMethodsOnly" class="headerlink" title="条件 1：allowPublicMethodsOnly()"></a>条件 1：allowPublicMethodsOnly()</h3><p>allowPublicMethodsOnly 返回了 AnnotationTransactionAttributeSource的publicMethodsOnly 属性。</p><p><img src="img_11.png"></p><blockquote><p>springframework:5.2.5.RELEASE,不同版本默认值不同</p></blockquote><p>这个publicMethodsOnly 属性是通过 AnnotationTransactionAttributeSource 的构造方法初始化的，默认为 false。</p><h3 id="条件-2：Modifier-isPublic"><a href="#条件-2：Modifier-isPublic" class="headerlink" title="条件 2：Modifier.isPublic()"></a>条件 2：Modifier.isPublic()</h3><p>这个方法根据传入的 method.getModifiers() 获取方法的修饰符。该修饰符是java.lang.reflect.Modifier 的静态属性，对应的几类修饰符分别是：PUBLIC: 1，PRIVATE: 2，PROTECTED: 4。这里面做了一个位运算，只有当传入的方法修饰符是public 类型的时候，才返回 true。<br><img src="img_12.png"></p><p>综合上述两个条件，你会发现，只有当注解为事务的方法被声明为 public 的时候，才会被Spring 处理。</p><h3 id="问题修正"><a href="#问题修正" class="headerlink" title="问题修正"></a>问题修正</h3><p>了解了问题的根源以后，解决它就变得很简单了，我们只需要把它的修饰符从 private 改成 public 就可以了。不过需要额外补充的是，我们调用这个加了事务注解的方法，必须是调用被 Spring AOP代理过的方法，也就是不能通过类的内部调用或者通过 this 的方式调用。<br>所以我们的案例的 StudentService，它含有一个自动装配（Autowired）了自身（StudentService）的实例来完成代理方法的调用。这个问题我们在之前 Spring AOP 的代码解析中重点强调过，此处就不再详述了。</p><h2 id="嵌套事务回滚错误"><a href="#嵌套事务回滚错误" class="headerlink" title="嵌套事务回滚错误"></a>嵌套事务回滚错误</h2><p>我们增加了一个新的业务类 CourseService，用于实现相关业务逻辑。分别调用了两个方法来保存学生与课程的关联关系，并给课程注册人数+1。最后，别忘了给这个方法加上事务注解。<br><img src="img_13.png"></p><p>我们在之前的 StudentService.saveStudent() 中调用了 regCourse()，实现了完整的业务逻辑。为了避免注册课程的业务异常导致学生信息无法保存，在这里 catch 了注册课程方法中抛出的异常。我们希望的结果是，当注册课程发生错误时，只回滚注册课程部分，保证学生信息依然正常。<br><img src="img_14.png"></p><p>为了验证异常是否符合预期，我们在 regCourse() 里抛出了一个注册失败的异常：<br><img src="img_15.png"></p><p>运行一下这段代码，在控制台里我们看到了以下提示信息：<br><img src="img_16.png"></p><p>运行一下这段代码，在控制台里我们看到了以下提示信息：其中，注册失败部分的异常符合预期，但是后面又多了一个这样的错误提示：Transaction rolled back because it has been marked as rollback-only。</p><p>最后的结果是，学生和选课的信息都被回滚了，显然这并不符合我们的预期。我们期待的结果是即便内部事务 regCourse() 发生异常，外部事务 saveStudent() 俘获该异常后，内部事务应自行回滚，不影响外部事务。那么这是什么原因造成的呢？我们需要研究一下Spring 的源码，来找找答案。</p><h3 id="案例解析"><a href="#案例解析" class="headerlink" title="案例解析"></a>案例解析</h3><p>在做进一步地解析之前，我们可以先通过伪代码把整个事务的结构梳理一下：<br><img src="img_17.png"><br>可以看出来，整个业务是包含了2层事务，外层的saveStudent()的事务和内层的regCourse() 事务。</p><p>在 Spring 声明式的事务处理中，有一个属性 propagation，表示打算对这些方法怎么使用事务，即一个带事务的方法调用了另一个带事务的方法，被调用的方法它怎么处理自己事务和调用方法事务之间的关系。</p><p>其中 propagation 有 7 种配置：REQUIRED、SUPPORTS、MANDATORY、REQUIRES_NEW、NOT_SUPPORTED、NEVER、NESTED。默认是 REQUIRED，它的含<br>义是：如果本来有事务，则加入该事务，如果没有事务，则创建新的事务。</p><p>结合我们的伪代码示例，因为在 saveStudent() 上声明了一个外部的事务，就已经存在一个事务了，在 propagation 值为默认的 REQUIRED 的情况下， regCourse() 就会加入到已有的事务中，两个方法共用一个事务。</p><p>我们再来看下 Spring 事务处理的核心，其关键实现参考<br>TransactionAspectSupport.invokeWithinTransaction()：<br><img src="img_18.png"><br>整个方法完成了事务的一整套处理逻辑，如下：<br>1.检查是否需要创建事务；<br>2.调用具体的业务方法进行处理；<br>3.提交事务；<br>4.处理异常。</p><p><img src="img_19.png"></p><p>这里要格外注意的是，当前案例是两个事务嵌套的场景，外层事务 doSaveStudent() 和内层事务 regCourse()，每个事务都会调用到这个方法。所以，这个方法会被调用两次。下面我们来具体来看下内层事务对异常的处理。</p><p>当捕获了异常，会调用TransactionAspectSupport.completeTransactionAfterThrowing() 进行异常处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><br># org.springframework.transaction.interceptor.TransactionAspectSupport.completeTransactionAfterThrowing<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completeTransactionAfterThrowing</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TransactionInfo txInfo, Throwable ex)</span> &#123;<br>        <span class="hljs-keyword">if</span> (txInfo != <span class="hljs-literal">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isTraceEnabled()) &#123;<br>                <span class="hljs-built_in">this</span>.logger.trace(<span class="hljs-string">&quot;Completing transaction for [&quot;</span> + txInfo.getJoinpointIdentification() + <span class="hljs-string">&quot;] after exception: &quot;</span> + ex);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (txInfo.transactionAttribute != <span class="hljs-literal">null</span> &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());<br>                &#125; <span class="hljs-keyword">catch</span> (TransactionSystemException var6) &#123;<br>                    <span class="hljs-built_in">this</span>.logger.error(<span class="hljs-string">&quot;Application exception overridden by rollback exception&quot;</span>, ex);<br>                    var6.initApplicationException(ex);<br>                    <span class="hljs-keyword">throw</span> var6;<br>                &#125; <span class="hljs-keyword">catch</span> (Error | RuntimeException var7) &#123;<br>                    <span class="hljs-built_in">this</span>.logger.error(<span class="hljs-string">&quot;Application exception overridden by rollback exception&quot;</span>, ex);<br>                    <span class="hljs-keyword">throw</span> var7;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());<br>                &#125; <span class="hljs-keyword">catch</span> (TransactionSystemException var4) &#123;<br>                    <span class="hljs-built_in">this</span>.logger.error(<span class="hljs-string">&quot;Application exception overridden by commit exception&quot;</span>, ex);<br>                    var4.initApplicationException(ex);<br>                    <span class="hljs-keyword">throw</span> var4;<br>                &#125; <span class="hljs-keyword">catch</span> (Error | RuntimeException var5) &#123;<br>                    <span class="hljs-built_in">this</span>.logger.error(<span class="hljs-string">&quot;Application exception overridden by commit exception&quot;</span>, ex);<br>                    <span class="hljs-keyword">throw</span> var5;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>在这个方法里，我们对异常类型做了一些检查，当符合声明中的定义后，执行了具体的rollback 操作，这个操作是通过 TransactionManager.rollback() 完成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"># org.springframework.transaction.support.AbstractPlatformTransactionManager.rollback<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">(TransactionStatus status)</span> <span class="hljs-keyword">throws</span> TransactionException &#123;<br>        <span class="hljs-keyword">if</span> (status.isCompleted()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalTransactionStateException</span>(<span class="hljs-string">&quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">DefaultTransactionStatus</span> <span class="hljs-variable">defStatus</span> <span class="hljs-operator">=</span> (DefaultTransactionStatus)status;<br>            <span class="hljs-built_in">this</span>.processRollback(defStatus, <span class="hljs-literal">false</span>);<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>而 rollback() 是在 AbstractPlatformTransactionManager 中实现的，继续调用了processRollback()：<br><img src="img_20.png"></p><p>这个方法里区分了三种不同类型的情况：<br>1.是否有保存点；<br>2.是否为一个新的事务；<br>3.是否处于一个更大的事务中。</p><p>在这里，因为我们用的是默认的传播类型 REQUIRED，嵌套的事务并没有开启一个新的事务，所以在这种情况下，当前事务是处于一个更大的事务中，所以会走到情况3分支1的代码块下。</p><p>这里有两个判断条件来确定是否设置为仅回滚：<br>if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure())</p><p>满足任何一个，都会执行 doSetRollbackOnly() 操作。isLocalRollbackOnly 在当前的情 况下是 false，所以是否分设置为仅回滚就由 isGlobalRollbackOnParticipationFailure()这个方法来决定了，其默认值为 true， 即是否回滚交由外层事务统一决定 。</p><p>显然这里的条件得到了满足，从而执行 doSetRollbackOnly：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"># org.springframework.jdbc.datasource.DataSourceTransactionManager.doSetRollbackOnly<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSetRollbackOnly</span><span class="hljs-params">(DefaultTransactionStatus status)</span> &#123;<br>        <span class="hljs-type">DataSourceTransactionObject</span> <span class="hljs-variable">txObject</span> <span class="hljs-operator">=</span> (DataSourceTransactionObject)status.getTransaction();<br>        <span class="hljs-keyword">if</span> (status.isDebug()) &#123;<br>            <span class="hljs-built_in">this</span>.logger.debug(<span class="hljs-string">&quot;Setting JDBC transaction [&quot;</span> + txObject.getConnectionHolder().getConnection() + <span class="hljs-string">&quot;] rollback-only&quot;</span>);<br>        &#125;<br><br>        txObject.setRollbackOnly();<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>以及最终调用到的 DataSourceTransactionObject 中的 setRollbackOnly()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"># org.springframework.jdbc.datasource.DataSourceTransactionManager.DataSourceTransactionObject.setRollbackOnly<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRollbackOnly</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-built_in">this</span>.getConnectionHolder().setRollbackOnly();<br>        &#125;<br></code></pre></td></tr></table></figure><p>到这一步，内层事务的操作基本执行完毕，它处理了异常，并最终调用到了DataSourceTransactionObject 中的 setRollbackOnly() 。</p><p>接下来，我们来看外层事务。因为在外层事务中，我们自己的代码捕获了内层抛出来的异常，所以这个异常不会继续往上抛，最后的事务会在 TransactionAspectSupport.invokeWithinTransaction() 中的 commitTransactionAfterReturning() 中进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">#org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commitTransactionAfterReturning</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TransactionInfo txInfo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (txInfo != <span class="hljs-literal">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isTraceEnabled()) &#123;<br>                <span class="hljs-built_in">this</span>.logger.trace(<span class="hljs-string">&quot;Completing transaction for [&quot;</span> + txInfo.getJoinpointIdentification() + <span class="hljs-string">&quot;]&quot;</span>);<br>            &#125;<br><br>            txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>在这个方法里我们执行了 commit 操作，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"># org.springframework.transaction.support.AbstractPlatformTransactionManager.commit<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(TransactionStatus status)</span> <span class="hljs-keyword">throws</span> TransactionException &#123;<br>        <span class="hljs-keyword">if</span> (status.isCompleted()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalTransactionStateException</span>(<span class="hljs-string">&quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">DefaultTransactionStatus</span> <span class="hljs-variable">defStatus</span> <span class="hljs-operator">=</span> (DefaultTransactionStatus)status;<br>            <span class="hljs-keyword">if</span> (defStatus.isLocalRollbackOnly()) &#123;<br>                <span class="hljs-keyword">if</span> (defStatus.isDebug()) &#123;<br>                    <span class="hljs-built_in">this</span>.logger.debug(<span class="hljs-string">&quot;Transactional code has requested rollback&quot;</span>);<br>                &#125;<br><br>                <span class="hljs-built_in">this</span>.processRollback(defStatus, <span class="hljs-literal">false</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;<br>                <span class="hljs-keyword">if</span> (defStatus.isDebug()) &#123;<br>                    <span class="hljs-built_in">this</span>.logger.debug(<span class="hljs-string">&quot;Global transaction is marked as rollback-only but transactional code requested commit&quot;</span>);<br>                &#125;<br><br>                <span class="hljs-built_in">this</span>.processRollback(defStatus, <span class="hljs-literal">true</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">this</span>.processCommit(defStatus);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在 AbstractPlatformTransactionManager.commit() 中，当满足了shouldCommitOnGlobalRollbackOnly() 和 defStatus.isGlobalRollbackOnly()，就会回<br>滚，否则会继续提交事务。其中 shouldCommitOnGlobalRollbackOnly() 的作用为，如果发现了事务被标记了全局回滚，并且在发生了全局回滚的情况下，判断是否应该提交事务，这个方法的默认实现是返回了 false，这里我们不需要关注它，继续查看isGlobalRollbackOnly() 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"># org.springframework.transaction.support.DefaultTransactionStatus.isGlobalRollbackOnly<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isGlobalRollbackOnly</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.transaction <span class="hljs-keyword">instanceof</span> SmartTransactionObject &amp;&amp; ((SmartTransactionObject)<span class="hljs-built_in">this</span>.transaction).isRollbackOnly();<br>    &#125;<br></code></pre></td></tr></table></figure><p>这个方法最终进入了 DataSourceTransactionObject 类中的 isRollbackOnly()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"># org.springframework.jdbc.datasource.DataSourceTransactionManager.DataSourceTransactionObject.isRollbackOnly<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isRollbackOnly</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getConnectionHolder().isRollbackOnly();<br>        &#125;<br></code></pre></td></tr></table></figure><p>现在让我们再次回顾一下之前的内部事务处理结果，其最终调用到的是DataSourceTransactionObject 中的 setRollbackOnly()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"># org.springframework.jdbc.datasource.DataSourceTransactionManager.DataSourceTransactionObject.setRollbackOnly<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRollbackOnly</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-built_in">this</span>.getConnectionHolder().setRollbackOnly();<br>        &#125;<br></code></pre></td></tr></table></figure><p>isRollbackOnly() 和 setRollbackOnly() 这两个方法的执行本质都是对ConnectionHolder 中 rollbackOnly 属性标志位的存取，而 ConnectionHolder 则存在于 DefaultTransactionStatus 类实例的 transaction 属性之中。</p><p>至此，答案基本浮出水面了，我们把整个逻辑串在一起就是：外层事务是否回滚的关键，最终取决于 <strong>DataSourceTransactionObject 类中的 isRollbackOnly()，而该方法的返回值，正是我们在内层异常的时候设置的</strong>。</p><p>所以最终外层事务也被回滚了，从而在控制台中打印出异常信息：”Transaction rolled back because it has been marked as rollback-only”。</p><p>所以到这里，问题也就清楚了，Spring 默认的事务传播属性为 REQUIRED，如我们之前介绍的，它的含义是：如果本来有事务，则加入该事务，如果没有事务，则创建新的事务，因而内外两层事务都处于同一个事务中。所以，当我们在 regCourse() 中抛出异常，并触发了回滚操作时，这个回滚会进一步传播，从而把 saveStudent() 也回滚了。最终导致整个事务都被回滚了。</p><h3 id="问题修正-1"><a href="#问题修正-1" class="headerlink" title="问题修正"></a>问题修正</h3><p>从上述案例解析中，我们了解到，Spring 在处理事务过程中，有个默认的传播属性REQUIRED，在整个事务的调用链上，任何一个环节抛出的异常都会导致全局回滚。</p><p>知道了这个结论，修改方法也就很简单了，我们只需要对传播属性进行修改，把类型改成REQUIRES_NEW 就可以了。于是这部分代码就修改成这样：<br><img src="img_21.png"></p><p>运行一下看看：<br><img src="img_22.png"><br>异常正常抛出，注册课程部分的数据没有保存，但是学生还是正常注册成功。这意味着此时 Spring 只对注册课程这部分的数据进行了回滚，并没有传播到上一级。</p><p>这里我简单解释下这个过程：</p><ul><li>当子事务声明为 Propagation.REQUIRES_NEW 时，在TransactionAspectSupport.invokeWithinTransaction() 中调用createTransactionIfNecessary() 就会创建一个新的事务，独立于外层事务。</li><li>而在 AbstractPlatformTransactionManager.processRollback() 进行 rollback 处理时，因为 status.isNewTransaction() 会因为它处于一个新的事务中而返回 true，所以它走入到了另一个分支，执行了 doRollback() 操作，让这个子事务单独回滚，不会影响到主事务。</li></ul><p>至此，这个问题得到了很好的解决。</p><h2 id="多数据源间切换之谜"><a href="#多数据源间切换之谜" class="headerlink" title="多数据源间切换之谜"></a>多数据源间切换之谜</h2><h3 id="案例解析-1"><a href="#案例解析-1" class="headerlink" title="案例解析"></a>案例解析</h3><p>这是一个相对常见的需求，学生注册和发卡都要在一个事务里完成，但是我们都默认只会连一个数据源，之前我们一直连的都是学生信息这个数据源，在这里，我们还需要对校园卡的数据源进行操作。于是，我们需要在一个事务里完成对两个数据源的操作，该如何实现这样的功能呢？</p><p>我们继续从 Spring 的源码中寻找答案。在 Spring 里有这样一个抽象类AbstractRoutingDataSource，这个类相当于 DataSource 的路由中介，在运行时根据某种key 值来动态切换到所需的 DataSource 上。通过实现这个类就可以实现我们期望的动态数据源切换。</p><p>这里强调一下，这个类里有这么几个关键属性：</p><ul><li>targetDataSources 保存了 key 和数据库连接的映射关系；</li><li>defaultTargetDataSource 标识默认的连接；</li><li>resolvedDataSources 存储数据库标识和数据源的映射关系。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">#org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractRoutingDataSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractDataSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">private</span> Map&lt;Object, Object&gt; targetDataSources;<br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">private</span> Object defaultTargetDataSource;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">lenientFallback</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">DataSourceLookup</span> <span class="hljs-variable">dataSourceLookup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JndiDataSourceLookup</span>();<br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">private</span> Map&lt;Object, DataSource&gt; resolvedDataSources;<br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">private</span> DataSource resolvedDefaultDataSource;<br>    <span class="hljs-comment">//省略非关键代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>AbstractRoutingDataSource 实现了 InitializingBean 接口，并覆写了afterPropertiesSet()。该方法会在初始化 Bean 的时候执行，将多个 DataSource 初始化到 resolvedDataSources。这里的 targetDataSources 属性存储了将要切换的多数据源Bean 信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">#org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource.afterPropertiesSet<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.targetDataSources == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Property &#x27;targetDataSources&#x27; is required&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.resolvedDataSources = CollectionUtils.newHashMap(<span class="hljs-built_in">this</span>.targetDataSources.size());<br>            <span class="hljs-built_in">this</span>.targetDataSources.forEach((key, value) -&gt; &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">lookupKey</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.resolveSpecifiedLookupKey(key);<br>                <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.resolveSpecifiedDataSource(value);<br>                <span class="hljs-built_in">this</span>.resolvedDataSources.put(lookupKey, dataSource);<br>            &#125;);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.defaultTargetDataSource != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-built_in">this</span>.resolvedDefaultDataSource = <span class="hljs-built_in">this</span>.resolveSpecifiedDataSource(<span class="hljs-built_in">this</span>.defaultTargetDataSource);<br>            &#125;<br><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>获取数据库连接的是 getConnection()，它调用了 determineTargetDataSource() 来创建连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"># org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource.getConnection()<br><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.determineTargetDataSource().getConnection();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">(String username, String password)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.determineTargetDataSource().getConnection(username, password);<br>    &#125;<br></code></pre></td></tr></table></figure><p>determineTargetDataSource() 是整个部分的核心，它的作用就是动态切换数据源。有多少个数据源，就存多少个数据源在 targetDataSources 中。</p><p>targetDataSources 是一个 Map 类型的属性，key 表示每个数据源的名字，value 对应的是每个数据源 DataSource。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">#org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource.determineTargetDataSource<br>    <span class="hljs-keyword">protected</span> DataSource <span class="hljs-title function_">determineTargetDataSource</span><span class="hljs-params">()</span> &#123;<br>        Assert.notNull(<span class="hljs-built_in">this</span>.resolvedDataSources, <span class="hljs-string">&quot;DataSource router not initialized&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">lookupKey</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.determineCurrentLookupKey();<br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> (DataSource)<span class="hljs-built_in">this</span>.resolvedDataSources.get(lookupKey);<br>        <span class="hljs-keyword">if</span> (dataSource == <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-built_in">this</span>.lenientFallback || lookupKey == <span class="hljs-literal">null</span>)) &#123;<br>            dataSource = <span class="hljs-built_in">this</span>.resolvedDefaultDataSource;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (dataSource == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Cannot determine target DataSource for lookup key [&quot;</span> + lookupKey + <span class="hljs-string">&quot;]&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> dataSource;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>而选择哪个数据源又是由 determineCurrentLookupKey() 来决定的，此方法是抽象方法，需要我们继承 AbstractRoutingDataSource 抽象类来重写此方法。该方法返回一个key，该 key 是 Bean 中的 beanName，并赋值给 lookupKey，由此 key 可以通过resolvedDataSources 属性的键来获取对应的 DataSource 值，从而达到数据源切换的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Object <span class="hljs-title function_">determineCurrentLookupKey</span><span class="hljs-params">()</span>;<br><br></code></pre></td></tr></table></figure><p>这样看来，这个方法的实现就得由我们完成了。接下来我们将会完成一系列相关的代码，解决这个问题。</p><h3 id="问题修正-2"><a href="#问题修正-2" class="headerlink" title="问题修正"></a>问题修正</h3><p>首先，我们创建一个 MyDataSource 类，继承了 AbstractRoutingDataSource，并覆写了 determineCurrentLookupKey()：<br><img src="img_23.png"></p><p>其次，我们需要修改 JdbcConfig。这里我新写了一个 dataSource，将原来的dataSource 改成 dataSourceCore，再将新定义的 dataSourceCore 和 dataSourceCard放进一个 Map，对应的 key 分别是 core 和 card，并把 Map 赋值给setTargetDataSources</p><p><img src="img_24.png"><br><img src="img_25.png"></p><p>最后还剩下一个问题，setDataSource 这个方法什么时候执行呢？</p><p>我们可以用 Spring AOP 来设置，把配置的数据源类型都设置成注解标签， Service 层中在切换数据源的方法上加上注解标签，就会调用相应的方法切换数据源。</p><p>我们定义了一个新的注解 @DataSource，可以直接加在 Service() 上，实现数据库切换：<br><img src="img_26.png"></p><p>声明方法如下：<br><img src="img_27.png"></p><p>另外，我们还需要写一个 Spring AOP 来对相应的服务方法进行拦截，完成数据源的切换操作。特别要注意的是，这里要加上一个 @Order(1) 标记它的初始化顺序。这个 Order值一定要比事务的 AOP 切面的值小，这样可以获得更高的优先级，否则自动切换数据源将会失效。<br><img src="img_28.png"></p><p>最后，我们实现了 Card 的发卡逻辑，在方法前声明了切换数据库：<br><img src="img_29.png"></p><p>并在 saveStudent() 里调用了发卡逻辑：<br><img src="img_30.png"></p><p>执行一下，一切正常，两个库的数据都可以正常保存了。<br>最后我们来看一下整个过程的调用栈，重新过一遍流程（这里我略去了不重要的部分）。<br>在创建了事务以后，会通过 DataSourceTransactionManager.doBegin() 获取相应的数据库连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBegin</span><span class="hljs-params">(Object transaction, TransactionDefinition definition)</span> &#123;<br>    <span class="hljs-type">DataSourceTransactionObject</span> <span class="hljs-variable">txObject</span> <span class="hljs-operator">=</span> (DataSourceTransactionObject)transaction;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (!txObject.hasConnectionHolder() || txObject.getConnectionHolder().isSynchronizedWithTransaction()) &#123;<br>            <span class="hljs-type">Connection</span> <span class="hljs-variable">newCon</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.obtainDataSource().getConnection();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isDebugEnabled()) &#123;<br>                <span class="hljs-built_in">this</span>.logger.debug(<span class="hljs-string">&quot;Acquired Connection [&quot;</span> + newCon + <span class="hljs-string">&quot;] for JDBC transaction&quot;</span>);<br>            &#125;<br><br>            txObject.setConnectionHolder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionHolder</span>(newCon), <span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-comment">//省略非关键代码</span><br>        &#125;<br>    <br>    &#125;<br></code></pre></td></tr></table></figure><p>这里的 obtainDataSource().getConnection() 调用到了AbstractRoutingDataSource.getConnection()，这就与我们实现的功能顺利会师了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.determineTargetDataSource().getConnection();<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="http://90.84.47.13/188-Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B%EF%BC%88%E5%AE%8C%E7%BB%93%EF%BC%89/04-Spring%E8%A1%A5%E5%85%85%E7%AF%87%287%E8%AE%B2%29/19%E4%B8%A8Spring%E4%BA%8B%E5%8A%A1%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%EF%BC%88%E4%B8%8A%EF%BC%89.html">19 | Spring 事务常见错误（上）</a></li><li><a href="http://90.84.47.13/188-Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B%EF%BC%88%E5%AE%8C%E7%BB%93%EF%BC%89/04-Spring%E8%A1%A5%E5%85%85%E7%AF%87%287%E8%AE%B2%29/20%E4%B8%A8Spring%E4%BA%8B%E5%8A%A1%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%EF%BC%88%E4%B8%8B%EF%BC%89.html">20 | Spring 事务常见错误（下）</a></li><li><a href="https://github.com/baymax55/springissue">code</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Use Kali Linux NetHunter on Android</title>
    <link href="/2022/09/13/other/Kali-Linux-NetHunter-Android-install-in-5-minutes/"/>
    <url>/2022/09/13/other/Kali-Linux-NetHunter-Android-install-in-5-minutes/</url>
    
    <content type="html"><![CDATA[<h1 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h1><ol><li>A Physical Android Phone. You can do this install on an Android 12 phone,but a phone running on a version before Android 12 is recommended. See the link to the article below on GitHub on how Android monitors and kills forked child processes of apps when they use too much of the CPU. <a href="https://github.com/termux/terethutmux-app/issues/2366">https://github.com/termux/terethutmux-app/issues/2366</a></li></ol><ol><li>You will need to install Termux. You can get Termux from the F-Droid store or from their<br>GitHub repo using one of the following links (In the demo we use GitHub):<ul><li><a href="https://f-droid.org/packages/com.termux/">https://f-droid.org/packages/com.termux/</a></li><li><a href="https://github.com/termux/termux-app/releases">https://github.com/termux/termux-app/releases</a><br>Take note that the official Termux Wiki and TermuxGitHub pages indicates that you<br>should not install the outdated version hosted on the Google Play Store.</li></ul></li><li>Download the latest Termux version at the time of writing it is termux-app_v0.118.0+github-debug_arm64-v8a.apk from the github link above.</li></ol><ol start="3"><li>Open and Install the downloaded APK file. Press on Install and then Open.</li></ol><h2 id="apt-update-and-apt-upgrade"><a href="#apt-update-and-apt-upgrade" class="headerlink" title="apt update and apt upgrade"></a>apt update and apt upgrade</h2><p>Debian Linux and many of its derivatives use <strong>APT (Advanced Package Tool)</strong> to install tools. We need to run <strong>apt update</strong> to get the package source information from the configured resources in the <strong>/etc/apt/sources.list</strong> file. This is how the system knows which files needs to be updated and where they can be downloaded from.</p><p><strong>apt upgrade</strong> will then use the information to upgrade all the installed packages to their latest versions.</p><ol start="4"><li>Enter the following command: apt update</li></ol><ol start="5"><li>Enter the following command: apt upgrade</li></ol><ol start="6"><li>When you get asked to “Do you want to continue” press Y and Enter.</li></ol><ol start="7"><li>When prompted for an action press <strong>Y</strong> and <strong><Enter></strong> so you install the package maintainer’s version.</li></ol><ol start="8"><li>Enter the following command:<br>You want to do this, so you get the <strong>wget</strong> package information.</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">apt update</span><br></code></pre></td></tr></table></figure><ol start="9"><li>Install wget and when you’re asked Do you want to continue, press Y and Enter.</li></ol><p>apt install wget</p><ol start="10"><li>When you get asked to “Do you want to continue” press Y and Enter.</li></ol><ol start="11"><li>Download the NetHunter install file.</li></ol><p>wget -O install-nethunter-termux <a href="https://offs.ec/2MceZWr">https://offs.ec/2MceZWr</a><br><img src="11.png"><br>12. Change the permissions so that you can execute the file:</p><p>chmod +x install-nethunter-termux<br><img src="12.png"></p><ol start="13"><li>Type the following command to execute the downloaded install file:</li></ol><p>./install-nethunter-termux<br><img src="13.png"></p><ol start="14"><li><p>The installation will take a while, when asked to delete rootfs, enter N.</p></li><li><p>To start Kali NetHunter you can use the following commands:</p><ul><li>To start the CLI :nethunter</li><li>To setup the NetHunter KeX password :nethunter kex passwd</li><li>To start NetHunter KeX (Password will ve set on first startup) :nethunter kex</li><li>To stop the NetHunter KeX GUI :nethunter kex stop</li><li>To run NetHunter as root : nethunter -r</li><li>You replace nethunter with nh in all these commands. :nh<br><img src="15.png"></li></ul></li><li><p>Once you run nh you are now in the Kali NetHunter CLI.</p></li></ol><ol start="17"><li>You can exit the NetHunter CLI by entering exit.</li></ol><ol start="18"><li>Set the password for KeX VNC by running nh kex for the first time. You’ll use the password again in Step 26 so remember it.</li></ol><ol start="19"><li>Remember the port number. You will use it in Step 26.</li></ol><ol start="20"><li>Set the password for KeX VNC by running nh kex for the first time. Say no to entering a view-only password.</li></ol><ol start="21"><li>Go to the Kali NetHunter App Store website: <a href="https://store.nethunter.com/en/">https://store.nethunter.com/en/</a></li></ol><ol start="22"><li>Download the NetHunter App Store.</li></ol><ol start="23"><li>Press on the Hamburger button of your browser, go to downloads and install NetHunterStore.apk</li></ol><ol start="24"><li>Press on the search button and enter KeX. Press to download NetHunter KeX.</li></ol><ol start="25"><li>Press on the search button and enter KeX. Press to download and install KeX.</li></ol><ol start="26"><li>You will get a popup window. You click on Settings, and then toggle Allow from this source. Then press Install.</li></ol><ol start="27"><li>Press on Allow to allow NetHunterKeX access to your files on the device.</li></ol><ol start="28"><li>Enter the port number from step 19, username as kali, and your password from step 14. Press on Connect.</li></ol><ol start="29"><li>You now should have Rootless Kali NetHunter GUI on your Android Phone!</li></ol><h2 id="Using-the-SSH-server"><a href="#Using-the-SSH-server" class="headerlink" title="Using the SSH server"></a>Using the SSH server</h2><p>in termux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">pkg update<br>pkg upgrade<br>pkg install openssh<br>sshd # start openssh server<br>passwd # set password<br><br>netstat # get sshd port number<br><br>ssh -p 8022 192.168.5.115 # connect in terminal<br></code></pre></td></tr></table></figure><p><img src="end.png"></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://www.youtube.com/watch?v=KxOGyuGq0Ts">Kali Linux NetHunter Android install in 5 minutes (rootless)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>kail</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>以windows服务的方式运行FRP</title>
    <link href="/2022/09/13/network/%E4%BB%A5windows%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%90%E8%A1%8CFRP/"/>
    <url>/2022/09/13/network/%E4%BB%A5windows%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%90%E8%A1%8CFRP/</url>
    
    <content type="html"><![CDATA[<p>前几天看见有人在frp提<a href="https://github.com/fatedier/frp/issues/1901">工单</a>问是否可以支持windows服务,正好有解决类似问题的经验，于是给作者提了一个PR，不过作者表示：</p><ol><li> 类似脚本打算放到专门的仓库中维护</li><li> 那个专门仓库目前无人维护</li></ol><p>那就是没法了，只能记在自己的小本子上了。</p><p>效果演示</p><p><img src="1.png"></p><h2 id="Run-frp-as-Windows-service"><a href="#Run-frp-as-Windows-service" class="headerlink" title="Run frp as Windows service"></a><a href="#Run-frp-as-Windows-service" title="Run frp as Windows service"></a>Run <code>frp</code> as Windows service</h2><ol><li> Download <a href="https://github.com/winsw/winsw/releases">winsw</a>(<code>WinSW.NET2.exe</code> means need <code>.NET 2.0</code> runtime,and so on),Rename it to <code>frpc-service.exe</code> and <code>frps-service.exe</code> .</li><li> Put <code>frpc-service.xml</code> and <code>frpc-service.xml</code> to same directory as <code>frp*-service.exe</code> .</li><li> Default location of frp is <code>C:\frp</code>, you can edit the xml config file.</li></ol><p>install service</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">for</span> frp client</span>  <br>frpc-service.exe install   <br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">for</span> frp server</span>  <br>frps-service.exe install <br></code></pre></td></tr></table></figure><blockquote><p>You will see frp service in windows service manager</p></blockquote><p>uninstall service</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">for</span> frp client</span>  <br>frpc-service.exe uninstall   <br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">for</span> frp server</span>  <br>frps-service.exe uninstall  <br></code></pre></td></tr></table></figure><h2 id="以Windows服务的方式运行frp"><a href="#以Windows服务的方式运行frp" class="headerlink" title="以Windows服务的方式运行frp"></a><a href="#%E4%BB%A5Windows%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%90%E8%A1%8Cfrp" title="以Windows服务的方式运行frp"></a>以Windows服务的方式运行<code>frp</code></h2><ol><li> 下载<a href="https://github.com/winsw/winsw/releases">winsw</a>(它有多个运行时版本,<code>WinSW.NET2.exe</code> 的意思是需要安装 <code>.NET 2.0</code> ),然后将其分别重命名为两个文件: <code>frpc-service.exe</code> 和<code>frps-service.exe</code> .</li><li> 将<code>frpc-service.xml</code> 和 <code>frpc-service.xml</code> 放到 <code>frp*-service.exe</code> 相同的目录下.</li><li> 默认的frp安装目录是 <code>C:\frp</code>, 你可以在xml配置文件中修改。</li></ol><p>创建服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">for</span> frp client</span>  <br>frpc-service.exe install   <br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">for</span> frp server</span>  <br>frps-service.exe install  <br></code></pre></td></tr></table></figure><blockquote><p>服务创建后你在Windows的服务管理器里面就能看见frp服务了</p></blockquote><p>服务卸载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">for</span> frp client</span>  <br>frpc-service.exe uninstall   <br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">for</span> frp server</span>  <br>frps-service.exe uninstall  <br></code></pre></td></tr></table></figure><h2 id="脚本-scripts"><a href="#脚本-scripts" class="headerlink" title="脚本(scripts)"></a><a href="#%E8%84%9A%E6%9C%AC-scripts" title="脚本(scripts)"></a>脚本(scripts)</h2><h3 id="frps-service-xml"><a href="#frps-service-xml" class="headerlink" title="frps-service.xml"></a><a href="#frps-service-xml" title="frps-service.xml"></a>frps-service.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;service\&gt;  <br>  <span class="hljs-comment">&lt;!-- ID of the service. It should be unique across the Windows system--&gt;</span>  <br>  &lt;id\&gt;frps&lt;/id\&gt;  <br>  <span class="hljs-comment">&lt;!-- Display name of the service --&gt;</span>  <br>  &lt;name\&gt;frp server&lt;/name\&gt;  <br>  <span class="hljs-comment">&lt;!-- Service description --&gt;</span>  <br>  &lt;description\&gt;Service for frp server&lt;/description\&gt;  <br>  <span class="hljs-comment">&lt;!-- frp install dir --&gt;</span>  <br>  &lt;workingdirectory\&gt;C:\\frp&lt;/workingdirectory\&gt;  <br>  <span class="hljs-comment">&lt;!-- frps.exe --&gt;</span>  <br>  &lt;executable\&gt;C:\\frp\\frps.exe&lt;/executable\&gt;  <br>  <span class="hljs-comment">&lt;!-- args --&gt;</span>  <br>  &lt;startarguments\&gt;\-c frps.ini&lt;/startarguments\&gt;  <br>&lt;/service\&gt;  <br></code></pre></td></tr></table></figure><h3 id="frps-service-xml-1"><a href="#frps-service-xml-1" class="headerlink" title="frps-service.xml"></a><a href="#frps-service-xml-1" title="frps-service.xml"></a>frps-service.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml">&lt;service\&gt;  <br>  <span class="hljs-comment">&lt;!-- ID of the service. It should be unique across the Windows system--&gt;</span>  <br>  &lt;id\&gt;frpc&lt;/id\&gt;  <br>  <span class="hljs-comment">&lt;!-- Display name of the service --&gt;</span>  <br>  &lt;name\&gt;frp client&lt;/name\&gt;  <br>  <span class="hljs-comment">&lt;!-- Service description --&gt;</span>  <br>  &lt;description\&gt;Service for frp client&lt;/description\&gt;  <br>  <span class="hljs-comment">&lt;!-- frp install dir --&gt;</span>  <br>  &lt;workingdirectory\&gt;C:\\frp&lt;/workingdirectory\&gt;  <br>  <span class="hljs-comment">&lt;!-- frpc.exe --&gt;</span>  <br>  &lt;executable\&gt;C:\\frp\\frpc.exe&lt;/executable\&gt;  <br>  <span class="hljs-comment">&lt;!-- args --&gt;</span>  <br>  &lt;startarguments\&gt;\-c frpc.ini&lt;/startarguments\&gt;  <br>&lt;/service\&gt;  <br></code></pre></td></tr></table></figure><h2 id="screenshot"><a href="#screenshot" class="headerlink" title="screenshot"></a><a href="#screenshot" title="screenshot"></a>screenshot</h2><p>frp install dir</p><p><img src="2.png"></p><p>service wrapper dir</p><p><img src="3.png"></p><p>install service</p><p><img src="4.png"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="http://note.eta.pub/2020/07/21/frp-windows-service/">以windows服务的方式运行FRP</a></li><li><a href="https://github.com/winsw/winsw/releases">winsw</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>frp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Network</title>
    <link href="/2022/09/13/network/network/"/>
    <url>/2022/09/13/network/network/</url>
    
    <content type="html"><![CDATA[<h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li><a href="https://github.com/bregman-arie/devops-exercises#Network">Network</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在黑群晖内安装虚拟机</title>
    <link href="/2022/09/13/nas/%E9%BB%91%E7%BE%A4%E6%99%96%E5%86%85%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/2022/09/13/nas/%E9%BB%91%E7%BE%A4%E6%99%96%E5%86%85%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>主要是安装 Virtual Machine Manager,在套件中心直接搜索安装即可</p><h2 id="安装注意点"><a href="#安装注意点" class="headerlink" title="安装注意点"></a>安装注意点</h2><ul><li>nas 内存至少4g+</li><li>磁盘格式必须为btrfs</li><li>貌似不需要安装官方映像文件,后续直接下载对于镜像进行安装即可</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://post.smzdm.com/p/apz37e79/">群晖中用VMM（Virtual Machine Manager）再虚拟安装一台群晖保姆教程</a></li><li><a href="https://archive.synology.com/download/Os/DSM">官方映像文件</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nas</tag>
      
      <tag>群晖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黑群晖系统安装</title>
    <link href="/2022/09/13/nas/%E9%BB%91%E7%BE%A4%E6%99%96%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
    <url>/2022/09/13/nas/%E9%BB%91%E7%BE%A4%E6%99%96%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>使用u盘作为引导盘,后续要一直插着,拔掉后会无法进行系统</p><ol><li>插入u盘,打开rufus软件,待识别u盘后,选择img镜像文件成功写入u盘</li><li>将u盘插入闲置主机,启动电脑并调试bios第一启动项为U盘</li><li>待出现如下图后,在另一设备操作<br><img src="1.png"></li><li>在浏览器打开 闲置主机的ip:5000 等待响应 </li><li>按浏览器提示操作即可,中间会提示选择系统,安装.pat文件即可</li></ol><h3 id="安装注意点"><a href="#安装注意点" class="headerlink" title="安装注意点"></a>安装注意点</h3><ol><li>我这边使用u盘作为引导盘,使用ssd作为引导时会报错(Failed to format the disk. (35))</li><li>修改bios设置第一启动项为u盘启动(否则每次手动选择启动项很烦)</li><li>安装其他群晖系统时无法进入系统,我这边只能适合ds3617_6.1版本</li><li>一定要设置u盘为默认的第一启动项(即电脑开机后默认选择u盘进入),否则系统安装完,需要重启,会出现无法进行系统问题</li></ol><h3 id="其他nas系统"><a href="#其他nas系统" class="headerlink" title="其他nas系统"></a>其他nas系统</h3><ol><li>TrueNAS</li><li>Unraid</li></ol><h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><p>用到的工具及系统文件下载地址:<br><a href="https://pan.baidu.com/share/init?surl=EqJ8s2YedADjV9zCX_LwRQ">https://pan.baidu.com/share/init?surl=EqJ8s2YedADjV9zCX_LwRQ</a><br>提取码: ifb5</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://post.smzdm.com/p/aqx07xmk/">文菌装NAS 篇五：手把手教您安装黑群晖918+ 6.2保姆级教程，这应该是装黑群晖NAS最详细的教程了，含群晖设置</a></li><li><a href="https://new.qq.com/omn/20210129/20210129A0C4S900.html">如何通过bios设置u盘启动项实现U盘启动</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nas</tag>
      
      <tag>群晖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机安装OpenWrt软路由</title>
    <link href="/2022/09/13/nas/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85OpenWrt%E8%BD%AF%E8%B7%AF%E7%94%B1/"/>
    <url>/2022/09/13/nas/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85OpenWrt%E8%BD%AF%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<p>虚拟机安装OpenWrt软路由,并实现局域网内所以设备自动科学上网,广告过滤等</p><h2 id="安装注意点"><a href="#安装注意点" class="headerlink" title="安装注意点"></a>安装注意点</h2><ul><li>安装后的OpenWrt需要手动设置ip地址</li></ul><h2 id="使局域网设备自动科学上网方式"><a href="#使局域网设备自动科学上网方式" class="headerlink" title="使局域网设备自动科学上网方式"></a>使局域网设备自动科学上网方式</h2><p>设置网口网关地址和dns为软路由ip<br><img src="1.png"></p><p>忽略该接口,并保存并应用<br><img src="2.png"></p><p>情况说明:我有俩个路由器,一级路由器负责拨号，二级路由器挂在一级路由器下面设置为固定ip范围获取,主要工作路由为二级路由</p><p>由于软路由处于在一级路由下，二级路由和软路由位于同一层，因此我设置二级路由的WAN口连接类型为固定ip获取,并将网关和dns设置为软路由IP.自此,我直接连上二级路由实现自动科学上网<br><img src="3.png"></p><h2 id="OpenWrt-开启openClash-服务后，WireGuard无法接收流量问题"><a href="#OpenWrt-开启openClash-服务后，WireGuard无法接收流量问题" class="headerlink" title="OpenWrt 开启openClash 服务后，WireGuard无法接收流量问题"></a>OpenWrt 开启openClash 服务后，WireGuard无法接收流量问题</h2><p>openClash-&gt; 全局设置-&gt; 模式设置 -&gt; 实验性：绕过中国大陆IP 功能 启用<br><strong>我的WireGuard server ip 为国内</strong>,可能被代理了<br><img src="4.png"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://post.smzdm.com/p/a5dn78pl/">群晖虚拟机安装 Openwrt 做旁路由的设置教程</a></li><li><a href="https://openwrt.club/dl">OpenWrt固件下载</a></li><li><a href="https://www.youtube.com/watch?v=OCF8KgoctfU">OpenWrt设置旁路由</a></li><li><a href="https://supes.top/">下载或定制适用于您设备的OpenWrt固件</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenWrt</tag>
      
      <tag>设置旁路由</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树,平衡二叉树,B-Tree,B+Tree</title>
    <link href="/2022/09/13/mysql/%E4%BA%8C%E5%8F%89%E6%A0%91,%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91,B-Tree,B+Tree/"/>
    <url>/2022/09/13/mysql/%E4%BA%8C%E5%8F%89%E6%A0%91,%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91,B-Tree,B+Tree/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一般说MySQL的索引，都清楚其索引主要以B+树为主，此外还有Hash、RTree、FullText。本文简要说明一下MySQL的B+Tree索引，以及和其相关的二叉树、平衡二叉树、B-Tree</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="二叉查找树（BST）"><a href="#二叉查找树（BST）" class="headerlink" title="二叉查找树（BST）"></a>二叉查找树（BST）</h3><ul><li><p><strong>概念</strong><br>二叉查找树是基于二分查找法来提高数据查找速度的二叉树的数据结构；关于二分查找法的时间复杂度可以看 <a href="https://juejin.im/entry/6844903481191432206">时间复杂度 O(log n) 意味着什么？</a>。</p></li><li><p><strong>特点</strong><br>二叉查找树是采用二分查找法把数据按规则组装成一个树形结构的数据，减少无关数据的检索，提升了数据检索的速度；二叉树的数据结构有以下规则：</p><p>1.非叶子节点只能允许最多两个子节点存在。<br>2.每一个非叶子节点数据分布规则为左边的子节点小当前节点的值，右边的子节点大于当前节点的值；<br>即二叉查找树的特点就是任何节点的左子节点的键值都小于当前节点的键值，右子节点的键值都大于当前节点的键值。 顶端的节点称为根节点，没有子节点的节点我们称之为叶节点。以下图中的圆为二叉查找树的节点，<strong>节点中存储了键(key)和数据(<br>data)</strong><br><img src="1.png"></p><p>查找结点值的方法就是二分查找法：查找次数就是树的高度。二叉查找树可以任意地构造 如果向一方倾斜的二叉树是不平衡的，查询效率就低了，二叉查找树变成了一个链表。如下图：</p><p><img src="2.png"><br>在上面的2张图中，查找键值为17的数据，第一张图里需要3次IO，第2张图里需要7次IO。原因是二叉查找树变得不平衡了，也就是高度太高了，从而导致查找效率的不稳定。为了解决这个问题，需要保证二叉查找树一直保持平衡，就需要用到平衡二叉树了。</p></li></ul><h3 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h3><p>在满足二叉查找树特性的基础上，如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。 类似于：</p><p><img src="3.png"></p><p>关于平衡二叉树的可以看 <a href="https://zhuanlan.zhihu.com/p/56066942">什么是平衡二叉树（AVL）</a> 该文章说明，平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。 <strong>需要注意的是平衡二叉树是每个节点只存储一个键值和数据的。</strong></p><h3 id="B树-B-Tree"><a href="#B树-B-Tree" class="headerlink" title="B树(B-Tree)"></a>B树(B-Tree)</h3><ul><li><p><strong>概念</strong><br>B树和平衡二叉树不同，B树属于多叉树又名<strong>平衡多路查找树</strong>（查找路径不只两个），数据库索引里大量使用者B-Tree和B+Tree的数据结构。</p></li><li><p><strong>特点</strong></p><p>1.方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；</p><p>2.子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路，当M=2则是2叉树,M=3则是3叉）；</p><p>3.关键字数：枝节点的关键字数量大于等于ceil(M/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</p><p>4.所有叶子节点均在同一层、叶子节点除了包含了关键字还包含了数据;</p><p>最后我们用一个图和一个实际的例子来理解B树（这里为了理解方便我就直接用实际字母的大小来排列C&gt;B&gt;A）</p><p><img src="4.png"><br>图中可以看到BTree的单个节点可以存储多个键值和数据的平衡树。和平衡二叉树相比：<br>比如要存储海量的数据，因为（平衡）<strong>二叉树的每个节点只存储一个键值和数据的</strong>，二叉树的节点将会非常多，高度也会及其高，当查找数据时也会进行很多次磁盘IO，查找的效率将会极低，大致的二叉树结构如下：<br><img src="5.png"><br>为了解决平衡二叉树的这个弊端，需要一种<strong>单个节点可以存储多个键值和数据的平衡树（BTree）</strong>：<br><img src="6.png"><br>从上图可以看出，<strong>B树相对于平衡二叉树，每个节点存储了更多的键值(key)和数据(data)，并且每个节点拥有更多的子节点</strong>，子节点的个数一般称为阶，上述图中的B树为3阶B树，高度也会很低。<br>基于这个特性，B树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。</p><p>假如我们要查找id=28的用户信息，那么我们在上图B树中查找的流程如下：</p><ol><li>先找到根节点也就是页1，判断28在键值17和35之间，我们那么我们根据页1中的指针p2找到页3。</li><li>将28和页3中的键值相比较，28在26和30之间，我们根据页3中的指针p2找到页8。</li><li>将28和页8中的键值相比较，发现有匹配的键值28，键值28对应的用户信息为(28,bv)。</li></ol><p><strong>区别:</strong><br>B树相对于平衡二叉树的不同是：每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度。<br><strong>相同数量的key在B-Tree中生成的节点要远远少于二叉树中的节点，相差的节点数量就等同于磁盘IO的次数。这样到达一定数量后，性能的差异就显现出来了。</strong></p></li></ul><h3 id="B-树（B-Tree）"><a href="#B-树（B-Tree）" class="headerlink" title="B+树（B+Tree）"></a>B+树（B+Tree）</h3><ul><li><p><strong>概念</strong><br>B+树是B树的一个进化，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。结构如下：<br><img src="7.png"><br>为什么说B+树查找的效率要比B树更高、更稳定；我们先看看两者的区别：</p><p>（1）<strong>B+树的非叶子节点不保存数据，只进行数据索引（</strong>关键字记录的指针<strong>），这样使得B+树每个非叶子节点所能保存的关键字大大增加；</strong></p><p>（2）<strong>B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</strong></p><p>（3）<strong>B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针；</strong></p><p>（4）<strong>B+树非叶子节点的子节点数=关键字数;</strong></p></li><li><p><strong>特点</strong></p><p>1、B+树的层级更少：相较于B树，B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；</p><p>2、B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</p><p>3、B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</p><p>4、B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</p><p>B树相对于B+树的优点是：如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。</p></li></ul><p><strong>根据上图我们来看下B+树和B树有什么不同：</strong>  </p><ol><li><p><strong>B+Tree 非叶子节点上是不存储数据的，仅存储键值，数据存储在同一层的叶节点，而B-Tree节点中不仅存储键值，也会存储数据</strong>。之所以这么做是因为在数据库中页的大小是固定的，innodb中页的默认大小是16KB。如果不存储数据，那么就会存储更多的键值，相应的树的阶数(节点的子节点树)就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。另外，B+Tree的阶数是等于键值的数量的，如果B+Tree一个节点可以存储1000个键值，那么3层B+树可以存储1000×1000×1000=10亿个数据。一般根节点是常驻内存的，所以一般我们查找10亿数据，只需要2次磁盘IO**。  </p></li><li><p>因为B+Tree索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而B-Tree 因为数据分散在各个节点，要实现这一点是很不容易的。</p><p> B+Tree 中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。</p><p> 其实上面的B-Tree也可以对各个节点加上链表。其实这些不是它们之前的区别，是因为在mysql的innodb存储引擎中，索引就是这样存储的。也就是说上图中的B+Tree索引就是innodb中B+Tree索引真正的实现方式，准确的说应该是聚集索引。</p><p> 通过上图可以看到，<strong>在innodb中，数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据。</strong></p><p> 注意：MyISAM中的B+树索引实现与innodb中的略有不同。在MyISAM中，B+树索引的叶子节点并不存储数据，而是存储数据的文件地址。 </p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>B+Tree 结构是从二叉查找树，平衡二叉树和B-Tree这三种数据结构演化来的，他们之前的区别上面已经介绍过，现在大致的总结下，如下：</p><ul><li><p>1.二叉查找树是基于二分查找法来提高数据查找速度的二叉树的数据结构，减少无关数据的检索，提升了数据检索的速度。非叶子节点只能允许最多两个子节点存在，每一个非叶子节点数据分布规则为左边的子节点小当前节点的值，右边的子节点大于当前节点的值，<strong>每个节点只存储一个键值和数据的。</strong></p></li><li><p>2.平衡二叉树满足二叉查找树特性的基础上，如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。</p></li><li><p>3.B-TreeB和平衡二叉树不同，B-Tree属于多叉树又名<strong>平衡多路查找树，</strong> <strong><strong>B-Tree相对于平衡二叉树，每个节点存储了更多的键值(key)和数据(data)，并且每个节点拥有更多的子节点。</strong></strong></p></li><li><p>4.B+Tree和B-Tree不同，<strong>B+Tree在非叶子节点上，不保存数据，只存储键指针</strong>，能存储更多的键值，相应的树的阶数(节点的子节点树)就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。并且B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。那么B+Tree使得范围查找，排序查找，分组查找以及去重查找变得异常简单。</p></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.cnblogs.com/zhoujinyi/p/13900554.html">二叉树、平衡二叉树、B-Tree、B+Tree 说明</a></li><li><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualizations</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>B+Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql分库分表方案</title>
    <link href="/2022/09/13/mysql/mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%88/"/>
    <url>/2022/09/13/mysql/mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://shardingsphere.apache.org/">ShardingSphere</a></li><li><a href="https://github.com/baymax55/sharding-jdbc-example">sharding-jdbc-example</a></li><li><a href="https://bbs.huaweicloud.com/blogs/323521">ShardingSphere(1)—主从篇</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>ShardingSphere</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tldr命令</title>
    <link href="/2022/09/13/linux/tldr/"/>
    <url>/2022/09/13/linux/tldr/</url>
    
    <content type="html"><![CDATA[<p>The tldr pages are a community effort to simplify the beloved man pages with practical examples.</p><h2 id="类似命令"><a href="#类似命令" class="headerlink" title="类似命令"></a>类似命令</h2><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><h3 id="cheat"><a href="#cheat" class="headerlink" title="cheat"></a>cheat</h3><p>Linux cheat 命令是一个实用程序，可以用来搜索和显示你想要使用的命令的使用示例</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://tldr.sh/">tldr</a></li><li><a href="https://linux.cn/article-14961-1.html">“作弊”：只需要知道这一个 Linux 命令就够了</a></li><li><a href="https://github.com/cheat/cheat">cheat</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux command</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rabbitMQ实现延迟消息队列</title>
    <link href="/2022/09/13/mq/rabbitMQ%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <url>/2022/09/13/mq/rabbitMQ%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="延迟消息实现的两种方式"><a href="#延迟消息实现的两种方式" class="headerlink" title="延迟消息实现的两种方式"></a>延迟消息实现的两种方式</h3><ul><li>通过Rabbitmq本身队列的特性来实现，需要使用Rabbitmq的死信交换机（Exchange）和消息的存活时间TTL</li><li>通过插件（rabbitmq-delayed-message-exchange）来实现</li></ul><h3 id="消息的TTL"><a href="#消息的TTL" class="headerlink" title="消息的TTL"></a>消息的TTL</h3><p>RabbitMQ可以针对Queue和Message设置 x-message-tt，来控制消息的生存时间，如果超时，则消息变为dead letter</p><h4 id="针对队列的过期时间"><a href="#针对队列的过期时间" class="headerlink" title="针对队列的过期时间"></a>针对队列的过期时间</h4><p>通过队列属性设置，队列中所有消息都有相同的过期时间。</p><h4 id="针对消息的过期时间"><a href="#针对消息的过期时间" class="headerlink" title="针对消息的过期时间"></a>针对消息的过期时间</h4><p>对消息进行单独设置，每条消息TTL可以不同。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>如果同时使用，则消息的过期时间以两者之间TTL较小的那个数值为准。消息在队列的生存时间一旦超过设置的TTL值，就成为dead letter</p><h3 id="DLX-Dead-Letter-Exchange"><a href="#DLX-Dead-Letter-Exchange" class="headerlink" title="DLX (Dead-Letter-Exchange)"></a>DLX (Dead-Letter-Exchange)</h3><p>Queue可以配置x-dead-letter-exchange 和x-dead-letter-routing-key（可选）两个参数，如果队列内出现了dead letter，则按照这两个参数重新路由</p><p>x-dead-letter-exchange: 出现dead letter之后将dead letter重新发送到指定exchange<br>x-dead-letter-routing-key:指定routing-key发送</p><h3 id="队列出现dead-letter的情况"><a href="#队列出现dead-letter的情况" class="headerlink" title="队列出现dead letter的情况"></a>队列出现dead letter的情况</h3><ul><li>消息或者队列的TTL过期</li><li>队列达到最大长度</li><li>消息被消费端拒绝（basic.reject or basic.nack）并且requeue=false</li></ul><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><ul><li><a href="https://cloud.tencent.com/developer/article/1877502">rabbitmq 怎么实现延迟消息队列？</a></li><li>RabbitMQ实战指南</li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rabbitmq</tag>
      
      <tag>延迟队列</tag>
      
      <tag>mq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k3s安装与部署</title>
    <link href="/2022/09/13/k8s/k3s%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
    <url>/2022/09/13/k8s/k3s%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>k3s是经过CNCF认证的由Rancher公司开发维护的一个轻量级的 Kubernetes 发行版，内核机制还是和 k8s 一样，但是剔除了很多外部依赖以及 K8s 的 alpha、beta 特性，同时改变了部署方式和运行方式，目的是轻量化 K8s，简单来说，K3s 就是阉割版 K8s，消耗资源极少。它主要用于边缘计算、物联网等场景。</p><h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><h3 id="k3s安装Dashboard无法外面访问时-修改kubernetes-dashboard-svc-type-为NodePort"><a href="#k3s安装Dashboard无法外面访问时-修改kubernetes-dashboard-svc-type-为NodePort" class="headerlink" title="k3s安装Dashboard无法外面访问时,修改kubernetes-dashboard svc type 为NodePort"></a>k3s安装Dashboard无法外面访问时,修改kubernetes-dashboard svc type 为NodePort</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-string">&quot;2022-08-22T03:45:00Z&quot;</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">kubernetes-dashboard</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubernetes-dashboard</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kubernetes-dashboard</span><br>  <span class="hljs-attr">resourceVersion:</span> <span class="hljs-string">&quot;12356&quot;</span><br>  <span class="hljs-attr">uid:</span> <span class="hljs-string">2b77a6f5-97fe-4f04-beac-a4503db1b402</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-number">10.43</span><span class="hljs-number">.217</span><span class="hljs-number">.53</span><br>  <span class="hljs-attr">clusterIPs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">10.43</span><span class="hljs-number">.217</span><span class="hljs-number">.53</span><br>  <span class="hljs-attr">externalTrafficPolicy:</span> <span class="hljs-string">Cluster</span><br>  <span class="hljs-attr">internalTrafficPolicy:</span> <span class="hljs-string">Cluster</span><br>  <span class="hljs-attr">ipFamilies:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">IPv4</span><br>  <span class="hljs-attr">ipFamilyPolicy:</span> <span class="hljs-string">SingleStack</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30619</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">443</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8443</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">kubernetes-dashboard</span><br>  <span class="hljs-attr">sessionAffinity:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br><span class="hljs-attr">status:</span><br>  <span class="hljs-attr">loadBalancer:</span> &#123;&#125; <br></code></pre></td></tr></table></figure><h3 id="Kubernetes-cluster-unreachable-with-helm-3-0"><a href="#Kubernetes-cluster-unreachable-with-helm-3-0" class="headerlink" title="Kubernetes cluster unreachable with helm 3.0"></a>Kubernetes cluster unreachable with helm 3.0</h3><p>Try setting the KUBECONFIG environment variable.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export KUBECONFIG=/etc/rancher/k3s/k3s.yaml<br></code></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.cnblogs.com/hujinzhong/p/15014487.html">k3s安装与部署</a></li><li><a href="https://docs.rancher.cn/docs/k3s/installation/install-options/_index#%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E5%AE%89%E8%A3%85%E7%9A%84%E9%80%89%E9%A1%B9">使用脚本安装的选项</a></li><li><a href="https://rancher.com/docs/k3s/latest/en/installation/kube-dashboard/">k3s install Kubernetes Dashboard</a></li><li><a href="https://opensource.com/article/20/5/helm-charts">How to make a Helm chart in 10 minutes</a></li><li><a href="https://github.com/ohmyzsh/ohmyzsh/blob/master/plugins/kubectl/README.md">ohmyzsh/plugins/kubectl/README.md</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>How to fix OOMKilled Kubernetes error</title>
    <link href="/2022/09/13/k8s/how-to-fix-OOMKilled-kubernetes-error/"/>
    <url>/2022/09/13/k8s/how-to-fix-OOMKilled-kubernetes-error/</url>
    
    <content type="html"><![CDATA[<h2 id="What-is-OOMKilled-exit-code-137"><a href="#What-is-OOMKilled-exit-code-137" class="headerlink" title="What is OOMKilled (exit code 137)"></a>What is OOMKilled (exit code 137)</h2><p>The <code>OOMKilled</code> error, also indicated by exit code 137, means that a container or pod was terminated because they used more memory than allowed. OOM stands for “Out Of Memory”.</p><p>Kubernetes allows pods to limit the resources their containers are allowed to utilize on the host machine. A pod can specify a <strong>memory limit</strong> – the maximum amount of memory the container is allowed to use, and a <strong>memory request</strong> – the minimum memory the container is expected to use.</p><p>If a container uses more memory than its memory limit, it is terminated with an <code>OOMKilled</code> status. Similarly, if overall memory usage on all containers, or all pods on the node, exceeds the defined limit, one or more pods may be terminated.</p><p>You can identify the error by running the <code>kubectl get pods command</code>—the pod status will appear as <code>Terminating</code>.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">NAME</span>        <span class="hljs-string">READY</span>    <span class="hljs-string">STATUS</span>       <span class="hljs-string">RESTARTS</span>    <span class="hljs-string">AGE</span><br><span class="hljs-string">my-pod-1</span>    <span class="hljs-number">0</span><span class="hljs-string">/1</span>      <span class="hljs-string">OOMKilled</span>    <span class="hljs-number">0</span>           <span class="hljs-string">3m12s</span><br></code></pre></td></tr></table></figure><p>We’ll provide a general process for identifying and resolving <code>OOMKilled</code>. More complex cases will require advanced diagnosis and troubleshooting, which is beyond the scope of this article.</p><h2 id="How-Does-the-OOM-Killer-Mechanism-Work"><a href="#How-Does-the-OOM-Killer-Mechanism-Work" class="headerlink" title="How Does the OOM Killer Mechanism Work?"></a>How Does the OOM Killer Mechanism Work?</h2><p><code>OOMKilled</code> is actually not native to Kubernetes—it is a feature of the Linux Kernel, known as the <code>OOM Killer</code>, which Kubernetes uses to manage container lifecycles. The <code>OOM Killer</code> mechanism monitors node memory and selects processes that are taking up too much memory, and should be killed. It is important to realize that <code>OOM Killer</code> may kill a process even if there is free memory on the node.</p><p>The Linux kernel maintains an <code>oom_score</code> for each process running on the host. The higher this score, the greater the chance that the process will be killed. Another value, called <code>oom_score_adj</code>, allows users to customize the OOM process and define when processes should be terminated.</p><p>Kubernetes uses the <code>oom_score_adj</code> value when defining a Quality of Service (QoS) class for a pod. There are three QoS classes that may be assigned to a pod:</p><ul><li>  Guaranteed</li><li>  Burstable</li><li>  BestEffort</li></ul><p>Each QoS class has a matching value for <code>oom_score_adj</code>:</p><table><thead><tr><th>Quality of Service</th><th>oom_score_adj</th></tr></thead><tbody><tr><td>Guaranteed</td><td>-997</td></tr><tr><td>BestEffort</td><td>1000</td></tr><tr><td>Burstable</td><td>min(max(2, 1000—(1000 * memoryRequestBytes) / machineMemoryCapacityBytes), 999)</td></tr></tbody></table><p>Because “Guaranteed” pods have a lower value, they are the last to be killed on a node that is running out of memory. “BestEffort” pods are the first to be killed.</p><p>A pod that is killed due to a memory issue is not necessarily evicted from a node—if the restart policy on the node is set to “Always”, it will try to restart the pod.</p><p>To see the QoS class of a pod, run the following command:</p><p><code>Kubectl get pod -o jsonpath=’&#123;.status.qosClass&#125;’</code></p><p>To see the <code>oom_score</code> of a pod:</p><ol><li> Run <code>kubectl exec -it /bin/bash</code></li><li> To see the <code>oom_score</code>, run <code>cat/proc//oom_score</code></li><li> To see the <code>oom_score_adj</code>, <code>run cat/proc//oom_score_adj</code></li></ol><p>The pod with the lowest <code>oom_score</code> is the first to be killed when the node runs out of memory.</p><h2 id="OOMKilled-Common-Causes"><a href="#OOMKilled-Common-Causes" class="headerlink" title="OOMKilled: Common Causes"></a>OOMKilled: Common Causes</h2><p>The following table shows the common causes of this error and how to resolve it. However, note there are many more causes of OOMKilled errors, and many cases are difficult to diagnose and troubleshoot.</p><table><thead><tr><th>Cause</th><th>Resolution</th></tr></thead><tbody><tr><td>Container memory limit was reached, and the application is experiencing higher load than normal</td><td>Increase memory limit in pod specifications</td></tr><tr><td>Container memory limit was reached, and application is experiencing a memory leak</td><td>Debug the application and resolve the memory leak</td></tr><tr><td>Node is overcommitted—this means the total memory used by pods is greater than node memory</td><td>Adjust memory requests (minimal threshold) and memory limits (maximal threshold) in your containers</td></tr></tbody></table><h2 id="OOMKilled-Diagnosis-and-Resolution"><a href="#OOMKilled-Diagnosis-and-Resolution" class="headerlink" title="OOMKilled: Diagnosis and Resolution"></a>OOMKilled: Diagnosis and Resolution</h2><h3 id="Step-1-Gather-Information"><a href="#Step-1-Gather-Information" class="headerlink" title="Step 1: Gather Information"></a>Step 1: Gather Information</h3><p>Run <code>kubectl describe pod [name]</code> and save the content to a text file for future reference:</p><p><code>kubectl describe pod [name] /tmp/troubleshooting_describe_pod.txt</code></p><h3 id="Step-2-Check-Pod-Events-Output-for-Exit-Code-137"><a href="#Step-2-Check-Pod-Events-Output-for-Exit-Code-137" class="headerlink" title="Step 2: Check Pod Events Output for Exit Code 137"></a>Step 2: Check Pod Events Output for Exit Code 137</h3><p>Check the Events section of the describe pod text file, and look for the following message:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">State:</span>          <span class="hljs-string">Running</span><br>       <span class="hljs-attr">Started:</span>      <span class="hljs-string">Thu,</span> <span class="hljs-number">10</span> <span class="hljs-string">Oct</span> <span class="hljs-number">2019 11:14:13</span> <span class="hljs-string">+0200</span><br>       <span class="hljs-attr">Last State:</span>   <span class="hljs-string">Terminated</span><br>       <span class="hljs-attr">Reason:</span>       <span class="hljs-string">OOMKilled</span><br>       <span class="hljs-attr">Exit Code:</span>    <span class="hljs-number">137</span><br>       <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>Exit code 137 indicates that the container was terminated due to an out of memory issue. Now look through the events in the pod’s recent history, and try to determine what caused the <code>OOMKilled</code> error:</p><ul><li>  The pod was terminated because a container limit was reached.</li><li>  The pod was terminated because the node was “overcommitted”—pods were scheduled to the node that, put together, request more memory than is available on the node.</li></ul><h3 id="Step-3-Troubleshooting"><a href="#Step-3-Troubleshooting" class="headerlink" title="Step 3: Troubleshooting"></a>Step 3: Troubleshooting</h3><p>If the pod was terminated because <strong>container limit was reached</strong>:</p><ul><li>  Determine if your application really needs more memory. For example, if the application is a website that is experiencing additional load, it may need more memory than originally specified. In this case, to resolve the error, increase the memory limit for the container in the pod specification.</li><li>  If memory use suddenly increases, and does not seem to be related to application loads, the application may be experiencing a memory leak. Debug the application and resolve the memory leak. In this case you should not increase the memory limit, because this will cause the application to use up too many resources on the nodes.</li></ul><p>If the pod was terminated because of <strong>overcommit on the node</strong>:</p><ul><li>  Overcommit on a node can occur because pods are allowed to schedule on a node if their memory requests value—the minimal memory value—is less than the memory available on the node.</li><li>  For example, Kubernetes may run 10 containers with a memory request value of 1 GB on a node with 10 GB memory. However, if these containers have a memory limit of 1.5 GB, some of the pods may use more than the minimum memory, and then the node will run out of memory and need to kill some of the pods.</li><li>  You need to determine why Kubernetes decided to terminate the pod with the <code>OOMKilled</code> error, and adjust memory requests and limit values to ensure that the node is not overcommitted.</li></ul><p>When adjusting memory requests and limits, keep in mind that when a node is overcommitted, Kubernetes kills nodes according to the following priority order:</p><ol><li> Pods that do not have requests or limits</li><li> Pods that have requests, but not limits</li><li> Pods that are using more than their memory request value—minimal memory specified—but under their memory limit</li><li> Pods that are using more than their memory limit</li></ol><p>To fully diagnose and resolve Kubernetes memory issues, you’ll need to monitor your environment, understand the memory behavior of pods and containers compared to the limits, and fine tune your settings. This can be a complex, unwieldy process without the right tooling.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://komodor.com/learn/how-to-fix-oomkilled-exit-code-137/">How to fix OOMKilled Kubernetes error (exit code 137)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>OOMKilled</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes网络模型的基础知识</title>
    <link href="/2022/09/13/k8s/Kubernetes%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/09/13/k8s/Kubernetes%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>Kubernetes 是为运行分布式集群而建立的，分布式系统的本质使得网络成为 Kubernetes 的核心和必要组成部分，了解 Kubernetes 网络模型可以使你能够正确运行、监控和排查应用程序故障。</p><p>网络所涉及的内容很多，拥有许多成熟的技术。对于不熟悉的人来说可能会非常痛苦，因为大多数人对网络都有先入为主的观念，并且有很多新旧概念需要理解并组合成一个连贯的整体。所说的网络可能包括网络命名空间、虚拟接口、IP 转发和网络地址转换等技术。本指南旨在通过讨论每种 Kubernetes 相关技术以及如何使用这些技术来启用 Kubernetes 网络模型的描述来揭开 Kubernetes 网络的神秘面纱。</p><p>本指南相当长，分为几个部分。我们首先讨论一些基本的 Kubernetes 术语，以确保在整个指南中正确使用术语，然后讨论 Kubernetes 网络模型以及它强加的设计和实施决策。接下来是本指南中最长且最有趣的部分：</p><p>深入讨论如何使用几个不同的用例展示在Kubernetes内是如何进行通信的。</p><p>文章大纲如下：<br><img src="./%E6%96%87%E7%AB%A0%E5%A4%A7%E7%BA%B2.png"></p><h2 id="1、Kubernetes基础知识"><a href="#1、Kubernetes基础知识" class="headerlink" title="1、Kubernetes基础知识"></a>1、Kubernetes基础知识</h2><p>Kubernetes 由几个核心概念构建而成，这些概念组合成越来越强大的功能。本节列出了这些概念中的每一个，并提供了一个简短的概述，以帮助促进讨论。Kubernetes 的内容远不止此，这里仅仅简要阐述一些基础知识。如果您已经熟悉 Kubernetes，请随意跳过本节。</p><h3 id="1-1、Kubernetes-API-server"><a href="#1-1、Kubernetes-API-server" class="headerlink" title="1.1、Kubernetes API server"></a>1.1、Kubernetes API server</h3><p>在 Kubernetes 中，一切都是由 Kubernetes API 服务器（kube-apiserver）提供的 API 调用。API 服务器是 etcd 数据存储的网关，它维护应用程序集群的所需状态。要更新 Kubernetes 集群的状态，您可以对描述所需状态的 API 服务器进行 API 调用。</p><h3 id="1-2、Controllers"><a href="#1-2、Controllers" class="headerlink" title="1.2、Controllers"></a>1.2、Controllers</h3><p>控制器是用于构建 Kubernetes 的核心抽象。一旦您使用 API 服务器声明了集群的所需状态，控制器就会通过持续观察 API 服务器的状态并对任何更改做出反应来确保集群的当前状态与所需状态相匹配。控制器内部实现了一个循环，该循环不断检查集群的当前状态与集群的期望状态。如果有任何差异，控制器将执行任务以使当前状态与所需状态匹配。在伪代码中：</p><p><img src="1.2%E4%BC%AA%E4%BB%A3%E7%A0%81.png"></p><p>例如，当您使用 API 服务器创建新 Pod 时，Kubernetes 调度程序（控制器）会注意到更改并决定将 Pod 放置在集群中的哪个位置。然后它使用 API 服务器（由 etcd 支持）写入状态更改。kubelet（一个控制器）然后会注意到新的变化并设置所需的网络功能以使 Pod 在集群内可访问。在这里，两个独立的控制器对两个独立的状态变化做出反应，以使集群的现实与用户的意图相匹配。</p><h3 id="1-3、Pods"><a href="#1-3、Pods" class="headerlink" title="1.3、Pods"></a>1.3、Pods</h3><p>Pod 是 Kubernetes 的原子——用于构建应用程序的最小可部署对象。单个 Pod 代表集群中正在运行的工作负载，并封装了一个或多个 Docker 容器、任何所需的存储和唯一的 IP 地址，组成 pod 的容器被设计为在同一台机器上共同定位和调度。</p><h3 id="1-4、Nodes"><a href="#1-4、Nodes" class="headerlink" title="1.4、Nodes"></a>1.4、Nodes</h3><p>节点是运行 Kubernetes 集群的机器。这些可以是裸机、虚拟机或其他任何东西。主机一词通常与节点互换使用。我将尝试一致地使用术语节点，但有时会根据上下文使用虚拟机这个词来指代节点。</p><h2 id="2、Kubernetes网络模型"><a href="#2、Kubernetes网络模型" class="headerlink" title="2、Kubernetes网络模型"></a>2、Kubernetes网络模型</h2><p>Kubernetes 对 Pod 的联网方式做出了自以为是的选择。特别是，Kubernetes 对任何网络实现都规定了以下要求：</p><ul><li>所有 Pod 都可以在不使用网络地址转换 (NAT) 的情况下与所有其他 Pod 通信。</li><li>所有节点都可以在没有 NAT 的情况下与所有 Pod 通信。</li><li>Pod 认为自己的 IP 与其他人认为的 IP 相同。</li></ul><p>鉴于这些限制，我们需要解决四个不同的网络问题：</p><ul><li>容器到容器网络</li><li>Pod 到 Pod 网络</li><li>Pod 到服务网络</li><li>Internet 到服务网络</li></ul><p>本指南的其余部分将讨论这些问题中的每一个 以及他们的解决方案。</p><h2 id="3、容器和容器之间网络通信"><a href="#3、容器和容器之间网络通信" class="headerlink" title="3、容器和容器之间网络通信"></a>3、容器和容器之间网络通信</h2><p>通常，我们将虚拟机中的网络通信视为直接与以太网设备交互，如图 1 所示。<br><img src="3.1.png"></p><p>实际上，情况比这更微妙。在 Linux 中，每个正在运行的进程都在一个网络命名空间内进行通信，该命名空间为逻辑网络堆栈提供了自己的路由、防火墙规则和网络设备。本质上，网络命名空间为命名空间内的所有进程提供了一个全新的网络堆栈。作为 Linux 用户，可以使用 ip 命令创建网络命名空间。例如，以下命令将创建一个名为 ns1 的新网络命名空间。<br><img src="3.2.png"></p><p>创建命名空间时，会在 /var/run/netns 下为其创建一个挂载点，即使没有附加任何进程，命名空间也可以保留。<br>您可以通过列出 /var/run/netns 下的所有挂载点或使用 ip 命令来列出可用的命名空间。<br><img src="3.3.png"></p><p>默认情况下，Linux 将每个进程分配给根网络命名空间以提供对外部世界的访问，如图 2 所示。<br><img src="3.4.png"></p><p>就 Docker 结构而言，Pod 被建模为一组共享网络命名空间的 Docker 容器。Pod 中的容器都具有相同的 IP 地址和端口空间，这些 IP 地址和端口空间是通过分配给 Pod 的网络命名空间分配的，并且可以通过 localhost 找到彼此，因为它们位于同一个命名空间中。我们可以为虚拟机上的每个 Pod 创建一个网络命名空间。这是使用 Docker 作为“Pod 容器”实现的，它保持网络命名空间打开，而“应用容器”（用户指定的东西）通过 Docker 的 –net=container: 函数加入该命名空间。图 3 显示了每个 Pod 如何由共享命名空间内的多个 Docker 容器 (ctr*) 组成。<br><img src="3.5.png"></p><p>Pod 中的应用程序还可以访问共享卷，这些卷被定义为 Pod 的一部分，并且可以挂载到每个应用程序的文件系统中。</p><h2 id="4、Pod和Pod之间网络通信"><a href="#4、Pod和Pod之间网络通信" class="headerlink" title="4、Pod和Pod之间网络通信"></a>4、Pod和Pod之间网络通信</h2><p>在 Kubernetes 中，每个 Pod 都有一个真实的 IP 地址，并且每个 Pod 都使用该 IP 地址与其他 Pod 通信。现在任务是了解 Kubernetes 如何使用真实 IP 实现 Pod 到 Pod 的通信，无论 Pod 部署在集群中的同一个物理节点还是不同的节点上。我们通过考虑驻留在同一台机器上的 Pod 来开始这个讨论，以避免通过内部网络跨节点通信的复杂性。</p><p>从 Pod 的角度来看，它存在于自己的以太网命名空间中，需要与同一节点上的其他网络命名空间进行通信。值得庆幸的是，可以使用 Linux 虚拟以太网设备或由两个虚拟接口组成的 veth 对连接命名空间，这些虚拟接口可以分布在多个命名空间上。要连接 Pod 命名空间，我们可以将 veth 对的一侧分配给根网络命名空间，将另一侧分配给 Pod 的网络命名空间。每对 veth 对的工作方式就像一根跳线，连接两侧并允许流量在它们之间流动。这个设置可以复制到机器上的尽可能多的 Pod。图 4 显示了将 VM 上的每个 Pod 连接到根命名空间的 veth 对。<br><img src="4.1.png"></p><p>此时，我们已将 Pod 设置为每个都有自己的网络命名空间，以便它们相信自己拥有自己的以太网设备和 IP 地址，并且它们连接到节点的根命名空间。现在，我们希望 Pod 通过根命名空间相互通信，为此我们使用网桥。</p><p>Linux 以太网网桥是一个虚拟的第 2 层网络设备，用于联合两个或多个网段，透明地工作以将两个网络连接在一起。网桥通过检查通过它的数据包的目的地并决定是否将数据包传递到连接到网桥的其他网段来维护源和目标之间的转发表来运行。桥接代码通过查看网络中每个以太网设备的唯一 MAC 地址来决定是桥接数据还是丢弃数据。</p><p>网桥实现 ARP 协议以发现与给定 IP 地址关联的链路层 MAC 地址。当网桥接收到数据帧时，网桥将帧广播到所有连接的设备（原始发送者除外），响应该帧的设备存储在查找表中。具有相同 IP 地址的未来流量使用查找表来发现将数据包转发到的正确 MAC 地址。<br><img src="4.2.png"><br>图5. 使用桥接连接网络</p><h3 id="4-1、同节点Pod通信"><a href="#4-1、同节点Pod通信" class="headerlink" title="4.1、同节点Pod通信"></a>4.1、同节点Pod通信</h3><p>给定将每个 Pod 与自己的网络堆栈隔离的网络命名空间、将每个命名空间连接到根命名空间的虚拟以太网设备以及将命名空间连接在一起的网桥，我们终于准备好在同一节点上的 Pod 之间进行通信。这如图 6 所示。<br><img src="https://images.elecfans.top/uploads/20220719/3fc2516c-076d-11ed-ba43-dac502259ad0.gif"></p><p>在图 6 中，Pod 1 将数据包发送到它自己的以太网设备 eth0，该设备可用作 Pod 的默认设备。对于 Pod 1，eth0 通过虚拟以太网设备连接到根命名空间 veth0 (1)。网桥 cbr0 配置有 veth0 连接到它的网段。一旦数据包到达网桥，网桥会解析正确的网段以使用 ARP 协议将数据包发送到 veth1 (3)。当数据包到达虚拟设备 veth1 时，它被直接转发到 Pod 2 的命名空间和该命名空间内的 eth0 设备 (4)。在整个流量流中，每个 Pod 仅与 localhost 上的 eth0 通信，并且流量被路由到正确的 Pod。使用网络的开发体验是开发人员所期望的默认行为。</p><p>Kubernetes 的网络模型规定 Pod 必须可以通过其 IP 地址跨节点访问。也就是说，一个 Pod 的 IP 地址始终对网络中的其他 Pod 可见，每个 Pod 看待自己的 IP 地址的方式与其他 Pod 看待它的方式相同。我们现在转向不同节点上的 Pod 之间如何进行通信的问题。</p><h3 id="4-2、跨节点Pod通信"><a href="#4-2、跨节点Pod通信" class="headerlink" title="4.2、跨节点Pod通信"></a>4.2、跨节点Pod通信</h3><p>在研究了如何在同一节点上的 Pod 之间如何进行通信之后，我们继续研究在不同节点上的 Pod 如何进行通信。Kubernetes 网络模型要求 Pod IP 可以通过网络访问，但它没有指定必须如何完成。</p><p>通常，集群中的每个节点都分配有一个 CIDR 块，指定该节点上运行的 Pod 可用的 IP 地址。一旦流向 CIDR 块的流量到达节点，节点就有责任将流量转发到正确的 Pod。图 7 说明了两个节点之间的流量流，假设网络可以将 CIDR 块中的流量路由到正确的节点。<br><img src="https://images.elecfans.top/uploads/20220719/3fd4d332-076d-11ed-ba43-dac502259ad0.gif"></p><p>图 7 以与图 6 相同的请求开始，但这次，目标 Pod（以绿色突出显示）与源 Pod（以蓝色突出显示）位于不同的节点上。数据包首先通过 Pod 1 的以太网设备发送，该设备与根命名空间 (1) 中的虚拟以太网设备配对。最终，数据包最终到达根命名空间的网桥 (2)。ARP 将在网桥上失败，因为没有设备连接到网桥并具有正确的数据包 MAC 地址。失败时，网桥将数据包发送到默认路由——根命名空间的 eth0 设备。此时路由离开节点并进入网络 (3)。我们现在假设网络可以根据分配给节点的 CIDR 块将数据包路由到正确的节点 (4)。数据包进入目标节点的根命名空间（VM 2 上的 eth0），在那里它通过网桥路由到正确的虚拟以太网设备 (5)。最后，路由通过位于 Pod 4 的命名空间 (6) 中的虚拟以太网设备对来完成。一般来说，每个节点都知道如何将数据包传递给在其中运行的 Pod。一旦数据包到达目标节点，数据包的流动方式与在同一节点上的 Pod 之间路由流量的方式相同。</p><p>我们轻松地避开了如何配置网络以将 Pod IP 的流量转发到负责这些 IP 的正确节点。这是特定于网络的，但查看特定示例将提供对所涉及问题的一些见解。例如，借助 AWS，Amazon 为 Kubernetes 维护了一个容器网络插件，允许节点到节点网络使用 [容器网络接口 (CNI) 插件] (<a href="https://github.com/aws/amazon">https://github.com/aws/amazon</a>) 在 Amazon VPC 环境中运行-vpc-cni-k8s）。</p><p>容器网络接口 (CNI) 提供了一个通用 API，用于将容器连接到外部网络。作为开发人员，我们想知道 Pod 可以使用 IP 地址与网络通信，并且我们希望此操作的机制是透明的。AWS 开发的 CNI 插件试图满足这些需求，同时通过 AWS 提供的现有 VPC、IAM 和安全组功能提供安全和可管理的环境，解决方案是使用弹性网络接口。</p><p>在 EC2 中，每个实例都绑定到一个弹性网络接口 (ENI)，并且所有 ENI 都连接在一个 VPC 内——ENI 无需额外努力即可相互访问。默认情况下，每个 EC2 实例部署一个 ENI，但您可以自由创建多个 ENI 并将它们部署到您认为合适的 EC2 实例。适用于 Kubernetes 的 AWS CNI 插件通过为部署到节点的每个 Pod 创建一个新的 ENI 来利用这种灵活性。因为 VPC 中的 ENI 已经连接到现有 AWS 基础设施中，所以这允许每个 Pod 的 IP 地址在 VPC 中本地可寻址。当 CNI 插件部署到集群时，每个节点（EC2 实例）都会创建多个弹性网络接口并为这些实例分配 IP 地址，从而为每个节点形成一个 CIDR 块。部署 Pod 时，作为 DaemonSet 部署到 Kubernetes 集群的小型二进制文件会从 Nodes 本地 kubelet 进程接收任何将 Pod 添加到网络的请求。这个二进制文件从节点的可用 ENI 池中选择一个可用的 IP 地址，并通过在 Linux 内核中连接虚拟以太网设备和网桥将其分配给 Pod，如在同一节点内联网 Pod 时所述。有了这个，Pod 流量就可以跨集群内的节点路由。</p><h2 id="5、Pod和Service之间网络通信"><a href="#5、Pod和Service之间网络通信" class="headerlink" title="5、Pod和Service之间网络通信"></a>5、Pod和Service之间网络通信</h2><p>我们已经展示了如何在 Pod 及其关联的 IP 地址之间路由转发。在我们需要应对变化之前，这很有效。Pod IP 地址不是持久的，并且会随着扩展或缩减、应用程序崩溃或节点重启而出现和消失。这些事件中的每一个都可以使 Pod IP 地址在没有警告的情况下更改。Service被内置到 Kubernetes 中来解决这个问题。</p><p>Kubernetes Service 管理一组 Pod 的状态，允许您跟踪一组随时间动态变化的 Pod IP 地址。Service充当对 Pod 的抽象，并将单个虚拟 IP 地址分配给一组 Pod IP 地址。任何发往 Service 虚拟 IP 的流量都将被转发到与虚拟 IP 关联的 Pod 集。这允许与 Service 关联的 Pod 集随时更改——客户端只需要知道 Service 的虚拟 IP即可，它不会更改。</p><p>创建新的 Kubernetes Service时，会为您创建一个新的虚拟 IP（也称为集群 IP）。在集群中的任何地方，发往虚拟 IP 的流量都将负载均衡到与服务关联的一组支持 Pod。实际上，Kubernetes 会自动创建并维护一个分布式集群内负载均衡器，将流量分配到服务相关联的健康 Pod。让我们仔细看看它是如何工作的。</p><h3 id="5-1、netfilter-和-iptables"><a href="#5-1、netfilter-和-iptables" class="headerlink" title="5.1、netfilter 和 iptables"></a>5.1、netfilter 和 iptables</h3><p>为了在集群中执行负载平衡，Kubernetes 依赖于 Linux 内置的网络框架——netfilter。Netfilter 是 Linux 提供的一个框架，它允许以自定义处理程序的形式实现各种与网络相关的操作。Netfilter 为数据包过滤、网络地址转换和端口转换提供了各种功能和操作，它们提供了引导数据包通过网络所需的功能，以及提供禁止数据包到达计算机网络中敏感位置的能力。</p><p>iptables 是一个用户空间程序，它提供了一个基于表的系统，用于定义使用 netfilter 框架操作和转换数据包的规则。在 Kubernetes 中，iptables 规则由 kube-proxy 控制器配置，该控制器监视 Kubernetes API 服务器的更改。当对 Service 或 Pod 的更改更新 Service 的虚拟 IP 地址或 Pod 的 IP 地址时，iptables 规则会更新以正确地将指向 Service 的流量转发到正确的Pod。iptables 规则监视发往 Service 的虚拟 IP 的流量，并且在匹配时，从可用 Pod 集中选择一个随机 Pod IP 地址，并且 iptables 规则将数据包的目标 IP 地址从 Service 的虚拟 IP 更改为选定的 Pod。当 Pod 启动或关闭时，iptables 规则集会更新以反映集群不断变化的状态。换句话说，iptables 已经在机器上进行了负载平衡，以将定向到服务 IP 的流量转移到实际 pod 的 IP。</p><p>在返回路径上，IP 地址来自目标 Pod。在这种情况下，iptables 再次重写 IP 标头以将 Pod IP 替换为 Service 的 IP，以便 Pod 认为它一直只与 Service 的 IP 通信。</p><h3 id="5-2、IPVS"><a href="#5-2、IPVS" class="headerlink" title="5.2、IPVS"></a>5.2、IPVS</h3><p>Kubernetes 的最新版本 (1.11) 包括用于集群内负载平衡的第二个选项：IPVS。IPVS（IP 虚拟服务器）也构建在 netfilter 之上，并将传输层负载平衡作为 Linux 内核的一部分实现。IPVS 被合并到 LVS（Linux 虚拟服务器）中，它在主机上运行并充当真实服务器集群前面的负载平衡器。IPVS 可以将基于 TCP 和 UDP 的服务的请求定向到真实服务器，并使真实服务器的服务在单个 IP 地址上表现为虚拟服务。这使得 IPVS 非常适合 Kubernetes 服务。</p><p>声明 Kubernetes Service时，您可以指定是否希望使用 iptables 或 IPVS 完成集群内负载平衡。IPVS 专为负载平衡而设计，并使用更高效的数据结构（哈希表），与 iptables 相比允许几乎无限的规模。在使用 IPVS 创建负载均衡的 Service 时，会发生三件事：在 Node 上创建一个虚拟 IPVS 接口，将 Service 的 IP 地址绑定到虚拟 IPVS 接口，并为每个 Service IP 地址创建 IPVS 服务器。</p><p>未来，IPVS 有望成为集群内负载均衡的默认方法。此更改仅影响集群内负载平衡，并且在本指南的其余部分中，您可以安全地将 iptables 替换为 IPVS 以实现集群内负载平衡，而不会影响其余讨论。现在让我们看看通过集群内负载平衡服务的数据包的生命周期。</p><h3 id="5-3、Pod和Service通信"><a href="#5-3、Pod和Service通信" class="headerlink" title="5.3、Pod和Service通信"></a>5.3、Pod和Service通信</h3><p><img src="https://images.elecfans.top/uploads/20220719/4003ef64-076d-11ed-ba43-dac502259ad0.gif"></p><p>在 Pod 和 Service 之间路由数据包时，与以前相同的方式开始。数据包首先通过连接到 Pod 的网络命名空间 (1) 的 eth0 接口离开 Pod。然后它通过虚拟以太网设备到达网桥 (2)。网桥上运行的 ARP 协议不知道 Service，因此它通过默认路由 eth0 (3) 将数据包传输出去。在这里，发生了一些不同的事情。在 eth0 接受之前，数据包会通过 iptables 过滤。iptables 收到数据包后，使用 kube-proxy 安装在 Node 上的规则响应 Service 或 Pod 事件，将数据包的目的地从 Service IP 重写为特定的 Pod IP（4）。数据包现在注定要到达 Pod 4，而不是服务的虚拟 IP。iptables 利用 Linux 内核的 conntrack 实用程序来记住所做的 Pod 选择，以便将来的流量路由到同一个 Pod（除非发生任何扩展事件）。本质上，iptables 直接在 Node 上做了集群内负载均衡。然后流量使用我们已经检查过的 Pod 到 Pod 路由流向 Pod (5)。</p><h3 id="5-4、Service和Pod通信"><a href="#5-4、Service和Pod通信" class="headerlink" title="5.4、Service和Pod通信"></a>5.4、Service和Pod通信</h3><p><img src="https://images.elecfans.top/uploads/20220719/4019bb0a-076d-11ed-ba43-dac502259ad0.gif"><br>收到此数据包的 Pod 将响应，将源 IP 识别为自己的 IP，将目标 IP 识别为最初发送数据包的 Pod (1)。进入节点后，数据包流经 iptables，它使用 conntrack 记住它之前所做的选择，并将数据包的源重写为服务的 IP 而不是 Pod 的 IP (2)。从这里开始，数据包通过网桥流向与 Pod 的命名空间配对的虚拟以太网设备 (3)，然后流向我们之前看到的 Pod 的以太网设备 (4)。</p><h3 id="5-5、使用DNS"><a href="#5-5、使用DNS" class="headerlink" title="5.5、使用DNS"></a>5.5、使用DNS</h3><p>Kubernetes 可以选择使用 DNS 来避免将服务的集群 IP 地址硬编码到您的应用程序中。Kubernetes DNS 作为在集群上调度的常规 Kubernetes 服务运行。它配置在每个节点上运行的 kubelet，以便容器使用 DNS 服务的 IP 来解析 DNS 名称。集群中定义的每个服务（包括 DNS 服务器本身）都被分配了一个 DNS 名称。DNS 记录将 DNS 名称解析为服务的集群 IP 或 POD 的 IP，具体取决于您的需要。SRV 记录用于指定运行服务的特定命名端口。</p><p>DNS Pod 由三个独立的容器组成：</p><ul><li>kubedns：监视 Kubernetes 主服务器的服务和端点变化，并维护内存中的查找结构以服务 DNS 请求。</li><li>dnsmasq：添加 DNS 缓存以提高性能。</li><li>sidecar：提供一个单一的健康检查端点来执行 dnsmasq 和 kubedns 的健康检查。</li></ul><p>DNS Pod 本身作为 Kubernetes 服务公开，具有静态集群 IP，该 IP 在启动时传递给每个正在运行的容器，以便每个容器都可以解析 DNS 条目。DNS 条目通过维护内存中 DNS 表示的 kubedns 系统解析。etcd 是集群状态的后端存储系统，kubedns 使用一个库将 etcd 键值存储转换为 DNS 整体，以便在必要时重建内存中 DNS 查找结构的状态。</p><p>CoreDNS 与 kubedns 的工作方式类似，但使用插件架构构建，使其更加灵活。从 Kubernetes 1.11 开始，CoreDNS 是 Kubernetes 的默认 DNS 实现。</p><h2 id="6、Internet和Service之间网络通信"><a href="#6、Internet和Service之间网络通信" class="headerlink" title="6、Internet和Service之间网络通信"></a>6、Internet和Service之间网络通信</h2><p>到目前为止，我们已经了解了 Kubernetes 集群内的流量是如何转发的。这一切都很好，但不幸的是，将您的应用程序与外界隔离无助于实现任何销售目标——在某些时候，您可能希望将您的服务暴露给外部流量。这种需求突出了两个相关的问题：</p><ul><li>1）从 Kubernetes 服务获取流量到 Internet。</li><li>2）从 Internet 获取流量到您的 Kubernetes 服务。</li></ul><h3 id="6-1、Egress-将Kubernetes流量转发到Internet"><a href="#6-1、Egress-将Kubernetes流量转发到Internet" class="headerlink" title="6.1、Egress-将Kubernetes流量转发到Internet"></a>6.1、Egress-将Kubernetes流量转发到Internet</h3><p>从节点到公共 Internet 的流量转发是特定于网络的，并且实际上取决于您的网络如何配置以发布流量。为了使本节更加具体，我将使用 AWS VPC 来讨论任何具体细节。</p><p>在 AWS 中，Kubernetes 集群在 VPC 中运行，其中每个节点都分配有一个私有 IP 地址，该地址可从 Kubernetes 集群内访问。要从集群外部访问流量，您需要将 Internet 网关连接到您的 VPC。Internet 网关有两个用途：在您的 VPC 路由表中为可路由到 Internet 的流量提供目标，以及为已分配公共 IP 地址的任何实例执行网络地址转换 (NAT)。NAT 转换负责将集群专用的节点内部 IP 地址更改为公共 Internet 中可用的外部 IP 地址。</p><p>有了 Internet 网关，VM 就可以自由地将流量路由到 Internet。不幸的是，有一个小问题。Pod 有自己的 IP 地址，与托管 Pod 的节点的 IP 地址不同，并且 Internet 网关的 NAT 转换仅适用于 VM IP 地址，因为它不知道 Pod 正在运行什么哪些虚拟机——网关不支持容器。让我们看看 Kubernetes 如何使用 iptables 解决这个问题（再次）。</p><h4 id="6-1-1、Node和Internet通信"><a href="#6-1-1、Node和Internet通信" class="headerlink" title="6.1.1、Node和Internet通信"></a>6.1.1、Node和Internet通信</h4><p>在下图中，数据包源自 Pod 的命名空间 (1)，并经过连接到根命名空间 (2) 的 veth 对。一旦进入根命名空间，数据包就会从网桥移动到默认设备，因为数据包上的 IP 与连接到网桥的任何网段都不匹配。在到达根命名空间的以太网设备 (3) 之前，iptables 会破坏数据包 (3)。在这种情况下，数据包的源 IP 地址是 Pod，如果我们将源保留为 Pod，Internet 网关将拒绝它，因为网关 NAT 只了解连接到 VM 的 IP 地址。解决方案是让 iptables 执行源 NAT——更改数据包源——使数据包看起来来自 VM 而不是 Pod。有了正确的源 IP，数据包现在可以离开 VM (4) 并到达 Internet 网关 (5)。Internet 网关将执行另一个 NAT，将源 IP 从 VM 内部 IP 重写为外部 IP。最后，数据包将到达公共 Internet (6)。在返回的路上，数据包遵循相同的路径，并且任何源 IP 修改都被撤消，以便系统的每一层都接收到它理解的 IP 地址：节点或 VM 级别的 VM 内部，以及 Pod 内的 Pod IP命名空间。<br><img src="https://images.elecfans.top/uploads/20220719/402ccfa6-076d-11ed-ba43-dac502259ad0.gif"></p><h3 id="6-2、Ingress-将Internet流量转发到Kubernetes"><a href="#6-2、Ingress-将Internet流量转发到Kubernetes" class="headerlink" title="6.2、Ingress-将Internet流量转发到Kubernetes"></a>6.2、Ingress-将Internet流量转发到Kubernetes</h3><p>入口——让流量进入你的集群——是一个非常难以解决的问题。同样，这是特定于您正在运行的网络的，但一般来说，Ingress 分为两种解决方案，适用于网络堆栈的不同部分：(</p><ul><li><ol><li>服务负载平衡器和 </li></ol></li><li><ol start="2"><li>入口控制器<h4 id="6-2-1、四层转发-Loadbalancer"><a href="#6-2-1、四层转发-Loadbalancer" class="headerlink" title="6.2.1、四层转发-Loadbalancer"></a>6.2.1、四层转发-Loadbalancer</h4>当你创建一个 Kubernetes 服务时，你可以选择指定一个 LoadBalancer 来配合它。LoadBalancer 的实现由知道如何为您的服务创建负载均衡器的云控制器提供。创建服务后，它将公布负载均衡器的 IP 地址。作为最终用户，您可以开始将流量引导到负载均衡器以开始与您的服务通信。</li></ol></li></ul><p>借助 AWS，负载均衡器可以了解其目标组中的节点，并将平衡集群中所有节点的流量。一旦流量到达一个节点，之前为您的服务在整个集群中安装的 iptables 规则将确保流量到达您感兴趣的服务的 Pod。</p><h4 id="6-2-2、Loadbalancer和Service通信"><a href="#6-2-2、Loadbalancer和Service通信" class="headerlink" title="6.2.2、Loadbalancer和Service通信"></a>6.2.2、Loadbalancer和Service通信</h4><p>让我们看看这在实践中是如何工作的。部署服务后，您正在使用的云提供商将为您创建一个新的负载均衡器 (1)。因为负载均衡器不支持容器，所以一旦流量到达负载均衡器，它就会分布在组成集群的所有虚拟机中 (2)。每个 VM 上的 iptables 规则会将来自负载均衡器的传入流量引导到正确的 Pod (3) — 这些是在服务创建期间实施并在前面讨论过的相同 IP 表规则。Pod 到客户端的响应将返回 Pod 的 IP，但客户端需要有负载均衡器的 IP 地址。正如我们之前看到的，iptables 和 conntrack 用于在返回路径上正确重写 IP。</p><p>下图显示了托管 Pod 的三个 VM 前面的网络负载均衡器。传入流量 (1) 指向您的服务的负载均衡器。一旦负载均衡器收到数据包 (2)，它就会随机选择一个 VM。在这种情况下，我们病态地选择了没有运行 Pod 的 VM：VM 2 (3)。在这里，运行在 VM 上的 iptables 规则将使用 kube-proxy 安装到集群中的内部负载平衡规则将数据包定向到正确的 Pod。iptables 执行正确的 NAT 并将数据包转发到正确的 Pod (4)。<br><img src="https://images.elecfans.top/uploads/20220719/40442c46-076d-11ed-ba43-dac502259ad0.gif"></p><h4 id="6-2-3、七层转发-Ingress-Controller"><a href="#6-2-3、七层转发-Ingress-Controller" class="headerlink" title="6.2.3、七层转发-Ingress Controller"></a>6.2.3、七层转发-Ingress Controller</h4><p>第 7 层网络 Ingress 在网络堆栈的 HTTP/HTTPS 协议范围内运行，并构建在 Services 之上。启用 Ingress 的第一步是使用 Kubernetes 中的 NodePort 服务类型在您的服务上打开一个端口。如果将 Service 的 type 字段设置为 NodePort，Kubernetes master 将从您指定的范围内分配一个端口，并且每个 Node 都会将该端口（每个 Node 上的相同端口号）代理到您的 Service 中。也就是说，任何指向节点端口的流量都将使用 iptables 规则转发到服务。这个 Service 到 Pod 的路由遵循我们在将流量从 Service 路由到 Pod 时已经讨论过的相同的内部集群负载平衡模式。</p><p>要向 Internet 公开节点的端口，您需要使用 Ingress 对象。Ingress 是一个更高级别的 HTTP 负载均衡器，它将 HTTP 请求映射到 Kubernetes 服务。Ingress 方法将根据 Kubernetes 云提供商控制器的实现方式而有所不同。HTTP 负载均衡器，如第 4 层网络负载均衡器，仅了解节点 IP（而不是 Pod IP），因此流量路由同样利用由 kube-proxy 安装在每个节点上的 iptables 规则提供的内部负载均衡。</p><p>在 AWS 环境中，ALB 入口控制器使用 Amazon 的第 7 层应用程序负载均衡器提供 Kubernetes 入口。下图详细介绍了此控制器创建的 AWS 组件。它还演示了 Ingress 流量从 ALB 到 Kubernetes 集群的路由。<br><img src="6.2.3.png"></p><p>创建后，(1) Ingress Controller 监视来自 Kubernetes API 服务器的 Ingress 事件。当它找到满足其要求的 Ingress 资源时，它会开始创建 AWS 资源。AWS 将 Application Load Balancer (ALB) (2) 用于 Ingress 资源。负载均衡器与用于将请求路由到一个或多个注册节点的目标组一起工作。(3) 在 AWS 中为 Ingress 资源描述的每个唯一 Kubernetes 服务创建目标组。(4) Listener 是一个 ALB 进程，它使用您配置的协议和端口检查连接请求。侦听器由 Ingress 控制器为您的 Ingress 资源注释中详述的每个端口创建。最后，为 Ingress 资源中指定的每个路径创建目标组规则。这确保了到特定路径的流量被路由到正确的 Kubernetes 服务 (5)。</p><h4 id="6-2-4、Ingress和Service通信"><a href="#6-2-4、Ingress和Service通信" class="headerlink" title="6.2.4、Ingress和Service通信"></a>6.2.4、Ingress和Service通信</h4><p>流经 Ingress 的数据包的生命周期与 LoadBalancer 的生命周期非常相似。主要区别在于 Ingress 知道 URL 的路径（允许并可以根据路径将流量路由到服务），并且 Ingress 和 Node 之间的初始连接是通过 Node 上为每个服务公开的端口。</p><p>让我们看看这在实践中是如何工作的。部署服务后，您正在使用的云提供商将为您创建一个新的 Ingress 负载均衡器 (1)。由于负载均衡器不支持容器，因此一旦流量到达负载均衡器，它就会通过为您的服务提供的广告端口分布在组成集群 (2) 的整个 VM 中。每个 VM 上的 iptables 规则会将来自负载均衡器的传入流量引导到正确的 Pod (3) — 正如我们之前所见。Pod 到客户端的响应将返回 Pod 的 IP，但客户端需要有负载均衡器的 IP 地址。正如我们之前看到的，iptables 和 conntrack 用于在返回路径上正确重写 IP。<br><img src="https://images.elecfans.top/uploads/20220719/40866d90-076d-11ed-ba43-dac502259ad0.gif"></p><p>第 7 层负载均衡器的一个好处是它们可以识别 HTTP，因此它们知道 URL 和路径。这使您可以按 URL 路径对服务流量进行分段。它们通常还在 HTTP 请求的 X-Forwarded-For 标头中提供原始客户端的 IP 地址。</p><h2 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h2><p>本指南为理解 Kubernetes 网络模型以及它如何支持常见的网络任务奠定了基础。网络领域既广泛又深入，不可能在这里涵盖所有内容。本指南应为您提供深入了解您感兴趣并想了解更多主题的起点。每当您遇到困难时，请利用 Kubernetes 文档和 Kubernetes 社区来帮助您找到自己的方式。</p><h2 id="8、网络术语"><a href="#8、网络术语" class="headerlink" title="8、网络术语"></a>8、网络术语</h2><p>Kubernetes 依赖于几种现有技术来构建一个正常运行的集群。全面探索这些技术中的每一个超出了本指南的范围，但本节将详细描述这些技术中的每一个，以便进行讨论。如果您感到困惑或需要复习，您可以随意略读本节，完全跳过它，或者根据需要参考它。</p><h3 id="二层网络"><a href="#二层网络" class="headerlink" title="二层网络"></a>二层网络</h3><p>第 2 层是提供节点到节点数据传输的数据链路层。它定义了在两个物理连接的设备之间建立和终止连接的协议。它还定义了它们之间的流量控制协议。</p><h3 id="四层网络"><a href="#四层网络" class="headerlink" title="四层网络"></a>四层网络</h3><p>传输层通过流量控制控制给定链路的可靠性。在 TCP/IP 中，这一层是指用于在不可靠网络上交换数据的 TCP 协议。</p><h3 id="七层网络"><a href="#七层网络" class="headerlink" title="七层网络"></a>七层网络</h3><p>应用层是最接近最终用户的层，这意味着应用层和用户都直接与软件应用程序交互。该层与实现通信组件的软件应用程序交互。通常，第 7 层网络是指 HTTP。</p><h3 id="Nat网络地址转换"><a href="#Nat网络地址转换" class="headerlink" title="Nat网络地址转换"></a>Nat网络地址转换</h3><p>NAT 或网络地址转换是将一个地址空间重新映射到另一个地址空间的 IP 级别。映射通过在数据包通过流量路由设备传输时修改数据包的 IP 标头中的网络地址信息来实现。</p><p>基本 NAT 是从一个 IP 地址到另一个 IP 地址的简单映射。更常见的是，NAT 用于将多个私有 IP 地址映射到一个公开的 IP 地址。通常，本地网络使用私有 IP 地址空间，并且该网络上的路由器在该空间中被赋予私有地址。然后路由器使用公共 IP 地址连接到 Internet。当流量从本地网络传递到 Internet 时，每个数据包的源地址都从私有地址转换为公共地址，这使得请求看起来好像直接来自路由器。路由器维护连接跟踪，以将回复转发到本地网络上的正确专用 IP。</p><p>NAT 提供了一个额外的好处，即允许大型专用网络使用单个公共 IP 地址连接到 Internet，从而节省公共使用的 IP 地址的数量。</p><h4 id="snat-源地址转换"><a href="#snat-源地址转换" class="headerlink" title="snat-源地址转换"></a>snat-源地址转换</h4><p>SNAT 只是指修改 IP 数据包源地址的 NAT 过程。这是上述 NAT 的典型行为。</p><h4 id="dnat-目标地址转换"><a href="#dnat-目标地址转换" class="headerlink" title="dnat-目标地址转换"></a>dnat-目标地址转换</h4><p>DNAT 是指修改 IP 数据包的目的地址的 NAT 过程。DNAT 用于将位于专用网络中的服务发布到可公开寻址的 IP 地址。</p><h3 id="网络名称空间"><a href="#网络名称空间" class="headerlink" title="网络名称空间"></a>网络名称空间</h3><p>在网络中，每台机器（真实的或虚拟的）都有一个以太网设备（我们将其称为 eth0）。所有流入和流出机器的流量都与该设备相关联。事实上，Linux 将每个以太网设备与一个网络命名空间相关联——整个网络堆栈的逻辑副本，以及它自己的路由、防火墙规则和网络设备。最初，所有进程共享来自 init 进程的相同默认网络命名空间，称为根命名空间。默认情况下，进程从其父进程继承其网络命名空间，因此，如果您不进行任何更改，所有网络流量都会流经为根网络命名空间指定的以太网设备。</p><h3 id="veth虚拟网卡对"><a href="#veth虚拟网卡对" class="headerlink" title="veth虚拟网卡对"></a>veth虚拟网卡对</h3><p>计算机系统通常由一个或多个网络设备（eth0、eth1 等）组成，这些设备与负责将数据包放置到物理线路上的物理网络适配器相关联。Veth 设备是虚拟网络设备，始终以互连的对创建。它们可以充当网络命名空间之间的隧道，以创建到另一个命名空间中的物理网络设备的桥接，但也可以用作独立的网络设备。您可以将 veth 设备视为设备之间的虚拟跳线——一端连接的设备将连接另一端。</p><h3 id="网络桥接"><a href="#网络桥接" class="headerlink" title="网络桥接"></a>网络桥接</h3><p>网桥是从多个通信网络或网段创建单个聚合网络的设备。桥接连接两个独立的网络，就好像它们是一个网络一样。桥接使用内部数据结构来记录每个数据包发送到的位置，以作为性能优化。</p><h3 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h3><p>CIDR 是一种分配 IP 地址和执行 IP 路由的方法。对于 CIDR，IP 地址由两组组成：网络前缀（标识整个网络或子网）和主机标识符（指定该网络或子网上的主机的特定接口）。CIDR 使用 CIDR 表示法表示 IP 地址，其中地址或路由前缀写有表示前缀位数的后缀，例如 IPv4 的 192.0.2.0/24。IP 地址是 CIDR 块的一部分，如果地址的初始 n 位和 CIDR 前缀相同，则称其属于 CIDR 块。</p><h3 id="CNI"><a href="#CNI" class="headerlink" title="CNI"></a>CNI</h3><p>CNI（容器网络接口）是一个云原生计算基金会项目，由规范和库组成，用于编写插件以在 Linux 容器中配置网络接口。CNI 只关心容器的网络连接以及在容器被删除时移除分配的资源。</p><h3 id="VIP地址"><a href="#VIP地址" class="headerlink" title="VIP地址"></a>VIP地址</h3><p>虚拟 IP 地址或 VIP 是软件定义的 IP 地址，与实际的物理网络接口不对应。</p><h3 id="netfilter"><a href="#netfilter" class="headerlink" title="netfilter"></a>netfilter</h3><p>netfilter 是 Linux 中的包过滤框架。实现此框架的软件负责数据包过滤、网络地址转换 (NAT) 和其他数据包处理。</p><p>netfilter、ip_tables、连接跟踪（ip_conntrack、nf_conntrack）和NAT子系统共同构建了框架的主要部分。</p><h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><p>iptables 是一个允许 Linux 系统管理员配置 netfilter 及其存储的链和规则的程序。IP 表中的每条规则都由许多分类器（iptables 匹配）和一个连接的操作（iptables 目标）组成。</p><h3 id="conntrack"><a href="#conntrack" class="headerlink" title="conntrack"></a>conntrack</h3><p>conntrack 是建立在 Netfilter 框架之上的用于处理连接跟踪的工具。连接跟踪允许内核跟踪所有逻辑网络连接或会话，并将每个连接或会话的数据包定向到正确的发送者或接收者。NAT 依靠此信息以相同的方式翻译所有相关数据包，并且 iptables 可以使用此信息充当状态防火墙。</p><h3 id="IPVS"><a href="#IPVS" class="headerlink" title="IPVS"></a>IPVS</h3><p>IPVS 将传输层负载平衡作为 Linux 内核的一部分来实现。</p><p>IPVS 是一个类似于 iptables 的工具。它基于 Linux 内核的 netfilter 钩子函数，但使用哈希表作为底层数据结构。这意味着，与 iptables 相比，IPVS 重定向流量更快，在同步代理规则时具有更好的性能，并提供更多的负载平衡算法。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>域名系统 (DNS) 是一个分散的命名系统，用于将系统名称与 IP 地址相关联。它将域名转换为用于定位计算机服务的数字 IP 地址。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://m.elecfans.com/article/1863588.html">Kubernetes网络模型的基础知识</a></li><li><a href="https://sookocheff.com/post/kubernetes/understanding-kubernetes-networking-model/">A Guide to the Kubernetes Networking Model</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的创建对象方式及存在问题</title>
    <link href="/2022/09/13/java/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/13/java/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="使用构造方法"><a href="#使用构造方法" class="headerlink" title="使用构造方法"></a>使用构造方法</h2><p>成员变量很多的时候，构造方法就没方便了.<br>举例:NutritionFacts是食品包装外面显示的营养成分标签，这里面有的营养成分是必须的：每一份的含量、每一罐的含量，其他的可选</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NutritionFacts</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> servingSize;  <span class="hljs-comment">// (mL)            required</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> servings;     <span class="hljs-comment">// (per container) required</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> calories;     <span class="hljs-comment">//                 optional</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> fat;          <span class="hljs-comment">// (g)             optional</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> sodium;       <span class="hljs-comment">// (mg)            optional</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> carbohydrate; <span class="hljs-comment">// (g)             optional</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">(<span class="hljs-type">int</span> servingSize, <span class="hljs-type">int</span> servings)</span> &#123;<br>        <span class="hljs-built_in">this</span>(servingSize, servings, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">(<span class="hljs-type">int</span> servingSize, <span class="hljs-type">int</span> servings,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> calories)</span> &#123;<br>        <span class="hljs-built_in">this</span>(servingSize, servings, calories, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">(<span class="hljs-type">int</span> servingSize, <span class="hljs-type">int</span> servings,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> calories, <span class="hljs-type">int</span> fat)</span> &#123;<br>        <span class="hljs-built_in">this</span>(servingSize, servings, calories, fat, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">(<span class="hljs-type">int</span> servingSize, <span class="hljs-type">int</span> servings,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> calories, <span class="hljs-type">int</span> fat, <span class="hljs-type">int</span> sodium)</span> &#123;<br>        <span class="hljs-built_in">this</span>(servingSize, servings, calories, fat, sodium, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">(<span class="hljs-type">int</span> servingSize, <span class="hljs-type">int</span> servings,</span><br><span class="hljs-params">           <span class="hljs-type">int</span> calories, <span class="hljs-type">int</span> fat, <span class="hljs-type">int</span> sodium, <span class="hljs-type">int</span> carbohydrate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.servingSize  = servingSize;<br>        <span class="hljs-built_in">this</span>.servings     = servings;<br>        <span class="hljs-built_in">this</span>.calories     = calories;<br>        <span class="hljs-built_in">this</span>.fat          = fat;<br>        <span class="hljs-built_in">this</span>.sodium       = sodium;<br>        <span class="hljs-built_in">this</span>.carbohydrate = carbohydrate;<br>    &#125;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><p>从上面的代码可见，为了尽量满足用户需要，NutritionFacts提供了多个构造方法给用户使用,以后要是加字段就麻烦了</p><p>缓解上述问题的一种方法是使用JavaBeans模式，用无参构造方法，然后按照调用setXXX设置每个所需字段，示例如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">NutritionFacts</span> <span class="hljs-variable">cocaCola</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NutritionFacts</span>();<br>cocaCola.setServingSize(<span class="hljs-number">240</span>);<br>cocaCola.setServings(<span class="hljs-number">8</span>);<br>cocaCola.setCalories(<span class="hljs-number">100</span>);<br>cocaCola.setSodium(<span class="hljs-number">35</span>);<br>cocaCola.setCarbohydrate(<span class="hljs-number">27</span>);<br><br></code></pre></td></tr></table></figure><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><ol><li>首先，直观的看，这种做法违背了不可变对象的定义，创建出对象后，又用setXXX方法改变了成员变量</li><li>《Effective Java》的原话是在构造过程中JavaBean可能处于不一致的中的状态</li></ol><h2 id="使用静态工厂方法"><a href="#使用静态工厂方法" class="headerlink" title="使用静态工厂方法"></a>使用静态工厂方法</h2><p>相比静态工厂方法，构造方法存在以下五个典型问题</p><ol><li>随着入参的不同，构造方法可以有多个，如下所示，然而都是同名的，这会给用户造成困惑，此刻用静态工厂方法，可以自由设置方法名（例如createWithName或者createWithAge），让用户更方便的选择合适的方法</li><li>使用构造方法意味着创建对象，而有时候我们只想使用，并不在乎对象本身是否是新建的</li><li>以动物类Animal.class为例，Animal类的构造方法创建的对象Animal的实例，而静态工厂方法的返回值声明虽然是Animal，但实际返回的实例可以是Animal的子类，例如Dog</li><li>静态工厂方法内部可以有灵活的逻辑来决定返回那种子类的实例</li><li>静态工厂方法还有一个优势：方法返回对象所属的类，在编写此静态方法时可以不存在，这句话有点晦涩，可以回想一下JDBC的获取connection的API，在编写此API的时候，并不需要知道MySQL的driver实现</li></ol><h3 id="存在问题-1"><a href="#存在问题-1" class="headerlink" title="存在问题"></a>存在问题</h3><ol><li>当您开发一个类时，如果决定对外提供静态工厂方法，那么将构造方法设为私有，就可以让用户只能选择静态工厂方法了，代码如下所示，然而，这样的Student类就无法被继承<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Student <span class="hljs-title function_">newInstance</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        student.setName(name);<br><br>        <span class="hljs-keyword">return</span> student;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li>一个类的代码中，可能已有一些静态方法，再加入静态工厂方法，一堆静态方法混杂在一起，用户从中找出静态工厂方法怕是不容易</li></ol><h2 id="使用builder"><a href="#使用builder" class="headerlink" title="使用builder"></a>使用builder</h2><p>builder pattern，《Effective Java》中文版译作建造者模式，用builder对象来创建真正的对象实例，前面提到的构造方法和静态工厂的不足，在builder pattern这里都得到了改善</p><p>来看代码吧，以刚才的NutritionFacts为例，使用builder pattern后的代码如下，新增一个静态成员类Builder，可以设置Builder的每个成员变量，最后调用其build方法的时候，才真正创建NutritionFacts对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NutritionFacts</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> servingSize;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> servings;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> calories;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> fat;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> sodium;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> carbohydrate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>        <span class="hljs-comment">// Required parameters</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> servingSize;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> servings;<br><br>        <span class="hljs-comment">// Optional parameters - initialized to default values</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">calories</span>      <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">fat</span>           <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">carbohydrate</span>  <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">sodium</span>        <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Builder</span><span class="hljs-params">(<span class="hljs-type">int</span> servingSize, <span class="hljs-type">int</span> servings)</span> &#123;<br>            <span class="hljs-built_in">this</span>.servingSize = servingSize;<br>            <span class="hljs-built_in">this</span>.servings    = servings;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">calories</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span><br>            &#123; calories = val;      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>; &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">fat</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span><br>            &#123; fat = val;           <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>; &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">carbohydrate</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span><br>            &#123; carbohydrate = val;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>; &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">sodium</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span><br>            &#123; sodium = val;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>; &#125;<br><br>        <span class="hljs-keyword">public</span> NutritionFacts <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NutritionFacts</span>(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">(Builder builder)</span> &#123;<br>        servingSize  = builder.servingSize;<br>        servings     = builder.servings;<br>        calories     = builder.calories;<br>        fat          = builder.fat;<br>        sodium       = builder.sodium;<br>        carbohydrate = builder.carbohydrate;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>以一个使用者的视角来看如何创建NutritionFacts对象，如下所示，流畅的写法，那些字段被设置以及具体的值都一目了然，最终build方法才会创建NutritionFacts对象，而且这是个不可变对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">NutritionFacts</span> <span class="hljs-variable">cocaCola</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NutritionFacts</span>.Builder(<span class="hljs-number">240</span>, <span class="hljs-number">8</span>)<br>                              .calories(<span class="hljs-number">100</span>)<br>                              .sodium(<span class="hljs-number">35</span>)<br>                              .carbohydrate(<span class="hljs-number">27</span>)<br>                              .build();<br><br></code></pre></td></tr></table></figure><h3 id="存在问题-2"><a href="#存在问题-2" class="headerlink" title="存在问题"></a>存在问题</h3><ol><li>即便能解决构造方法和静态工厂自身的一些问题，builder pattern也不是万能的，缺点很明显：创建对象之前，先要创建builder对象，这在一些性能要求高、资源限制苛刻的场景中就不适合了</li><li>另外builder pattern适合的场景是成员变量多的时候，而这个所谓的多究竟如何理解呢？这可能是个小马过河的问题吧：见惯了几十个成员变量的类，再去看十几个成员变量的类，可能会有种很清爽的感觉，呃，扯远了，其实《Effective Java》的说法是四个或者更多个参数，就适合用builder apttern了</li></ol><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><a href="https://xinchen.blog.csdn.net/article/details/125324863">java与es8实战之一：以builder pattern开篇</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JsonTypeInfo annotation usage</title>
    <link href="/2022/09/13/java/Using%20@JsonTypeInfo%20annotation%20to%20handle%20polymorphic%20types/"/>
    <url>/2022/09/13/java/Using%20@JsonTypeInfo%20annotation%20to%20handle%20polymorphic%20types/</url>
    
    <content type="html"><![CDATA[<p>In cases where polymorphic types are persisted to JSON, there’s no way for Jackson to figure out the right type during deserialization. Let’s understand that with an example.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> w;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> h;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>  <span class="hljs-type">int</span> radius;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">View</span> &#123;<br>  <span class="hljs-keyword">private</span> List&lt;Shape&gt; shapes;<br>&#125;<br></code></pre></td></tr></table></figure><p>Let’s serialize and then deserialize a View object:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleMain</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>      <span class="hljs-type">View</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>();<br>      v.setShapes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(List.of(Rectangle.of(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>), Circle.of(<span class="hljs-number">5</span>))));<br><br>      System.out.println(<span class="hljs-string">&quot;-- serializing --&quot;</span>);<br>      <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>      <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> om.writeValueAsString(v);<br>      System.out.println(s);<br><br>      System.out.println(<span class="hljs-string">&quot;-- deserializing --&quot;</span>);<br>      <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> om.readValue(s, View.class);<br>      System.out.println(view);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">--</span> <span class="hljs-string">serializing</span> <span class="hljs-string">--</span><br>&#123;<span class="hljs-string">&quot;shapes&quot;</span><span class="hljs-string">:</span>[&#123;<span class="hljs-string">&quot;w&quot;</span><span class="hljs-string">:3</span>,<span class="hljs-string">&quot;h&quot;</span><span class="hljs-string">:6</span>&#125;,&#123;<span class="hljs-string">&quot;radius&quot;</span><span class="hljs-string">:5</span>&#125;]&#125;<br><span class="hljs-string">--</span> <span class="hljs-string">deserializing</span> <span class="hljs-string">--</span><br><span class="hljs-string">Exception</span> <span class="hljs-string">in</span> <span class="hljs-string">thread</span> <span class="hljs-string">&quot;main&quot;</span> <span class="hljs-attr">com.fasterxml.jackson.databind.exc.InvalidDefinitionException:</span> <span class="hljs-string">Cannot</span> <span class="hljs-string">construct</span> <span class="hljs-string">instance</span> <span class="hljs-string">of</span> <span class="hljs-string">`com.logicbig.example.Shape`</span> <span class="hljs-string">(no</span> <span class="hljs-string">Creators,</span> <span class="hljs-string">like</span> <span class="hljs-string">default</span> <span class="hljs-string">construct,</span> <span class="hljs-string">exist):</span> <span class="hljs-string">abstract</span> <span class="hljs-string">types</span> <span class="hljs-string">either</span> <span class="hljs-string">need</span> <span class="hljs-string">to</span> <span class="hljs-string">be</span> <span class="hljs-string">mapped</span> <span class="hljs-string">to</span> <span class="hljs-string">concrete</span> <span class="hljs-string">types,</span> <span class="hljs-string">have</span> <span class="hljs-string">custom</span> <span class="hljs-string">deserializer,</span> <span class="hljs-string">or</span> <span class="hljs-string">contain</span> <span class="hljs-string">additional</span> <span class="hljs-string">type</span> <span class="hljs-string">information</span><br> <span class="hljs-string">at</span> [<span class="hljs-attr">Source:</span> <span class="hljs-string">(String)&quot;</span>&#123;<span class="hljs-string">&quot;shapes&quot;</span><span class="hljs-string">:</span>[&#123;<span class="hljs-string">&quot;w&quot;</span><span class="hljs-string">:3</span>,<span class="hljs-string">&quot;h&quot;</span><span class="hljs-string">:6</span>&#125;,&#123;<span class="hljs-string">&quot;radius&quot;</span><span class="hljs-string">:5</span>&#125;]&#125;<span class="hljs-string">&quot;; line: 1, column: 12] (through reference chain: com.logicbig.example.View[&quot;</span><span class="hljs-string">shapes&quot;</span>]<span class="hljs-string">-&gt;java.util.ArrayList[0])</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.fasterxml.jackson.databind.exc.InvalidDefinitionException.from(InvalidDefinitionException.java:67)</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.fasterxml.jackson.databind.DeserializationContext.reportBadDefinition(DeserializationContext.java:1451)</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.fasterxml.jackson.databind.DeserializationContext.handleMissingInstantiator(DeserializationContext.java:1027)</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.fasterxml.jackson.databind.deser.AbstractDeserializer.deserialize(AbstractDeserializer.java:265)</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:286)</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:245)</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:27)</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.fasterxml.jackson.databind.deser.impl.MethodProperty.deserializeAndSet(MethodProperty.java:127)</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:288)</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:151)</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4013)</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3004)</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.logicbig.example.ExampleMain.main(ExampleMain.java:18)</span><br></code></pre></td></tr></table></figure><h2 id="Using-JsonTypeInfo"><a href="#Using-JsonTypeInfo" class="headerlink" title="Using @JsonTypeInfo"></a>Using @JsonTypeInfo</h2><p>This annotation is used to serialize information about actual class of polymorphic instances, so that Jackson can know what subtype is to be deserialized. Let’s fix about exception by using this annotation:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = &quot;className&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>Above configuration specifies that the qualified class name should be used (use = JsonTypeInfo.Id.CLASS) and persist that as JSON property (include = JsonTypeInfo.As.PROPERTY). The property name should be ‘className’.<br>Let’s run our main method again:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">--</span> <span class="hljs-string">serializing</span> <span class="hljs-string">--</span><br>&#123;<span class="hljs-string">&quot;shapes&quot;</span><span class="hljs-string">:</span>[&#123;<span class="hljs-string">&quot;className&quot;</span><span class="hljs-string">:&quot;com.logicbig.example.Rectangle&quot;</span>,<span class="hljs-string">&quot;w&quot;</span><span class="hljs-string">:3</span>,<span class="hljs-string">&quot;h&quot;</span><span class="hljs-string">:6</span>&#125;,&#123;<span class="hljs-string">&quot;className&quot;</span><span class="hljs-string">:&quot;com.logicbig.example.Circle&quot;</span>,<span class="hljs-string">&quot;radius&quot;</span><span class="hljs-string">:5</span>&#125;]&#125;<br><span class="hljs-string">--</span> <span class="hljs-string">deserializing</span> <span class="hljs-string">--</span><br><span class="hljs-string">View&#123;shapes=[Rectangle&#123;w=3,</span> <span class="hljs-string">h=6&#125;,</span> <span class="hljs-string">Circle&#123;radius=5&#125;]&#125;</span><br></code></pre></td></tr></table></figure><p>In above configuration if we skip optional elements, ‘include’ and ‘property’, then defaults will be used. The default ‘include’ is also JsonTypeInfo.As.PROPERTY and default ‘property’ is @class. So our example will be:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>which will be serialized as:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml">&#123;<span class="hljs-string">&quot;shapes&quot;</span><span class="hljs-string">:</span>[&#123;<span class="hljs-string">&quot;@class&quot;</span><span class="hljs-string">:&quot;com.logicbig.example.Rectangle&quot;</span>,<span class="hljs-string">&quot;w&quot;</span><span class="hljs-string">:3</span>,<span class="hljs-string">&quot;h&quot;</span><span class="hljs-string">:6</span>&#125;,&#123;<span class="hljs-string">&quot;@class&quot;</span><span class="hljs-string">:&quot;com.logicbig.example.Circle&quot;</span>,<span class="hljs-string">&quot;radius&quot;</span><span class="hljs-string">:5</span>&#125;]&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Using-JsonTypeInfo-on-properties"><a href="#Using-JsonTypeInfo-on-properties" class="headerlink" title="Using @JsonTypeInfo on properties"></a>Using @JsonTypeInfo on properties</h2><p>@JsonTypeInfo annotation can be used both on classes (above example) and properties. In our example using the annotation on ‘shapes’ property:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = &quot;className&quot;)</span><br>    <span class="hljs-keyword">private</span> List&lt;Shape&gt; shapes;<br>    <br>&#125; <br></code></pre></td></tr></table></figure><p>If this annotation exists on both class and property, then the one on property has precedence, as it is considered more specific.</p><p>When used on properties (fields, methods), this annotation applies to values. That means when used on collection types (Collection, Map, arrays) it will apply to the elements, not the collection itself. For non-collection types there is no difference. In above snippet when we used it on ‘shapes’ list, it is applied on each element (Shape) of the List rather than List type itself.</p><h2 id="Using-JsonTypeInfo-Id-MINIMAL-CLASS"><a href="#Using-JsonTypeInfo-Id-MINIMAL-CLASS" class="headerlink" title="Using JsonTypeInfo.Id.MINIMAL_CLASS"></a>Using JsonTypeInfo.Id.MINIMAL_CLASS</h2><p>use = JsonTypeInfo.Id.MINIMAL_CLASS option will serialize minimal relative package path. Check out complete example <a href="https://www.logicbig.com/examples/jackson/jackson-json-type-info-annotation-with-minimal-class.html">here</a>.</p><h2 id="Using-ObjectMapper-enableDefaultTyping"><a href="#Using-ObjectMapper-enableDefaultTyping" class="headerlink" title="Using ObjectMapper.enableDefaultTyping()"></a>Using ObjectMapper.enableDefaultTyping()</h2><p>This method can be used to enable global automatic inclusion of type information in cases where polymorphic types are used.</p><p>Let’s use this method in our example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleMain2</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>      <span class="hljs-type">View</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>();<br>      v.setShapes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(List.of(Rectangle.of(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>), Circle.of(<span class="hljs-number">5</span>))));<br><br>      System.out.println(<span class="hljs-string">&quot;-- serializing --&quot;</span>);<br>      <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>      om.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE, JsonTypeInfo.As.PROPERTY);<br><br>      <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> om.writeValueAsString(v);<br>      System.out.println(s);<br><br>      System.out.println(<span class="hljs-string">&quot;-- deserializing --&quot;</span>);<br>      <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> om.readValue(s, View.class);<br>      System.out.println(view);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">--</span> <span class="hljs-string">serializing</span> <span class="hljs-string">--</span><br>&#123;<span class="hljs-string">&quot;shapes&quot;</span><span class="hljs-string">:</span>[<span class="hljs-string">&quot;java.util.ArrayList&quot;</span>,[&#123;<span class="hljs-string">&quot;@class&quot;</span><span class="hljs-string">:&quot;com.logicbig.example.Rectangle&quot;</span>,<span class="hljs-string">&quot;w&quot;</span><span class="hljs-string">:3</span>,<span class="hljs-string">&quot;h&quot;</span><span class="hljs-string">:6</span>&#125;,&#123;<span class="hljs-string">&quot;@class&quot;</span><span class="hljs-string">:&quot;com.logicbig.example.Circle&quot;</span>,<span class="hljs-string">&quot;radius&quot;</span><span class="hljs-string">:5</span>&#125;]]&#125;<br><span class="hljs-string">--</span> <span class="hljs-string">deserializing</span> <span class="hljs-string">--</span><br><span class="hljs-string">View&#123;shapes=[Rectangle&#123;w=3,</span> <span class="hljs-string">h=6&#125;,</span> <span class="hljs-string">Circle&#123;radius=5&#125;]&#125;</span><br></code></pre></td></tr></table></figure><p>In above example DefaultTyping.OBJECT_AND_NON_CONCRETE specifies that default typing will be used for properties with declared type of java.lang.Object or an abstract type (abstract class or interface, Shape in our example).</p><p>Note that in above output the actual type of List<Shape> is also persisted as ArrayList. That’s because List is also a non-concrete type.</p><h2 id="Example-Project"><a href="#Example-Project" class="headerlink" title="Example Project"></a>Example Project</h2><p>Dependencies and Technologies Used:</p><ul><li>ackson-databind 2.9.6: General data-binding functionality for Jackson: works on core streaming API.</li><li>JDK 10 </li><li>Maven 3.3.9</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.logicbig.com/tutorials/misc/jackson/jackson-json-type-info-annotation.html">Jackson JSON - Using @JsonTypeInfo annotation to handle polymorphic types</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>Jackson</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java ThreadLocal</title>
    <link href="/2022/09/13/java/threadlocal/"/>
    <url>/2022/09/13/java/threadlocal/</url>
    
    <content type="html"><![CDATA[<p>The <em>Java</em> <em>ThreadLocal</em> class enables you to create variables that can only be read and written by the same thread. Thus, even if two threads are executing the same code, and the code has a reference to the same <code>ThreadLocal</code> variable, the two threads cannot see each other’s <code>ThreadLocal</code> variables. Thus, the Java ThreadLocal class provides a simple way to make code <a href="http://tutorials.jenkov.com/java-concurrency/thread-safety.html">thread safe</a> that would not otherwise be so.</p><h2 id="Java-ThreadLocal-Tutorial-Video"><a href="#Java-ThreadLocal-Tutorial-Video" class="headerlink" title="Java ThreadLocal Tutorial Video"></a>Java ThreadLocal Tutorial Video</h2><p>If you prefer video, I have a video version of this Java ThreadLocal tutorial here:<br><a href="https://www.youtube.com/watch?v=a_BoqsnVR2U&list=PLL8woMHwr36EDxjUoCzboZjedsnhLP1j4&index=9" title="Java ThreadLocal Tutorial Video">Java ThreadLocal Tutorial</a></p><h2 id="Creating-a-ThreadLocal"><a href="#Creating-a-ThreadLocal" class="headerlink" title="Creating a ThreadLocal"></a>Creating a ThreadLocal</h2><p>You create a <code>ThreadLocal</code> instance just like you create any other Java object - via the <code>new</code> operator. Here is an example that shows how to create a <code>ThreadLocal</code> variable:</p><p>private ThreadLocal threadLocal = new ThreadLocal();</p><p>This only needs to be done once per thread. Multiple threads can now get and set values inside this <code>ThreadLocal</code>, and each thread will only see the value it set itself.</p><h2 id="Set-ThreadLocal-Value"><a href="#Set-ThreadLocal-Value" class="headerlink" title="Set ThreadLocal Value"></a>Set ThreadLocal Value</h2><p>Once a <code>ThreadLocal</code> has been created you can set the value to be stored in it using its <code>set()</code> method.</p><p>threadLocal.set(“A thread local value”);</p><h2 id="Get-ThreadLocal-Value"><a href="#Get-ThreadLocal-Value" class="headerlink" title="Get ThreadLocal Value"></a>Get ThreadLocal Value</h2><p>You read the value stored in a <code>ThreadLocal</code> using its <code>get()</code> method. Here is an example obtaining the value stored inside a Java <code>ThreadLocal</code>:</p><p>String threadLocalValue = (String) threadLocal.get();</p><h2 id="Remove-ThreadLocal-Value"><a href="#Remove-ThreadLocal-Value" class="headerlink" title="Remove ThreadLocal Value"></a>Remove ThreadLocal Value</h2><p>It is possible to remove a value set in a ThreadLocal variable. You remove a value by calling the <code>ThreadLocal</code> <code>remove()</code> method. Here is an example of removing the value set on a Java <code>ThreadLocal</code>:</p><p>threadLocal.remove();</p><h2 id="Generic-ThreadLocal"><a href="#Generic-ThreadLocal" class="headerlink" title="Generic ThreadLocal"></a>Generic ThreadLocal</h2><p>You can create a <code>ThreadLocal</code> with a generic type. Using a generic type only objects of the generic type can be set as value on the <code>ThreadLocal</code>. Additionally, you do not have to typecast the value returned by <code>get()</code>. Here is a generic <code>ThreadLocal</code> example:</p><p>private ThreadLocal<String> myThreadLocal = new ThreadLocal<String>();</p><p>Now you can only store strings in the <code>ThreadLocal</code> instance. Additionally, you do not need to typecast the value obtained from the <code>ThreadLocal</code>:</p><p>myThreadLocal.set(“Hello ThreadLocal”);</p><p>String threadLocalValue = myThreadLocal.get();</p><h2 id="Initial-ThreadLocal-Value"><a href="#Initial-ThreadLocal-Value" class="headerlink" title="Initial ThreadLocal Value"></a>Initial ThreadLocal Value</h2><p>It is possible to set an initial value for a Java <code>ThreadLocal</code> which will get used the first time <code>get()</code> is called - before <code>set()</code> has been called with a new value. You have two options for specifying an initial value for a ThreadLocal:</p><ul><li>  Create a ThreadLocal subclass that overrides the <code>initialValue()</code> method.</li><li>  Create a ThreadLocal with a <code>Supplier</code> interface implementation.</li></ul><p>I will show you both options in the following sections.</p><h3 id="Override-initialValue"><a href="#Override-initialValue" class="headerlink" title="Override initialValue()"></a>Override initialValue()</h3><p>The first way to specify an initial value for a Java <code>ThreadLocal</code> variable is to create a subclass of <code>ThreadLocal</code> which overrides its <code>initialValue()</code> method. The easiest way to create a subclass of <code>ThreadLocal</code> is to simply create an anonymous subclass, right where you create the <code>ThreadLocal</code> variable. Here is an example of creating an anonymous subclass of <code>ThreadLocal</code> which overrides the <code>initialValue()</code> method:</p><p>private ThreadLocal myThreadLocal = new ThreadLocal<String>() {<br>    @Override protected String initialValue() {<br>        return String.valueOf(System.currentTimeMillis());<br>    }<br>};    </p><p>Note, that different threads will still see different initial values. Each thread will create its own initial value. Only if you return the exact same object from the <code>initialValue()</code> method, will all threads see the same object. However, the whole point of using a <code>ThreadLocal</code> in the first place is to avoid the different threads seeing the same instance.</p><h3 id="Provide-a-Supplier-Implementation"><a href="#Provide-a-Supplier-Implementation" class="headerlink" title="Provide a Supplier Implementation"></a>Provide a Supplier Implementation</h3><p>The second method for specifying an initial value for a Java <code>ThreadLocal</code> variable is to use its static factory method <code>withInitial(Supplier)</code> passing a <code>Supplier</code> interface implementation as parameter. This <code>Supplier</code> implementation supplies the initial value for the <code>ThreadLocal</code>. Here is an example of creating a <code>ThreadLocal</code> using its <code>withInitial()</code> static factory method, passing a simple <code>Supplier</code> implementation as parameter:</p><p>ThreadLocal<String> threadLocal = ThreadLocal.withInitial(new Supplier<String>() {<br>    @Override<br>    public String get() {<br>        return String.valueOf(System.currentTimeMillis());<br>    }<br>});</p><p>Since <code>Supplier</code> is a <a href="http://tutorials.jenkov.com/java-functional-programming/functional-interfaces.html">functional interface</a>, it an be implemented using a <a href="http://tutorials.jenkov.com/java/lambda-expressions.html">Java Lambda Expression</a>. Here is how providing a <code>Supplier</code> implementation as a lambda expression to <code>withInitial()</code> looks:</p><p>ThreadLocal threadLocal = ThreadLocal.withInitial(<br>        () -&gt; { return String.valueOf(System.currentTimeMillis()); } );</p><p>As you can see, this is somewhat shorter than the previous example. But it can be made even a bit shorter yet, using the most dense syntax of lambda expressions:</p><p>ThreadLocal threadLocal3 = ThreadLocal.withInitial(<br>        () -&gt; String.valueOf(System.currentTimeMillis()) );</p><h2 id="Lazy-Setting-of-ThreadLocal-Value"><a href="#Lazy-Setting-of-ThreadLocal-Value" class="headerlink" title="Lazy Setting of ThreadLocal Value"></a>Lazy Setting of ThreadLocal Value</h2><p>In some situations you cannot use the standard ways of setting an initial value. For instance, perhaps you need some configuration information which is not available at the time you create the ThreadLocal variable. In that case you can set the initial value lazily. Here is an example of how setting an initial value lazily on a Java ThreadLocal:</p><p>public class MyDateFormatter {</p><pre><code class="hljs">private ThreadLocal&lt;SimpleDateFormat&gt; simpleDateFormatThreadLocal = new ThreadLocal&lt;&gt;();public String format(Date date) &#123;    SimpleDateFormat simpleDateFormat = getThreadLocalSimpleDateFormat();    return simpleDateFormat.format(date);&#125;</code></pre><p>​<br>​    private SimpleDateFormat getThreadLocalSimpleDateFormat() {<br>​        SimpleDateFormat simpleDateFormat = simpleDateFormatThreadLocal.get();<br>​        if(simpleDateFormat == null) {<br>​            simpleDateFormat = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);<br>​            simpleDateFormatThreadLocal.set(simpleDateFormat);<br>​        }<br>​        return simpleDateFormat;<br>​    }<br>}</p><p>Notice how the <code>format()</code> method calls the <code>getThreadLocalSimpleDateFormat()</code> method to obtain a <a href="http://tutorials.jenkov.com/java-internationalization/simpledateformat.html">Java SimpleDatFormat</a> instance. If a <code>SimpleDateFormat</code> instance has not been set in the <code>ThreadLocal</code>, a new <code>SimpleDateFormat</code> is created and set in the <code>ThreadLocal</code> variable. Once a thread has set its own <code>SimpleDateFormat</code> in the <code>ThreadLocal</code> variable, the same <code>SimpleDateFormat</code> object is used for that thread going forward. But only for that thread. Each thread creates its own <code>SimpleDateFormat</code> instance, as they cannot see each others instances set on the <code>ThreadLocal</code> variable.</p><p>The <code>SimpleDateFormat</code> class is not thread safe, so multiple threads cannot use it at the same time. To solve this problem, the <code>MyDateFormatter</code> class above creates a <code>SimpleDateFormat</code> per thread, so each thread calling the <code>format()</code> method will use its own <code>SimpleDateFormat</code> instance.</p><h2 id="Using-a-ThreadLocal-with-a-Thread-Pool-or-ExecutorService"><a href="#Using-a-ThreadLocal-with-a-Thread-Pool-or-ExecutorService" class="headerlink" title="Using a ThreadLocal with a Thread Pool or ExecutorService"></a>Using a ThreadLocal with a Thread Pool or ExecutorService</h2><p>If you plan to use a Java <code>ThreadLocal</code> from inside a task passed to a <a href="http://tutorials.jenkov.com/java-concurrency/thread-pools.html">Java Thread Pool</a> or a <a href="http://tutorials.jenkov.com/java-util-concurrent/executorservice.html">Java ExecutorService</a>, keep in mind that you do not have any guarantees which thread will execute your task. However, if all you need is to make sure that each thread uses its own instance of some object, this is not a problem. Then you can use a Java ThreadLocal with a thread pool or <code>ExecutorService</code> just fine.</p><h2 id="Full-ThreadLocal-Example"><a href="#Full-ThreadLocal-Example" class="headerlink" title="Full ThreadLocal Example"></a>Full ThreadLocal Example</h2><p>Here is a fully runnable Java <code>ThreadLocal</code> example:</p><p>public class ThreadLocalExample {</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String\[\] args)</span> &#123;<br>    <span class="hljs-type">MyRunnable</span> <span class="hljs-variable">sharedRunnableInstance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(sharedRunnableInstance);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(sharedRunnableInstance);<br><br>    thread1.start();<br>    thread2.start();<br><br>    thread1.join(); <span class="hljs-comment">//wait for thread 1 to terminate</span><br>    thread2.join(); <span class="hljs-comment">//wait for thread 2 to terminate</span><br>&#125;<br></code></pre></td></tr></table></figure><p>}</p><p>public class MyRunnable implements Runnable {</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Integer&gt;();<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    threadLocal.set( (<span class="hljs-type">int</span>) (Math.random() \* <span class="hljs-number">100D</span>) );<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    &#125;<br><br>    System.out.println(threadLocal.get());<br>&#125;<br></code></pre></td></tr></table></figure><p>}</p><p>This example creates a single <code>MyRunnable</code> instance which is passed to two different threads. Both threads execute the <code>run()</code> method, and thus sets different values on the <code>ThreadLocal</code> instance. If the access to the <code>set()</code> call had been synchronized, and it had <em>not</em> been a <code>ThreadLocal</code> object, the second thread would have overridden the value set by the first thread.</p><p>However, since it <em>is</em> a <code>ThreadLocal</code> object then the two threads cannot see each other’s values. Thus, they set and get different values.</p><h2 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h2><p>The <code>InheritableThreadLocal</code> class is a subclass of <code>ThreadLocal</code>. Instead of each thread having its own value inside a <code>ThreadLocal</code>, the <code>InheritableThreadLocal</code> grants access to values to a thread and all child threads created by that thread. Here is a full Java <code>InheritableThreadLocal</code> example:</p><p>public class InheritableThreadLocalBasicExample {</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String\[\] args)</span> &#123;<br><br>    ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>    InheritableThreadLocal&lt;String&gt; inheritableThreadLocal =<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;===== Thread 1 =====&quot;</span>);<br>        threadLocal.set(<span class="hljs-string">&quot;Thread 1 - ThreadLocal&quot;</span>);<br>        inheritableThreadLocal.set(<span class="hljs-string">&quot;Thread 1 - InheritableThreadLocal&quot;</span>);<br><br>        System.out.println(threadLocal.get());<br>        System.out.println(inheritableThreadLocal.get());<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">childThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>( () -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;===== ChildThread =====&quot;</span>);<br>            System.out.println(threadLocal.get());<br>            System.out.println(inheritableThreadLocal.get());<br>        &#125;);<br>        childThread.start();<br>    &#125;);<br><br>    thread1.start();<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;===== Thread2 =====&quot;</span>);<br>        System.out.println(threadLocal.get());<br>        System.out.println(inheritableThreadLocal.get());<br>    &#125;);<br>    thread2.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>}</p><p>This example creates a normal Java ThreadLocal and a Java InheritableThreadLocal. Then the example creates one thread which sets the value of the ThreadLocal and InheritableThreadLocal - and then creates a child thread which accesses the values of the ThreadLocal and InheritableThreadLocal. Only the value of the InheritableThreadLocal is visible to the child thread.</p><p>Finally the example creates a third thread which also tries to access both the ThreadLocal and InheritableThreadLocal - but which does not see any of the values stored by the first thread.</p><p>The output printed from running this example would look like this:</p><p>===== Thread 1 =====<br>Thread 1 - ThreadLocal<br>Thread 1 - InheritableThreadLocal<br>===== ChildThread =====<br>null<br>Thread 1 - InheritableThreadLocal<br>===== Thread2 =====<br>null<br>null</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://jenkov.com/tutorials/java-concurrency/threadlocal.html">Java ThreadLocal</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>ThreadLocal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程之LockSupport</title>
    <link href="/2022/09/13/java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BLockSupport/"/>
    <url>/2022/09/13/java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BLockSupport/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>LockSupport是一个工具类，提供了基本的线程阻塞和唤醒功能</strong>，它是创建锁和其他同步组件的基础工具，内部是使用sun.misc.Unsafe类实现的。</p><p>LockSupport和使用它的线程都会关联一个许可，park方法表示消耗一个许可，调用park方法时，如果许可可用则park方法返回，如果没有许可则一直阻塞直到许可可用。unpark方法表示增加一个许可，多次调用并不会积累许可，因为许可数最大值为1。</p><h2 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h2><p><strong>park()：</strong> 阻塞当前线程，直到unpark方法被调用或当前线程被中断，park方法才会返回。</p><p><strong>park(Object blocker)：</strong> 同park()方法，多了一个阻塞对象blocker参数。</p><p><strong>parkNanos(long nanos)：</strong> 同park方法，nanos表示最长阻塞超时时间，超时后park方法将自动返回。</p><p><strong>parkNanos(Object blocker, long nanos)：</strong> 同parkNanos(long nanos)方法，多了一个阻塞对象blocker参数。</p><p><strong>parkUntil(long deadline)：</strong> 同park()方法，deadline参数表示最长阻塞到某一个时间点，当到达这个时间点，park方法将自动返回。（该时间为从1970年到现在某一个时间点的毫秒数）</p><p><strong>parkUntil(Object blocker, long deadline)：</strong> 同parkUntil(long deadline)方法，多了一个阻塞对象blocker参数。</p><p><strong>unpark(Thread thread)：</strong> 唤醒处于阻塞状态的线程thread。</p><h2 id="阻塞和唤醒实例"><a href="#阻塞和唤醒实例" class="headerlink" title="阻塞和唤醒实例"></a>阻塞和唤醒实例</h2><p>子线程执行LockSupport.park()，由于没有许可，进入阻塞状态。主线程3秒后调用unpark方法给子线程增加了一个许可，park方法返回，子线程被唤醒继续执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;do something start&quot;</span>);<br>            LockSupport.park();<br>            System.out.println(<span class="hljs-string">&quot;do something end&quot;</span>);<br>        &#125;);<br><br>        thread.start();<br>        Thread.sleep(<span class="hljs-number">3000</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;给子线程thread增加一个许可&quot;</span>);<br>        LockSupport.unpark(thread);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 输出结果：</span><br><span class="hljs-comment"> * do something start</span><br><span class="hljs-comment"> * 给子线程thread增加一个许可</span><br><span class="hljs-comment"> * do something end</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>先unpark增加许可，后park消费许可也是可以的。unpark会给thread增加一个许可，此时调用park方法，由于许可是可用的，所以park方法直接返回了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;do something start&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;子线程thread给自己增加一个许可&quot;</span>);<br>            LockSupport.unpark(Thread.currentThread());<br>            LockSupport.park();<br>            System.out.println(<span class="hljs-string">&quot;do something end&quot;</span>);<br>        &#125;);<br><br>        thread.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 输出结果：</span><br><span class="hljs-comment"> * do something start</span><br><span class="hljs-comment"> * 子线程thread给自己增加一个许可</span><br><span class="hljs-comment"> * do something end</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>连续调用unpark不会累计许可，许可最大值为1，第一次park就已经消耗了许可，所以第二次park一直阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;do something start&quot;</span>);<br><br>            LockSupport.unpark(Thread.currentThread());<br>            System.out.println(<span class="hljs-string">&quot;unpark 1&quot;</span>);<br>            LockSupport.unpark(Thread.currentThread());<br>            System.out.println(<span class="hljs-string">&quot;unpark 2&quot;</span>);<br><br>            LockSupport.park();<br>            System.out.println(<span class="hljs-string">&quot;park 1&quot;</span>);<br>            LockSupport.park();<br>            System.out.println(<span class="hljs-string">&quot;park 2&quot;</span>);<br><br>            System.out.println(<span class="hljs-string">&quot;do something end&quot;</span>);<br>        &#125;);<br><br>        thread.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 输出结果：</span><br><span class="hljs-comment"> * do something start</span><br><span class="hljs-comment"> * unpark 1</span><br><span class="hljs-comment"> * unpark 2</span><br><span class="hljs-comment"> * park 1</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="阻塞对象blocker的作用"><a href="#阻塞对象blocker的作用" class="headerlink" title="阻塞对象blocker的作用"></a>阻塞对象blocker的作用</h2><p>通过前面方法介绍可以看到，park、parkNanos、parkUntil方法都有对应的带阻塞对象blocker参数的重载方法。Thread类有一个变量为parkBlocker，对应的就是LockSupport的park等方法设置进去的阻塞对象。</p><p><strong>该参数主要用于问题排查和系统监控，在线程dump中会显示该参数的信息，有利于问题定位。</strong></p><p>分别调用park()和park(Object blocker)，然后使用jstack查看线程堆栈信息，对比发现后者会多输出一条阻塞对象的信息：</p><p>park():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        LockSupport.park();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="1.png"></p><p>park(Object blocker):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        LockSupport.park(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="2.png"></p><h2 id="和显式锁、隐式锁等待唤醒的区别"><a href="#和显式锁、隐式锁等待唤醒的区别" class="headerlink" title="和显式锁、隐式锁等待唤醒的区别"></a>和显式锁、隐式锁等待唤醒的区别</h2><ol><li> park和unpark方法的调用不需要获取锁。</li><li> 先调用unpark方法后调用park方法依然可以唤醒。</li><li> park方法响应中断，线程被中断后park方法直接返回，但是不会InterruptedException异常。</li><li> unpark方法是直接唤醒指定的线程。</li></ol><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.cnblogs.com/seve/p/14555740.html">Java并发编程之LockSupport</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程之Condition</title>
    <link href="/2022/09/13/java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCondition/"/>
    <url>/2022/09/13/java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCondition/</url>
    
    <content type="html"><![CDATA[<p>Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作</p><p>相比使用Object的wait()、notify()，使用Condition的await()、signal()这种方式实现线程间协作更加安全和高效。</p><p>因此通常来说，线程通信的实现比较推荐使用Condition</p><ul><li>  Condition是个接口，基本的方法就是await()和signal()方法；</li><li>  Condition依赖于Lock接口，生成一个Condition的基本代码是<strong>lock.newCondition()</strong></li><li>  <strong>调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用，因为内部会做释放锁的操作，如果不是在lock和unlock之间使用，会报错<code>java.lang.IllegalMonitorStateException</code></strong></li></ul><p><strong>Conditon中的await()对应Object的wait()；</strong></p><p><strong>Condition中的signal()对应Object的notify()；</strong></p><p><strong>Condition中的signalAll()对应Object的notifyAll()。</strong></p><h2 id="简单demo"><a href="#简单demo" class="headerlink" title="简单demo"></a>简单demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionTest</span> &#123;<br><br>    <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">conditionTest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>::conditionWait).start();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>::conditionSignal).start();<br><br>    &#125;<br><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">conditionWait</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            condition.await();<br>            System.out.println(<span class="hljs-string">&quot;awaiting&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">conditionSignal</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            condition.signal();<br>            System.out.println(<span class="hljs-string">&quot;signal&quot;</span>);<br><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一般都会将Condition对象作为成员变量。当调用await()方法后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的signal()方法，通知当前线程后，当前线程才从await()方法返回，并且在返回前已经获取了锁。</p><h2 id="深入理解demo"><a href="#深入理解demo" class="headerlink" title="深入理解demo"></a>深入理解demo</h2><p>获取一个Condition必须通过Lock的newCondition()方法。下面通过一个有界队列的示例来深入了解Condition的使用方式。</p><p>有界队列是一种特殊的队列，当队列为空时，队列的获取操作将会阻塞获取线程，直到队列中有新增元素，当队列已满时，队列的插入操作将会阻塞插入线程，直到队列出现“空位”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionTest</span> &#123;<br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">boundedQueueTest</span><span class="hljs-params">()</span> &#123;<br><br>        BoundedQueue&lt;Integer&gt; boundedQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BoundedQueue</span>&lt;&gt;(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>                boundedQueue.add(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>                boundedQueue.remove();<br>            &#125;<br>        &#125;).start();<br><br>        Thread.currentThread().join();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BoundedQueue</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object[] items;<br><br>    <span class="hljs-comment">// 添加的下标，删除的下标和数组当前数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> addIndex, removeIndex, count;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BoundedQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> &#123;<br>        items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[size];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加一个元素，如果数组满，则添加线程进入等待状态，直到有&quot;空位&quot;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T t)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (count == items.length) &#123;<br>                System.out.println(<span class="hljs-string">&quot;items is full&quot;</span>);<br>                notFull.await();<br>            &#125;<br>            items[addIndex] = t;<br>            <span class="hljs-keyword">if</span> (++addIndex == items.length)<br>                addIndex = <span class="hljs-number">0</span>;<br>            ++count;<br>            notEmpty.signal();<br>            System.out.println(<span class="hljs-string">&quot;add success&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 由头部删除一个元素，如果数组空，则删除线程进入等待状态，直到有新添加元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>                System.out.println(<span class="hljs-string">&quot;items length is 0&quot;</span>);<br>            notEmpty.await();<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> items[removeIndex];<br>            <span class="hljs-keyword">if</span> (++removeIndex == items.length)<br>                removeIndex = <span class="hljs-number">0</span>;<br>            --count;<br>            notFull.signal();<br>            System.out.println(<span class="hljs-string">&quot;remove success&quot;</span>);<br>            <span class="hljs-keyword">return</span> (T) x;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先需要获得锁，目的是确保数组修改的可见性和排他性。当数组数量等于数组长度时，表示数组已满，则调用notFull.await()，当前线程随之释放锁并进入等待状态。如果数组数量不等于数组长度，表示数组未满，则添加元素到数组中，同时通知等待在notEmpty上的线程，数组中已经有新元素可以获取。在添加和删除方法中使用while循环而非if判断，目的是防止过早或意外的通知，只有条件符合才能够退出循环。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h3><p>等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态一个Condition包含一个等待队列，Condition拥有首节点（firstWaiter）和尾节点（lastWaiter）。当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列，等待队列的基本结构如下图所示</p><p><img src="await_queue.png"></p><p>如图所示，Condition拥有首尾节点的引用，而新增节点只需要将原有的尾节点nextWaiter指向它，并且更新尾节点即可。上述节点引用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。在Object的监视器模型上，一个对象拥有一个同步队列和等待队列，而并发包中的Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列，其对应关系如下图所示</p><p><img src="1.png"></p><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p>调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中</p><pre><code class="hljs">public final void await() throws InterruptedException &#123;        if (Thread.interrupted())            throw new InterruptedException();        // 当前线程加入等待队列        Node node = addConditionWaiter();        // 释放同步状态，也就是释放锁        int savedState = fullyRelease(node);        int interruptMode = 0;        while (!isOnSyncQueue(node)) &#123;            LockSupport.park(this);            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)                break;        &#125;        if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)            interruptMode = REINTERRUPT;        if (node.nextWaiter != null)            unlinkCancelledWaiters();        if (interruptMode != 0)            reportInterruptAfterWait(interruptMode);    &#125;</code></pre><p>调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。当等待队列中的节点被唤醒，则唤醒节点的线程开始尝试获取同步状态。如果不是通过其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException</p><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>调用Condition的signal()方法，将会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到同步队列中</p><p><img src="2.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br>        <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>            doSignal(first);<br>    &#125;<br></code></pre></td></tr></table></figure><p>调用该方法的前置条件是当前线程必须获取了锁，可以看到signal()方法进行了isHeldExclusively()检查，也就是当前线程必须是获取了锁的线程。接着获取等待队列的首节点，将其移动到同步队列并使用LockSupport唤醒节点中的线程节点从等待队列移动到同步队列的过程如下图所示</p><p><img src="3.png"></p><p>通过调用同步器的enq(Node node)方法，等待队列中的头节点线程安全地移动到同步队列。当节点移动到同步队列后，当前线程再使用LockSupport唤醒该节点的线程。被唤醒后的线程，将从await()方法中的while循环中退出（isOnSyncQueue(Node node)方法返回true，节点已经在同步队列中），进而调用同步器的acquireQueued()方法加入到获取同步状态的竞争中。成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。</p><p>Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法（<strong>注意是这个Condition对应的等待队列</strong>），效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://segmentfault.com/a/1190000039075214">Java中的condition类</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java新特性教程</title>
    <link href="/2022/09/13/java/Java%20%E6%96%B0%E7%89%B9%E6%80%A7%E6%95%99%E7%A8%8B/"/>
    <url>/2022/09/13/java/Java%20%E6%96%B0%E7%89%B9%E6%80%A7%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li><a href="https://www.wdbyte.com/java-feature/">Java 新特性教程</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中field和property的区别</title>
    <link href="/2022/09/13/java/Java%E4%B8%ADfield%E5%92%8Cproperty%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/09/13/java/Java%E4%B8%ADfield%E5%92%8Cproperty%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>field和property中文的翻译差不多，实际上是两个不同的概念。</p><blockquote><p>field: A data member of a class. Unless specified otherwise, a field is not static.</p><p>property: Characteristics of an object that users can set, such as the color of a window.</p><p>摘自：<a href="https://docs.oracle.com/javase/tutorial/information/glossary.html#P">Glossary of Terms</a></p></blockquote><p>我的理解是，field指那些在类的内部，未通过getter/setter访问的成员变量。而property指的是通过getter/setter访问的成员变量</p><p><img src="img.png"></p><p>如上图所示我们新建一个Demo类，在没有设置getter/setter方法时，filed1,filed2,filed3,filed4都是field，然后我给property1和property2添加getter/setter方法后，getProperty1(), setProperty1()和property1就变成了一个property。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://xinxingastro.github.io/2018/07/21/Java/Java%E4%B8%ADfield%E5%92%8Cproperty%E7%9A%84%E5%8C%BA%E5%88%AB/">Java中field和property的区别</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java TreeMap vs HashMap</title>
    <link href="/2022/09/13/java/Java%20TreeMap%20vs%20HashMap/"/>
    <url>/2022/09/13/java/Java%20TreeMap%20vs%20HashMap/</url>
    
    <content type="html"><![CDATA[<p>In this tutorial, we are going to focus on the core <strong>differences between the <em>TreeMap</em> and the <em>HashMap</em>.</strong></p><p><em>TreeMap</em> and <em>HashMap</em> are quite similar, both are collections that implement the <em>Map</em> interface. But they also have some differences that make one better than the other in some situations. Let’s look at those differences.</p><p>Table Of Contents</p><ol><li><a href="#1-Differences-between-HashMap-and-TreeMap">1. Differences between HashMap and TreeMap</a><ul><li>  <a href="#1-1-Class-Hierarchy">1.1. Class Hierarchy</a></li><li>  <a href="#1-2-Internal-Implementations">1.2. Internal Implementations</a></li><li>  <a href="#1-3-Null-Keys-and-Values">1.3. Null Keys and Values</a></li><li>  <a href="#1-4-Functionality">1.4. Functionality</a></li><li>  <a href="#1-5-Element-Ordering">1.5. Element Ordering</a></li><li>  <a href="#1-6-Performance-Comparison">1.6. Performance Comparison</a></li><li>  <a href="#1-7-Memory-Usage">1.7. Memory Usage</a></li><li>  <a href="#1-8-Key-Searches">1.8. Key Searches</a></li></ul></li><li> <a href="#2-When-to-use-HashMap-and-TreeMap">2. When to use HashMap and TreeMap</a></li><li> <a href="#3-Conclusion">3. Conclusion</a></li><li> <a href="#4-References">4. References</a></li></ol><h2 id="1-Differences-between-HashMap-and-TreeMap"><a href="#1-Differences-between-HashMap-and-TreeMap" class="headerlink" title="1.Differences between HashMap and TreeMap"></a>1.Differences between HashMap and TreeMap</h2><p>Let’s discuss some of the main differences between the two maps.</p><h3 id="1-1-Class-Hierarchy"><a href="#1-1-Class-Hierarchy" class="headerlink" title="1.1. Class Hierarchy"></a>1.1. Class Hierarchy</h3><p><em><a href="https://howtodoinjava.com/java-hashmap/">HashMap</a></em> class extends <em>AbstractMap</em> class and <strong>implements <em>Map</em> interface</strong> whereas <em><a href="https://howtodoinjava.com/java/collections/treemap-class/">TreeMap</a></em> class extends <em>AbstractMap</em> class and <strong>implements</strong> _<strong>NavigableMap</strong>_ <strong>interface</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// HashMap class declaration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span>&lt;K, V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K, V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K, V&gt;, Cloneable, Serializable<br><br><span class="hljs-comment">// TreeMap class declaration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeMap</span>&lt;K, V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K, V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NavigableMap</span>&lt;K, V&gt;, Cloneable, Serializable<br></code></pre></td></tr></table></figure><p><img src="img.png"></p><p><img src="img_1.png"></p><h3 id="1-2-Internal-Implementations"><a href="#1-2-Internal-Implementations" class="headerlink" title="1.2. Internal Implementations"></a>1.2. Internal Implementations</h3><ul><li>  <em>HashMap</em> internally uses <em><a href="https://howtodoinjava.com/java/collections/hashtable-class/">HashTable</a></em> and works on the principle of <strong>Hashing</strong>. It contains the buckets in the form of a <em><a href="https://howtodoinjava.com/java/collections/java-linkedlist-class/">LinkedList</a>,</em> and when there are more than 8 entries in the bucket, then the <em>LinkedList</em> transforms into a <em>Balanced Tree</em> (TreeNodes).</li><li>  <em>TreeMap</em> internally uses <strong><em>Red-Black Tree</em>,</strong> a self-balancing <em>Binary Search Tree.</em></li></ul><h3 id="1-3-Null-Keys-and-Values"><a href="#1-3-Null-Keys-and-Values" class="headerlink" title="1.3. Null Keys and Values"></a>1.3. Null Keys and Values</h3><p><strong><em>TreeMap</em> doesn’t allow a <em>null</em> key</strong> but may contain any number of <em>null</em> values<code>.</code></p><p><strong><em>HashMap</em></strong> <strong>allows one null key</strong> (for other <em>null</em> keys, the existing value will simply be overwritten with a new value) and any number of <em>null</em> values.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Putting null key in TreeMap</span><br>TreeMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br><br>map.put(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;value&quot;</span>);    <span class="hljs-comment">//Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br></code></pre></td></tr></table></figure><p><em>TreeMap</em> internally uses <code>compareTo</code>() or <code>compare</code>() method from <em><a href="https://howtodoinjava.com/java/collections/java-comparable-interface/">Comparable</a></em> &amp; <em><a href="https://howtodoinjava.com/java/collections/java-comparator/">Comparator</a></em> Interfaces respectively to maintain the order of elements in the map based on the keys and in case of <em>null</em> key, these method throws <strong>‘</strong><em><a href="https://howtodoinjava.com/java/exception-handling/how-to-effectively-handle-nullpointerexception-in-java/">NullPointerException</a></em><strong>‘.</strong></p><h3 id="1-4-Functionality"><a href="#1-4-Functionality" class="headerlink" title="1.4. Functionality"></a>1.4. Functionality</h3><p><strong><em>TreeMap</em> is richer in functionality as compared with <em>HashMap</em>.</strong> Along with the normal methods <code>(get(), put(), remove())</code> of <em>Map</em> Interface, it contains methods from <em>NavigableMap</em> interface as well like <code>pollFirstEntry(), pollLastEntry(), tailMap(), firstKey(), lastKey()</code>, etc. which the <em>HashMap</em> class doesn’t have.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Creating TreeMap</span><br>TreeMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br><br><span class="hljs-comment">// Putting values in TreeMap</span><br>map.put(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>map.put(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>map.put(<span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-string">&quot;value3&quot;</span>);<br><br><span class="hljs-comment">// Printing map</span><br>System.out.println(map);                       <span class="hljs-comment">// Prints &#123;key1=value1, key2=value2, key3=value3&#125;</span><br><br><span class="hljs-comment">// Getting first key from map</span><br>System.out.println(map.firstKey());              <span class="hljs-comment">// Prints key1</span><br><span class="hljs-comment">// Getting last key from map</span><br>System.out.println(map.lastKey());             <span class="hljs-comment">// Prints key3</span><br><br><span class="hljs-comment">// Getting first entry from map</span><br>System.out.println(map.firstEntry());         <span class="hljs-comment">// Prints key1=value1</span><br><span class="hljs-comment">// Polling last entry from map</span><br>System.out.println(map.pollLastEntry());       <span class="hljs-comment">// Prints key3=value3</span><br><br><span class="hljs-comment">// Printing map again</span><br>System.out.println(map);                           <span class="hljs-comment">// Prints &#123;key1=value1, key2=value2&#125;</span><br></code></pre></td></tr></table></figure><h3 id="1-5-Element-Ordering"><a href="#1-5-Element-Ordering" class="headerlink" title="1.5. Element Ordering"></a>1.5. Element Ordering</h3><p><strong><em>HashMap</em> does not maintain any order</strong> for its elements i.e. it won’t provide any guarantee that the element inserted first in the map will print first during the iteration of the map.</p><p><strong><em>TreeMap</em> stores the elements in the sorting order of their keys.</strong> The sorting can be default natural sorting order (ascending order for numbers &amp; alphabetical order for strings) or customized sorting based on the <a href="https://howtodoinjava.com/java/collections/java-comparator/"><em>Comparator</em></a> object specified during the map creation.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Creating HashMap</span><br>HashMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br><span class="hljs-comment">// Putting values in the map</span><br>map.put(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>map.put(<span class="hljs-number">13</span>, <span class="hljs-string">&quot;value3&quot;</span>);<br>map.put(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;value4&quot;</span>);<br>map.put(<span class="hljs-number">25</span>, <span class="hljs-string">&quot;value5&quot;</span>);<br><br><span class="hljs-comment">// Printing map</span><br>System.out.println(map);   <span class="hljs-comment">//&#123;2=value2, 5=value4, 25=value5, 10=value1, 13=value3&#125;  - No ordering</span><br><br><span class="hljs-comment">// Creating TreeMap using normal TreeMap() constructor which sorts the elements </span><br><span class="hljs-comment">// based on natural sorting order of keys</span><br>TreeMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br><br><span class="hljs-comment">// Putting values in map</span><br>map.put(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>map.put(<span class="hljs-number">13</span>, <span class="hljs-string">&quot;value3&quot;</span>);<br>map.put(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;value4&quot;</span>);<br>map.put(<span class="hljs-number">25</span>, <span class="hljs-string">&quot;value5&quot;</span>);<br><br><span class="hljs-comment">// Printing map</span><br>System.out.println(map);  <span class="hljs-comment">//&#123;2=value2, 5=value4, 10=value1, 13=value3, 25=value5&#125;</span><br></code></pre></td></tr></table></figure><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Creating TreeMap using TreeMap(Comparator) constructor by specifying Comparator object </span><br><span class="hljs-comment">// as Lambda expression which sorts the elements according to customized sorting of keys</span><br>map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;Integer,String&gt;((I1,I2) -&gt; (I1&lt;I2) ? <span class="hljs-number">1</span> : (I1&gt;I2) ? -<span class="hljs-number">1</span> : <span class="hljs-number">0</span>); <br><br><span class="hljs-comment">// Putting values in map</span><br>map.put(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>map.put(<span class="hljs-number">13</span>, <span class="hljs-string">&quot;value3&quot;</span>);<br>map.put(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;value4&quot;</span>);<br>map.put(<span class="hljs-number">25</span>, <span class="hljs-string">&quot;value5&quot;</span>);<br><br><span class="hljs-comment">// Printing map</span><br>System.out.println(map);  <span class="hljs-comment">//&#123;25=value5, 13=value3, 10=value1, 5=value4, 2=value2&#125;</span><br></code></pre></td></tr></table></figure><h3 id="1-6-Performance-Comparison"><a href="#1-6-Performance-Comparison" class="headerlink" title="1.6. Performance Comparison"></a>1.6. Performance Comparison</h3><ul><li>  <strong><em>HashMap</em> is faster than <em>TreeMap</em></strong> and provides constant time performance <strong>O(1)</strong> for the most basic operations like <code>get(), put(), contains() &amp; remove()</code> in the best case scenario without hash collisions.</li><li>  In case of <strong>hash collisions</strong> (two keys are having the same hashcode), <em>HashMap</em> handles it by using a <em>LinkedList</em> to store the collided elements and hence the performance reduces up to <strong>O(n)</strong> in this case.</li><li>  To improve <em>HashMap’s</em> performance during collisions, <em>LinkedList</em> transforms into a <em>Balanced Tree</em> in case the number of entries in a bucket are more than 8 so that it improves the worst-case performance from <strong>O(n) to O(log(n)).</strong></li></ul><p>On the other hand, <em>TreeMap</em> provides a performance of <strong><em>O(log(n))</em></strong> for most basic operations like <code>get(), put(), contains() &amp; remove()</code>.</p><h3 id="1-7-Memory-Usage"><a href="#1-7-Memory-Usage" class="headerlink" title="1.7. Memory Usage"></a>1.7. Memory Usage</h3><p><strong><em>TreeMap</em> has better performance in memory management as it does not maintain an array internally</strong> to store key-value pairs.</p><p>In <em>HashMap</em>, the array size is determined while initialization or resizing which is often more than needed at the time. It wastes memory. There is no such problem with <em>TreeMap</em>.</p><h3 id="1-8-Key-Searches"><a href="#1-8-Key-Searches" class="headerlink" title="1.8. Key Searches"></a>1.8. Key Searches</h3><p><em>HashMap</em> uses <code>hashCode()</code> and <code>equals()</code> method while comparing the keys of the map while <em>TreeMap</em> uses <code>compareTo()</code> or <code>compare()</code> methods during key comparison.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Creating HashMap</span><br>HashMap&lt;Integer, String&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br><span class="hljs-comment">// Putting values in map</span><br>hashMap.put(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>hashMap.put(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;HashMap: &quot;</span> + hashMap);<br><br><span class="hljs-comment">// Creating TreeMap</span><br>TreeMap&lt;Integer, String&gt; treeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br><br><span class="hljs-comment">// Putting values in map</span><br>treeMap.put(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>treeMap.put(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;TreeMap: &quot;</span> + treeMap);<br></code></pre></td></tr></table></figure><p>Notice the program output. Even though the output is same for both cases, internally <em>HashMap</em> uses <strong><em>equals()</em> while comparing the keys</strong> and rejects the second key as it is a duplicate. Whereas, <em>TreeMap</em> uses <strong><em>compareTo()</em> while comparing keys</strong> and thus rejects the second key.</p><p>Also, both the maps update the previous entry, and a single entry is there on the <em>Map</em>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap: &#123;<span class="hljs-number">10</span>=value2&#125;<br>TreeMap: &#123;<span class="hljs-number">10</span>=value2&#125;<br></code></pre></td></tr></table></figure><h2 id="2-When-to-use-HashMap-and-TreeMap"><a href="#2-When-to-use-HashMap-and-TreeMap" class="headerlink" title="2. When to use HashMap and TreeMap"></a><strong>2</strong>. When to use HashMap and TreeMap</h2><p>We should use <em>TreeMap</em> if we need to add elements (key-value pairs) in sorted order. Let’s take an example of creating a <strong>Dictionary</strong> where the words sort in alphabetical order. So we can easily implement this using a <em>TreeMap</em>.</p><p>A <em>TreeMap</em> is more <strong>memory efficient,</strong> so it is a good map implementation for us in case we are not sure of the number of elements to be stored in the memory.</p><p><em><a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">HashMap</a></em> is more of a general purpose map implementation and can be used where we don’t want any kind of sorting for our data, and the entries can be maintained in any order or sequence. In high-performance applications, we can prefer using <em>HashMap</em> over <em>TreeMap</em> as it performs better as compared to <em><a href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html">TreeMap</a></em>.</p><h2 id="3-Conclusion"><a href="#3-Conclusion" class="headerlink" title="3. Conclusion"></a>3. Conclusion</h2><p>In this post, we have seen some of the key differences between <em>HashMap</em> and <em>TreeMap</em> and on which factors we can decide between the two while using them in our code.</p><p>Happy Learning !!</p><h2 id="4-References"><a href="#4-References" class="headerlink" title="4.References"></a>4.References</h2><ul><li><a href="https://howtodoinjava.com/java/collections/java-treemap-vs-hashmap/">Java TreeMap vs HashMap</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Integer.toString() vs String.valueOf()</title>
    <link href="/2022/09/13/java/Integer.toString()vsString.valueOf()/"/>
    <url>/2022/09/13/java/Integer.toString()vsString.valueOf()/</url>
    
    <content type="html"><![CDATA[<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.baeldung.com/java-tostring-valueof">Integer.toString() vs String.valueOf() in Java</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JMH - Java 代码性能基准测试</title>
    <link href="/2022/09/13/java/JMH-Java%20%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/"/>
    <url>/2022/09/13/java/JMH-Java%20%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Java-性能测试难题"><a href="#Java-性能测试难题" class="headerlink" title="Java 性能测试难题"></a>Java 性能测试难题</h2><p>现在的 JVM 已经越来越为智能，它可以在编译阶段、加载阶段、运行阶段对代码进行优化。比如你写了一段不怎么聪明的代码，到了 JVM 这里，它发现几处可以优化的地方，就顺手帮你优化了一把。这对程序的运行固然美妙，却让开发者不能准确了解程序的运行情况。在需要进行性能测试时，如果不知道 JVM 优化细节，可能会导致你的测试结果差之毫厘，失之千里，同样的，Java 诞生之初就有一次编译、随处运行的口号，JVM 提供了底层支持，也提供了内存管理机制，这些机制都会对我们的性能测试结果造成不可预测的影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><span class="hljs-comment">// ....</span><br><span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>System.out.println(end - start);<br></code></pre></td></tr></table></figure><p>上面可能就是你最常见的性能测试了，这样的测试结果真的准确吗？答案是否定的，它有下面几个问题。</p><ol><li> 时间精度问题，本身获取到的时间戳就是存在<strong>误差</strong>的，它和操作系统有关。</li><li> JVM 在运行时会进行<strong>代码预热</strong>，说白了就是<strong>越跑越快</strong>。因为类需要装载、需要准备操作。</li><li> JVM 会在各个阶段都有可能对你的代码进行<strong>优化处理</strong>。</li><li> <strong>资源回收</strong>的不确定性，可能运行很快，回收很慢。</li></ol><p>带着这些问题，突然发现进行一次严格的基准测试的难度大大增加。那么如何才能进行一次严格的基准测试呢？</p><h2 id="JMH-介绍"><a href="#JMH-介绍" class="headerlink" title="JMH 介绍"></a>JMH 介绍</h2><p>那么如何对 Java 程序进行一次精准的性能测试呢？难道需要掌握很多 JVM 优化细节吗？难道要研究如何避免，并进行正确编码才能进行严格的性能测试吗？显然不是，如果是这样的话，未免过于困难了，好在有一款一款官方的微基准测试工具 - <strong>JMH</strong>.</p><p><strong>JMH</strong> 的全名是 Java Microbenchmark Harness，它是由 <strong>Java 虚拟机团队</strong>开发的一款用于 Java <strong>微基准测试工具</strong>。用自己开发的工具测试自己开发的另一款工具，以子之矛，攻子之盾果真手到擒来，如臂使指。使用 <strong>JMH</strong> 可以让你方便快速的进行一次严格的代码基准测试，并且有多种测试模式，多种测试维度可供选择；而且使用简单、增加注解便可启动测试。</p><h2 id="JMH-使用"><a href="#JMH-使用" class="headerlink" title="JMH 使用"></a>JMH 使用</h2><p>JMH 的使用首先引入 maven 所需依赖，当前最新版 为 1.23 版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--jmh 基准测试 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jmh<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jmh-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.35<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jmh<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.35<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="快速测试"><a href="#快速测试" class="headerlink" title="快速测试"></a>快速测试</h3><p>下面使用注解的方式指定测试参数，通过一个例子展示 JMH 基准测试的具体用法，先看一次运行效果，然后再了解每个注解的具体含义。</p><p>这个例子是使用 JMH 测试，使用加号拼接字符串和使用 <code>StringBuilder</code> 的 <code>append</code> 方法拼接字符串时的速度如何，每次拼接1000个数字进行平均速度比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.*;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.Runner;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.RunnerException;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.options.Options;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * JMH 基准测试入门</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> niujinpeng</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2020/8/21 1:13</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@BenchmarkMode(Mode.AverageTime)</span><br><span class="hljs-meta">@State(Scope.Thread)</span><br><span class="hljs-meta">@Fork(1)</span><br><span class="hljs-meta">@OutputTimeUnit(TimeUnit.MILLISECONDS)</span><br><span class="hljs-meta">@Warmup(iterations = 3)</span><br><span class="hljs-meta">@Measurement(iterations = 5)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JmhHello</span> &#123;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">stringAdd</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            string = string + i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> string;<br>    &#125;<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">stringBuilderAppend</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            stringBuilder.append(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> stringBuilder.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RunnerException &#123;<br>        <span class="hljs-type">Options</span> <span class="hljs-variable">opt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptionsBuilder</span>()<br>            .include(JmhHello.class.getSimpleName())<br>            .build();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runner</span>(opt).run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码很简单，不做解释，<code>stringAdd</code> 使用加号拼接字符串 1000次，<code>stringBuilderAppend</code> 使用 <code>append</code> 拼接字符串 1000次。直接运行 main 方法，稍等片刻后可以得到详细的运行输出结果。</p><h4 id="java8测试结果"><a href="#java8测试结果" class="headerlink" title="java8测试结果"></a>java8测试结果</h4><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">// 开始测试 stringAdd 方法</span><br><span class="hljs-meta"># JMH version: 1.23</span><br><span class="hljs-meta"># VM version: JDK 1.8.0_181, Java HotSpot(TM) 64-Bit Server VM, 25.181-b13</span><br><span class="hljs-meta"># VM invoker: D:\develop\Java\jdk8_181\jre\bin\java.exe</span><br><span class="hljs-meta"># VM options: -javaagent:C:\ideaIU-2020.1.3.win\lib\idea_rt.jar=50363:C:\ideaIU-2020.1.3.win\bin -Dfile.encoding=UTF-8</span><br><span class="hljs-meta"># Warmup: 3 iterations, 10 s each  <span class="hljs-comment">// 预热运行三次</span></span><br><span class="hljs-meta"># Measurement: 5 iterations, 10 s each <span class="hljs-comment">// 性能测试5次 </span></span><br><span class="hljs-meta"># Timeout: 10 min per iteration  <span class="hljs-comment">// 超时时间10分钟</span></span><br><span class="hljs-meta"># Threads: 1 thread, will synchronize iterations  <span class="hljs-comment">// 线程数量为1</span></span><br><span class="hljs-meta"># Benchmark mode: Average time, time/op  <span class="hljs-comment">// 统计方法调用一次的平均时间</span></span><br><span class="hljs-meta"># Benchmark: net.codingme.jmh.JmhHello.stringAdd <span class="hljs-comment">// 本次执行的方法</span></span><br><br><span class="hljs-meta"># Run progress: 0.00% complete, ETA 00:02:40</span><br><span class="hljs-meta"># Fork: 1 of 1</span><br><span class="hljs-meta"># Warmup Iteration   1: 95.153 ms/op  <span class="hljs-comment">// 第一次预热，耗时95ms</span></span><br><span class="hljs-meta"># Warmup Iteration   2: 108.927 ms/op <span class="hljs-comment">// 第二次预热，耗时108ms</span></span><br><span class="hljs-meta"># Warmup Iteration   3: 167.760 ms/op <span class="hljs-comment">// 第三次预热，耗时167ms</span></span><br>Iteration   <span class="hljs-number">1</span>: <span class="hljs-number">198.897</span> ms/op  <span class="hljs-comment">// 执行五次耗时度量</span><br>Iteration   <span class="hljs-number">2</span>: <span class="hljs-number">243.437</span> ms/op<br>Iteration   <span class="hljs-number">3</span>: <span class="hljs-number">271.171</span> ms/op<br>Iteration   <span class="hljs-number">4</span>: <span class="hljs-number">295.636</span> ms/op<br>Iteration   <span class="hljs-number">5</span>: <span class="hljs-number">327.822</span> ms/op<br><br>Result <span class="hljs-string">&quot;net.codingme.jmh.JmhHello.stringAdd&quot;</span>:<br><span class="hljs-number">267.393</span> ±(<span class="hljs-number">99.9</span>%) <span class="hljs-number">189.907</span> ms/op [Average]<br>(<span class="hljs-built_in">min</span>, avg, <span class="hljs-built_in">max</span>) = (<span class="hljs-number">198.897</span>, <span class="hljs-number">267.393</span>, <span class="hljs-number">327.822</span>), stdev = <span class="hljs-number">49.318</span>  <span class="hljs-comment">// 执行的最小、平均、最大、误差值</span><br>CI (<span class="hljs-number">99.9</span>%): [<span class="hljs-number">77.486</span>, <span class="hljs-number">457.299</span>] (assumes normal distribution)<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">//</span> <span class="hljs-string">开始测试</span> <span class="hljs-string">stringBuilderAppend</span> <span class="hljs-string">方法</span><br><span class="hljs-comment"># Benchmark: net.codingme.jmh.JmhHello.stringBuilderAppend</span><br><br><span class="hljs-comment"># Run progress: 50.00% complete, ETA 00:01:21</span><br><span class="hljs-comment"># Fork: 1 of 1</span><br><span class="hljs-comment"># Warmup Iteration   1: 1.872 ms/op</span><br><span class="hljs-comment"># Warmup Iteration   2: 4.491 ms/op</span><br><span class="hljs-comment"># Warmup Iteration   3: 5.866 ms/op</span><br><span class="hljs-attr">Iteration   1:</span> <span class="hljs-number">6.936</span> <span class="hljs-string">ms/op</span><br><span class="hljs-attr">Iteration   2:</span> <span class="hljs-number">8.465</span> <span class="hljs-string">ms/op</span><br><span class="hljs-attr">Iteration   3:</span> <span class="hljs-number">8.925</span> <span class="hljs-string">ms/op</span><br><span class="hljs-attr">Iteration   4:</span> <span class="hljs-number">9.766</span> <span class="hljs-string">ms/op</span><br><span class="hljs-attr">Iteration   5:</span> <span class="hljs-number">10.143</span> <span class="hljs-string">ms/op</span><br><br><span class="hljs-string">Result</span> <span class="hljs-attr">&quot;net.codingme.jmh.JmhHello.stringBuilderAppend&quot;:</span><br><span class="hljs-number">8.847</span> <span class="hljs-string">±(99.9%)</span> <span class="hljs-number">4.844</span> <span class="hljs-string">ms/op</span> [<span class="hljs-string">Average</span>]<br><span class="hljs-string">(min,</span> <span class="hljs-string">avg,</span> <span class="hljs-string">max)</span> <span class="hljs-string">=</span> <span class="hljs-string">(6.936,</span> <span class="hljs-number">8.847</span><span class="hljs-string">,</span> <span class="hljs-number">10.143</span><span class="hljs-string">),</span> <span class="hljs-string">stdev</span> <span class="hljs-string">=</span> <span class="hljs-number">1.258</span><br><span class="hljs-string">CI</span> <span class="hljs-string">(99.9%):</span> [<span class="hljs-number">4.003</span>, <span class="hljs-number">13.691</span>] <span class="hljs-string">(assumes</span> <span class="hljs-string">normal</span> <span class="hljs-string">distribution)</span><br></code></pre></td></tr></table></figure><pre><code class="hljs"># Run complete. Total time: 00:02:42REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up onwhy the numbers are the way they are. Use profilers (see -prof, -lprof), design factorialexperiments, perform baseline and negative tests that provide experimental control, make surethe benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.Do not assume the numbers tell you what you want them to tell.// 测试结果对比Benchmark                     Mode  Cnt    Score     Error  UnitsJmhHello.stringAdd            avgt    5  267.393 ± 189.907  ms/opJmhHello.stringBuilderAppend  avgt    5    8.847 ±   4.844  ms/op</code></pre><p>上面日志里的 <code>//</code> 注释是我手动增加上去的，其实我们只需要看下面的最终结果就可以了，可以看到 <code>stringAdd</code> 方法平均耗时 267.393ms，而 <code>stringBuilderAppend</code> 方法平均耗时只有 8.847ms，可见 <code>StringBuilder</code> 的 <code>append</code> 方法进行字符串拼接速度快的多，这也是我们推荐使用<code>append</code> 进行字符串拼接的原因。</p><h4 id="java17"><a href="#java17" class="headerlink" title="java17"></a>java17</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># JMH version: 1.35</span><br><span class="hljs-comment"># VM version: JDK 17, Java HotSpot(TM) 64-Bit Server VM, 17+35-LTS-2724</span><br><span class="hljs-comment"># VM invoker: D:\devPrograms\jdk\jdk-17_windows-x64_bin\jdk-17\bin\java.exe</span><br><span class="hljs-comment"># VM options: -javaagent:D:\devPrograms\JetBrains\ideaIU-2022.1.3.win\lib\idea_rt.jar=50503:D:\devPrograms\JetBrains\ideaIU-2022.1.3.win\bin -Dfile.encoding=UTF-8</span><br><span class="hljs-comment"># Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)</span><br><span class="hljs-comment"># Warmup: 3 iterations, 10 s each</span><br><span class="hljs-comment"># Measurement: 5 iterations, 10 s each</span><br><span class="hljs-comment"># Timeout: 10 min per iteration</span><br><span class="hljs-comment"># Threads: 1 thread, will synchronize iterations</span><br><span class="hljs-comment"># Benchmark mode: Average time, time/op</span><br><span class="hljs-comment"># Benchmark: jmh.JmhHello.stringAdd</span><br><br><span class="hljs-comment"># Run progress: 0.00% complete, ETA 00:02:40</span><br><span class="hljs-comment"># Fork: 1 of 1</span><br><span class="hljs-comment"># Warmup Iteration   1: 37.778 ms/op</span><br><span class="hljs-comment"># Warmup Iteration   2: 91.377 ms/op</span><br><span class="hljs-comment"># Warmup Iteration   3: 122.324 ms/op</span><br>Iteration   <span class="hljs-number">1</span>: <span class="hljs-number">131.892</span> ms/op<br>Iteration   <span class="hljs-number">2</span>: <span class="hljs-number">174.695</span> ms/op<br>Iteration   <span class="hljs-number">3</span>: <span class="hljs-number">172.821</span> ms/op<br>Iteration   <span class="hljs-number">4</span>: <span class="hljs-number">177.970</span> ms/op<br>Iteration   <span class="hljs-number">5</span>: <span class="hljs-number">209.361</span> ms/op<br><br><br>Result <span class="hljs-string">&quot;jmh.JmhHello.stringAdd&quot;</span>:<br>  <span class="hljs-number">173.348</span> ±(<span class="hljs-number">99.9</span>%) <span class="hljs-number">106.138</span> ms/op [Average]<br>  (<span class="hljs-built_in">min</span>, <span class="hljs-built_in">avg</span>, <span class="hljs-built_in">max</span>) = (<span class="hljs-number">131.892</span>, <span class="hljs-number">173.348</span>, <span class="hljs-number">209.361</span>), stdev = <span class="hljs-number">27.564</span><br>  CI (<span class="hljs-number">99.9</span>%): [<span class="hljs-number">67.210</span>, <span class="hljs-number">279.486</span>] (assumes <span class="hljs-keyword">normal</span> distribution)<br><br><br><span class="hljs-comment"># JMH version: 1.35</span><br><span class="hljs-comment"># VM version: JDK 17, Java HotSpot(TM) 64-Bit Server VM, 17+35-LTS-2724</span><br><span class="hljs-comment"># VM invoker: D:\devPrograms\jdk\jdk-17_windows-x64_bin\jdk-17\bin\java.exe</span><br><span class="hljs-comment"># VM options: -javaagent:D:\devPrograms\JetBrains\ideaIU-2022.1.3.win\lib\idea_rt.jar=50503:D:\devPrograms\JetBrains\ideaIU-2022.1.3.win\bin -Dfile.encoding=UTF-8</span><br><span class="hljs-comment"># Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)</span><br><span class="hljs-comment"># Warmup: 3 iterations, 10 s each</span><br><span class="hljs-comment"># Measurement: 5 iterations, 10 s each</span><br><span class="hljs-comment"># Timeout: 10 min per iteration</span><br><span class="hljs-comment"># Threads: 1 thread, will synchronize iterations</span><br><span class="hljs-comment"># Benchmark mode: Average time, time/op</span><br><span class="hljs-comment"># Benchmark: jmh.JmhHello.stringBuilderAppend</span><br><br><span class="hljs-comment"># Run progress: 50.00% complete, ETA 00:01:21</span><br><span class="hljs-comment"># Fork: 1 of 1</span><br><span class="hljs-comment"># Warmup Iteration   1: 1.426 ms/op</span><br><span class="hljs-comment"># Warmup Iteration   2: 3.321 ms/op</span><br><span class="hljs-comment"># Warmup Iteration   3: 4.922 ms/op</span><br>Iteration   <span class="hljs-number">1</span>: <span class="hljs-number">5.732</span> ms/op<br>Iteration   <span class="hljs-number">2</span>: <span class="hljs-number">6.849</span> ms/op<br>Iteration   <span class="hljs-number">3</span>: <span class="hljs-number">6.621</span> ms/op<br>Iteration   <span class="hljs-number">4</span>: <span class="hljs-number">6.950</span> ms/op<br>Iteration   <span class="hljs-number">5</span>: <span class="hljs-number">8.269</span> ms/op<br><br><br>Result <span class="hljs-string">&quot;jmh.JmhHello.stringBuilderAppend&quot;</span>:<br>  <span class="hljs-number">6.884</span> ±(<span class="hljs-number">99.9</span>%) <span class="hljs-number">3.508</span> ms/op [Average]<br>  (<span class="hljs-built_in">min</span>, <span class="hljs-built_in">avg</span>, <span class="hljs-built_in">max</span>) = (<span class="hljs-number">5.732</span>, <span class="hljs-number">6.884</span>, <span class="hljs-number">8.269</span>), stdev = <span class="hljs-number">0.911</span><br>  CI (<span class="hljs-number">99.9</span>%): [<span class="hljs-number">3.376</span>, <span class="hljs-number">10.392</span>] (assumes <span class="hljs-keyword">normal</span> distribution)<br><br><br><span class="hljs-comment"># Run complete. Total time: 00:02:42</span><br><br>REMEMBER: The numbers below are just data. To gain reusable insights, you need <span class="hljs-built_in">to</span> follow up <span class="hljs-keyword">on</span><br>why <span class="hljs-keyword">the</span> numbers are <span class="hljs-keyword">the</span> way they are. Use profilers (see -prof, -lprof), design factorial<br>experiments, perform baseline <span class="hljs-keyword">and</span> negative tests that provide experimental control, make sure<br><span class="hljs-keyword">the</span> benchmarking environment is safe <span class="hljs-keyword">on</span> <span class="hljs-title">JVM</span>/<span class="hljs-title">OS</span>/<span class="hljs-title">HW</span> <span class="hljs-title">level</span>, <span class="hljs-title">ask</span> <span class="hljs-title">for</span> <span class="hljs-title">reviews</span> <span class="hljs-title">from</span> <span class="hljs-title">the</span> <span class="hljs-title">domain</span> <span class="hljs-title">experts</span>.<br>Do <span class="hljs-keyword">not</span> assume <span class="hljs-keyword">the</span> numbers tell you what you want them <span class="hljs-built_in">to</span> tell.<br><br>NOTE: Current JVM experimentally supports Compiler Blackholes, <span class="hljs-keyword">and</span> they are <span class="hljs-keyword">in</span> use. Please exercise<br>extra caution when trusting <span class="hljs-keyword">the</span> results, look <span class="hljs-keyword">into</span> <span class="hljs-keyword">the</span> generated code <span class="hljs-built_in">to</span> check <span class="hljs-keyword">the</span> benchmark still<br>works, <span class="hljs-keyword">and</span> factor <span class="hljs-keyword">in</span> <span class="hljs-keyword">a</span> small probability <span class="hljs-keyword">of</span> <span class="hljs-built_in">new</span> VM bugs. Additionally, <span class="hljs-keyword">while</span> comparisons between<br>different JVMs are already problematic, <span class="hljs-keyword">the</span> performance <span class="hljs-built_in">difference</span> caused <span class="hljs-keyword">by</span> different Blackhole<br>modes can be very significant. Please make sure you use <span class="hljs-keyword">the</span> consistent Blackhole mode <span class="hljs-keyword">for</span> comparisons.<br><br>Benchmark                     Mode  Cnt    Score     Error  Units<br>JmhHello.stringAdd            avgt    <span class="hljs-number">5</span>  <span class="hljs-number">173.348</span> ± <span class="hljs-number">106.138</span>  ms/op<br>JmhHello.stringBuilderAppend  avgt    <span class="hljs-number">5</span>    <span class="hljs-number">6.884</span> ±   <span class="hljs-number">3.508</span>  ms/op<br></code></pre></td></tr></table></figure><h3 id="注解说明"><a href="#注解说明" class="headerlink" title="注解说明"></a>注解说明</h3><p>经过上面的示例，想必你也可以快速的使用 JMH 进行基准测试了，不过上面的诸多注解你可能还有疑惑，下面一一介绍。</p><p><strong>类上</strong>使用了六个注解。</p><pre><code class="hljs">@BenchmarkMode(Mode.AverageTime)@State(Scope.Thread)@Fork(1)@OutputTimeUnit(TimeUnit.MILLISECONDS)@Warmup(iterations = 3)@Measurement(iterations = 5)</code></pre><p><strong>@BenchmarkMode(Mode.AverageTime)</strong> 表示统计平均响应时间，不仅可以用在类上，也可用在<strong>测试方法</strong>上。</p><p>除此之外还可以取值：</p><ul><li>  Throughput：统计单位时间内可以对方法测试多少次。</li><li>  SampleTime：统计每个响应时间范围内的响应次数，比如 0-1ms，3次；1-2ms，5次。</li><li>  SingleShotTime：跳过预热阶段，直接进行<strong>一次微基准</strong>测试。</li></ul><p>@State(Scope.Thread)：每个进行基准测试的线程都会独享一个对象示例。</p><p>除此之外还能取值：</p><ul><li>  Benchmark：多线程共享一个示例。</li><li>  Group：线程组共享一个示例，在测试方法上使用 @Group 设置线程组。</li></ul><p>@Fork(1)：表示开启一个线程进行测试。</p><p>@OutputTimeUnit(TimeUnit.MILLISECONDS)：输出的时间单位，这里写的是毫秒。</p><p>@Warmup(iterations = 3)：微基准测试前进行三次预热执行，也可用在<strong>测试方法</strong>上。</p><p>@Measurement(iterations = 5)：进行 5 次微基准测试，也可用在<strong>测试方法</strong>上。</p><p>在两个测试方法上只使用了一个注解 <strong>@Benchmark</strong>，这个注解表示这个方法是要进行基准测试的方法，它类似于 Junit 中的 <strong>@Test</strong> 注解。上面还提到某些注解还可以用到测试方法上，也就是使用了 <strong>@Benchmark</strong> 的方法之上，如果类上和测试方法同时存在注解，会以<strong>方法上的注解</strong>为准。</p><p>其实 JMH 也可以把这些参数直接在 main 方法中指定，这时 main 方法中指定的级别最高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RunnerException &#123;<br>    <span class="hljs-type">Options</span> <span class="hljs-variable">opt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptionsBuilder</span>()<br>            .include(JmhHello.class.getSimpleName())<br>            .forks(<span class="hljs-number">1</span>)<br>            .warmupIterations(<span class="hljs-number">5</span>)<br>            .measurementIterations(<span class="hljs-number">10</span>)<br>            .build();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runner</span>(opt).run();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="正确的微基准测试"><a href="#正确的微基准测试" class="headerlink" title="正确的微基准测试"></a>正确的微基准测试</h2><p>如果编写的代码本身就存在着诸多问题，那么即使使用正确的测试方法，也不可能得到正确的测试结果。这些测试代码中的问题应该由我们进行主动避免，那么有哪些常见问题呢？下面介绍两种最常见的情况。</p><h3 id="无用代码消除-（-Dead-Code-Elimination-）"><a href="#无用代码消除-（-Dead-Code-Elimination-）" class="headerlink" title="无用代码消除 （ Dead Code Elimination ）"></a>无用代码消除 （ Dead Code Elimination ）</h3><p>也有网友形象的翻译成<strong>死代码</strong>，死代码是指那些 JVM 经过检查发现的根本不会使用到的代码。比如下面这个代码片段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.*;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.Runner;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.RunnerException;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.options.Options;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 测试死代码消除</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> niujinpeng</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2020/8/21 8:04</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@BenchmarkMode(Mode.AverageTime)</span><br><span class="hljs-meta">@State(Scope.Thread)</span><br><span class="hljs-meta">@Fork(1)</span><br><span class="hljs-meta">@OutputTimeUnit(TimeUnit.MICROSECONDS)</span><br><span class="hljs-meta">@Warmup(iterations = 3, time = 3)</span><br><span class="hljs-meta">@Measurement(iterations = 5, time = 3)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JmhDCE</span> &#123;<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.log(Math.PI);<br>    &#125;<br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Math.log(Math.PI);<br>        result = Math.log(result);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RunnerException &#123;<br>        <span class="hljs-type">Options</span> <span class="hljs-variable">opt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptionsBuilder</span>()<br>                .include(JmhDCE.class.getSimpleName())<br>                .build();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runner</span>(opt).run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个代码片段里里，<code>test1</code> 方法对圆周率进行对数计算，并返回计算结果；而 <code>test2</code> 中不仅对圆周率进行对数计算，还对计算的结果再次对数计算，看起来复杂一些，但是因为没有用到计算结果，所以 JVM 会自动消除这段代码， 因为它没有任何意义。</p><pre><code class="hljs">Benchmark     Mode  Cnt   Score    Error  UnitsJmhDCE.test1  avgt    5   0.002 ±  0.001  us/opJmhDCE.test2  avgt    5  ≈ 10⁻⁴           us/op</code></pre><p>测试结果里也可以看到 <code>test</code> 平均耗时 0.0004 微秒，而 <code>test1</code> 平均耗时 0.002 微秒。</p><h3 id="常量折叠-（Constant-Folding）"><a href="#常量折叠-（Constant-Folding）" class="headerlink" title="常量折叠 （Constant Folding）"></a>常量折叠 （Constant Folding）</h3><p>在对 Java 源文件编译的过程中，编译器通过语法分析，可以发现某些能直接得到计算结果而不会再次更改的代码，然后会将计算结果记录下来，这样在执行的过程中就不需要再次运算了。比如这段代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.*;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.Runner;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.RunnerException;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.options.Options;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 测试常量折叠</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> niujinpeng</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2020/8/21 8:23</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@BenchmarkMode(Mode.AverageTime)</span><br><span class="hljs-meta">@State(Scope.Thread)</span><br><span class="hljs-meta">@Fork(1)</span><br><span class="hljs-meta">@OutputTimeUnit(TimeUnit.MICROSECONDS)</span><br><span class="hljs-meta">@Warmup(iterations = 3, time = 3)</span><br><span class="hljs-meta">@Measurement(iterations = 5, time = 3)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JmhConstantFolding</span> &#123;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">PI1</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14159265358979323846</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">PI2</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14159265358979323846</span>;<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.log(PI1) * Math.log(PI1);<br>    &#125;<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.log(PI2) * Math.log(PI2);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RunnerException &#123;<br>        <span class="hljs-type">Options</span> <span class="hljs-variable">opt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptionsBuilder</span>().include(JmhConstantFolding.class.getSimpleName()).build();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runner</span>(opt).run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>test</code>1 中使用 <code>final</code> 修饰的 PI1 进行对象计算，因为 PI1 不能再次更改，所以 <code>test1</code> 的计算结果必定是不会更改的，所以 JVM 会进行常量折叠优化，而 <code>test2</code> 使用的 <code>PI2</code> 可能会被修改，所以只能每次进行计算。</p><pre><code class="hljs">Benchmark                 Mode  Cnt  Score    Error  UnitsJmhConstantFolding.test1  avgt    5  0.002 ±  0.001  us/opJmhConstantFolding.test2  avgt    5  0.019 ±  0.001  us/op</code></pre><p>可以看到 <code>test2</code> 耗时要多的多，达到了 0.019 微秒。</p><p>其实 JVM 做的优化操作远不止上面这些，还有比如常量传播（Constant Propagation）、循环展开（Loop Unwinding）、循环表达式外提（Loop Expression Hoisting）、消除公共子表达式（Common Subexpression Elimination）、本块重排序（Basic Block Reordering）、范围检查消除（Range Check Elimination）等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JMH 进行基准测试的使用过程并不复杂，同为 Java 虚拟机团队开发，准确性毋容置疑。但是在进行基准测试时还是要注意自己的代码问题，如果编写的要进行测试的代码本身存在问题，那么测试的结果必定是不准的。掌握了 JMH 基准测试之后，可以尝试测试一些常用的工具或者框架的性能如何，看看哪个工具的性能最好，比如 FastJSON 真的比 GSON 在进行 JSON 转换时更 Fast 吗？</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.wdbyte.com/2020/08/develop/tool-jmh/">JMH - Java 代码性能基准测试</a></li><li><a href="http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/">http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/</a></li><li><a href="https://github.com/openjdk/jmh">https://github.com/openjdk/jmh</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>JMH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Enum</title>
    <link href="/2022/09/13/java/Java%20Enum/"/>
    <url>/2022/09/13/java/Java%20Enum/</url>
    
    <content type="html"><![CDATA[<h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><ul><li><a href="https://github.com/dromara/hutool/issues/2075">序列化JSON时, 当字段类型为枚举且枚举类存在静态方法时, 反序列化结果与预期不符.</a></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.baeldung.com/java-enum-values">Attaching Values to Java Enum</a></li><li><a href="https://www.baeldung.com/a-guide-to-java-enums">A Guide to Java Enums</a></li><li><a href="https://www.baeldung.com/java-enum-iteration">Iterating over Enum Values in Java</a></li><li><a href="https://www.runoob.com/java/java-enum.html">Java 枚举(enum)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Generic Constructors</title>
    <link href="/2022/09/13/java/GenericConstructors/"/>
    <url>/2022/09/13/java/GenericConstructors/</url>
    
    <content type="html"><![CDATA[<p>In this blog post I will give you a quick overview of generic constructors.</p><h2 id="Generic-constructors-are-rarely-used-in-the-JDK"><a href="#Generic-constructors-are-rarely-used-in-the-JDK" class="headerlink" title="Generic constructors are rarely used (in the JDK)"></a>Generic constructors are rarely used (in the JDK)</h2><p>As I have never seen generic constructors before I wanted to know how “real-world” code uses them. So I wrote a <a href="https://github.com/objectos/blog-examples/blob/master/p011-generic-constructors/src/main/java/shared/JdkSearch.java">program</a> that parses the Java files in the JDK source code. It uses the <a href="https://github.com/javaparser/javaparser">JavaParser</a> open-source library. Since its README file mentions Java 15, I ran the program on tag <a href="https://github.com/openjdk/jdk/tree/jdk-15+36/src">jdk-15+36</a> of the <a href="https://github.com/openjdk/jdk/tree/jdk-15+36">JDK source code</a>.</p><p>I found seven classes having generic constructors. They are all in the <code>java.management</code> module. Four classes are exported (and therefore have Javadocs):</p><ul><li>  <a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.management/javax/management/StandardEmitterMBean.html">javax.management.StandardEmitterMBean</a></li><li>  <a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.management/javax/management/StandardMBean.html">javax.management.StandardMBean</a></li><li>  <a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.management/javax/management/openmbean/OpenMBeanAttributeInfoSupport.html">javax.management.openmbean.OpenMBeanAttributeInfoSupport</a></li><li>  <a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.management/javax/management/openmbean/OpenMBeanParameterInfoSupport.html">javax.management.openmbean.OpenMBeanParameterInfoSupport</a></li></ul><p>While three of the classes are internal:</p><ul><li>  <a href="https://github.com/openjdk/jdk/blob/jdk-15%2B36/src/java.management/share/classes/com/sun/jmx/mbeanserver/MXBeanSupport.java">com.sun.jmx.mbeanserver.MXBeanSupport</a></li><li>  <a href="https://github.com/openjdk/jdk/blob/jdk-15%2B36/src/java.management/share/classes/com/sun/jmx/mbeanserver/MBeanSupport.java">com.sun.jmx.mbeanserver.MBeanSupport</a></li><li>  <a href="https://github.com/openjdk/jdk/blob/jdk-15%2B36/src/java.management/share/classes/com/sun/jmx/mbeanserver/StandardMBeanSupport.java">com.sun.jmx.mbeanserver.StandardMBeanSupport</a></li></ul><p>Therefore one can safely say generic constructors are rarely used. At least in the JDK source code.</p><h2 id="Still…-it-gives-a-glimpse-on-how-to-use-them"><a href="#Still…-it-gives-a-glimpse-on-how-to-use-them" class="headerlink" title="Still… it gives a glimpse on how to use them"></a>Still… it gives a glimpse on how to use them</h2><p>Let’s study the signature of one of those constructors. For example, let’s take this one from the <a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.management/javax/management/openmbean/OpenMBeanParameterInfoSupport.html#%3Cinit%3E(java.lang.String,java.lang.String,javax.management.openmbean.OpenType,T)"><code>OpenMBeanAttributeInfoSupport</code></a> class. Its signature is:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; OpenMBeanParameterInfoSupport(String name, String description,OpenType&lt;T&gt; openType,<br>                                         T defaultValue) <span class="hljs-keyword">throws</span> OpenDataException<br></code></pre></td></tr></table></figure><p>The Javadocs for the type parameter <code>&lt;T&gt;</code> says:</p><blockquote><p>T - allows the compiler to check that the defaultValue, if non-null, has the correct Java type for the given openType.</p></blockquote><p>So the type parameter in the constructor prevents mixing incompatible types. In other words, the following code to compiles:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">OpenType&lt;Foo&gt; openType = getOpenType();<br><span class="hljs-type">Foo</span> <span class="hljs-variable">foo</span> <span class="hljs-operator">=</span> getFoo();<br><span class="hljs-type">var</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenMBeanParameterInfoSupport</span>(<span class="hljs-string">&quot;A Name&quot;</span>, <span class="hljs-string">&quot;Some description&quot;</span>, openType, foo);<br></code></pre></td></tr></table></figure><p>As <code>OpenType&lt;Foo&gt;</code> is compatible with <code>Foo</code>. However, the following code fails to compile:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">OpenType&lt;Foo&gt; openType = getOpenType();<br><span class="hljs-type">Bar</span> <span class="hljs-variable">bar</span> <span class="hljs-operator">=</span> getBar();<br><span class="hljs-type">var</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenMBeanParameterInfoSupport</span>(<span class="hljs-string">&quot;A Name&quot;</span>, <span class="hljs-string">&quot;Some description&quot;</span>, openType, bar);<br><span class="hljs-comment">// compilation error                                                              ^^^</span><br></code></pre></td></tr></table></figure><p>As <code>OpenType&lt;Foo&gt;</code> is <strong>not</strong> compatible with <code>Bar</code>.</p><p>Great, let’s try to create an example using same idea. It should make things clearer.</p><h2 id="A-simple-example"><a href="#A-simple-example" class="headerlink" title="A simple example"></a>A simple example</h2><p>Suppose we have a <code>Payload</code> class that represents arbitrary data to be sent over the wire. For example, It could be JSON data to be sent over HTTPS. To keep our example simple, we will model the data as a <code>String</code> value. Additionally, since our data is immutable, we will use a Java record:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">Payload</span><span class="hljs-params">(String data)</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>So, if we were to send a “Hello world!” message over the wire, we could invoke a hypothetical <code>send</code> method like so:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Payload</span>(<span class="hljs-string">&quot;Hello world!&quot;</span>));<br></code></pre></td></tr></table></figure><p>The actual JSON payload sent by our hypothetical service is not important for our example. But, for completeness sake, let’s suppose the JSON data sent in our previous example was:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Hello world!&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>That’s great. Next, let’s add a little complexity to our data.j</p><h3 id="Sending-other-data-types"><a href="#Sending-other-data-types" class="headerlink" title="Sending other data types"></a>Sending other data types</h3><p>Suppose now we want to send data that is both structured and more complex than our previous “Hello world!” message. For example, we want to send a simplified log message represented by the following Java record:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">Log</span><span class="hljs-params">(<span class="hljs-type">long</span> millis, Level level, String msg)</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>This data is structured in the sense that its JSON format is defined by the following converter:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogConverter</span> &#123;<br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">convert</span><span class="hljs-params">(Log log)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">      &quot;millis&quot;: %d,</span><br><span class="hljs-string">      &quot;level&quot;: &quot;%s&quot;,</span><br><span class="hljs-string">      &quot;msg&quot;: &quot;%s&quot;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    &quot;&quot;&quot;</span>.formatted(log.millis(), log.level(), log.msg());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>To send our log record we could just:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">var</span> <span class="hljs-variable">converter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LogConverter</span>();<br><span class="hljs-type">var</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Log</span>(<span class="hljs-number">12345L</span>, Level.INFO, <span class="hljs-string">&quot;A message&quot;</span>);<br><span class="hljs-type">var</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> converter.convert(log);<br>send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Payload</span>(data));<br></code></pre></td></tr></table></figure><p>But we expect more data types each with its own structure. That is, each data type will bring its own converter. So, let’s refactor our <code>Payload</code> record.</p><h3 id="Enter-the-generic-constructor"><a href="#Enter-the-generic-constructor" class="headerlink" title="Enter the generic constructor"></a>Enter the generic constructor</h3><p>Since each data type will have its own converter there is a chance to use a generic constructor like so:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">Payload</span><span class="hljs-params">(String data)</span> &#123;<br>  <span class="hljs-keyword">public</span> &lt;T&gt; Payload(Function&lt;T, String&gt; converter, T item) &#123;<br>    <span class="hljs-built_in">this</span>(converter.apply(item));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>The converter is represented by a <code>Function</code> from a generic type <code>T</code> to a <code>String</code>. Our parameterized constructor ensures that the second argument’s type is compatible with the converter.</p><p>So let’s use our new constructor. The following test does just that:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">data</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">var</span> <span class="hljs-variable">converter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LogConverter</span>();<br>  <span class="hljs-type">var</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Log</span>(<span class="hljs-number">12345L</span>, Level.INFO, <span class="hljs-string">&quot;A message&quot;</span>);<br>  <span class="hljs-type">var</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Payload</span>(converter::convert, log);<br><br>  assertEquals(p.data(), <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">  &#123;</span><br><span class="hljs-string">    &quot;millis&quot;: 12345,</span><br><span class="hljs-string">    &quot;level&quot;: &quot;INFO&quot;,</span><br><span class="hljs-string">    &quot;msg&quot;: &quot;A message&quot;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">  &quot;&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Good, our test passes. Granted, there is very little difference to the previous example using the canonical constructor. But it does its job as an example of generic constructors.</p><h2 id="Invoking-generic-constructors"><a href="#Invoking-generic-constructors" class="headerlink" title="Invoking generic constructors"></a>Invoking generic constructors</h2><p>In our last example we invoked our generic constructor just like we do with a non-generic one. In other words, we did not provide explicit type arguments to our generic constructor. The actual type arguments were <a href="https://docs.oracle.com/javase/specs/jls/se18/html/jls-18.html">inferred</a> by the compiler.</p><p>We can be explicit if we wanted. That is, we can provide a type argument list to the generic constructor.</p><h3 id="Providing-type-arguments-with-the-new-keyword"><a href="#Providing-type-arguments-with-the-new-keyword" class="headerlink" title="Providing type arguments with the new keyword"></a>Providing type arguments with the <code>new</code> keyword</h3><p>Taking again our last example, we can provide explicit type arguments. So the class instance creation becomes:</p><pre><code class="hljs">var p = new &lt;Log&gt; Payload(converter::convert, log);</code></pre><p>Notice the <code>&lt;Log&gt;</code> right after the <code>new</code> keyword. Providing explicit type arguments means that the following code does <strong>not</strong> compile:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">var</span> <span class="hljs-variable">converter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LogConverter</span>();<br><span class="hljs-type">var</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Log</span>(<span class="hljs-number">12345L</span>, Level.INFO, <span class="hljs-string">&quot;A message&quot;</span>);<br><span class="hljs-type">var</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> &lt;Category&gt; Payload(converter::convert, log);<br><span class="hljs-comment">// compilation error           ^^^                 ^^^</span><br></code></pre></td></tr></table></figure><p>The compiler tries to match the actual arguments to a “virtual” constructor having the following signature:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Payload</span><span class="hljs-params">(Function&lt;Category, String&gt; converter, Category item)</span>;<br></code></pre></td></tr></table></figure><p>As the types are not compatible, compilation fails.</p><h3 id="Providing-type-arguments-with-the-this-or-super-keyword"><a href="#Providing-type-arguments-with-the-this-or-super-keyword" class="headerlink" title="Providing type arguments with the this or super keyword"></a>Providing type arguments with the <code>this</code> or <code>super</code> keyword</h3><p>Apart from the class instance creation expression (i.e., <code>new</code> keyword), there are other ways to invoke constructors. In particular, constructors themselves can invoke other constructors:</p><ul><li>  a constructor in the same class using <code>this</code>; </li><li>  a constructor from the superclass using <code>super</code>.</li></ul><p>But what happens if the invoked constructor is generic? Let’s investigate.</p><p>Here’s the production from <a href="https://docs.oracle.com/javase/specs/jls/se18/html/jls-8.html#jls-8.8.7.1">Section 8.8.7.1</a> of the JLS:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ExplicitConstructorInvocation:<br>  [TypeArguments] <span class="hljs-built_in">this</span> ( [ArgumentList] ) ;<br>  [TypeArguments] <span class="hljs-built_in">super</span> ( [ArgumentList] ) ;<br>  ExpressionName . [TypeArguments] <span class="hljs-built_in">super</span> ( [ArgumentList] ) ;<br>  Primary . [TypeArguments] <span class="hljs-built_in">super</span> ( [ArgumentList] ) ;<br></code></pre></td></tr></table></figure><p>As suspected, both <code>this</code> and <code>super</code> can be invoked with a type arguments list.</p><p>So let’s try it with our <code>Payload</code> record. We can add a specialized constructor for a <code>Log</code> instance like so:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">Payload</span><span class="hljs-params">(String data)</span> &#123;<br>  <span class="hljs-keyword">public</span> &lt;T&gt; Payload(Function&lt;T, String&gt; converter, T item) &#123;<br>    <span class="hljs-built_in">this</span>(converter.apply(item));<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Function&lt;Log, String&gt; LOG_CONVERTER = LogConverter.INSTANCE::convert;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Payload</span><span class="hljs-params">(Log log)</span> &#123;<br>    &lt;Log&gt; <span class="hljs-built_in">this</span>(LOG_CONVERTER, log);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>We added an invocation to the other constructor in the same class. It supplies a type argument to it:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Payload</span><span class="hljs-params">(Log log)</span> &#123;<br>  &lt;Log&gt; <span class="hljs-built_in">this</span>(LOG_CONVERTER, log);<br>&#125;<br></code></pre></td></tr></table></figure><p>This means that the following code does <strong>not</strong> compile:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Payload</span><span class="hljs-params">(Log log)</span> &#123;<br>  &lt;LocalDate&gt; <span class="hljs-built_in">this</span>(LOG_CONVERTER, log);<br>  <span class="hljs-comment">// error         ^^^            ^^^</span><br>&#125;<br></code></pre></td></tr></table></figure><p>As the compiler tries to match the actual arguments to a “virtual” constructor having the following signature:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Payload</span><span class="hljs-params">(Function&lt;LocalDate, String&gt; converter, LocalDate item)</span>;<br></code></pre></td></tr></table></figure><p>As the types are not compatible, compilation fails.</p><h3 id="Caveat-with-new-keyword-and-diamond-form"><a href="#Caveat-with-new-keyword-and-diamond-form" class="headerlink" title="Caveat with new keyword and diamond form"></a>Caveat with <code>new</code> keyword and diamond form</h3><p><a href="https://docs.oracle.com/javase/specs/jls/se18/html/jls-15.html#jls-15.9">Section 15.9</a> of the JLS has the following in bold:</p><blockquote><p><strong>It is a compile-time error if a class instance creation expression provides type arguments to a constructor but uses the diamond form for type arguments to the class.</strong></p></blockquote><p>Let’s investigate. Here’s a small Java program:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Caveat</span>&lt;T&gt; &#123;<br>  <span class="hljs-keyword">public</span> &lt;E&gt; Caveat(T t, E e) &#123;&#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">var</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> LocalDate.now();<br>    <span class="hljs-type">var</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><br>    <span class="hljs-keyword">new</span> &lt;String&gt; Caveat&lt;&gt;(t, e);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>The class <code>Caveat</code> is generic on <code>&lt;T&gt;</code>. It declares a single constructor which is generic on <code>&lt;E&gt;</code>. In the <code>main</code> method it tries to create a new instance of the <code>Caveat</code> class.</p><p>Let’s compile it:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">$ javac src/main/java/iter3/Caveat.java<br>src/main/java/iter3/Caveat.java:<span class="hljs-number">17</span>: error: cannot infer type arguments <span class="hljs-keyword">for</span> Caveat&lt;T&gt;<br>    <span class="hljs-keyword">new</span> &lt;String&gt; Caveat&lt;&gt;(t, e);<br>                       ^<br>  reason: cannot use <span class="hljs-string">&#x27;&lt;&gt;&#x27;</span> with explicit type parameters <span class="hljs-keyword">for</span> constructor<br>  where T is a type-variable:<br>    T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Object</span> declared in <span class="hljs-keyword">class</span> <span class="hljs-title class_">Caveat</span><br><span class="hljs-number">1</span> error<br></code></pre></td></tr></table></figure><p>Here’s the explanation from the JLS:</p><blockquote><p>This rule is introduced because inference of a generic class’s type arguments may influence the constraints on a generic constructor’s type arguments.</p></blockquote><p>To be honest, I was not able to understand it. In any case, to fix the compilation error we replace the diamond form:</p><pre><code class="hljs">new &lt;String&gt; Caveat&lt;LocalDate&gt;(t, e);</code></pre><p>With an explicit <code>&lt;LocalDate&gt;</code>. The code now compiles.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In this blog post we discussed a few topics on generic constructors. A feature of the Java language I did not know until recently.</p><p>We have seen how it is rarely used in the JDK source code. Is it safe to extrapolate and say that it is rarely used in general? I personally believe it is. But don’t take my word for it.</p><p>We then saw an example exercising a possible use-case.</p><p>Finally, we saw how to invoke generic constructors using:</p><ul><li>  <code>new</code> keyword; and</li><li>  <code>this</code> keyword (which can be equally applied to the <code>super</code> keyword).</li></ul><p>The source code of the examples in this post can be found in this <a href="https://github.com/objectos/blog-examples/tree/master/p011-generic-constructors">GitHub repository</a>.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.objectos.com.br/blog/java-generic-constructors.html">Things I didn’t know about Java: Generic Constructors</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Guide to Java HashMap</title>
    <link href="/2022/09/13/java/Guide-to-Java-HashMap/"/>
    <url>/2022/09/13/java/Guide-to-Java-HashMap/</url>
    
    <content type="html"><![CDATA[<p><strong>HashMap in Java</strong> is a collection class that implements the Map interface. It is used to store key &amp; value pairs. Each key is mapped to a single value in the map.</p><p>Keys are unique. It means we can insert a key ‘K’ only once in a map. Duplicate keys are not allowed. Though a value <code>&#39;V&#39;</code> can be mapped to multiple keys.</p><h2 id="1-java-util-HashMap-Class"><a href="#1-java-util-HashMap-Class" class="headerlink" title="1. java.util.HashMap Class"></a>1. <em>java.util.HashMap</em> Class</h2><h3 id="1-1-HashMap-class-declaration"><a href="#1-1-HashMap-class-declaration" class="headerlink" title="1.1. HashMap class declaration"></a>1.1. HashMap class declaration</h3><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">HashMap</a> has been declared as follows:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K,V&gt;<br><span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable<br></code></pre></td></tr></table></figure><h3 id="1-2-HashMap-class-Hierarchy"><a href="#1-2-HashMap-class-Hierarchy" class="headerlink" title="1.2. HashMap class Hierarchy"></a>1.2. HashMap class Hierarchy</h3><p>As shown above, HashMap implements <code>Map</code> interface and extends <code>AbstractMap</code> class.</p><p><img src="img.png"></p><h2 id="2-Java-HashMap-Features"><a href="#2-Java-HashMap-Features" class="headerlink" title="2. Java HashMap Features"></a>2. Java HashMap Features</h2><ul><li>  HashMap cannot contain duplicate keys.</li><li>  HashMap allows multiple <code>null</code> values but only one <code>null</code> key.</li><li>  HashMap is an <strong>unordered collection</strong>. It does not guarantee any specific order of the elements.</li><li>  HashMap is <strong>not thread-safe</strong>. You must explicitly synchronize concurrent modifications to the HashMap. Or you can use <strong>Collections.synchronizedMap(hashMap)</strong> to get the synchronized version of HashMap.</li><li>  A value can be retrieved only using the associated key.</li><li>  HashMap stores only object references. So primitives must be used with their corresponding wrapper classes. Such as <code>int</code></li><li>  will be stored as <code>Integer</code>.</li><li>  HashMap implements <strong>Cloneable</strong> and <strong>Serializable</strong> interfaces.</li></ul><h2 id="3-Internal-Implementation-of-HashMap"><a href="#3-Internal-Implementation-of-HashMap" class="headerlink" title="3. Internal Implementation of HashMap"></a>3. Internal Implementation of HashMap</h2><p>HashMap works on principle of hashing. Hashing is a way to assigning a unique code for any variable/object after applying any formula/algorithm on its properties. Each object in java has it’s <strong>hash code</strong> in such a way that two equal objects must produce the same hash code consistently.</p><h3 id="3-1-HashMap-Entry-class"><a href="#3-1-HashMap-Entry-class" class="headerlink" title="3.1. HashMap.Entry class"></a>3.1. HashMap.Entry class</h3><p>The key-value pairs are stored as instances of the inner class <code>HashMap.Entry</code> which has key and value mapping stored as attributes. key has been marked as <code>final</code>.</p><pre><code class="hljs">static class Entry&lt;K ,V&gt; implements Map.Entry&lt;K, V&gt;&#123;    final K key;    V value;    Entry&lt;K ,V&gt; next;    final int hash;    ...//More code goes here&#125;</code></pre><h3 id="3-2-Internal-working"><a href="#3-2-Internal-working" class="headerlink" title="3.2. Internal working"></a>3.2. Internal working</h3><p>All instances of <em>Entry</em> class are stored in an array declared as <code>&#39;transient Entry[] table&#39;</code>. For each key-value to be stored in HashMap, a hash value is calculated using the key’s hash code. This hash value is used to calculate the <strong>index</strong> in the array for storing Entry object.</p><p>In case of <strong>collision</strong>, where multiple keys are mapped to a single index location, a <strong>linked list</strong> is formed to store all such key-value pairs that should go in a single array index location.</p><p>While retrieving the value by key, the first index location is found using key’s hashcode. Then all elements are iterated in the LinkedList, and the correct value object is found by identifying the correct key using its <strong>equals()</strong> method.</p><h2 id="4-Java-HashMap-Example"><a href="#4-Java-HashMap-Example" class="headerlink" title="4. Java HashMap Example"></a>4. Java HashMap Example</h2><p>Let’s quickly go through some examples to work with HashMap in Java.</p><h3 id="4-1-Add-key-value-–-HashMap-put"><a href="#4-1-Add-key-value-–-HashMap-put" class="headerlink" title="4.1. Add key-value – HashMap.put()"></a>4.1. Add key-value – HashMap.put()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMapExample</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException<br>    &#123;<br>        HashMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        map.put(<span class="hljs-number">1</span>,  <span class="hljs-string">&quot;A&quot;</span>);<br>        map.put(<span class="hljs-number">2</span>,  <span class="hljs-string">&quot;B&quot;</span>);<br>        map.put(<span class="hljs-number">3</span>,  <span class="hljs-string">&quot;C&quot;</span>);<br><br>        System.out.println(map);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Program output.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<span class="hljs-number">1</span>=A, <span class="hljs-number">2</span>=B, <span class="hljs-number">3</span>=C&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-Get-value-by-key-–-HashMap-get"><a href="#4-2-Get-value-by-key-–-HashMap-get" class="headerlink" title="4.2. Get value by key – HashMap.get()"></a>4.2. Get value by key – HashMap.get()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>map.put(<span class="hljs-number">1</span>,  <span class="hljs-string">&quot;A&quot;</span>);<br>map.put(<span class="hljs-number">2</span>,  <span class="hljs-string">&quot;B&quot;</span>);<br>map.put(<span class="hljs-number">3</span>,  <span class="hljs-string">&quot;C&quot;</span>);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(<span class="hljs-number">2</span>);<br><br>System.out.println(<span class="hljs-string">&quot;The value is :: &quot;</span>+  value );<br></code></pre></td></tr></table></figure><p>Program output.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">The value is :: B<br></code></pre></td></tr></table></figure><h3 id="4-3-Remove-pair-by-key-–-HashMap-remove"><a href="#4-3-Remove-pair-by-key-–-HashMap-remove" class="headerlink" title="4.3. Remove pair by key – HashMap.remove()"></a>4.3. Remove pair by key – HashMap.remove()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;B&quot;</span>);<br>map.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;C&quot;</span>);<br><br>System.out.println(map);<br><br>map.remove(<span class="hljs-number">3</span>);<br><br>System.out.println(map);<br></code></pre></td></tr></table></figure><p>Program output.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<span class="hljs-number">1</span>=A, <span class="hljs-number">2</span>=B, <span class="hljs-number">3</span>=C&#125;<br>&#123;<span class="hljs-number">1</span>=A, <span class="hljs-number">2</span>=B&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-Iterate-a-HashMap"><a href="#4-4-Iterate-a-HashMap" class="headerlink" title="4.4. Iterate a HashMap"></a>4.4. Iterate a HashMap</h3><p>Please note that iterators of this class are <strong>fail-fast</strong> and if any structure modification is done after creation of iterator, it will throw <code>ConcurrentModificationException</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;B&quot;</span>);<br>map.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;C&quot;</span>);<br><br>System.out.println(<span class="hljs-string">&quot;//Iterate over keys&quot;</span>);<br><br>Iterator&lt;Integer&gt; itr = map.keySet().iterator();<br><br><span class="hljs-keyword">while</span> (itr.hasNext())<br>&#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> itr.next();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(key);<br><br>    System.out.println(<span class="hljs-string">&quot;The key is :: &quot;</span> + key + <span class="hljs-string">&quot;, and value is :: &quot;</span> + value );<br>&#125;<br><br>System.out.println(<span class="hljs-string">&quot;//Iterate over entries set&quot;</span>);<br><br>Iterator&lt;Entry&lt;Integer, String&gt;&gt; entryIterator = map.entrySet().iterator();<br><br><span class="hljs-keyword">while</span> (entryIterator.hasNext())<br>&#123;<br>    Entry&lt;Integer, String&gt; entry = entryIterator.next();<br><br>    System.out.println(<span class="hljs-string">&quot;The key is :: &quot;</span> + entry.getKey() + <span class="hljs-string">&quot;, and value is :: &quot;</span> + entry.getValue() );<br>&#125;<br></code></pre></td></tr></table></figure><p>Program output.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Iterate over keys</span><br>The key is :: <span class="hljs-number">1</span>, and value is :: A<br>The key is :: <span class="hljs-number">2</span>, and value is :: B<br>The key is :: <span class="hljs-number">3</span>, and value is :: C<br><br><span class="hljs-comment">//Iterate over entries set</span><br>The key is :: <span class="hljs-number">1</span>, and value is :: A<br>The key is :: <span class="hljs-number">2</span>, and value is :: B<br>The key is :: <span class="hljs-number">3</span>, and value is :: C<br></code></pre></td></tr></table></figure><h2 id="5-HashMap-Methods"><a href="#5-HashMap-Methods" class="headerlink" title="5. HashMap Methods"></a>5. HashMap Methods</h2><p>List of methods in HashMap class and their short description.</p><ol><li> <strong>void clear()</strong> : removes all the key-value pairs from the HashMap.</li><li> <strong>Object clone()</strong> : returns a shallow copy of the specified HashMap.</li><li> <strong>boolean containsKey(Object key)</strong> : returns <code>true</code> or <code>false</code> based on whether the specified key is found in the map or not.</li><li> <strong>boolean containsValue(Object Value)</strong> : Similar to containsKey() method, it looks for the specified value instead of key.</li><li> <strong>Object get(Object key)</strong> : returns the value for the specified key in the HashMap.</li><li> <strong>boolean isEmpty()</strong> : checks whether the map is empty.</li><li> <strong>Set keySet()</strong> : returns the <strong>Set</strong> of all keys stored in the HashMap.</li><li> <strong>Object put(Key k, Value v)</strong> : Inserts key-value pair into the HashMap.</li><li> <strong>int size()</strong> : returns the map size equal to the number of key-value pairs stored in the HashMap.</li><li> <strong>Collection values()</strong> : returns a collection of all values in the map.</li><li> <strong>Value remove(Object key)</strong> : removes the key-value pair for the specified key.</li><li> <strong>void putAll(Map m)</strong> : copies all the elements of a map to another specified map.</li></ol><h2 id="6-HashMap-Examples"><a href="#6-HashMap-Examples" class="headerlink" title="6. HashMap Examples"></a>6. HashMap Examples</h2><ul><li>  <a href="https://howtodoinjava.com/java/collections/hashmap/how-hashmap-works-in-java/">How HashMap works in Java</a></li><li>  <a href="https://howtodoinjava.com/java/collections/hashmap/performance-comparison-of-different-ways-to-iterate-over-hashmap/">Performance Comparison of Different Ways to Iterate over HashMap</a></li><li>  <a href="https://howtodoinjava.com/java/collections/hashmap/design-good-key-for-hashmap/">How to design a good custom key object for HashMap</a></li><li>  <a href="https://howtodoinjava.com/java/collections/hashmap-vs-hashtable/">Difference between HashMap and Hashtable in Java</a></li><li>  <a href="https://howtodoinjava.com/java/sort/java-sort-map-by-key/">Java sort Map by keys (ascending and descending orders)</a></li><li>  <a href="https://howtodoinjava.com/java/sort/java-sort-map-by-values/">Java sort Map by values (ascending and descending orders)</a></li><li>  <a href="https://howtodoinjava.com/java/basics/java-hashcode-equals-methods/">Java hashCode() and equals() – Contract, rules and best practices</a></li><li>  <a href="https://howtodoinjava.com/interview-questions/hashmap-concurrenthashmap-interview-questions/">HashMap and ConcurrentHashMap Interview Questions</a></li><li>  <a href="https://howtodoinjava.com/java/multi-threading/best-practices-for-using-concurrenthashmap/">Java ConcurrentHashMap Best Practices</a></li><li>  <a href="https://howtodoinjava.com/jackson/jackson-json-to-from-hashmap/">Convert JSON to Map and Map to JSON</a></li><li>  <a href="https://howtodoinjava.com/jaxb/jaxb-example-marshalling-and-unmarshalling-hashmap-in-java/">Marshal and Unmarshal HashMap in Java</a></li><li>  <a href="https://howtodoinjava.com/java/string/how-to-find-duplicate-words-in-a-string-in-java/">How to Find Duplicate Words in String using HashMap</a></li><li>  <a href="https://howtodoinjava.com/java/collections/hashmap/compare-two-hashmaps/">Compare two hashmaps</a></li><li>  <a href="https://howtodoinjava.com/java/collections/hashmap/synchronize-hashmap/">Synchronize HashMap</a></li><li>  <a href="https://howtodoinjava.com/java/collections/hashmap/merge-two-hashmaps/">Merge two HashMaps</a></li><li>  <a href="https://howtodoinjava.com/java/collections/hashmap/shallow-deep-copy-hashmap/">How to clone a HashMap</a></li></ul><h2 id="7-References"><a href="#7-References" class="headerlink" title="7. References"></a>7. References</h2><ul><li><a href="https://howtodoinjava.com/java/collections/hashmap/java-hashmap/">Guide to Java HashMap</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>hasMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD分层架构、洋葱架构、六边形架构</title>
    <link href="/2022/09/13/java/DDD%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E3%80%81%E6%B4%8B%E8%91%B1%E6%9E%B6%E6%9E%84%E3%80%81%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84/"/>
    <url>/2022/09/13/java/DDD%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E3%80%81%E6%B4%8B%E8%91%B1%E6%9E%B6%E6%9E%84%E3%80%81%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="一、DDD分层架构"><a href="#一、DDD分层架构" class="headerlink" title="一、DDD分层架构"></a>一、DDD分层架构</h2><p>DDD分层架构中有很重要的依赖原则：每层只能与位于下方的层发生耦合，类似于网络的7层或TCP/IP的4层模型架构，每一层各司其职，并且只关心向下一层的实现，而不会出现各层耦合。</p><p>DDD分层架构中包含四层：从上到下分别是用户接口层，应用层，领域层和基础层。</p><p><img src="DDD%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84.png"></p><h2 id="二、洋葱架构"><a href="#二、洋葱架构" class="headerlink" title="二、洋葱架构"></a>二、洋葱架构</h2><p>2008年Jeffrey Palermo已经提出了具有分层思想的洋葱架构，如下图，同心圆代表软件的不同部分，从里向外依次是领域模型，领域服务，应用服务和外层的基础设施和用户终端。</p><p>洋葱架构根据依赖原则，定义了各层的依赖关系，越往里依赖程度越低，代码级别越高，越是核心能力。外圆代码依赖只能指向内圆，内圆不需要知道外圆的情况，这种架构也是典型的分层架构，和DDD分层架构一样，都体现了高内聚，低耦合的设计特性。洋葱架构也常作为指导微服务设计的重要架构之一。</p><p><img src="%E6%B4%8B%E8%91%B1%E6%9E%B6%E6%9E%84.png"></p><h2 id="三、六边形架构"><a href="#三、六边形架构" class="headerlink" title="三、六边形架构"></a>三、六边形架构</h2><p>2005年Alistair Cockburn提出了六边形架构，在这个架构中，将应用分为内六边形和外六边形两层，内六边形实现应用的核心业务逻辑。外六边形完成外部应用，基础资源等的交互和访问，对于与不同的外部系统交互，由外六边形的适配器负责协议转换，保证内六边形业务逻辑的干净。</p><p>这种架构也是典型的分层架构，和DDD分层架构一样，都体现了高内聚，低耦合的设计特性。六边形也常作为指导微服务设计的重要架构之一。</p><p><img src="%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84.png"></p><h2 id="四、DDD分层协作"><a href="#四、DDD分层协作" class="headerlink" title="四、DDD分层协作"></a>四、DDD分层协作</h2><p>DDD各层的主要职责和怎么分工协作如下图：</p><p><img src="DDD%E5%88%86%E5%B1%82%E5%8D%8F%E4%BD%9C.png"></p><p>PO（数据持久化对象）：与数据库字段映射的数据载体</p><p>DO（领域对象）：领域模型核心业务对象的载体，包括实体和值对象</p><p>DTO（数据传输对象）：用于前端和微服务交互的数据传输载体</p><p><strong>用户接口层：主要有facade接口，Assembler转换器</strong></p><ul><li>微服务面向不同前端时，需要展示的数据可能不同，此时由于需要保持领域核心业务逻辑的稳定，不可能去定制开发各种领域服务和应用服务编排。因此，为避免暴露服务端业务逻辑，防止非必需的字段数据外泄<br>，同时保证领域逻辑的干净，用户接口层的facade接口和Assembler转换器就发挥作用了。</li><li>facade接口用于封装应用服务，适配不同前端需要的字段，提供不同要求的服务接口适配。Assembler根据不同前端的数据请求，完成DTO和领域DO对象的组装，转换，完成数据适配。</li></ul><p><strong>应用层：</strong></p><ul><li><p>应用层连接用户接口层和领域层，主要协调领域层，面向用例和业务流程，协调多个聚合完成服务的组合和编排，在这一层不实现任何业务逻辑，只是很薄的一层</p></li><li><p>如何判定一个东西是否属于业务逻辑？</p><p>很简单，只需设想你和产品聊这个事情时，需不需要把这部分信息输入给它？比如接口调用的处理，数据的转换，是否加了缓存等等都不属于产品关心的东西，所以不算是业务逻辑</p></li><li><p>应用层编排成应用服务后，被接口层facade封装，完成接口和数据适配后，以粗粒度向API网关发布服务</p></li><li><p>应用层还负责事件的订阅和发布，以及与其他外部服务的交互，事件的具体实现则在领域层</p></li></ul><p><strong>领域层：</strong></p><ul><li>领域层位于应用层之下，是领域模型的核心，主要实现领域模型的核心业务逻辑，体现领域模型的业务能力</li><li>领域层关注实现领域对象的充血模型和聚合本身的原子业务逻辑，至于用户操作和业务流程，则交给应用层去编排。这样设计可以保证领域模型不容易受外部需求变化的影响，保证领域模型的稳定</li><li>跨多个聚合的领域逻辑在领域层实现，由领域服务组织和协调多聚合的多实体，实现原子业务逻辑</li></ul><p><strong>基础层：</strong></p><ul><li>基础层贯穿了DDD所有层，包括第三方工具，API网关，消息中间件，分布式事务，消息最终一致性能力，数据库，缓存能能力的提供。</li><li>基础层有仓储模式的代码逻辑，通过仓储接口和仓储实现，解耦领域层和基础层，保证领域核心业务逻辑的干净，降低DB资源变化给领域层带来的影响，这部分内容，请见下回分解。</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li>《基于DDD和微服务的中台架构与实现》欧创新、邓頔</li><li>《领域驱动设计》Eric Evans</li><li>《架构真经》Martin L. Abbott</li><li><a href="https://www.cnblogs.com/jiyukai/p/14830869.html">DDD—分层架构、洋葱架构、六边形架构</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>architecture</tag>
      
      <tag>DDD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>COLA 4.0:应用架构的最佳实践</title>
    <link href="/2022/09/13/java/COLA%204.0%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <url>/2022/09/13/java/COLA%204.0%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://blog.csdn.net/significantfrank/article/details/110934799">COLA 4.0：应用架构的最佳实践</a></li><li><a href="https://github.com/alibaba/COLA">COLA</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>architecture</tag>
      
      <tag>COLA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Collections in Java</title>
    <link href="/2022/09/13/java/Collections%20in%20Java/"/>
    <url>/2022/09/13/java/Collections%20in%20Java/</url>
    
    <content type="html"><![CDATA[<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://howtodoinjava.com/java-collections/">Collections in Java</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>Collections</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/09/13/hello-world/"/>
    <url>/2022/09/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>5种限流算法,7种限流方式,挡住突发流量</title>
    <link href="/2022/09/13/java/5%20%E7%A7%8D%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%EF%BC%8C7%20%E7%A7%8D%E9%99%90%E6%B5%81%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%8C%A1%E4%BD%8F%E7%AA%81%E5%8F%91%E6%B5%81%E9%87%8F/"/>
    <url>/2022/09/13/java/5%20%E7%A7%8D%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%EF%BC%8C7%20%E7%A7%8D%E9%99%90%E6%B5%81%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%8C%A1%E4%BD%8F%E7%AA%81%E5%8F%91%E6%B5%81%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img.wdbyte.com/git/2021/20220314204028.png"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近几年，随着微服务的流行，服务和服务之间的依赖越来越强，调用关系越来越复杂，服务和服务之间的<strong>稳定性</strong>越来越重要。在遇到突发的请求量激增，恶意的用户访问，亦或请求频率过高给下游服务带来较大压力时，我们常常需要通过缓存、限流、熔断降级、负载均衡等多种方式保证服务的稳定性。其中<strong>限流</strong>是不可或缺的一环，这篇文章介绍<strong>限流</strong>相关知识。</p><h2 id="1-限流"><a href="#1-限流" class="headerlink" title="1. 限流"></a>1. 限流</h2><p><strong>限流</strong>顾名思义，就是对请求或并发数进行限制；通过对一个时间窗口内的请求量进行限制来保障系统的正常运行。如果我们的服务资源有限、处理能力有限，就需要对调用我们服务的上游请求进行限制，以防止自身服务由于资源耗尽而停止服务。</p><p>在限流中有两个概念需要了解。</p><ul><li>  <strong>阈值</strong>：在一个单位时间内允许的请求量。如 QPS 限制为10，说明 1 秒内最多接受 10 次请求。</li><li>  <strong>拒绝策略</strong>：超过阈值的请求的拒绝策略，常见的拒绝策略有直接拒绝、排队等待等。</li></ul><h2 id="2-固定窗口算法"><a href="#2-固定窗口算法" class="headerlink" title="2. 固定窗口算法"></a>2. 固定窗口算法</h2><p><strong>固定窗口算法</strong>又叫<strong>计数器算法</strong>，是一种<strong>简单</strong>方便的限流算法。主要通过一个支持<strong>原子操作</strong>的计数器来累计 1 秒内的请求次数，当 1 秒内计数达到限流阈值时触发拒绝策略。每过 1 秒，计数器重置为 0 开始重新计数。</p><h3 id="2-1-代码实现"><a href="#2-1-代码实现" class="headerlink" title="2.1. 代码实现"></a>2.1. 代码实现</h3><p>下面是简单的代码实现，QPS 限制为 2，这里的代码做了一些<strong>优化</strong>，并没有单独开一个线程去每隔 1 秒重置计数器，而是在每次调用时进行时间间隔计算来确定是否先重置计数器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> https://www.wdbyte.com</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimiterSimpleWindow</span> &#123;<br>    <span class="hljs-comment">// 阈值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">QPS</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 时间窗口（毫秒）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-variable">TIME_WINDOWS</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>    <span class="hljs-comment">// 计数器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">REQ_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-variable">START_TIME</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> ((System.currentTimeMillis() - START_TIME) &gt; TIME_WINDOWS) &#123;<br>            REQ_COUNT.set(<span class="hljs-number">0</span>);<br>            START_TIME = System.currentTimeMillis();<br>        &#125;<br>        <span class="hljs-keyword">return</span> REQ_COUNT.incrementAndGet() &lt;= QPS;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            Thread.sleep(<span class="hljs-number">250</span>);<br>            <span class="hljs-type">LocalTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalTime.now();<br>            <span class="hljs-keyword">if</span> (!tryAcquire()) &#123;<br>                System.out.println(now + <span class="hljs-string">&quot; 被限流&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(now + <span class="hljs-string">&quot; 做点什么&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs log">20:53:43.038922 做点什么<br>20:53:43.291435 做点什么<br>20:53:43.543087 被限流<br>20:53:43.796666 做点什么<br>20:53:44.050855 做点什么<br>20:53:44.303547 被限流<br>20:53:44.555008 被限流<br>20:53:44.809083 做点什么<br>20:53:45.063828 做点什么<br>20:53:45.314433 被限流<br></code></pre></td></tr></table></figure><p>从输出结果中可以看到大概每秒操作 3 次，由于限制 QPS 为 2，所以平均会有一次被限流。看起来可以了，不过我们思考一下就会发现这种简单的限流方式是有问题的，虽然我们限制了 QPS 为 2，但是当遇到时间窗口的临界突变时，如 1s 中的后 500 ms 和第 2s 的前 500ms 时，虽然是加起来是 1s 时间，却可以被请求 4 次。</p><p><img src="https://img.wdbyte.com/git/2021/20220223215006.png" alt="固定窗口算法"></p><p>简单修改测试代码，可以进行验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先休眠 400ms，可以更快的到达时间窗口。</span><br>Thread.sleep(<span class="hljs-number">400</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    Thread.sleep(<span class="hljs-number">250</span>);<br>    <span class="hljs-keyword">if</span> (!tryAcquire()) &#123;<br>        System.out.println(<span class="hljs-string">&quot;被限流&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;做点什么&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>得到输出中可以看到连续 4 次请求，间隔 250 ms 没有却被限制。：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">20:51:17.395087 做点什么<br>20:51:17.653114 做点什么<br>20:51:17.903543 做点什么<br>20:51:18.154104 被限流<br>20:51:18.405497 做点什么<br>20:51:18.655885 做点什么<br>20:51:18.906177 做点什么<br>20:51:19.158113 被限流<br>20:51:19.410512 做点什么<br>20:51:19.661629 做点什么<br></code></pre></td></tr></table></figure><h2 id="3-滑动窗口算法"><a href="#3-滑动窗口算法" class="headerlink" title="3. 滑动窗口算法"></a>3. 滑动窗口算法</h2><p>我们已经知道固定窗口算法的实现方式以及它所存在的问题，而滑动窗口算法是对固定窗口算法的改进。既然固定窗口算法在遇到时间窗口的临界突变时会有问题，那么我们在遇到下一个时间窗口前也调整时间窗口不就可以了吗？</p><p>下面是滑动窗口的示意图。</p><p><img src="https://img.wdbyte.com/git/2021/20220223215316.png" alt="滑动窗口算法"></p><p>上图的示例中，每 500ms 滑动一次窗口，可以发现窗口滑动的间隔越短，时间窗口的临界突变问题发生的概率也就越小，不过只要有时间窗口的存在，还是有可能发生<strong>时间窗口的临界突变问题</strong>。</p><h3 id="3-1-代码实现"><a href="#3-1-代码实现" class="headerlink" title="3.1. 代码实现"></a>3.1. 代码实现</h3><p>下面是基于以上滑动窗口思路实现的简单的滑动窗口限流工具类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wdbyte.rate.limiter;<br><br><span class="hljs-keyword">import</span> java.time.LocalTime;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 滑动窗口限流工具类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> https://www.wdbyte.com</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimiterSlidingWindow</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 阈值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">qps</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 时间窗口总大小（毫秒）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">windowSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 多少个子窗口</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">windowCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 窗口列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> WindowInfo[] windowArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowInfo</span>[windowCount];<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RateLimiterSlidingWindow</span><span class="hljs-params">(<span class="hljs-type">int</span> qps)</span> &#123;<br>        <span class="hljs-built_in">this</span>.qps = qps;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">currentTimeMillis</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; windowArray.length; i++) &#123;<br>            windowArray[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowInfo</span>(currentTimeMillis, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 计算当前时间窗口</span><br><span class="hljs-comment">     * 2. 更新当前窗口计数 &amp; 重置过期窗口计数</span><br><span class="hljs-comment">     * 3. 当前 QPS 是否超过限制</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">currentTimeMillis</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">// 1. 计算当前时间窗口</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">currentIndex</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(currentTimeMillis % windowSize / (windowSize / windowCount));<br>        <span class="hljs-comment">// 2.  更新当前窗口计数 &amp; 重置过期窗口计数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; windowArray.length; i++) &#123;<br>            <span class="hljs-type">WindowInfo</span> <span class="hljs-variable">windowInfo</span> <span class="hljs-operator">=</span> windowArray[i];<br>            <span class="hljs-keyword">if</span> ((currentTimeMillis - windowInfo.getTime()) &gt; windowSize) &#123;<br>                windowInfo.getNumber().set(<span class="hljs-number">0</span>);<br>                windowInfo.setTime(currentTimeMillis);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (currentIndex == i &amp;&amp; windowInfo.getNumber().get() &lt; qps) &#123;<br>                windowInfo.getNumber().incrementAndGet();<br>            &#125;<br>            sum = sum + windowInfo.getNumber().get();<br>        &#125;<br>        <span class="hljs-comment">// 3. 当前 QPS 是否超过限制</span><br>        <span class="hljs-keyword">return</span> sum &lt;= qps;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowInfo</span> &#123;<br>        <span class="hljs-comment">// 窗口开始时间</span><br>        <span class="hljs-keyword">private</span> Long time;<br>        <span class="hljs-comment">// 计数器</span><br>        <span class="hljs-keyword">private</span> AtomicInteger number;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">WindowInfo</span><span class="hljs-params">(<span class="hljs-type">long</span> time, AtomicInteger number)</span> &#123;<br>            <span class="hljs-built_in">this</span>.time = time;<br>            <span class="hljs-built_in">this</span>.number = number;<br>        &#125;<br>        <span class="hljs-comment">// get...set...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>77</p><p>下面是测试用例，设置 QPS 为 2,测试次数 20 次，每次间隔 300 毫秒，预计成功次数在 12 次左右。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">qps</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>, count = <span class="hljs-number">20</span>, sleep = <span class="hljs-number">300</span>, success = count * sleep / <span class="hljs-number">1000</span> * qps;<br>    System.out.println(String.format(<span class="hljs-string">&quot;当前QPS限制为:%d,当前测试次数:%d,间隔:%dms,预计成功次数:%d&quot;</span>, qps, count, sleep, success));<br>    success = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">RateLimiterSlidingWindow</span> <span class="hljs-variable">myRateLimiter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RateLimiterSlidingWindow</span>(qps);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        Thread.sleep(sleep);<br>        <span class="hljs-keyword">if</span> (myRateLimiter.tryAcquire()) &#123;<br>            success++;<br>            <span class="hljs-keyword">if</span> (success % qps == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(LocalTime.now() + <span class="hljs-string">&quot;: success, &quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.print(LocalTime.now() + <span class="hljs-string">&quot;: success, &quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(LocalTime.now() + <span class="hljs-string">&quot;: fail&quot;</span>);<br>        &#125;<br>    &#125;<br>    System.out.println();<br>    System.out.println(<span class="hljs-string">&quot;实际测试成功次数:&quot;</span> + success);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是测试的结果。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">当前QPS限制为:2,当前测试次数:20,间隔:300ms,预计成功次数:12<br>16:04:27.077782: success, 16:04:27.380715: success, <br>16:04:27.684244: fail<br>16:04:27.989579: success, 16:04:28.293347: success, <br>16:04:28.597658: fail<br>16:04:28.901688: fail<br>16:04:29.205262: success, 16:04:29.507117: success, <br>16:04:29.812188: fail<br>16:04:30.115316: fail<br>16:04:30.420596: success, 16:04:30.725897: success, <br>16:04:31.028599: fail<br>16:04:31.331047: fail<br>16:04:31.634127: success, 16:04:31.939411: success, <br>16:04:32.242380: fail<br>16:04:32.547626: fail<br>16:04:32.847965: success, <br>实际测试成功次数:11<br></code></pre></td></tr></table></figure><h2 id="4-滑动日志算法"><a href="#4-滑动日志算法" class="headerlink" title="4. 滑动日志算法"></a>4. 滑动日志算法</h2><p>滑动日志算法是实现限流的另一种方法，这种方法比较简单。基本逻辑就是记录下所有的请求时间点，新请求到来时先判断最近指定时间范围内的请求数量是否超过指定阈值，由此来确定是否达到限流，这种方式没有了时间窗口突变的问题，限流比较准确，但是因为要记录下每次请求的时间点，所以<strong>占用的内存较多</strong>。</p><h3 id="4-1-代码实现"><a href="#4-1-代码实现" class="headerlink" title="4.1. 代码实现"></a>4.1. 代码实现</h3><p>下面是简单实现的 一个滑动日志算法，因为滑动日志要每次请求单独存储一条记录，可能占用内存过多。所以下面这个实现其实不算严谨的滑动日志，更像一个把 1 秒时间切分成 1000 个时间窗口的滑动窗口算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wdbyte.rate.limiter;<br><br><span class="hljs-keyword">import</span> java.time.LocalTime;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> java.util.TreeMap;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 滑动日志方式限流</span><br><span class="hljs-comment"> * 设置 QPS 为 2.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> https://www.wdbyte.com</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimiterSildingLog</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 阈值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">qps</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 记录请求的时间戳,和数量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> TreeMap&lt;Long, Long&gt; treeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 清理请求记录间隔, 60 秒</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">claerTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RateLimiterSildingLog</span><span class="hljs-params">(Integer qps)</span> &#123;<br>        <span class="hljs-built_in">this</span>.qps = qps;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">// 清理过期的数据老数据，最长 60 秒清理一次</span><br>        <span class="hljs-keyword">if</span> (!treeMap.isEmpty() &amp;&amp; (treeMap.firstKey() - now) &gt; claerTime) &#123;<br>            Set&lt;Long&gt; keySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(treeMap.subMap(<span class="hljs-number">0L</span>, now - <span class="hljs-number">1000</span>).keySet());<br>            <span class="hljs-keyword">for</span> (Long key : keySet) &#123;<br>                treeMap.remove(key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 计算当前请求次数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Long value : treeMap.subMap(now - <span class="hljs-number">1000</span>, now).values()) &#123;<br>            sum += value;<br>        &#125;<br>        <span class="hljs-comment">// 超过QPS限制，直接返回 false</span><br>        <span class="hljs-keyword">if</span> (sum + <span class="hljs-number">1</span> &gt; qps) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 记录本次请求</span><br>        <span class="hljs-keyword">if</span> (treeMap.containsKey(now)) &#123;<br>            treeMap.compute(now, (k, v) -&gt; v + <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            treeMap.put(now, <span class="hljs-number">1L</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum &lt;= qps;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">RateLimiterSildingLog</span> <span class="hljs-variable">rateLimiterSildingLog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RateLimiterSildingLog</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            Thread.sleep(<span class="hljs-number">250</span>);<br>            <span class="hljs-type">LocalTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalTime.now();<br>            <span class="hljs-keyword">if</span> (rateLimiterSildingLog.tryAcquire()) &#123;<br>                System.out.println(now + <span class="hljs-string">&quot; 做点什么&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(now + <span class="hljs-string">&quot; 被限流&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中把阈值 QPS 设定为 3，运行可以得到如下日志：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">20:51:17.395087 做点什么<br>20:51:17.653114 做点什么<br>20:51:17.903543 做点什么<br>20:51:18.154104 被限流<br>20:51:18.405497 做点什么<br>20:51:18.655885 做点什么<br>20:51:18.906177 做点什么<br>20:51:19.158113 被限流<br>20:51:19.410512 做点什么<br>20:51:19.661629 做点什么<br></code></pre></td></tr></table></figure><h2 id="5-漏桶算法"><a href="#5-漏桶算法" class="headerlink" title="5. 漏桶算法"></a>5. 漏桶算法</h2><p>漏桶算法中的漏桶是一个形象的比喻，这里可以用生产者消费者模式进行说明，请求是一个生产者，每一个请求都如一滴水，请求到来后放到一个队列（漏桶）中，而桶底有一个孔，不断的漏出水滴，就如消费者不断的在消费队列中的内容，消费的速率（漏出的速度）等于限流阈值。即假如 QPS 为 2，则每 <code>1s / 2= 500ms</code> 消费一次。漏桶的桶有大小，就如队列的容量，当请求堆积超过指定容量时，会触发拒绝策略。</p><p>下面是漏桶算法的示意图。</p><p><img src="https://img.wdbyte.com/git/2021/20220225161827.png" alt="漏桶算法"></p><p>由介绍可以知道，漏桶模式中的消费处理总是能以恒定的速度进行，可以很好的<strong>保护自身系统</strong>不被突如其来的流量冲垮；但是这也是漏桶模式的缺点，假设 QPS 为 2，同时 2 个请求进来，2 个请求并不能同时进行处理响应，因为每 <code>1s / 2= 500ms</code> 只能处理一个请求。</p><h2 id="6-令牌桶算法"><a href="#6-令牌桶算法" class="headerlink" title="6. 令牌桶算法"></a>6. 令牌桶算法</h2><p>令牌桶算法同样是实现限流是一种常见的思路，最为常用的 Google 的 Java 开发工具包 Guava 中的限流工具类 RateLimiter 就是令牌桶的一个实现。令牌桶的实现思路类似于生产者和消费之间的关系。</p><p>系统服务作为生产者，按照指定频率向桶（容器）中添加令牌，如 QPS 为 2，每 500ms 向桶中添加一个令牌，如果桶中令牌数量达到阈值，则不再添加。</p><p>请求执行作为消费者，每个请求都需要去桶中拿取一个令牌，取到令牌则继续执行；如果桶中无令牌可取，就触发拒绝策略，可以是超时等待，也可以是直接拒绝本次请求，由此达到限流目的。</p><p>下面是令牌桶限流算法示意图。</p><p><img src="https://img.wdbyte.com/git/2021/20220225160801.png" alt="令牌桶算法"></p><p>思考令牌桶的实现可以以下特点。</p><ol><li> 1s / 阈值（QPS） = 令牌添加时间间隔。</li><li> 桶的容量等于限流的阈值，令牌数量达到阈值时，不再添加。</li><li> 可以适应流量突发，N 个请求到来只需要从桶中获取 N 个令牌就可以继续处理。</li><li> 有启动过程，令牌桶启动时桶中无令牌，然后按照令牌添加时间间隔添加令牌，若启动时就有阈值数量的请求过来，会因为桶中没有足够的令牌而触发拒绝策略，不过如 RateLimiter 限流工具已经优化了这类问题。</li></ol><h3 id="6-1-代码实现"><a href="#6-1-代码实现" class="headerlink" title="6.1. 代码实现"></a>6.1. 代码实现</h3><p>Google 的 Java 开发工具包 Guava 中的限流工具类 RateLimiter 就是令牌桶的一个实现，日常开发中我们也不会手动实现了，这里直接使用 RateLimiter 进行测试。</p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>31.0.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br></code></pre></td></tr></table></figure><p>RateLimiter 限流体验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// qps 2</span><br><span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> RateLimiter.create(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_TIME);<br>    System.out.println(time + <span class="hljs-string">&quot;:&quot;</span> + rateLimiter.tryAcquire());<br>    Thread.sleep(<span class="hljs-number">250</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中限制 QPS 为 2，也就是每隔 500ms 生成一个令牌，但是程序每隔 250ms 获取一次令牌，所以两次获取中只有一次会成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">17:19:06.797557:true<br>17:19:07.061419:false<br>17:19:07.316283:true<br>17:19:07.566746:false<br>17:19:07.817035:true<br>17:19:08.072483:false<br>17:19:08.326347:true<br>17:19:08.577661:false<br>17:19:08.830252:true<br>17:19:09.085327:false<br></code></pre></td></tr></table></figure><h3 id="6-2-思考"><a href="#6-2-思考" class="headerlink" title="6.2. 思考"></a>6.2. 思考</h3><p>虽然演示了 Google Guava 工具包中的 RateLimiter 的实现，但是我们需要思考一个问题，就是令牌的添加方式，如果按照指定间隔添加令牌，那么需要开一个线程去定时添加，如果有很多个接口很多个 RateLimiter 实例，<strong>线程数会随之增加</strong>，这显然不是一个好的办法。显然 Google 也考虑到了这个问题，在 RateLimiter 中，是<strong>在每次令牌获取时才进行计算令牌是否足够的</strong>。它通过存储的下一个令牌生成的时间，和当前获取令牌的时间差，再结合阈值，去计算令牌是否足够，同时再记录下一个令牌的生成时间以便下一次调用。</p><p>下面是 Guava 中 RateLimiter 类的子类 SmoothRateLimiter 的 <code>resync()</code> 方法的代码分析，可以看到其中的令牌计算逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">resync</span><span class="hljs-params">(<span class="hljs-type">long</span> nowMicros)</span> &#123; <span class="hljs-comment">// 当前微秒时间</span><br>    <span class="hljs-comment">// 当前时间是否大于下一个令牌生成时间</span><br>    <span class="hljs-keyword">if</span> (nowMicros &gt; <span class="hljs-built_in">this</span>.nextFreeTicketMicros) &#123; <br>      <span class="hljs-comment">// 可生成的令牌数 newPermits = （当前时间 - 下一个令牌生成时间）/ 令牌生成时间间隔。</span><br>      <span class="hljs-comment">// 如果 QPS 为2，这里的 coolDownIntervalMicros 就是 500000.0 微秒(500ms)</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">newPermits</span> <span class="hljs-operator">=</span> (<span class="hljs-type">double</span>)(nowMicros - <span class="hljs-built_in">this</span>.nextFreeTicketMicros) / <span class="hljs-built_in">this</span>.coolDownIntervalMicros();<br><span class="hljs-comment">// 更新令牌库存 storedPermits。</span><br>      <span class="hljs-built_in">this</span>.storedPermits = Math.min(<span class="hljs-built_in">this</span>.maxPermits, <span class="hljs-built_in">this</span>.storedPermits + newPermits);<br><span class="hljs-comment">// 更新下一个令牌生成时间 nextFreeTicketMicros</span><br>      <span class="hljs-built_in">this</span>.nextFreeTicketMicros = nowMicros;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-Redis-分布式限流"><a href="#7-Redis-分布式限流" class="headerlink" title="7. Redis 分布式限流"></a>7. Redis 分布式限流</h2><p>Redis 是一个开源的内存数据库，可以用来作为数据库、缓存、消息中间件等。Redis 是单线程的，又在内存中操作，所以速度极快，得益于 Redis 的各种特性，所以使用 Redis 实现一个限流工具是十分方便的。</p><p>下面的演示都基于Spring Boot 项目，并需要以下依赖。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>配置 Redis 信息。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">password:</span> <br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">shutdown-timeout:</span> <span class="hljs-string">100ms</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">5</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">10</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-string">1ms</span><br></code></pre></td></tr></table></figure><h3 id="7-1-固定窗口限流"><a href="#7-1-固定窗口限流" class="headerlink" title="7.1. 固定窗口限流"></a>7.1. 固定窗口限流</h3><p>Redis 中的固定窗口限流是使用 <code>incr</code> 命令实现的，<code>incr</code> 命令通常用来自增计数；如果我们使用时间戳信息作为 key，自然就可以统计每秒的请求量了，以此达到限流目的。</p><p>这里有两点要注意。</p><ol><li> 对于不存在的 key，第一次新增时，value 始终为 1。</li><li> INCR 和 EXPIRE 命令操作应该在一个<strong>原子操作</strong>中提交，以保证每个 key 都正确设置了过期时间，不然会有 key 值无法自动删除而导致的内存溢出。</li></ol><p>由于 Redis 中实现事务的复杂性，所以这里直接只用 <code>lua</code> 脚本来实现原子操作。下面是 <code>lua</code> 脚本内容。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> count = redis.call(<span class="hljs-string">&quot;incr&quot;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">if</span> count == <span class="hljs-number">1</span> <span class="hljs-keyword">then</span><br>  redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">2</span>])<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">if</span> count &gt; <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">1</span>]) <span class="hljs-keyword">then</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>下面是使用 Spring Boot 中 <code>RedisTemplate</code> 来实现的 <code>lua</code> 脚本调用测试代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> https://www.wdbyte.com</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisLuaLimiterByIncr</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;limiter_&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QPS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;4&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXPIRE_TIME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">redisLuaLimiterTests</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, IOException &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">15</span>; i++) &#123;<br>            Thread.sleep(<span class="hljs-number">200</span>);<br>            System.out.println(LocalTime.now() + <span class="hljs-string">&quot; &quot;</span> + acquire(<span class="hljs-string">&quot;user1&quot;</span>));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计数器限流</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-comment">// 当前秒数作为 key</span><br>        key = KEY_PREFIX + key + System.currentTimeMillis() / <span class="hljs-number">1000</span>;<br>        DefaultRedisScript&lt;Long&gt; redisScript = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>        redisScript.setResultType(Long.class);<br>        <span class="hljs-comment">//lua文件存放在resources目录下</span><br>        redisScript.setScriptSource(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceScriptSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;limiter.lua&quot;</span>)));<br>        <span class="hljs-keyword">return</span> stringRedisTemplate.execute(redisScript, Arrays.asList(key), QPS, EXPIRE_TIME) == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中虽然限制了 QPS 为 4，但是因为这种限流实现是把毫秒时间戳作为 key 的，所以会有临界窗口突变的问题，下面是运行结果，可以看到因为时间窗口的变化，导致了 QPS 超过了限制值 4。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">17:38:23.122044 true<br>17:38:23.695124 true<br>17:38:23.903220 true<br><span class="hljs-meta prompt_"># </span><span class="language-bash">此处有时间窗口变化，所以下面继续 <span class="hljs-literal">true</span></span><br>17:38:24.106206 true<br>17:38:24.313458 true<br>17:38:24.519431 true<br>17:38:24.724446 true<br>17:38:24.932387 false<br>17:38:25.137912 true<br>17:38:25.355595 true<br>17:38:25.558219 true<br>17:38:25.765801 true<br>17:38:25.969426 false<br>17:38:26.176220 true<br>17:38:26.381918 true<br></code></pre></td></tr></table></figure><h3 id="7-3-滑动窗口限流"><a href="#7-3-滑动窗口限流" class="headerlink" title="7.3. 滑动窗口限流"></a>7.3. 滑动窗口限流</h3><p>通过对上面的基于 <code>incr</code> 命令实现的 Redis 限流方式的测试，我们已经发现了固定窗口限流所带来的问题，在这篇文章的第三部分已经介绍了滑动窗口限流的优势，它可以大幅度降低因为窗口临界突变带来的问题，那么如何使用 Redis 来实现滑动窗口限流呢？</p><p>这里主要使用 <code>ZSET</code> 有序集合来实现滑动窗口限流，<code>ZSET</code> 集合有下面几个特点：</p><ol><li> ZSET 集合中的 key 值可以自动排序。</li><li> ZSET 集合中的 value 不能有重复值。</li><li> ZSET 集合可以方便的使用 ZCARD 命令获取元素个数。</li><li> ZSET 集合可以方便的使用 ZREMRANGEBYLEX 命令移除指定范围的 key 值。</li></ol><p>基于上面的四点特性，可以编写出基于 <code>ZSET</code> 的滑动窗口限流 <code>lua</code> 脚本。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--KEYS[1]: 限流 key</span><br><span class="hljs-comment">--ARGV[1]: 时间戳 - 时间窗口</span><br><span class="hljs-comment">--ARGV[2]: 当前时间戳（作为score）</span><br><span class="hljs-comment">--ARGV[3]: 阈值</span><br><span class="hljs-comment">--ARGV[4]: score 对应的唯一value</span><br><span class="hljs-comment">-- 1. 移除时间窗口之前的数据</span><br>redis.call(<span class="hljs-string">&#x27;zremrangeByScore&#x27;</span>, KEYS[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>, ARGV[<span class="hljs-number">1</span>])<br><span class="hljs-comment">-- 2. 统计当前元素数量</span><br><span class="hljs-keyword">local</span> res = redis.call(<span class="hljs-string">&#x27;zcard&#x27;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-comment">-- 3. 是否超过阈值</span><br><span class="hljs-keyword">if</span> (res == <span class="hljs-literal">nil</span>) <span class="hljs-keyword">or</span> (res &lt; <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">3</span>])) <span class="hljs-keyword">then</span><br>    redis.call(<span class="hljs-string">&#x27;zadd&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>], ARGV[<span class="hljs-number">4</span>])<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>下面是使用 Spring Boot 中 <code>RedisTemplate</code> 来实现的 <code>lua</code> 脚本调用测试代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisLuaLimiterByZset</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;limiter_&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">QPS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;4&quot;</span>;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">redisLuaLimiterTests</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, IOException &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">15</span>; i++) &#123;<br>            Thread.sleep(<span class="hljs-number">200</span>);<br>            System.out.println(LocalTime.now() + <span class="hljs-string">&quot; &quot;</span> + acquire(<span class="hljs-string">&quot;user1&quot;</span>));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计数器限流</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        key = KEY_PREFIX + key;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">oldest</span> <span class="hljs-operator">=</span> String.valueOf(now - <span class="hljs-number">1_000</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> String.valueOf(now);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">scoreValue</span> <span class="hljs-operator">=</span> score;<br>        DefaultRedisScript&lt;Long&gt; redisScript = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>        redisScript.setResultType(Long.class);<br>        <span class="hljs-comment">//lua文件存放在resources目录下</span><br>        redisScript.setScriptSource(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceScriptSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;limiter2.lua&quot;</span>)));<br>        <span class="hljs-keyword">return</span> stringRedisTemplate.execute(redisScript, Arrays.asList(key), oldest, score, QPS, scoreValue) == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中限制 QPS 为 4，运行结果信息与之一致。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">17:36:37.150370 true<br>17:36:37.716341 true<br>17:36:37.922577 true<br>17:36:38.127497 true<br>17:36:38.335879 true<br>17:36:38.539225 false<br>17:36:38.745903 true<br>17:36:38.952491 true<br>17:36:39.159497 true<br>17:36:39.365239 true<br>17:36:39.570572 false<br>17:36:39.776635 true<br>17:36:39.982022 true<br>17:36:40.185614 true<br>17:36:40.389469 true<br></code></pre></td></tr></table></figure><p>这里介绍了 Redis 实现限流的两种方式，当然使用 Redis 也可以实现漏桶和令牌桶两种限流算法，这里就不做演示了，感兴趣的可以自己研究下。</p><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>这篇文章介绍实现限流的几种方式，主要是<strong>窗口算法和桶算法</strong>，两者各有优势。</p><ul><li>  窗口算法实现简单，逻辑清晰，可以很直观的得到当前的 QPS 情况，但是会有时间窗口的临界突变问题，而且不像桶一样有队列可以缓冲。</li><li>桶算法虽然稍微复杂，不好统计 QPS 情况，但是桶算法也有优势所在。<ul><li>  漏桶模式消费速率恒定，可以很好的<strong>保护自身系统</strong>，可以对流量进行整形，但是面对突发流量不能快速响应。</li><li>  令牌桶模式可以面对突发流量，但是启动时会有缓慢加速的过程，不过常见的开源工具中已经对此优化。</li></ul></li></ul><p><strong>单机限流与分布式限流</strong></p><p>上面演示的基于代码形式的窗口算法和桶算法限流都适用于单机限流，如果需要分布式限流可以结合注册中心、负载均衡计算每个服务的限流阈值，但这样会降低一定精度，如果对精度要求不是太高，可以使用。</p><p>而 Redis 的限流，由于 Redis 的单机性，本身就可以用于分布式限流。使用 Redis 可以实现各种可以用于限流算法，如果觉得麻烦也可以使用开源工具如 redisson，已经封装了基于 Redis 的限流。</p><p><strong>其他限流工具</strong></p><p>文中已经提到了 <code>Guava</code> 的限流工具包，不过它毕竟是单机的，开源社区中也有很多分布式限流工具，如阿里开源的 Sentinel 就是不错的工具，Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p><p>一如既往，文章中的代码存放在：<a href="https://github.com/niumoo/JavaNotes/tree/master/core-java-rate-limiter">github.com/niumoo/JavaNotes</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.wdbyte.com/java/rate-limiter.html">5 种限流算法，7 种限流方式，挡住突发流量</a></li><li><a href="https://redis.io/commands/incr">Redis INCR</a></li><li><a href="https://en.wikipedia.org/wiki/Rate_limiting">Rate Limiting Wikipedia</a></li><li><a href="https://www.cnblogs.com/lenve/p/10965667.html">SpringBoot Redis</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>限流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Structs</title>
    <link href="/2022/09/13/go/Structs/"/>
    <url>/2022/09/13/go/Structs/</url>
    
    <content type="html"><![CDATA[<h2 id="Go’s-structs-are-typed-collections-of-fields-They’re-useful-for-grouping-data-together-to-form-records"><a href="#Go’s-structs-are-typed-collections-of-fields-They’re-useful-for-grouping-data-together-to-form-records" class="headerlink" title="Go’s structs are typed collections of fields. They’re useful for grouping data together to form records."></a>Go’s structs are typed collections of fields. They’re useful for grouping data together to form records.</h2><h2 id="The-Go-Playground"><a href="#The-Go-Playground" class="headerlink" title="The Go Playground"></a><a href="https://go.dev/play/p/n7jt1x3iw4Z">The Go Playground</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// This `person` struct type has `name` and `age` fields.</span><br><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// `newPerson` constructs a new person struct with the given name.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newPerson</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> *person &#123;<br><span class="hljs-comment">// You can safely return a pointer to local variable</span><br><span class="hljs-comment">// as a local variable will survive the scope of the function.</span><br>p := person&#123;name: name&#125;<br>p.age = <span class="hljs-number">42</span><br><span class="hljs-keyword">return</span> &amp;p<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">// This syntax creates a new struct.</span><br>fmt.Println(person&#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">20</span>&#125;)<br><br><span class="hljs-comment">// You can name the fields when initializing a struct.</span><br>fmt.Println(person&#123;name: <span class="hljs-string">&quot;Alice&quot;</span>, age: <span class="hljs-number">30</span>&#125;)<br><br><span class="hljs-comment">// Omitted fields will be zero-valued.</span><br>fmt.Println(person&#123;name: <span class="hljs-string">&quot;Fred&quot;</span>&#125;)<br><br><span class="hljs-comment">// An `&amp;` prefix yields a pointer to the struct.</span><br>fmt.Println(&amp;person&#123;name: <span class="hljs-string">&quot;Ann&quot;</span>, age: <span class="hljs-number">40</span>&#125;)<br><br><span class="hljs-comment">// It&#x27;s idiomatic to encapsulate new struct creation in constructor functions</span><br>fmt.Println(newPerson(<span class="hljs-string">&quot;Jon&quot;</span>))<br><br><span class="hljs-comment">// Access struct fields with a dot.</span><br>s := person&#123;name: <span class="hljs-string">&quot;Sean&quot;</span>, age: <span class="hljs-number">50</span>&#125;<br>fmt.Println(s.name)<br><br><span class="hljs-comment">// You can also use dots with struct pointers - the</span><br><span class="hljs-comment">// pointers are automatically dereferenced.</span><br>sp := &amp;s<br>fmt.Println(sp.age)<br><br><span class="hljs-comment">// Structs are mutable.</span><br>sp.age = <span class="hljs-number">51</span><br>fmt.Println(sp.age)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><a href="https://gobyexample.com/structs">Go by Example: Structs</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>Structs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Interfaces</title>
    <link href="/2022/09/13/go/Interfaces/"/>
    <url>/2022/09/13/go/Interfaces/</url>
    
    <content type="html"><![CDATA[<p><img src="1.png"></p><h2 id="Interfaces-are-named-collections-of-method-signatures"><a href="#Interfaces-are-named-collections-of-method-signatures" class="headerlink" title="Interfaces are named collections of method signatures."></a>Interfaces are named collections of method signatures.</h2><h2 id="The-Go-Playground"><a href="#The-Go-Playground" class="headerlink" title="The Go Playground"></a><a href="https://go.dev/play/p/XJASG4MxBQr">The Go Playground</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// _Interfaces_ are named collections of method signatures.</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-comment">// Here&#x27;s a basic interface for geometric shapes.</span><br><span class="hljs-keyword">type</span> geometry <span class="hljs-keyword">interface</span> &#123;<br>area() <span class="hljs-type">float64</span><br>perim() <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-comment">// For our example we&#x27;ll implement this interface on</span><br><span class="hljs-comment">// `rect` and `circle` types.</span><br><span class="hljs-keyword">type</span> rect <span class="hljs-keyword">struct</span> &#123;<br>width, height <span class="hljs-type">float64</span><br>&#125;<br><span class="hljs-keyword">type</span> circle <span class="hljs-keyword">struct</span> &#123;<br>radius <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-comment">// To implement an interface in Go, we just need to</span><br><span class="hljs-comment">// implement all the methods in the interface. Here we</span><br><span class="hljs-comment">// implement `geometry` on `rect`s.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r rect)</span></span> area() <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> r.width * r.height<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r rect)</span></span> perim() <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*r.width + <span class="hljs-number">2</span>*r.height<br>&#125;<br><br><span class="hljs-comment">// The implementation for `circle`s.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c circle)</span></span> area() <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> math.Pi * c.radius * c.radius<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c circle)</span></span> perim() <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * math.Pi * c.radius<br>&#125;<br><br><span class="hljs-comment">// If a variable has an interface type, then we can call</span><br><span class="hljs-comment">// methods that are in the named interface. Here&#x27;s a</span><br><span class="hljs-comment">// generic `measure` function taking advantage of this</span><br><span class="hljs-comment">// to work on any `geometry`.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">measure</span><span class="hljs-params">(g geometry)</span></span> &#123;<br>fmt.Println(g)<br>fmt.Println(g.area())<br>fmt.Println(g.perim())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := rect&#123;width: <span class="hljs-number">3</span>, height: <span class="hljs-number">4</span>&#125;<br>c := circle&#123;radius: <span class="hljs-number">5</span>&#125;<br><br><span class="hljs-comment">// The `circle` and `rect` struct types both</span><br><span class="hljs-comment">// implement the `geometry` interface so we can use</span><br><span class="hljs-comment">// instances of</span><br><span class="hljs-comment">// these structs as arguments to `measure`.</span><br>measure(r)<br>measure(c)<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><a href="https://gobyexample.com/interfaces">Go by Example: Interfaces</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>Interfaces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dubbo自定义路由设置</title>
    <link href="/2022/09/13/dubbo/router/dubbo%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E8%AE%BE%E7%BD%AE/"/>
    <url>/2022/09/13/dubbo/router/dubbo%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>开发人员进行本地开发时,经常会出现接口调到k8s容器内的服务上,我们本地和k8s共用一个nacos服务.</p><p>根据调研,打算使用dubbo的自定义路由实现.本地服务调接口时,使用路由过滤掉k8s内部的provider地址,从而实现,本地consumer能够一直本地provider服务.</p><p>由于过滤了k8s内部实例的ip,因此需要,将此路由只能在本地生效,在k8s环境内失效,通过spring.profiles实现.</p><h3 id="实现自定义路由"><a href="#实现自定义路由" class="headerlink" title="实现自定义路由"></a>实现自定义路由</h3><h4 id="继承AbstractRouter"><a href="#继承AbstractRouter" class="headerlink" title="继承AbstractRouter"></a>继承AbstractRouter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.apache.dubbo.common.URL;<br><span class="hljs-keyword">import</span> org.apache.dubbo.rpc.Invocation;<br><span class="hljs-keyword">import</span> org.apache.dubbo.rpc.Invoker;<br><span class="hljs-keyword">import</span> org.apache.dubbo.rpc.RpcException;<br><span class="hljs-keyword">import</span> org.apache.dubbo.rpc.cluster.router.AbstractRouter;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IpRouter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractRouter</span> &#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">IpRouter</span><span class="hljs-params">(URL url)</span> &#123;<br>        <span class="hljs-built_in">super</span>(url);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; <span class="hljs-title function_">route</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> <span class="hljs-keyword">throws</span> RpcException &#123;<br><br>        <span class="hljs-keyword">if</span> (!SpringContextUtil.isLocal()) &#123; <span class="hljs-comment">//仅在本地进行路由</span><br>            <span class="hljs-keyword">return</span> invokers;<br>        &#125;<br>        <br>        log.info(<span class="hljs-string">&quot; before route :&#123;&#125;,&#123;&#125;&quot;</span>, invokers.size(), invokers);<br>        <span class="hljs-keyword">if</span> (invokers.size() &lt;= <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//存在少于一个provider时不进行路由,可选</span><br>            <span class="hljs-keyword">return</span> invokers;<br>        &#125;<br><br>        <span class="hljs-comment">//存在多个provider时,过滤掉属于k8s内服务的provider,保留本地服务</span><br>        Predicate&lt;Invoker&lt;T&gt;&gt; useLocalIP = str -&gt; !str.getUrl().toServiceString().contains(<span class="hljs-string">&quot;10.0.80.9&quot;</span>);<br>        List&lt;Invoker&lt;T&gt;&gt; collect = invokers.stream().filter(useLocalIP).collect(Collectors.toList());<br><br>        log.info(<span class="hljs-string">&quot; after route:&#123;&#125;,&#123;&#125;&quot;</span>, collect.size(), collect);<br>        <span class="hljs-keyword">return</span> collect;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="实现RouterFactory"><a href="#实现RouterFactory" class="headerlink" title="实现RouterFactory"></a>实现RouterFactory</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> org.apache.dubbo.common.URL;<br><span class="hljs-keyword">import</span> org.apache.dubbo.common.extension.Activate;<br><span class="hljs-keyword">import</span> org.apache.dubbo.rpc.cluster.Router;<br><span class="hljs-keyword">import</span> org.apache.dubbo.rpc.cluster.RouterFactory;<br><br><span class="hljs-meta">@Activate(group = &quot;consumer&quot;)</span><span class="hljs-comment">//只在consumer侧激活</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IpRouterFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RouterFactory</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Router <span class="hljs-title function_">getRouter</span><span class="hljs-params">(URL url)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IpRouter</span>(url);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="加载RouterFactory"><a href="#加载RouterFactory" class="headerlink" title="加载RouterFactory"></a>加载RouterFactory</h4><p>在resources 目录下创建目录META-INF\dubbo<br>创建文件:org.apache.dubbo.rpc.cluster.RouterFactory,<br>值为:ip=com.wtt.demo.app.route.IpRouterFactory</p><h3 id="解决只在本地生效"><a href="#解决只在本地生效" class="headerlink" title="解决只在本地生效"></a>解决只在本地生效</h3><h4 id="创建SpringContextUtil工具类"><a href="#创建SpringContextUtil工具类" class="headerlink" title="创建SpringContextUtil工具类"></a>创建SpringContextUtil工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.BeansException;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContextAware;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringContextUtil</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextAware</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String[] getActiveProfileList() &#123;<br>        <span class="hljs-keyword">return</span> context.getEnvironment().getActiveProfiles();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Boolean <span class="hljs-title function_">isLocal</span><span class="hljs-params">()</span> &#123;<br>        String[] activeProfileList = getActiveProfileList();<br>        Predicate&lt;String&gt; containsLocalProfile = m -&gt; m.contains(<span class="hljs-string">&quot;local&quot;</span>);<br>        <span class="hljs-keyword">return</span> Arrays.stream(activeProfileList).anyMatch(containsLocalProfile);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-built_in">this</span>.context = applicationContext;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><ul><li>深入理解Apache Dubbo与实战</li><li><a href="https://zzshuo.github.io/2021/05/21/005-dubbo-tag-invoker-chain/">dubbo自定义标签路由</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dubbo</tag>
      
      <tag>router</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用docker搭建dnsmasq</title>
    <link href="/2022/09/13/dns/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAdnsmasq/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAdnsmasq/"/>
    <url>/2022/09/13/dns/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAdnsmasq/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAdnsmasq/</url>
    
    <content type="html"><![CDATA[<h3 id="关闭默认dns服务解决53端口被占用问题"><a href="#关闭默认dns服务解决53端口被占用问题" class="headerlink" title="关闭默认dns服务解决53端口被占用问题"></a>关闭默认dns服务解决53端口被占用问题</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl stop systemd-resolved<br>systemctl start systemd-resolved<br></code></pre></td></tr></table></figure><h3 id="docker启动命令"><a href="#docker启动命令" class="headerlink" title="docker启动命令"></a>docker启动命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name dnsmasq -d  --net=host \<br>--cap-add=NET_ADMIN  \<br>-v /home/baymax/dns/dnsmasq.conf:/etc/dnsmasq.conf \<br>-v /home/baymax/dns/resolv.conf:/etc/resolv.conf \<br> --log-opt &quot;max-size=100m&quot;   -e &quot;HTTP_USER=admin&quot;  -e &quot;HTTP_PASS=admin&quot; \<br>  --restart always jpillora/dnsmasq<br></code></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><p>本文未使用 –privileged,使用–cap-add和–cap-drop对功能进行细粒度控制</p><h3 id="DNS配置"><a href="#DNS配置" class="headerlink" title="DNS配置"></a>DNS配置</h3><p>修改/etc/resolv.conf目录下的nameserver为本机ip</p><h3 id="登录-http-localhost-8080-进行配置"><a href="#登录-http-localhost-8080-进行配置" class="headerlink" title="登录(http://localhost:8080)进行配置"></a>登录(<a href="http://localhost:8080)进行配置">http://localhost:8080)进行配置</a></h3><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>配置成功后直接在页面进行修改保存,启动即可</p><h4 id="配置文件demo"><a href="#配置文件demo" class="headerlink" title="配置文件demo"></a>配置文件demo</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">配置上行DNS</span><br>resolv-file=/etc/resolv.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">resolv.conf DNS寻址从上到下</span><br>strict-order<br><span class="hljs-meta prompt_"># </span><span class="language-bash">DNS解析hosts时对应的hosts文件，对应no-hosts</span><br>addn-hosts=/etc/hosts<br>cache-size=1024 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">多个IP用逗号分隔，192.168.x.x表示本机的ip地址，只有127.0.0.1的时候表示只有本机可以访问。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过这个设置就可以实现同一局域网内的设备，通过把网络DNS设置为本机IP从而实现局域网范围内的DNS泛解析(注：无效IP有可能导至服务无法启动）</span><br>listen-address=127.0.0.1,192.168.168.4<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重要！！这一行就是你想要泛解析的域名配置.</span><br>address=/baymax.bb/192.168.168.1<br>address=/blog.bb/192.168.168.1<br>address=/103.bb/192.168.168.2<br>address=/dns.bb/192.168.168.4<br>address=/gitlab.bb/192.168.168.4<br><span class="hljs-meta prompt_">#</span><span class="language-bash">指定使用哪个DNS服务器进行解析，对于不同的网站可以使用不同的域名对应解析。</span><br>server=/google.com/8.8.8.8<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">国内指定DNS</span><br>server=/bb/192.168.168.4<br>server=/cn/114.114.114.114<br>server=/com/8.8.8.8<br></code></pre></td></tr></table></figure><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><ul><li>nslookup</li><li>dig</li><li>ping</li></ul><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><ul><li><a href="https://www.qikqiak.com/post/capabilities-on-k8s/">在 Kubernetes 中配置 Container Capabilities</a></li><li><a href="https://www.yisu.com/zixun/161163.html">Docker 1分钟搭建DNS服务器的方法</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>dns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理模式</title>
    <link href="/2022/09/13/design-patterns/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/09/13/design-patterns/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>提供另一个对象的代理或占位符来控制对它的访问</p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><h4 id="现实世界举例"><a href="#现实世界举例" class="headerlink" title="现实世界举例"></a>现实世界举例</h4><p>想象一下，有一座塔，当地的巫师去那里学习咒语。这个象牙塔只能通过一个代理访问，这个代理确保只有前三个巫师可以进入。这里的代理代表塔的功能并向其添加访问控制。</p><h4 id="大白话"><a href="#大白话" class="headerlink" title="大白话"></a>大白话</h4><p>使用代理模式，一个类代表另一个类的功能。</p><h4 id="维基百科解释"><a href="#维基百科解释" class="headerlink" title="维基百科解释"></a>维基百科解释</h4><p>代理，在其最一般的形式中，是作为其他事物的界面功能的类。代理是客户机调用的包装器或代理对象，用于在幕后访问真正的服务对象。<br>使用代理可以简单地转发到实际对象，也可以提供额外的逻辑。在代理中可以提供额外的功能，例如在对实际对象的操作是资源密集型时进行缓存，或者在调用对实际对象的操作之前检查先决条件。</p><h3 id="编程示例"><a href="#编程示例" class="headerlink" title="编程示例"></a>编程示例</h3><p>以我们上面的巫师塔为例。首先，我们有WizardTower接口和IvoryTower类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">WizardTower</span> &#123;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">enter</span><span class="hljs-params">(Wizard wizard)</span>;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IvoryTower</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WizardTower</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enter</span><span class="hljs-params">(Wizard wizard)</span> &#123;<br>    LOGGER.info(<span class="hljs-string">&quot;&#123;&#125; enters the tower.&quot;</span>, wizard);<br>  &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后是一个简单的Wizard类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wizard</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Wizard</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> name;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后我们有了WizardTowerProxy来为WizardTower添加访问控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WizardTowerProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WizardTower</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NUM_WIZARDS_ALLOWED</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> numWizards;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WizardTower tower;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">WizardTowerProxy</span><span class="hljs-params">(WizardTower tower)</span> &#123;<br>    <span class="hljs-built_in">this</span>.tower = tower;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enter</span><span class="hljs-params">(Wizard wizard)</span> &#123;<br>    <span class="hljs-keyword">if</span> (numWizards &lt; NUM_WIZARDS_ALLOWED) &#123;<br>      tower.enter(wizard);<br>      numWizards++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      LOGGER.info(<span class="hljs-string">&quot;&#123;&#125; is not allowed to enter!&quot;</span>, wizard);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是塔进入的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">var</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WizardTowerProxy</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IvoryTower</span>());<br>proxy.enter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Wizard</span>(<span class="hljs-string">&quot;Red wizard&quot;</span>));<br>proxy.enter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Wizard</span>(<span class="hljs-string">&quot;White wizard&quot;</span>));<br>proxy.enter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Wizard</span>(<span class="hljs-string">&quot;Black wizard&quot;</span>));<br>proxy.enter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Wizard</span>(<span class="hljs-string">&quot;Green wizard&quot;</span>));<br>proxy.enter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Wizard</span>(<span class="hljs-string">&quot;Brown wizard&quot;</span>));<br><br></code></pre></td></tr></table></figure><p>程序输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>Red wizard enters the tower.<br>White wizard enters the tower.<br>Black wizard enters the tower.<br>Green wizard is not allowed to enter!<br>Brown wizard is not allowed to enter!<br></code></pre></td></tr></table></figure><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="1.png"></p><h2 id="适应范围"><a href="#适应范围" class="headerlink" title="适应范围"></a>适应范围</h2><p>当需要比简单指针更通用或更复杂的对象引用时，代理是适用的。以下是代理模式适用的几种常见情况。</p><ul><li>远程代理为不同地址空间中的对象提供本地代表。</li><li>虚拟代理按需创建昂贵的对象。</li><li>保护代理控制对原始对象的访问。当对象应具有不同的访问权限时，保护代理很有用。</li></ul><p>通常，代理模式用于</p><ul><li>控制对另一个对象的访问</li><li>惰性初始化</li><li>实现日志记录</li><li>促进网络连接</li><li>计数对对象的引用</li></ul><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><a href="https://java-design-patterns.com/patterns/proxy/">Proxy</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>代理</tag>
      
      <tag>proxy</tag>
      
      <tag>译文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>苏格拉底的申辩</title>
    <link href="/2022/09/13/book/%E8%8B%8F%E6%A0%BC%E6%8B%89%E5%BA%95%E7%9A%84%E7%94%B3%E8%BE%A9/"/>
    <url>/2022/09/13/book/%E8%8B%8F%E6%A0%BC%E6%8B%89%E5%BA%95%E7%9A%84%E7%94%B3%E8%BE%A9/</url>
    
    <content type="html"><![CDATA[<p><img src="1.png"></p><h2 id="译者"><a href="#译者" class="headerlink" title="译者"></a>译者</h2><p>吴飞</p><h2 id="原文摘录"><a href="#原文摘录" class="headerlink" title="原文摘录"></a>原文摘录</h2><ul><li><p><strong>我很难赢得你们，不是因为缺少语言，而是缺乏勇气和无耻，我不愿对你们说那些你们最喜欢听得到话，我不哀悼，不悲恸，不做也不说别的很多我认为不合我品行、而你们习惯从别人那里听到的那些。我宁愿选择这样申辩而死，也不选择那样活着。</strong></p></li><li><p><strong>不过，是该走的时候了，我去死，你们去生。我们所去做的哪个事更好，谁也不知道，除了神。</strong></p></li><li><p><strong>一个未经省察的生活是不值得人过的生活</strong></p></li></ul><h2 id="短评"><a href="#短评" class="headerlink" title="短评"></a>短评</h2><p><strong>苏格拉底的申辩毋宁是哲学在政治面前的申辩，与孔子的礼法调和不同，苏格拉底宣判了哲学和政治间矛盾的不可化解，一个德性的原则，一个现实的原则，是理念和实践、应然和实然的分野，由此看，哲学永无法在尘世中战胜政治，只能获得德性的飞升。无知之知，“认识你自己”，局限，省察，VS康德反思性理念VS黑格尔辩证法。正义与众议，说服与取悦，真理与修辞。法庭是政治上取胜，苏却只想说出哲学真理。和康德以道德化的上帝代替宗教化的上帝一样，苏拉拉底的精灵在实质上亦改变了宗教基础。吴飞好牛，文风又晓畅，引言从奥古斯丁狄德罗卢梭到康德黑格尔马克思施特劳斯福柯，各种贯通。后边义疏理路十分清晰，简直没得多说。中间申辨数次感动，结尾牛逼闪闪。“不过，是该走的时候了，我去死，你们去生。我们所做的哪个事更好，谁也不知道，除非是神。</strong></p><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li><a href="https://book.douban.com/subject/2170983/">豆瓣读书</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哲学</tag>
      
      <tag>柏拉图注疏集</tag>
      
      <tag>吴飞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>活着</title>
    <link href="/2022/09/13/book/%E6%B4%BB%E7%9D%80/"/>
    <url>/2022/09/13/book/%E6%B4%BB%E7%9D%80/</url>
    
    <content type="html"><![CDATA[<p><img src="%E6%B4%BB%E7%9D%80.png"></p><h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>余华</p><h2 id="原文摘录"><a href="#原文摘录" class="headerlink" title="原文摘录"></a>原文摘录</h2><ul><li><p><strong>作为一个词语，“活着”在我们中国的语言中充满了力量，它的力量不是来自于喊叫，也不是来自于进攻，而是忍受，去忍受生命赋予我们的责任，去忍受现实给予我们的幸福和苦难、无聊和平庸。</strong></p></li><li><p><strong>做人不能忘记四条，话不要说错，床不要睡错，门槛不要踏错，口袋不要摸错。</strong></p></li><li><p><strong>做人还是平常点好，争这个争那个，争来争去赔了自己的命。</strong></p></li></ul><h2 id="短评"><a href="#短评" class="headerlink" title="短评"></a>短评</h2><p><strong>一个长寿的悲剧，生命本就是孤孤单单的来，最后只落得和一头牛为友，让它象征自己生命中走过的人们。这位曾经的富家子弟现在的垂垂老者，一生之中谨守本份，随波逐流，就像每个平凡的中国人，皆是有起有落的生活。</strong></p><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li><a href="https://book.douban.com/subject/1082154/">豆瓣读书</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文学</tag>
      
      <tag>余华</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>凤凰架构</title>
    <link href="/2022/09/13/book/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/"/>
    <url>/2022/09/13/book/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><img src="1.png"></p><h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>周志明</p><h2 id="原文摘录"><a href="#原文摘录" class="headerlink" title="原文摘录"></a>原文摘录</h2><h2 id="短评"><a href="#短评" class="headerlink" title="短评"></a>短评</h2><p><strong>作者一如既往的高屋建瓴、用词严谨、逻辑清晰，深度与广度并存，适合一气读完。</strong></p><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li><a href="https://book.douban.com/subject/35492898/">豆瓣读书</a></li><li><a href="https://icyfenix.cn/">官方电子书链接</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>周志明</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人人都是产品经理2.0</title>
    <link href="/2022/09/13/book/%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%862.0/"/>
    <url>/2022/09/13/book/%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%862.0/</url>
    
    <content type="html"><![CDATA[<p><img src="2.jpg"></p><h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>苏杰</p><h2 id="原文摘录"><a href="#原文摘录" class="headerlink" title="原文摘录"></a>原文摘录</h2><p><strong>一看到问题，马上就想答案，这是典型的“学生”思维，因为我们所 受的学校训练，绝大多数都是针对“经过简化的问题”：有确定的目标、 完备的信息，有刚刚学过的解法，有标准答案……而职场中，面对的问 题通常目标不明、信息片面、闻所未闻。特别对产品经理而言，各种用 户提的问题，一般都是经过扭曲、有欺骗性的，要怎么解决也没有标准 答案。</strong></p><h2 id="短评"><a href="#短评" class="headerlink" title="短评"></a>短评</h2><p><strong>苏杰这本书细说了人人都是产品经理这个名字的含义，从这个层面来看，未来确实人人都可能是“泛产品经理”，每个人都应该具备一定的产品思维，通过这些思路来解决生活和工作的问题。</strong></p><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li><a href="https://book.douban.com/subject/27029547/">豆瓣读书</a></li></ul><p><img src="1.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>管理</tag>
      
      <tag>苏杰</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>丑陋的中国人</title>
    <link href="/2022/09/13/book/%E4%B8%91%E9%99%8B%E7%9A%84%E4%B8%AD%E5%9B%BD%E4%BA%BA/"/>
    <url>/2022/09/13/book/%E4%B8%91%E9%99%8B%E7%9A%84%E4%B8%AD%E5%9B%BD%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<p><img src="%E4%B8%91%E9%99%8B%E7%9A%84%E4%B8%AD%E5%9B%BD%E4%BA%BA.png"></p><h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>柏杨</p><h2 id="原文摘录"><a href="#原文摘录" class="headerlink" title="原文摘录"></a>原文摘录</h2><ul><li><p><strong>没有包容性的性格，如此这般狭窄的心胸，造成中国人两个极端，不够平衡。一方面是绝对的自卑，一方面是绝对的自傲。 自卑的时候，成了奴才；自傲的时候，成了主人！独独的，没有自尊。自卑的时候觉得自己是团狗屎，和权势走得越近，脸上的笑容越多。 自傲的时候觉得其他人都是狗屎，不屑一顾；变成了一种人格分裂的奇异动物。</strong></p></li><li><p><strong>”算了算了”四个字，不知害死了多少中国人，使我们民族的元气，受到挫伤。这种神经质的恐惧，是培养暴君、暴官最好的温床，所以中国的暴君、暴官，永远不会绝迹。 中国传统文化里———各位在《资治通鉴》中可以看到———一再强调明哲保身，暴君暴官最喜欢、最欣赏的就是人民明哲保身，所以中国人就越来越堕落萎缩</strong>。</p></li><li><p><strong>一个人生活在世上，就好像水泥搅拌器里的石子一样，运转起来之后，身不由主。使我们感到，不是某一个人的问题，而是社会问题，而是文化问题。 耶稣临死的时候说：＂宽容他们！他们做的他们不知道。</strong></p></li></ul><h2 id="短评"><a href="#短评" class="headerlink" title="短评"></a>短评</h2><ul><li><strong>这本书创作于十年文革结束，中国从动乱中开始觉醒的这个特殊时间，创作背景很特殊，但其中有些观点评论依旧适用于今日的中国。 有人说作者有些偏激，但有些观点确实就是这个社会的现状。这本书毁誉参半，我认为应该用历史观，辩证地看待它，还是有不小意义的。</strong></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://book.douban.com/subject/1027247/">豆瓣读书</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文学</tag>
      
      <tag>柏杨</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WireGuard杂记</title>
    <link href="/2022/09/13/WireGuard%E6%9D%82%E8%AE%B0/"/>
    <url>/2022/09/13/WireGuard%E6%9D%82%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="安装WireGuard"><a href="#安装WireGuard" class="headerlink" title="安装WireGuard"></a>安装WireGuard</h2><h3 id="通过密钥对安装"><a href="#通过密钥对安装" class="headerlink" title="通过密钥对安装"></a>通过密钥对安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wg genkey | tee aliyun_privatekey | wg pubkey &gt; aliyun_publickey<br>wg genkey | tee thinkpad_privatekey | wg pubkey &gt; thinkpad_publickey<br><br></code></pre></td></tr></table></figure><h3 id="通过wg-gen-web安装"><a href="#通过wg-gen-web安装" class="headerlink" title="通过wg-gen-web安装"></a>通过wg-gen-web安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run  --name wg-web -itd -v /etc/wireguard:/data -p 8080:8080 -e &quot;WG_CONF_DIR=/data&quot; vx3r/wg-gen-web:latest<br></code></pre></td></tr></table></figure><h3 id="使用docker部署"><a href="#使用docker部署" class="headerlink" title="使用docker部署"></a>使用docker部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>docker run -d --network=host --name=wireguard  --cap-add=NET_ADMIN   --cap-add=SYS_MODULE   --restart unless-stopped   linuxserver/wireguard<br><br></code></pre></td></tr></table></figure><h3 id="使用k8s部署"><a href="#使用k8s部署" class="headerlink" title="使用k8s部署"></a>使用k8s部署</h3><h4 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">wg-deployment</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">wg</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">wg</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">wg</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">linuxserver/wireguard</span><br>        <span class="hljs-attr">securityContext:</span><br>          <span class="hljs-attr">capabilities:</span><br>            <span class="hljs-attr">add:</span> <span class="hljs-comment"># 添加</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">NET_ADMIN</span><br>      <span class="hljs-attr">hostNetwork:</span> <span class="hljs-literal">true</span><br><br></code></pre></td></tr></table></figure><h4 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">wireguard</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">wireguard</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">linuxserver/wireguard</span><br>    <span class="hljs-attr">securityContext:</span><br>      <span class="hljs-attr">capabilities:</span><br>        <span class="hljs-attr">add:</span> <span class="hljs-comment"># 添加</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">NET_ADMIN</span><br>  <span class="hljs-attr">hostNetwork:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="通过WireGuard访问节点内局域网内ip"><a href="#通过WireGuard访问节点内局域网内ip" class="headerlink" title="通过WireGuard访问节点内局域网内ip"></a>通过WireGuard访问节点内局域网内ip</h2><p>使用iptables实现,需开启开启IP地址转发</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在需要使用的节点添加如下配置</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">xxx 为对应的网卡名</span><br>PostUp = iptables -A FORWARD -i %i -j ACCEPT<br>PostUp = iptables -t nat -A POSTROUTING -o xxx -j MASQUERADE<br>PostDown = iptables -D FORWARD -i %i -j ACCEPT<br>PostDown = iptables -t nat -D POSTROUTING -o xxx -j MASQUERADE<br><br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="WireGuard常用命令"><a href="#WireGuard常用命令" class="headerlink" title="WireGuard常用命令"></a>WireGuard常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动server端</span><br>systemctl start wg-quick@wg0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建节点后需要重启服务</span><br>systemctl restart wg-quick@wg0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询网卡信息</span><br>wg show wg0<br><br>sudo apt install wireguard<br>wg-quick up wg0<br>wg-quick down wg0<br><br></code></pre></td></tr></table></figure><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">清除iptables规则：</span><br>iptables -P INPUT ACCEPT<br>iptables -P FORWARD ACCEPT<br>iptables -P OUTPUT ACCEPT<br>iptables -t nat -F<br>iptables -t mangle -F<br>iptables -F<br>iptables -X<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">清除ip6tables规则：</span><br>ip6tables -P INPUT ACCEPT<br>ip6tables -P FORWARD ACCEPT<br>ip6tables -P OUTPUT ACCEPT<br>ip6tables -t nat -F<br>ip6tables -t mangle -F<br>ip6tables -F<br>ip6tables -X<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用tcpdump监听client网口icmp包</span><br>tcpdump -i client icmp<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启IP地址转发</span><br>sysctl -w net.ipv4.ip_forward=1<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查询ip地址转发是否开启</span><br>sysctl net.ipv4.ip_forward<br><br></code></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>使用公网服务时,记得放开WireGuard使用的UDP端口</li><li>WireGuard未内置,则需要先安装(sudo apt install wireguard)</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="884358.com/wireguard/#kai_qiIP_de_zhi_zhuan_fa">通过WireGuard实现内网穿透</a></li><li><a href="https://qastack.cn/server/200635/best-way-to-clear-all-iptables-rules">清除所有iptables规则的最佳方法</a></li><li><a href="https://github.com/vx3r/wg-gen-web">wg-gen-web</a></li><li><a href="https://www.zsythink.net/archives/category/%e8%bf%90%e7%bb%b4%e7%9b%b8%e5%85%b3/iptables">iptables</a></li><li><a href="https://icloudnative.io/posts/configure-wireguard-using-wg-gen-web/">WireGuard 配置教程：使用 wg-gen-web 来管理 WireGuard 的配置</a></li><li><a href="https://stackoverflow.com/questions/27708376/why-am-i-getting-an-rtnetlink-operation-not-permitted-when-using-pipework-with-d">Why am I getting an RTNETLINK Operation Not Permitted when using Pipework with Docker containers?</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WireGuard</tag>
      
      <tag>内网穿透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes网络权威指南：基础、原理与实践</title>
    <link href="/2022/09/13/book/Kubernetes%E7%BD%91%E7%BB%9C%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    <url>/2022/09/13/book/Kubernetes%E7%BD%91%E7%BB%9C%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p><img src="img.png"></p><h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>杜军</p><h2 id="原文摘录"><a href="#原文摘录" class="headerlink" title="原文摘录"></a>原文摘录</h2><h2 id="短评"><a href="#短评" class="headerlink" title="短评"></a>短评</h2><ul><li><strong>1-3章还是比较基础的， 4章讲解了一些原理性的东西 总体比较全面吧，但是讲解的不是很深入，适合初学者。</strong></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://book.douban.com/subject/34855927/">豆瓣读书</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>network</tag>
      
      <tag>杜军</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raft 动画演示</title>
    <link href="/2022/09/13/Raft%20%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA/"/>
    <url>/2022/09/13/Raft%20%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="raft算法"><a href="#raft算法" class="headerlink" title="raft算法"></a>raft算法</h3><p>Raft 是一种为了管理复制日志的一致性算法。它提供了和 Paxos 算法相同的功能和性能，但是它的算法结构和 Paxos 不同，使得 Raft 算法更加容易理解并且更容易构建实际的系统。<br>为了提升可理解性，Raft 将一致性算法分解成了几个关键模块，如领导人选举、日志复制。这个演示动画就是为了方便理解这几个关键模块而设计的。</p><h3 id="动画演示地址"><a href="#动画演示地址" class="headerlink" title="动画演示地址"></a>动画演示地址</h3><ul><li><a href="http://www.kailing.pub/raft/index.html#home">中文</a></li><li><a href="http://thesecretlivesofdata.com/raft/">英文</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Raft</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>034--设计模式常见面试题汇总</title>
    <link href="/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/034--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/034--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h4 id="1-说一下设计模式？你都知道哪些？"><a href="#1-说一下设计模式？你都知道哪些？" class="headerlink" title="1.说一下设计模式？你都知道哪些？"></a>1.说一下设计模式？你都知道哪些？</h4><p>答：设计模式总共有 23 种，总体来说可以分为三大类：创建型模式（ Creational Patterns ）、结构型模式（ Structural Patterns ）和行为型模式（ Behavioral Patterns ）。</p><table><thead><tr><th align="left"><strong>分类</strong></th><th><strong>包含</strong></th><th><strong>关注点</strong></th></tr></thead><tbody><tr><td align="left">创建型模式</td><td>工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式</td><td>关注于对象的创建，同时隐藏创建逻辑</td></tr><tr><td align="left">结构型模式</td><td>适配器模式、过滤器模式、装饰模式、享元模式、代理模式、外观模式、组合模式、桥接模式</td><td>关注类和对象之间的组合</td></tr><tr><td align="left">行为型模式</td><td>责任链模式、命令模式、中介者模式、观察者模式、状态模式、策略模式、模板模式、空对象模式、备忘录模式、迭代器模式、解释器模式、访问者模式</td><td>关注对象之间的通信</td></tr></tbody></table><p>下面会对常用的设计模式分别做详细的说明。</p><h4 id="2-什么是单例模式？"><a href="#2-什么是单例模式？" class="headerlink" title="2.什么是单例模式？"></a>2.什么是单例模式？</h4><p>答：单例模式是一种常用的软件设计模式，在应用这个模式时，单例对象的类必须保证只有一个实例存在，整个系统只能使用一个对象实例。</p><p>优点：不会频繁地创建和销毁对象，浪费系统资源。</p><p>使用场景：IO 、数据库连接、Redis 连接等。</p><p>单例模式代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>单例模式调用代码：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Lesson7_3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton1</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton2</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br>        System.out.println(singleton1 == singleton2); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序的输出结果：true</p><p>可以看出以上单例模式是在类加载的时候就创建了，这样会影响程序的启动速度，那如何实现单例模式的延迟加载？在使用时再创建？</p><p>单例延迟加载代码：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 单例模式-延迟加载版</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonLazy</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonLazy instance;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonLazy <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonLazy</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上为非线程安全的，单例模式如何支持多线程？</p><p>使用 synchronized 来保证，单例模式的线程安全代码：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonLazy</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonLazy instance;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> SingletonLazy <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonLazy</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-什么是简单工厂模式？"><a href="#3-什么是简单工厂模式？" class="headerlink" title="3.什么是简单工厂模式？"></a>3.什么是简单工厂模式？</h4><p>答：简单工厂模式又叫静态工厂方法模式，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。比如，一台咖啡机就可以理解为一个工厂模式，你只需要按下想喝的咖啡品类的按钮（摩卡或拿铁），它就会给你生产一杯相应的咖啡，你不需要管它内部的具体实现，只要告诉它你的需求即可。</p><p><strong>优点</strong> ：</p><ul><li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象；</li><li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量；</li><li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li></ul><p><strong>缺点</strong> ：</p><ul><li>不易拓展，一旦添加新的产品类型，就不得不修改工厂的创建逻辑；</li><li>产品类型较多时，工厂的创建逻辑可能过于复杂，一旦出错可能造成所有产品的创建失败，不利于系统的维护。</li></ul><p>简单工厂示意图如下：</p><p><img src="https://images.gitbook.cn/35024ce0-e066-11e9-bc61-0549c31758ee" alt="1"></p><p>简单工厂 <strong>代码实现</strong> ：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">createProduct</span><span class="hljs-params">(String product)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span> (product) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Mocca&quot;</span>:<br>                result = <span class="hljs-string">&quot;摩卡&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Latte&quot;</span>:<br>                result = <span class="hljs-string">&quot;拿铁&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                result = <span class="hljs-string">&quot;其他&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-什么是抽象工厂模式？"><a href="#4-什么是抽象工厂模式？" class="headerlink" title="4.什么是抽象工厂模式？"></a>4.什么是抽象工厂模式？</h4><p>答：抽象工厂模式是在简单工厂的基础上将未来可能需要修改的代码抽象出来，通过继承的方式让子类去做决定。</p><p>比如，以上面的咖啡工厂为例，某天我的口味突然变了，不想喝咖啡了想喝啤酒，这个时候如果直接修改简单工厂里面的代码，这种做法不但不够优雅，也不符合软件设计的“开闭原则”，因为每次新增品类都要修改原来的代码。这个时候就可以使用抽象工厂类了，抽象工厂里只声明方法，具体的实现交给子类（子工厂）去实现，这个时候再有新增品类的需求，只需要新创建代码即可。</p><p>抽象工厂实现代码如下：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFactoryTest</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-comment">// 抽象工厂</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">CoffeeFactory</span>()).createProduct(<span class="hljs-string">&quot;Latte&quot;</span>);<br>       System.out.println(result); <span class="hljs-comment">// output:拿铁</span><br>   &#125;<br>&#125;<br><span class="hljs-comment">// 抽象工厂</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFactory</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">createProduct</span><span class="hljs-params">(String product)</span>;<br>&#125;<br><span class="hljs-comment">// 啤酒工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BeerFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractFactory</span>&#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">createProduct</span><span class="hljs-params">(String product)</span> &#123;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>       <span class="hljs-keyword">switch</span> (product) &#123;<br>           <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Hans&quot;</span>:<br>               result = <span class="hljs-string">&quot;汉斯&quot;</span>;<br>               <span class="hljs-keyword">break</span>;<br>           <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Yanjing&quot;</span>:<br>               result = <span class="hljs-string">&quot;燕京&quot;</span>;<br>               <span class="hljs-keyword">break</span>;<br>           <span class="hljs-keyword">default</span>:<br>               result = <span class="hljs-string">&quot;其他啤酒&quot;</span>;<br>               <span class="hljs-keyword">break</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> result;<br>   &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 咖啡工厂</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CoffeeFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractFactory</span>&#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">createProduct</span><span class="hljs-params">(String product)</span> &#123;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>       <span class="hljs-keyword">switch</span> (product) &#123;<br>           <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Mocca&quot;</span>:<br>               result = <span class="hljs-string">&quot;摩卡&quot;</span>;<br>               <span class="hljs-keyword">break</span>;<br>           <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Latte&quot;</span>:<br>               result = <span class="hljs-string">&quot;拿铁&quot;</span>;<br>               <span class="hljs-keyword">break</span>;<br>           <span class="hljs-keyword">default</span>:<br>               result = <span class="hljs-string">&quot;其他咖啡&quot;</span>;<br>               <span class="hljs-keyword">break</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> result;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-什么是观察者模式？"><a href="#5-什么是观察者模式？" class="headerlink" title="5.什么是观察者模式？"></a>5.什么是观察者模式？</h4><p>观察者模式是定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。 </p><p><strong>优点</strong> ：</p><ul><li>观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色；</li><li>观察者模式在观察目标和观察者之间建立一个抽象的耦合；</li><li>观察者模式支持广播通信；</li><li>观察者模式符合开闭原则（对拓展开放，对修改关闭）的要求。</li></ul><p><strong>缺点</strong> ：</p><ul><li>如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间；</li><li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃；</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li></ul><p>在观察者模式中有如下角色：</p><ul><li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象；</li><li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知；</li><li>Observer：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己；</li><li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li></ul><p>观察者模式实现代码如下。</p><h5 id="1）定义观察者（消息接收方）"><a href="#1）定义观察者（消息接收方）" class="headerlink" title="1）定义观察者（消息接收方）"></a>1）定义观察者（消息接收方）</h5><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 观察者（消息接收方）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String message)</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 具体的观察者（消息接收方）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcrereObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcrereObserver</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String message)</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;：&quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2）定义被观察者（消息发送方）"><a href="#2）定义被观察者（消息发送方）" class="headerlink" title="2）定义被观察者（消息发送方）"></a>2）定义被观察者（消息发送方）</h5><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 被观察者（消息发布方）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-comment">// 增加订阅者</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(Observer observer)</span>;<br>    <span class="hljs-comment">// 删除订阅者</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(Observer observer)</span>;<br>    <span class="hljs-comment">// 通知订阅者更新消息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message)</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 具体被观察者（消息发布方）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-comment">// 订阅者列表（存储信息）</span><br>    <span class="hljs-keyword">private</span> List&lt;Observer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Observer&gt;();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(Observer observer)</span> &#123;<br>        list.add(observer);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(Observer observer)</span> &#123;<br>        list.remove(observer);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Observer observer : list) &#123;<br>            observer.update(message);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3）代码调用"><a href="#3）代码调用" class="headerlink" title="3）代码调用"></a>3）代码调用</h5><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObserverTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 定义发布者</span><br>        <span class="hljs-type">ConcreteSubject</span> <span class="hljs-variable">concreteSubject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteSubject</span>();<br>        <span class="hljs-comment">// 定义订阅者</span><br>        <span class="hljs-type">ConcrereObserver</span> <span class="hljs-variable">concrereObserver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcrereObserver</span>(<span class="hljs-string">&quot;老王&quot;</span>);<br>        <span class="hljs-type">ConcrereObserver</span> <span class="hljs-variable">concrereObserver2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcrereObserver</span>(<span class="hljs-string">&quot;Java&quot;</span>);<br>        <span class="hljs-comment">// 添加订阅</span><br>        concreteSubject.attach(concrereObserver);<br>        concreteSubject.attach(concrereObserver2);<br>        <span class="hljs-comment">// 发布信息</span><br>        concreteSubject.notify(<span class="hljs-string">&quot;更新了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行结果如下：</p><blockquote><p>老王：更新了</p></blockquote><blockquote></blockquote><blockquote><p>Java：更新了</p></blockquote><h4 id="6-什么是装饰器模式？"><a href="#6-什么是装饰器模式？" class="headerlink" title="6.什么是装饰器模式？"></a>6.什么是装饰器模式？</h4><p>答：装饰器模式是指动态地给一个对象增加一些额外的功能，同时又不改变其结构。</p><p><strong>优点</strong>：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p><p><strong>装饰器模式的关键</strong>：装饰器中使用了被装饰的对象。</p><p>比如，创建一个对象“laowang”，给对象添加不同的装饰，穿上夹克、戴上帽子……，这个执行过程就是装饰者模式，实现代码如下。</p><h5 id="1）定义顶层对象，定义行为"><a href="#1）定义顶层对象，定义行为" class="headerlink" title="1）定义顶层对象，定义行为"></a>1）定义顶层对象，定义行为</h5><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPerson</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2）定义装饰器超类"><a href="#2）定义装饰器超类" class="headerlink" title="2）定义装饰器超类"></a>2）定义装饰器超类</h5><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoratorBase</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IPerson</span>&#123;<br>    IPerson iPerson;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DecoratorBase</span><span class="hljs-params">(IPerson iPerson)</span>&#123;<br>        <span class="hljs-built_in">this</span>.iPerson = iPerson;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        iPerson.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3）定义具体装饰器"><a href="#3）定义具体装饰器" class="headerlink" title="3）定义具体装饰器"></a>3）定义具体装饰器</h5><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Jacket</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DecoratorBase</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Jacket</span><span class="hljs-params">(IPerson iPerson)</span> &#123;<br>        <span class="hljs-built_in">super</span>(iPerson);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 执行已有功能</span><br>        iPerson.show();<br>        <span class="hljs-comment">// 定义新行为</span><br>        System.out.println(<span class="hljs-string">&quot;穿上夹克&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DecoratorBase</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Hat</span><span class="hljs-params">(IPerson iPerson)</span> &#123;<br>        <span class="hljs-built_in">super</span>(iPerson);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 执行已有功能</span><br>        iPerson.show();<br>        <span class="hljs-comment">// 定义新行为</span><br>        System.out.println(<span class="hljs-string">&quot;戴上帽子&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4）定义具体对象"><a href="#4）定义具体对象" class="headerlink" title="4）定义具体对象"></a>4）定义具体对象</h5><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LaoWang</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IPerson</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;什么都没穿&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5）装饰器模式调用"><a href="#5）装饰器模式调用" class="headerlink" title="5）装饰器模式调用"></a>5）装饰器模式调用</h5><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoratorTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LaoWang</span> <span class="hljs-variable">laoWang</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LaoWang</span>();<br>        <span class="hljs-type">Jacket</span> <span class="hljs-variable">jacket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jacket</span>(laoWang);<br>        <span class="hljs-type">Hat</span> <span class="hljs-variable">hat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hat</span>(jacket);<br>        hat.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-什么是模板方法模式？"><a href="#7-什么是模板方法模式？" class="headerlink" title="7.什么是模板方法模式？"></a>7.什么是模板方法模式？</h4><p>答：模板方法模式是指定义一个模板结构，将具体内容延迟到子类去实现。</p><p><strong>优点</strong> ：</p><ul><li>提高代码复用性：将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中；</li><li>实现了反向控制：通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制并且符合开闭原则。</li></ul><p>以给冰箱中放水果为例，比如，我要放一个香蕉：开冰箱门 → 放香蕉 → 关冰箱门；如果我再要放一个苹果：开冰箱门 → 放苹果 →<br>关冰箱门。可以看出它们之间的行为模式都是一样的，只是存放的水果品类不同而已，这个时候就非常适用模板方法模式来解决这个问题，实现代码如下：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 添加模板方法 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Refrigerator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开冰箱门&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;关冰箱门&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Banana</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Refrigerator</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;放香蕉&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Refrigerator</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;放苹果&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 调用模板方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TemplateTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Refrigerator</span> <span class="hljs-variable">refrigerator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Banana</span>();<br>        refrigerator.open();<br>        refrigerator.put();<br>        refrigerator.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行结果：</p><blockquote><p>开冰箱门</p></blockquote><blockquote></blockquote><blockquote><p>放香蕉</p></blockquote><blockquote></blockquote><blockquote><p>关冰箱门</p></blockquote><h4 id="8-什么是代理模式？"><a href="#8-什么是代理模式？" class="headerlink" title="8.什么是代理模式？"></a>8.什么是代理模式？</h4><p>代理模式是给某一个对象提供一个代理，并由代理对象控制对原对象的引用。</p><p><strong>优点</strong> ：</p><ul><li>代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；</li><li>可以灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务。</li></ul><p><strong>缺点</strong> ：</p><ul><li>由于使用了代理模式，因此程序的性能没有直接调用性能高；</li><li>使用代理模式提高了代码的复杂度。</li></ul><p>举一个生活中的例子：比如买飞机票，由于离飞机场太远，直接去飞机场买票不太现实，这个时候我们就可以上携程 App 上购买飞机票，这个时候携程 App就相当于是飞机票的代理商。</p><p>代理模式实现代码如下：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 定义售票接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IAirTicket</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">buy</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 定义飞机场售票</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AirTicket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IAirTicket</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buy</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;买票&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 代理售票平台</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyAirTicket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IAirTicket</span> &#123;<br>    <span class="hljs-keyword">private</span> AirTicket airTicket;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyAirTicket</span><span class="hljs-params">()</span> &#123;<br>        airTicket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AirTicket</span>();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buy</span><span class="hljs-params">()</span> &#123;<br>        airTicket.buy();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 代理模式调用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">IAirTicket</span> <span class="hljs-variable">airTicket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyAirTicket</span>();<br>        airTicket.buy();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-什么是策略模式？"><a href="#9-什么是策略模式？" class="headerlink" title="9.什么是策略模式？"></a>9.什么是策略模式？</h4><p>答：策略模式是指定义一系列算法，将每个算法都封装起来，并且使他们之间可以相互替换。</p><p><strong>优点</strong> ：遵循了开闭原则，扩展性良好。</p><p><strong>缺点</strong> ：随着策略的增加，对外暴露越来越多。</p><p>以生活中的例子来说，比如我们要出去旅游，选择性很多，可以选择骑车、开车、坐飞机、坐火车等，就可以使用策略模式，把每种出行作为一种策略封装起来，后面增加了新的交通方式了，如超级高铁、火箭等，就可以不需要改动原有的类，新增交通方式即可，这样也符合软件开发的开闭原则。<br>策略模式实现代码如下：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 声明旅行</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITrip</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">going</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bike</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITrip</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">going</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;骑自行车&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Drive</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITrip</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">going</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开车&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 定义出行类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trip</span> &#123;<br>    <span class="hljs-keyword">private</span> ITrip trip;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trip</span><span class="hljs-params">(ITrip trip)</span> &#123;<br>        <span class="hljs-built_in">this</span>.trip = trip;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doTrip</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.trip.going();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 执行方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Trip</span> <span class="hljs-variable">trip</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trip</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bike</span>());<br>        trip.doTrip();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行的结果：</p><blockquote><p>骑自行车</p></blockquote><h4 id="10-什么是适配器模式？"><a href="#10-什么是适配器模式？" class="headerlink" title="10.什么是适配器模式？"></a>10.什么是适配器模式？</h4><p>答：适配器模式是将一个类的接口变成客户端所期望的另一种接口，从而使原本因接口不匹配而无法一起工作的两个类能够在一起工作。</p><p><strong>优点</strong> ：</p><ul><li>可以让两个没有关联的类一起运行，起着中间转换的作用；</li><li>灵活性好，不会破坏原有的系统。</li></ul><p><strong>缺点</strong> ：过多地使用适配器，容易使代码结构混乱，如明明看到调用的是 A 接口，内部调用的却是 B 接口的实现。</p><p>以生活中的例子来说，比如有一个充电器是 MicroUSB 接口，而手机充电口却是 TypeC 的，这个时候就需要一个把 MicroUSB 转换成 TypeC的适配器，如下图所示：</p><p><img src="https://images.gitbook.cn/55a69fa0-e066-11e9-bc61-0549c31758ee" alt="2"></p><p>适配器实现代码如下：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 传统的充电线 MicroUSB</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MicroUSB</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">charger</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * TypeC 充电口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITypeC</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">charger</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeC</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITypeC</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">charger</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;TypeC 充电&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 适配器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AdapterMicroUSB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MicroUSB</span> &#123;<br>    <span class="hljs-keyword">private</span> TypeC typeC;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AdapterMicroUSB</span><span class="hljs-params">(TypeC typeC)</span> &#123;<br>        <span class="hljs-built_in">this</span>.typeC = typeC;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">charger</span><span class="hljs-params">()</span> &#123;<br>        typeC.charger();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 测试调用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdapterTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TypeC</span> <span class="hljs-variable">typeC</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeC</span>();<br>        <span class="hljs-type">MicroUSB</span> <span class="hljs-variable">microUSB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AdapterMicroUSB</span>(typeC);<br>        microUSB.charger();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行结果：</p><blockquote><p>TypeC 充电</p></blockquote><h4 id="11-JDK-类库常用的设计模式有哪些？"><a href="#11-JDK-类库常用的设计模式有哪些？" class="headerlink" title="11.JDK 类库常用的设计模式有哪些？"></a>11.JDK 类库常用的设计模式有哪些？</h4><p>答：JDK 常用的设计模式如下：</p><h5 id="1）工厂模式"><a href="#1）工厂模式" class="headerlink" title="1）工厂模式"></a>1）工厂模式</h5><p>java.text.DateFormat 工具类，它用于格式化一个本地日期或者时间。</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> DateFormat <span class="hljs-title function_">getDateInstance</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> DateFormat <span class="hljs-title function_">getDateInstance</span><span class="hljs-params">(<span class="hljs-type">int</span> style)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> DateFormat <span class="hljs-title function_">getDateInstance</span><span class="hljs-params">(<span class="hljs-type">int</span> style,Locale locale)</span>;<br></code></pre></td></tr></table></figure><p>加密类</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">KeyGenerator</span> <span class="hljs-variable">keyGenerator</span> <span class="hljs-operator">=</span> KeyGenerator.getInstance(<span class="hljs-string">&quot;DESede&quot;</span>);<br><span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(<span class="hljs-string">&quot;DESede&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="2）适配器模式"><a href="#2）适配器模式" class="headerlink" title="2）适配器模式"></a>2）适配器模式</h5><p>把其他类适配为集合类</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; arrayList = java.util.Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;);<br>List&lt;Integer&gt; arrayList = java.util.Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h5 id="3）代理模式"><a href="#3）代理模式" class="headerlink" title="3）代理模式"></a>3）代理模式</h5><p>如 JDK 本身的动态代理。</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The dog is eating&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The cat is eating&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// JDK 代理类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimalProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> Object target; <span class="hljs-comment">// 代理对象</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getInstance</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>        <span class="hljs-comment">// 取得代理对象</span><br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;调用前&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args); <span class="hljs-comment">// 方法调用</span><br>        System.out.println(<span class="hljs-string">&quot;调用后&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// JDK 动态代理调用</span><br>    <span class="hljs-type">AnimalProxy</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnimalProxy</span>();<br>    <span class="hljs-type">Animal</span> <span class="hljs-variable">dogProxy</span> <span class="hljs-operator">=</span> (Animal) proxy.getInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());<br>    dogProxy.eat();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4）单例模式"><a href="#4）单例模式" class="headerlink" title="4）单例模式"></a>4）单例模式</h5><p>全局只允许有一个实例，比如：</p><p>​<br>    Runtime.getRuntime();</p><h5 id="5）装饰器"><a href="#5）装饰器" class="headerlink" title="5）装饰器"></a>5）装饰器</h5><p>为一个对象动态的加上一系列的动作，而不需要因为这些动作的不同而产生大量的继承类。</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">java.io.BufferedInputStream(InputStream);  <br>java.io.DataInputStream(InputStream);  <br>java.io.BufferedOutputStream(OutputStream);  <br>java.util.zip.ZipOutputStream(OutputStream);  <br>java.util.Collections.checkedList(List list, Class type) ;<br></code></pre></td></tr></table></figure><h5 id="6）模板方法模式"><a href="#6）模板方法模式" class="headerlink" title="6）模板方法模式"></a>6）模板方法模式</h5><p>定义一个操作中算法的骨架，将一些步骤的执行延迟到其子类中。</p><p>比如，Arrays.sort() 方法，它要求对象实现 Comparable 接口。</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&#123;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(Integer age)</span>&#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person)o;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age.compareTo(person.age);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SortTest</span>()&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">15</span>);<br>        Person[] persons = &#123;p1,p2,p3&#125;;<br>        <span class="hljs-comment">//排序</span><br>        Arrays.sort(persons);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="12-IO-使用了什么设计模式？"><a href="#12-IO-使用了什么设计模式？" class="headerlink" title="12.IO 使用了什么设计模式？"></a>12.IO 使用了什么设计模式？</h4><p>答：IO 使用了适配器模式和装饰器模式。</p><ul><li>适配器模式：由于 InputStream 是字节流不能享受到字符流读取字符那么便捷的功能，借助 InputStreamReader 将其转为 Reader 子类，因而可以拥有便捷操作文本文件方法；</li><li>装饰器模式：将 InputStream 字节流包装为其他流的过程就是装饰器模式，比如，包装为 FileInputStream、ByteArrayInputStream、PipedInputStream 等。</li></ul><h4 id="13-Spring-中都使用了哪些设计模式？"><a href="#13-Spring-中都使用了哪些设计模式？" class="headerlink" title="13.Spring 中都使用了哪些设计模式？"></a>13.Spring 中都使用了哪些设计模式？</h4><p>答：Spring 框架使用的设计模式如下。</p><ul><li>代理模式：在 AOP 中有使用</li><li>单例模式：bean 默认是单例模式</li><li>模板方法模式：jdbcTemplate</li><li>工厂模式：BeanFactory</li><li>观察者模式：Spring 事件驱动模型就是观察者模式很经典的一个应用，比如，ContextStartedEvent 就是 ApplicationContext 启动后触发的事件</li><li>适配器模式：Spring MVC 中也是用到了适配器模式适配 Controller</li></ul><blockquote><p>[点击此处下载本文源码](<a href="https://github.com/vipstone/java-">https://github.com/vipstone/java-</a><br>interview/tree/master/interview-code/src/main/java/com/interview)</p></blockquote><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul><li>设计模式之禅（第2版）</li><li><a href="https://java-design-patterns.com/patterns/">Java Design Patterns</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java面试全解析核心知识点与典型面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>036--JVM面试题汇总</title>
    <link href="/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/036--JVM%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/036--JVM%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h4 id="1-什么是-JVM？它有什么作用？"><a href="#1-什么是-JVM？它有什么作用？" class="headerlink" title="1.什么是 JVM？它有什么作用？"></a>1.什么是 JVM？它有什么作用？</h4><p>答：JVM 是 Java Virtual Machine（Java 虚拟机）的缩写，顾名思义它是一个虚拟计算机，也是 Java程序能够实现跨平台的基础。它的作用是加载 Java 程序，把字节码翻译成机器码再交由 CPU 执行的一个虚拟计算器。</p><h4 id="2-JVM-主要组成部分有哪些？"><a href="#2-JVM-主要组成部分有哪些？" class="headerlink" title="2.JVM 主要组成部分有哪些？"></a>2.JVM 主要组成部分有哪些？</h4><p>答：JVM 主要组成部分如下：</p><ul><li>类加载器（ClassLoader）</li><li>运行时数据区（Runtime Data Area）</li><li>执行引擎（Execution Engine）</li><li>本地库接口（Native Interface）</li></ul><h4 id="3-JVM-是如何工作的？"><a href="#3-JVM-是如何工作的？" class="headerlink" title="3.JVM 是如何工作的？"></a>3.JVM 是如何工作的？</h4><p>答：首先程序在执行之前先要把 Java 代码（.java）转换成字节码（.class），JVM通过类加载器（ClassLoader）把字节码加载到内存中，但字节码文件是 JVM的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine） 将字节码翻译成底层机器码，再交由CPU 去执行，CPU 执行的过程中需要调用本地库接口（Native Interface）来完成整个程序的运行。</p><h4 id="4-JVM-内存布局是怎样的？"><a href="#4-JVM-内存布局是怎样的？" class="headerlink" title="4.JVM 内存布局是怎样的？"></a>4.JVM 内存布局是怎样的？</h4><p>答：不同虚拟机实现可能略微有所不同，但都会遵从 Java 虚拟机规范，Java 8 虚拟机规范规定，Java 虚拟机所管理的内存将会包括以下几个区域：</p><ul><li>程序计数器（Program Counter Register）</li><li>Java 虚拟机栈（Java Virtual Machine Stacks）</li><li>本地方法栈（Native Method Stack）</li><li>Java 堆（Java Heap）</li><li>方法区（Method Area）</li></ul><p><strong>① 程序计数器</strong></p><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解析器的工作是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于 JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，也就是任何时刻，一个处理器（或者说一个内核）都只会执行一条线程中的指令。因此为了线程切换后能恢复到正确地执行位置，每个线程都有独立的程序计数器。</p><p>如果线程正在执行 Java 中的方法，程序计数器记录的就是正在执行虚拟机字节码指令的地址，如果是 Native方法，这个计数器就为空（undefined），因此该内存区域是唯一一个在 Java 虚拟机规范中没有规定 OutOfMemoryError 的区域。</p><p><strong>② Java 虚拟机栈</strong></p><p>Java 虚拟机栈（Java Virtual Machine Stacks）描述的是 Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack<br>Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用直至执行完成的过程，都对应着一个线帧在虚拟机栈中入栈到出栈的过程。</p><ul><li>如果线程请求的栈深度大于虚拟机所允许的栈深度就会抛出 StackOverflowError 异常。</li><li>如果虚拟机是可以动态扩展的，如果扩展时无法申请到足够的内存就会抛出 OutOfMemoryError 异常。</li></ul><p><strong>③ 本地方法栈</strong></p><p>本地方法栈（Native Method Stack）与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用<br>Native 方法服务的。</p><p>在 Java 虚拟机规范中对于本地方法栈没有特殊的要求，虚拟机可以自由地实现它，因此在 Sun HotSpot 虚拟机直接把本地方法栈和虚拟机栈合二为一了。</p><p><strong>④ Java 堆</strong></p><p>Java 堆（Java Heap）是 JVM 中内存最大的一块，是被所有线程共享的，在虚拟机启动时候创建，Java堆唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存，随着JIT编译器的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化的技术将会导致一些微妙的变化，所有的对象都分配在堆上渐渐变得不那么绝对了。</p><p>如果在堆中没有内存完成实例分配，并且堆不可以再扩展时，将会抛出 OutOfMemoryError。 Java 虚拟机规范规定，Java堆可以处在物理上不连续的内存空间中，只要逻辑上连续即可，就像我们的磁盘空间一样。在实现上也可以是固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是可扩展的，通过-Xmx 和 -Xms 控制。</p><p><strong>⑤ 方法区</strong></p><p>方法区（Method Area）用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</p><p>很多人把方法区称作“永久代”（Permanent Generation），本质上两者并不等价，只是 HotSpot 虚拟机垃圾回收器团队把 GC分代收集扩展到了方法区，或者说是用来永久代来实现方法区而已，这样能省去专门为方法区编写内存管理的代码，但是在 JDK 8 也移除了“永久代”，使用Native Memory 来实现方法区。</p><p>当方法无法满足内存分配需求时会抛出 OutOfMemoryError 异常。</p><h4 id="5-在-Java-中负责字节码解释执行的是？"><a href="#5-在-Java-中负责字节码解释执行的是？" class="headerlink" title="5.在 Java 中负责字节码解释执行的是？"></a>5.在 Java 中负责字节码解释执行的是？</h4><p>A：应用服务器<br>B：垃圾回收器<br>C：虚拟机<br>D：编译器</p><p>答：C</p><h4 id="6-静态变量存储在哪个区？"><a href="#6-静态变量存储在哪个区？" class="headerlink" title="6.静态变量存储在哪个区？"></a>6.静态变量存储在哪个区？</h4><p>A：栈区<br>B：堆区<br>C：全局区<br>D：常量区</p><p>答：C</p><p>题目解析：栈区存放函数的参数值，局部变量的值等；堆区存放的是程序员创建的对象；全局区存放全局变量和静态变量；常量区存放常量字符串。</p><h4 id="7-垃圾回收算法有哪些？"><a href="#7-垃圾回收算法有哪些？" class="headerlink" title="7.垃圾回收算法有哪些？"></a>7.垃圾回收算法有哪些？</h4><p>答：垃圾回收算法如下。</p><ul><li>引用计数器算法：引用计算器判断对象是否存活的算法是这样的，给每一个对象设置一个引用计数器，每当有一个地方引用这个对象的时候，计数器就加 1，与之相反，每当引用失效的时候就减 1。</li><li>可达性分析算法：在主流的语言的主流实现中，比如 Java、C#，甚至是古老的 Lisp 都是使用的可达性分析算法来判断对象是否存活的。这个算法的核心思路就是通过一些列的“GC Roots”对象作为起始点，从这些对象开始往下搜索，搜索所经过的路径称之为“引用链”。当一个对象到 GC Roots 没有任何引用链相连的时候，证明此对象是可以被回收的。</li><li>复制算法：复制算法是将内存分为大小相同的两块，当这一块使用完了，就把当前存活的对象复制到另一块，然后一次性清空当前区块。此算法的缺点是只能利用一半的内存空间。</li><li>标记-清除算法：此算法执行分两阶段，第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</li><li>标记-整理：此算法结合了“标记-清除”和“复制”两个算法的优点。分为两个阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。</li></ul><h4 id="8-哪些对象可以作为引用链的-Root-对象？"><a href="#8-哪些对象可以作为引用链的-Root-对象？" class="headerlink" title="8.哪些对象可以作为引用链的 Root 对象？"></a>8.哪些对象可以作为引用链的 Root 对象？</h4><p>答：引用链的 Root 对象可以为以下内容：</p><ul><li>Java 虚拟机栈中的引用对象；</li><li>本地方法栈中 JNI（既一般说的 Native 方法）引用的对象；</li><li>方法区中类静态常量的引用对象；</li><li>方法区中常量的引用对象。</li></ul><h4 id="9-对象引用关系都有哪些？"><a href="#9-对象引用关系都有哪些？" class="headerlink" title="9.对象引用关系都有哪些？"></a>9.对象引用关系都有哪些？</h4><p>答：不管是引用计数法还是可达性分析算法都与对象的“引用”有关，这说明对象的引用决定了对象的生死，对象的引用关系如下。</p><ul><li>强引用：在代码中普遍存在的，类似 <code>Object obj = new Object()</code> 这类引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。</li><li>软引用：是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当JVM 认为内存不足时，才会去试图回收软引用指向的对象，JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。</li><li>弱引用：非必需对象，但它的强度比软引用更弱，弱引用关联的对象只能生存到下一次垃圾收集发生之前。</li><li>虚引用：也称为幽灵引用或幻影引用，是最弱的一种引用关系，无法通过虚引用来获取一个对象实例，为对象设置虚引用的目的只有一个，就是当着个对象被收集器回收时收到一条系统通知。</li></ul><h4 id="10-内存溢出和内存泄漏的区别是什么？"><a href="#10-内存溢出和内存泄漏的区别是什么？" class="headerlink" title="10.内存溢出和内存泄漏的区别是什么？"></a>10.内存溢出和内存泄漏的区别是什么？</h4><p>答：内存溢出和内存泄漏的区别如下：</p><ul><li>内存溢出是指程序申请内存时，没有足够的内存，就会报错 OutOfMemory；</li><li>内存泄漏是指垃圾对象无法回收，可以使用 Memory Analyzer 等工具排出内存泄漏。</li></ul><h4 id="11-垃圾回收的分类都有哪些？"><a href="#11-垃圾回收的分类都有哪些？" class="headerlink" title="11.垃圾回收的分类都有哪些？"></a>11.垃圾回收的分类都有哪些？</h4><p>答：垃圾回收的分类如下：</p><ul><li>新生代回收器：Serial、ParNew、Parallel Scavenge</li><li>老年代回收器：Serial Old、Parallel Old、CMS</li><li>整堆回收器：G1</li></ul><h4 id="12-分代垃圾回收器的组成部分有哪些？"><a href="#12-分代垃圾回收器的组成部分有哪些？" class="headerlink" title="12.分代垃圾回收器的组成部分有哪些？"></a>12.分代垃圾回收器的组成部分有哪些？</h4><p>答：分代垃圾回收器是由：新生代（Young Generation）和老生代（Tenured Generation）组成的，默认情况下新生代和老生代的内存比例是 1:2。</p><h4 id="13-新生代的组成部分有哪些？"><a href="#13-新生代的组成部分有哪些？" class="headerlink" title="13.新生代的组成部分有哪些？"></a>13.新生代的组成部分有哪些？</h4><p>答：新生代是由：Eden、Form Survivor、To Survivor 三个区域组成的，它们内存默认占比是 8:1:1。</p><h4 id="14-新生代垃圾回收是怎么执行的？"><a href="#14-新生代垃圾回收是怎么执行的？" class="headerlink" title="14.新生代垃圾回收是怎么执行的？"></a>14.新生代垃圾回收是怎么执行的？</h4><p>答：新生代垃圾回收的执行过程如下：</p><p>① Eden 区 + From Survivor 区存活着的对象复制到 To Survivor 区；<br>② 清空 Eden 和 From Survivor 分区；<br>③ From Survivor 和 To Survivor 分区交换（From 变 To，To 变 From）。</p><h4 id="15-为什么新生代有两个-Survivor-分区？"><a href="#15-为什么新生代有两个-Survivor-分区？" class="headerlink" title="15.为什么新生代有两个 Survivor 分区？"></a>15.为什么新生代有两个 Survivor 分区？</h4><p>答：当新生代的 Survivor 分区为 2 个的时候，不论是空间利用率还是程序运行的效率都是最优的。</p><ul><li>如果 Survivor 是 0 的话，也就是说新生代只有一个 Eden 分区，每次垃圾回收之后，存活的对象都会进入老生代，这样老生代的内存空间很快就被占满了，从而触发最耗时的 Full GC ，显然这样的收集器的效率是我们完全不能接受的。</li><li>如果 Survivor 分区是 1 个的话，假设把两个区域分为 1:1，那么任何时候都有一半的内存空间是闲置的，显然空间利用率太低不是最佳的方案。但如果设置内存空间的比例是 8:2 ，只是看起来似乎“很好”，假设新生代的内存为 100 MB（ Survivor 大小为 20 MB ），现在有 70 MB 对象进行垃圾回收之后，剩余活跃的对象为 15 MB 进入 Survivor 区，这个时候新生代可用的内存空间只剩了 5 MB，这样很快又要进行垃圾回收操作，显然这种垃圾回收器最大的问题就在于，需要频繁进行垃圾回收。</li><li>如果 Survivor 分区有 2 个分区，我们就可以把 Eden、From Survivor、To Survivor 分区内存比例设置为 8:1:1 ，那么任何时候新生代内存的利用率都 90% ，这样空间利用率基本是符合预期的。再者就是虚拟机的大部分对象都符合“朝生夕死”的特性，因此每次新对象的产生都在空间占比比较大的 Eden 区，垃圾回收之后再把存活的对象方法存入 Survivor 区，如果是 Survivor 区存活的对象，那么“年龄”就 +1 ，当年龄增长到 15 （可通过 -XX:+MaxTenuringThreshold 设定）对象就升级到老生代。</li></ul><p>经过以上对比，可以得出结论，当新生代的 Survivor 分区为 2 个的时候，不论是空间利用率还是程序运行的效率都是最优的。</p><h4 id="16-什么是-CMS-垃圾回收器？"><a href="#16-什么是-CMS-垃圾回收器？" class="headerlink" title="16.什么是 CMS 垃圾回收器？"></a>16.什么是 CMS 垃圾回收器？</h4><p>答：CMS（Concurrent Mark Sweep）一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。</p><h4 id="17-CMS-垃圾回收器有哪些优缺点？"><a href="#17-CMS-垃圾回收器有哪些优缺点？" class="headerlink" title="17.CMS 垃圾回收器有哪些优缺点？"></a>17.CMS 垃圾回收器有哪些优缺点？</h4><p>答：CMS 垃圾回收器的优点是使用多线程，标记清除垃圾的，它缺点如下。</p><ul><li>对 CPU 资源要求敏感：CMS 回收器过分依赖于多线程环境，默认情况下，开启的线程数为（CPU 的数量 + 3）/ 4，当 CPU 数量少于 4 个时，CMS 对用户本身的操作的影响将会很大，因为要分出一半的运算能力去执行回收器线程；</li><li>CMS 无法清除浮动垃圾：浮动垃圾指的是 CMS 清除垃圾的时候，还有用户线程产生新的垃圾，这部分未被标记的垃圾叫做“浮动垃圾”，只能在下次 GC 的时候进行清除；</li><li>CMS 垃圾回收会产生大量空间碎片：CMS 使用的是标记-清除算法，所有在垃圾回收的时候回产生大量的空间碎片。</li></ul><h4 id="18-什么是-G1-垃圾回收器？"><a href="#18-什么是-G1-垃圾回收器？" class="headerlink" title="18.什么是 G1 垃圾回收器？"></a>18.什么是 G1 垃圾回收器？</h4><p>答：G1 垃圾回收器是一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。G1 可以直观的设定停顿时间的目标，相比于 CMS，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</p><p>G1 GC 仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一个个 Region。Region之间是复制算法，但整体上实际可看作是标记 - 整理（Mark-Compact）算法，可以有效地避免内存碎片，尤其是当 Java 堆非常大的时候，G1的优势更加明显。</p><h4 id="19-垃圾回收的调优参数有哪些？"><a href="#19-垃圾回收的调优参数有哪些？" class="headerlink" title="19.垃圾回收的调优参数有哪些？"></a>19.垃圾回收的调优参数有哪些？</h4><p>答：垃圾回收的常用调优如下：</p><ul><li>-Xmx:512 设置最大堆内存为 512 M；</li><li>-Xms:215 初始堆内存为 215 M；</li><li>-XX:MaxNewSize 设置最大年轻区内存；</li><li>-XX:MaxTenuringThreshold=5 设置新生代对象经过 5 次 GC 晋升到老年代；</li><li>-XX:PretrnureSizeThreshold 设置大对象的值，超过这个值的大对象直接进入老生代；</li><li>-XX:NewRatio 设置分代垃圾回收器新生代和老生代内存占比；</li><li>-XX:SurvivorRatio 设置新生代 Eden、Form Survivor、To Survivor 占比。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java面试全解析核心知识点与典型面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>033--Redis面试题汇总</title>
    <link href="/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/033--Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/033--Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis-面试题汇总"><a href="#Redis-面试题汇总" class="headerlink" title="Redis 面试题汇总"></a>Redis 面试题汇总</h2><h4 id="1-Redis-使用场景有哪些？"><a href="#1-Redis-使用场景有哪些？" class="headerlink" title="1.Redis 使用场景有哪些？"></a>1.Redis 使用场景有哪些？</h4><p>答：Redis 使用场景如下：</p><ul><li>记录帖子点赞数、点击数、评论数</li><li>缓存近期热帖</li><li>缓存文章详情信息</li><li>记录用户会话信息</li></ul><h4 id="2-Redis-有哪些功能？"><a href="#2-Redis-有哪些功能？" class="headerlink" title="2.Redis 有哪些功能？"></a>2.Redis 有哪些功能？</h4><p>答：Redis 功能如下：</p><ul><li>数据缓存功能</li><li>分布式锁的功能</li><li>支持数据持久化</li><li>支持事务</li><li>支持消息队列</li></ul><h4 id="3-Redis-支持哪些数据类型？"><a href="#3-Redis-支持哪些数据类型？" class="headerlink" title="3.Redis 支持哪些数据类型？"></a>3.Redis 支持哪些数据类型？</h4><p>答：Redis 支持的数据类型如下：</p><ul><li>String 字符串</li><li>List 列表</li><li>Set 无序集合</li><li>ZSet 有序集合</li><li>Hash 哈希类型</li></ul><h4 id="4-Redis-相比-Memcached-有哪些优势？"><a href="#4-Redis-相比-Memcached-有哪些优势？" class="headerlink" title="4.Redis 相比 Memcached 有哪些优势？"></a>4.Redis 相比 Memcached 有哪些优势？</h4><p>答：Redis 相比 Memcached 优势如下：</p><ul><li>Memcached 所有的值均是简单的字符串，Redis 支持更为丰富的数据类型</li><li>Redis 的速度比 Memcached 要快</li><li>Redis 可以持久化</li><li>Redis 可以设置过期时间</li><li>Redis 支持主从同步</li></ul><h4 id="5-Redis-支持哪些淘汰策略？"><a href="#5-Redis-支持哪些淘汰策略？" class="headerlink" title="5.Redis 支持哪些淘汰策略？"></a>5.Redis 支持哪些淘汰策略？</h4><p>答：Redis 淘汰策略如下：</p><ul><li>noeviction：禁止淘汰数据；</li><li>allkeys-lru：尝试回收最少使用的键，使得新添加的数据有空间存放；</li><li>volatile-lru：尝试回收最少使用的键，但仅限于在过期集合的键，使得新添加的数据有空间存放；</li><li>allkeys-random：回收随机的键使得新添加的数据有空间存放；</li><li>volatile-random：回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键；</li><li>volatile-ttl：回收在过期集合的键，并且优先回收存活时间较短的键，使得新添加的数据有空间存放。</li></ul><h4 id="6-官方为什么不支持-Windows-版本？"><a href="#6-官方为什么不支持-Windows-版本？" class="headerlink" title="6.官方为什么不支持 Windows 版本？"></a>6.官方为什么不支持 Windows 版本？</h4><p>答：Redis 官方是不支持 Windows 版的，因为目前 Linux 版本已经相当稳定，如果开发 Windows 版本，反而会带来兼容性等问题。</p><h4 id="7-为什么-Redis-是单线程的？"><a href="#7-为什么-Redis-是单线程的？" class="headerlink" title="7.为什么 Redis 是单线程的？"></a>7.为什么 Redis 是单线程的？</h4><p>答：因为 Redis 的瓶颈最有可能是机器内存或者网络带宽，而非单线程，既然单线程不是 Redis 的性能瓶颈，并且单线程又比较容易实现，所以 Redis就选择使用单线程来实现。</p><p>单线程并不代表运行速度就慢，比如，Nginx 和 NodeJs 都是单线程高性能的代表。</p><h4 id="8-为什么-Redis-需要把所有数据放到内存中？"><a href="#8-为什么-Redis-需要把所有数据放到内存中？" class="headerlink" title="8.为什么 Redis 需要把所有数据放到内存中？"></a>8.为什么 Redis 需要把所有数据放到内存中？</h4><p>答：Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘，这样 Redis 就拥有了快速查询和数据持久化等特征。</p><h4 id="9-在-Redis-中-key-的最大容量是多少？"><a href="#9-在-Redis-中-key-的最大容量是多少？" class="headerlink" title="9.在 Redis 中 key 的最大容量是多少？"></a>9.在 Redis 中 key 的最大容量是多少？</h4><p>答：最大容量 512 MB，官方说明如下图所示：</p><p><img src="https://images.gitbook.cn/4ea56a20-e05b-11e9-99bc-59d43b30c641" alt="1"></p><h4 id="10-Jedis-和-Redisson-有什么区别？"><a href="#10-Jedis-和-Redisson-有什么区别？" class="headerlink" title="10.Jedis 和 Redisson 有什么区别？"></a>10.Jedis 和 Redisson 有什么区别？</h4><p>答：Jedis 和 Redisson 的区别如下：</p><ul><li>Jedis 是 Redis 的 Java 实现客户端，其 API 提供了比较全面的 Redis 命令的支持；</li><li>Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等 Redis 特性。Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</li></ul><h4 id="11-Redis-如何设置过期时间？如何设置永久有效？"><a href="#11-Redis-如何设置过期时间？如何设置永久有效？" class="headerlink" title="11.Redis 如何设置过期时间？如何设置永久有效？"></a>11.Redis 如何设置过期时间？如何设置永久有效？</h4><p>答：Redis 通过 expire() 方法设置过期时间，语法：redis.expire(key, expiration)。当 expire的过期时间设置为 -1 时，表示永不过期。</p><h4 id="12-如何保证-Redis-的数据一致性？"><a href="#12-如何保证-Redis-的数据一致性？" class="headerlink" title="12.如何保证 Redis 的数据一致性？"></a>12.如何保证 Redis 的数据一致性？</h4><p>答：可使用以下方法来保证 Redis 的数据一致性：</p><ul><li>合理设置缓存的过期时间；</li><li>新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</li></ul><h4 id="13-Redis-的数据结构是什么？它有什么优缺点？"><a href="#13-Redis-的数据结构是什么？它有什么优缺点？" class="headerlink" title="13.Redis 的数据结构是什么？它有什么优缺点？"></a>13.Redis 的数据结构是什么？它有什么优缺点？</h4><p>答：Redis的数据结构是跳跃表，跳跃表是一种基于链表的扩展，跳跃表还是一个链表，是一个有序的链表，在遍历的时候基于比较，但普通链表只能遍历，跳跃表加入了一个层的概念，层级越高元素越少，每次先从高层查找，直到找到合适的位置，从图中可以看到高层的节点远远少于底层的节点数，从而实现了跳跃式查找。</p><p><img src="https://images.gitbook.cn/693382a0-e05b-11e9-bc61-0549c31758ee" alt="2"></p><p>跳跃表优点：</p><ul><li>实现比红黑树简单</li><li>比红黑树更容易扩展</li><li>红黑树插入删除时为了平衡高度需要旋转附近节点，高并发需要锁，跳跃表不需要考虑</li></ul><p>跳跃表缺点：</p><ul><li>比红黑树占用更多的内存，每个节点的大小取决于该节点层数</li><li>空间局部性差导致缓存命中率低，比红黑树略慢</li></ul><h4 id="14-Redis-为什么用跳跃表来存储？"><a href="#14-Redis-为什么用跳跃表来存储？" class="headerlink" title="14.Redis 为什么用跳跃表来存储？"></a>14.Redis 为什么用跳跃表来存储？</h4><p>答：第一是因为红黑树存储比较复杂，调整涉及到多个节点的并发修改；第二是越接近根节点的地方越容易产生竞争，即使是不同叶子节点的操作由于平衡操作也可能逐级向上涉及到接近根的节点，而跳跃表可以用CAS（Compare And Swap）来并发操作节点，比较容易实现，且更加局部化。</p><h4 id="15-什么是缓存穿透？如何解决？"><a href="#15-什么是缓存穿透？如何解决？" class="headerlink" title="15.什么是缓存穿透？如何解决？"></a>15.什么是缓存穿透？如何解决？</h4><p>答：缓存穿透是指查询一个一定不存在的数据，由于缓存中没有，因而每次需要从数据库中查询，但数据库也没有相应的数据，所以不会写入缓存，这就将导致每次请求都会去数据库查询，这种行为就叫缓存穿透。</p><p>解决方案是不管查询数据库是否有数据，都缓存起来，只不过把没有数据的缓存结果的过期时间设置为比较短的一个值，比如 3 分钟。</p><h4 id="16-什么是缓存雪崩，该如何解决？"><a href="#16-什么是缓存雪崩，该如何解决？" class="headerlink" title="16.什么是缓存雪崩，该如何解决？"></a>16.什么是缓存雪崩，该如何解决？</h4><p>答：指缓存由于某些原因，比如，宕机或者缓存大量过期等，从而导致大量请求到达后端数据库，进而导致数据库崩溃的情况。</p><p>解决缓存雪崩的方案如下：</p><ul><li>分析业务功能，尽量让缓存的失效时间点均匀分布；</li><li>使用 Redis 主备，保证缓存系统的高可用。</li></ul><h4 id="17-什么是缓存预热？有几种实现方式？"><a href="#17-什么是缓存预热？有几种实现方式？" class="headerlink" title="17.什么是缓存预热？有几种实现方式？"></a>17.什么是缓存预热？有几种实现方式？</h4><p>答：缓存预热是指系统上线后，将相关的缓存数据直接加载到缓存系统，这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。</p><p>缓存预热的实现方式，可分为以下两种：</p><ul><li>数据量不大的时候，工程启动的时候进行加载缓存动作；</li><li>数据量大的时候，设置一个定时任务脚本，进行缓存的刷新。</li></ul><h4 id="18-在-Java-程序中如何使用-Redis？"><a href="#18-在-Java-程序中如何使用-Redis？" class="headerlink" title="18.在 Java 程序中如何使用 Redis？"></a>18.在 Java 程序中如何使用 Redis？</h4><p>答：在 Java 程序中可使用 Jedis 来操作 Redis，使用步骤如下：</p><p>1）添加 Jedis 引用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>x.x.x<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2）连接并操作 Redis</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">Jedis jedis = new Jedis(&quot;127.0.0.1&quot;,6379);<br>    // 存值<br>    jedis.set(&quot;hello&quot;,&quot;world&quot;);<br>    // 取值<br>    jedis.get(&quot;hello&quot;);<br>    // 关闭连接<br>    jedis.close();<br></code></pre></td></tr></table></figure><h4 id="19-什么是-Redis-持久化？如何进行-Redis-持久化？"><a href="#19-什么是-Redis-持久化？如何进行-Redis-持久化？" class="headerlink" title="19.什么是 Redis 持久化？如何进行 Redis 持久化？"></a>19.什么是 Redis 持久化？如何进行 Redis 持久化？</h4><p>答：Redis 持久化是指将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis 有以下两种持久化方案：</p><ul><li>RDB（Redis DataBase）：是指在制定的时间间隔内将内存中的数据集快照写入磁盘；</li><li>AOF（Append Only File）：该机制将以日志的形式记录服务器所处理的每一个写操作，在 Redis 服务器启动之初会读取该文件来重新构建数据库，以保证启动后数据库中的数据是完整的。</li></ul><p>Redis 默认支持的持久化方式是 RDB 方式。</p><h4 id="20-RDB-和-AOF-有什么区别？"><a href="#20-RDB-和-AOF-有什么区别？" class="headerlink" title="20.RDB 和 AOF 有什么区别？"></a>20.RDB 和 AOF 有什么区别？</h4><p>答：RDB 和 AOF 的区别如下：</p><ul><li>RDB 可能会引起一定程度的数据丢失，AOF 不会造成数据丢失</li><li>RDB 的启动效率更高</li><li>AOF 占用的空间比 RDB 大，AOF 的同步速度比 RDB 慢</li></ul><p>总体来说如果对数据的完整性要求不高，RDB 是最好的解决方案，反之则选择 AOF。</p><h4 id="21-Redis-的监控工具都有哪些？"><a href="#21-Redis-的监控工具都有哪些？" class="headerlink" title="21.Redis 的监控工具都有哪些？"></a>21.Redis 的监控工具都有哪些？</h4><p>答：常用的 Redis 监控工具如下：</p><ul><li>Redis-stat：采用 Ruby 开发，基于 Redis 的 info 命令来统计，不影响 Redis 的性能；</li><li>RedisLive：采用 Python 开发的可视化及查询分析工具，它是通过监控脚本来 Redis 提供的 MONITOR 命令从被监控 Redis 实例中获取数据，并存储到 Redis 的监控实例中。</li></ul><h4 id="22-如何定位-Redis-的慢查询？"><a href="#22-如何定位-Redis-的慢查询？" class="headerlink" title="22.如何定位 Redis 的慢查询？"></a>22.如何定位 Redis 的慢查询？</h4><p>答：使用 slowlog get 来定位慢查询操作，如下所示：</p><blockquote><p>127.0.0.1:6379&gt; slowlog get</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span>) <span class="hljs-number">1</span>) (<span class="hljs-type">integer</span>) <span class="hljs-number">219</span><br>   <span class="hljs-number">2</span>) (<span class="hljs-type">integer</span>) <span class="hljs-number">1658999722</span><br>   <span class="hljs-number">3</span>) (<span class="hljs-type">integer</span>) <span class="hljs-number">17351</span><br>   <span class="hljs-number">4</span>) <span class="hljs-number">1</span>) &quot;SUNION&quot;<br>      <span class="hljs-number">2</span>) &quot;pms:role:permission:1534381742130094080&quot;<br>      <span class="hljs-number">3</span>) &quot;pms:role:permission:1534783302026846208&quot;<br>   <span class="hljs-number">5</span>) &quot;172.21.226.147:44782&quot;<br>   <span class="hljs-number">6</span>) &quot;&quot;<br></code></pre></td></tr></table></figure><p>其中：</p><ol><li><p>表示慢查询记录 id</p></li><li><p>表示发起命令的时间戳</p></li><li><p>表示命令耗时，单位为微秒</p></li><li><p>表示该条记录的命令及参数</p></li></ol><h4 id="23-SAVE-和-BGSAVE-有什么区别？"><a href="#23-SAVE-和-BGSAVE-有什么区别？" class="headerlink" title="23.SAVE 和 BGSAVE 有什么区别？"></a>23.SAVE 和 BGSAVE 有什么区别？</h4><p>答：SAVE 和 BGSAVE 都是用于 Redis 持久化的，它们的区别如下：</p><ul><li>SAVE 直接调用 rdbSave 函数（用于 Redis 持久化的函数），阻塞 Redis 主进程，直到保存完成为止，在主进程阻塞期间，服务器不能处理客户端的任何请求；</li><li>BGSAVE 则会创建一个子进程，子进程负责调用 rdbSave 函数，并在保存完成之后向主进程发送完成信号，Redis 服务器在 BGSAVE 执行期间仍然可以继续处理客户端的请求。</li></ul><h4 id="24-Redis-是如何实现同步的？"><a href="#24-Redis-是如何实现同步的？" class="headerlink" title="24.Redis 是如何实现同步的？"></a>24.Redis 是如何实现同步的？</h4><p>答：Redis 可以实现主从同步和从从同步。当第一次同步时，主节点做一次 BGSAVE，并同时将后续修改操作记录到内存中，待完成后将 RDB文件全量同步到复制节点，复制节点接受完成后将 RDB镜像加载到内存，加载完成后再通知主节点将期间修改的操作记录，同步到复制节点进行重放，这样就完成了同步过程。</p><h4 id="25-Redis-可以切换数据库吗？如何切换？"><a href="#25-Redis-可以切换数据库吗？如何切换？" class="headerlink" title="25.Redis 可以切换数据库吗？如何切换？"></a>25.Redis 可以切换数据库吗？如何切换？</h4><p>答：Redis 不像 MySQL 等关系型数据库那样有数据库的概念，不同的数据存在不同的数据库中，Redis数据库是由一个整数索引标识，而不是一个数据库名称，默认情况下客户端连接到数据库 0，可以在配置文件中控制数据库总数，默认是 16 个。</p><p>可以使用 select index 来切换数据库，如下所示：</p><blockquote><p>127.0.0.1:6379&gt; select 0</p></blockquote><blockquote><p>OK</p></blockquote><h4 id="26-Redis-有哪些集群策略？"><a href="#26-Redis-有哪些集群策略？" class="headerlink" title="26.Redis 有哪些集群策略？"></a>26.Redis 有哪些集群策略？</h4><p>答：Redis 集群策略有以下 3 种：</p><ul><li>主从策略：1 台机器作为写操作，另外 2 台作为读操作，类似于 MySQL 的主从方式；</li><li>哨兵策略：增加 1 台机器作为哨兵，监控 3 台主从机器，当主节点挂机的时候，机器内部进行选举，从集群中从节点里指定一台机器升级为主节点，从而实现高可用。当主节点恢复的时候，加入到从节点中继续提供服务；</li><li>集群策略：Redis 3.0 之后增加了集群的概念，可实现多主多从的结构，实现真正的高可用。</li></ul><h4 id="27-Redis-集群方案都有哪些？"><a href="#27-Redis-集群方案都有哪些？" class="headerlink" title="27.Redis 集群方案都有哪些？"></a>27.Redis 集群方案都有哪些？</h4><p>答：Redis 集群实现方案如下：</p><ul><li>Twemproxy 是 Twitter 开源的 Redis 代理，它的使用和普通 Redis 完全一致，它会以一个代理的身份接收请求，并使用 hash 算法将请求转接到具体 Redis，将结果再返回 Twemproxy；</li><li>Codis 是开源解决方案，也是目前用的最多的集群方案，基本和 Twemproxy 效果一致，但它支持在节点数量改变情况下，旧节点数据可恢复到新 hash 节点；</li><li>Redis Cluster 是 Redis 3.0 自带的集群方案，特点在于他的分布式算法不是一致性 hash，而是 hash 槽的概念，以及自身支持节点设置从节点；</li><li>业务代码层实现，创建几个独立的 Redis 实例，在代码层对 key 进行 hash 计算，然后去对应的 Redis 实例操作数据。这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复、实例的监控等。</li></ul><h4 id="28-Redis-如何做内存优化？"><a href="#28-Redis-如何做内存优化？" class="headerlink" title="28.Redis 如何做内存优化？"></a>28.Redis 如何做内存优化？</h4><p>答：把相关的信息整体存储，而不是把每个信息独立存储，这样就可以有效的减少内存使用。</p><h4 id="29-分布式锁设计时需要注意哪些事项？"><a href="#29-分布式锁设计时需要注意哪些事项？" class="headerlink" title="29.分布式锁设计时需要注意哪些事项？"></a>29.分布式锁设计时需要注意哪些事项？</h4><p>答：通常分布式锁在设计时，需同时满足以下四个约束条件。</p><ul><li>互斥性：在任意时刻，只有一个客户端能持有锁。</li><li>安全性：即不会形成死锁，当一个客户端在持有锁的期间崩溃而没有主动解锁的情况下，其持有的锁也能够被正确释放，并保证后续其他客户端能加锁。</li><li>可用性：就 Redis 而言，当提供锁服务的 Redis master 节点发生宕机等不可恢复性故障时，slave 节点能够升主并继续提供服务，支持客户端加锁和解锁；对基于分布式一致性算法实现的锁服务，如 ETCD 而言，当 leader 节点宕机时，follow 节点能够选举出新的 leader 继续提供锁服务。</li><li>对称性：对于任意一个锁，其加锁和解锁必须是同一个客户端，即，客户端 A 不能把客户端 B 加的锁给解了。</li></ul><h4 id="30-Redis-集群实现的原理是什么？"><a href="#30-Redis-集群实现的原理是什么？" class="headerlink" title="30.Redis 集群实现的原理是什么？"></a>30.Redis 集群实现的原理是什么？</h4><p>答：集群的实现原理和集群的实现方式有关，如下所述：</p><ul><li>Redis Sentinal 着眼于高可用，在 Master 宕机时会自动将 Slave 提升为 Master，继续提供服务；</li><li>Redis Cluster 着眼于扩展性，在单个 Redis 内存不足时，使用 Cluster 进行分片存储。</li></ul><h4 id="31-Redis-常见的性能问题有哪些？"><a href="#31-Redis-常见的性能问题有哪些？" class="headerlink" title="31.Redis 常见的性能问题有哪些？"></a>31.Redis 常见的性能问题有哪些？</h4><p>答：Redis 常见性能问题如下：</p><ul><li>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，因此主服务器最好不要写内存快照；</li><li>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java面试全解析核心知识点与典型面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis 核心组件</title>
    <link href="/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/028--MyBatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    <url>/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/028--MyBatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="MyBatis-介绍"><a href="#MyBatis-介绍" class="headerlink" title="MyBatis 介绍"></a>MyBatis 介绍</h3><p>MyBatis 是一款优秀的 ORM（Object Relational Mapping，对象关系映射）框架，它可以通过对象和数据库之间的映射，将程序中的对象自动存储到数据库中。它是 Apache提供的一个开源项目，之前的名字叫做 iBatis，2010 年迁移到了 Google Code，并且将名字改为我们现在所熟知的 MyBatis，又于2013 年 11 月迁移到了 Github。</p><p>MyBatis 提供了普通 SQL 查询、事务、存储过程等功能，它的优缺点如下。</p><p><strong>优点</strong> ：</p><ul><li>相比于 JDBC 需要编写的代码更少</li><li>使用灵活，支持动态 SQL</li><li>提供映射标签，支持对象与数据库的字段关系映射</li></ul><p><strong>缺点</strong> ：</p><ul><li>SQL 语句依赖于数据库，数据库移植性差</li><li>SQL 语句编写工作量大，尤其在表、字段比较多的情况下</li></ul><p>总体来说，MyBatis 是一个非常优秀和灵活的数据持久化框架，适用于需求多变的互联网项目，也是当前主流的 ORM 框架。</p><h4 id="MyBatis-重要组件"><a href="#MyBatis-重要组件" class="headerlink" title="MyBatis 重要组件"></a>MyBatis 重要组件</h4><p>MyBatis 中的重要组件如下：</p><ul><li>Mapper 配置：用于组织具体的查询业务和映射数据库的字段关系，可以使用 XML 格式或 Java 注解格式来实现；</li><li>Mapper 接口：数据操作接口也就是通常说的 DAO 接口，要和 Mapper 配置文件中的方法一一对应；</li><li>Executor：MyBatis 中所有的 Mapper 语句的执行都是通过 Executor 执行的；</li><li>SqlSession：类似于 JDBC 中的 Connection，可以用 SqlSession 实例来直接执行被映射的 SQL 语句；</li><li>SqlSessionFactory：SqlSessionFactory 是创建 SqlSession 的工厂，可以通过 SqlSession openSession() 方法创建 SqlSession 对象。</li></ul><h4 id="MyBatis-执行流程"><a href="#MyBatis-执行流程" class="headerlink" title="MyBatis 执行流程"></a>MyBatis 执行流程</h4><p>MyBatis 完整执行流程如下图所示：</p><p><img src="https://images.gitbook.cn/4070e4c0-da75-11e9-b7a4-5f21fd84c626" alt="1"></p><p>MyBatis 执行流程说明：</p><ol><li>首先加载 Mapper 配置的 SQL 映射文件，或者是注解的相关 SQL 内容。</li><li>创建会话工厂，MyBatis 通过读取配置文件的信息来构造出会话工厂（SqlSessionFactory）。</li><li>创建会话，根据会话工厂，MyBatis 就可以通过它来创建会话对象（SqlSession），会话对象是一个接口，该接口中包含了对数据库操作的增、删、改、查方法。</li><li>创建执行器，因为会话对象本身不能直接操作数据库，所以它使用了一个叫做数据库执行器（Executor）的接口来帮它执行操作。</li><li>封装 SQL 对象，在这一步，执行器将待处理的 SQL 信息封装到一个对象中（MappedStatement），该对象包括 SQL 语句、输入参数映射信息（Java 简单类型、HashMap 或 POJO）和输出结果映射信息（Java 简单类型、HashMap 或 POJO）。</li><li>操作数据库，拥有了执行器和 SQL 信息封装对象就使用它们访问数据库了，最后再返回操作结果，结束流程。</li></ol><h3 id="MyBatis-XML-版"><a href="#MyBatis-XML-版" class="headerlink" title="MyBatis XML 版"></a>MyBatis XML 版</h3><p>MyBatis 使用分为两个版本：XML 版和 Java 注解版。接下来我们使用 Spring Boot 结合 MyBatis 的 XML版，来实现对数据库的基本操作，步骤如下。</p><h4 id="1）创建数据表"><a href="#1）创建数据表" class="headerlink" title="1）创建数据表"></a>1）创建数据表</h4><p>​    </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> `t_user`;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> `t_user` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment comment <span class="hljs-string">&#x27;主键id&#x27;</span>,<br>  `username` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;用户名&#x27;</span>,<br>  `password` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;密码&#x27;</span>,<br>  `nick_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span>,<br>  <span class="hljs-keyword">primary</span> key (`id`)<br>) engine<span class="hljs-operator">=</span>innodb auto_increment<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><h4 id="2）添加依赖"><a href="#2）添加依赖" class="headerlink" title="2）添加依赖"></a>2）添加依赖</h4><p>在项目添加对 MyBatis 和 MySQL 支持的依赖包，在 pom.xml 文件中添加如下代码：</p><p>​    </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>mybatis-spring-boot-starter 是 MyBatis 官方帮助我们快速集成 Spring Boot 提供的一个组件包，mybatis-spring-boot-starter 2.1.0 对应 MyBatis 的版本是 3.5.2。</p><h4 id="3）增加配置文件"><a href="#3）增加配置文件" class="headerlink" title="3）增加配置文件"></a>3）增加配置文件</h4><p>在 application.yml 文件中添加以下内容：</p><p>​    </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/learndb?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">config-location:</span> <span class="hljs-string">classpath:mybatis/mybatis-config.xml</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mybatis/mapper/*.xml</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.interview.mybatislearning.model</span><br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>mybatis.config-location：配置 MyBatis 基础属性；</li><li>mybatis.mapper-locations：配置 Mapper 对应的 XML 文件路径；</li><li>mybatis.type-aliases-package：配置项目中实体类包路径。</li></ul><p>注：如果配置文件使用的是 application.properties，配置内容是相同的，只是内容格式不同。</p><h4 id="4）创建实体类"><a href="#4）创建实体类" class="headerlink" title="4）创建实体类"></a>4）创建实体类</h4><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserEntity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">5980266333958177104L</span>;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-keyword">private</span> String passWord;<br>    <span class="hljs-keyword">private</span> String nickName;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserEntity</span><span class="hljs-params">(String userName, String passWord, String nickName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userName = userName;<br>        <span class="hljs-built_in">this</span>.passWord = passWord;<br>        <span class="hljs-built_in">this</span>.nickName = nickName;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Integer id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUserName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> userName;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserName</span><span class="hljs-params">(String userName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userName = userName;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPassWord</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> passWord;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPassWord</span><span class="hljs-params">(String passWord)</span> &#123;<br>        <span class="hljs-built_in">this</span>.passWord = passWord;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNickName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> nickName;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNickName</span><span class="hljs-params">(String nickName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nickName = nickName;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5）创建-XML-文件"><a href="#5）创建-XML-文件" class="headerlink" title="5）创建 XML 文件"></a>5）创建 XML 文件</h4><p><strong>mybatis-config.xml</strong> （基础配置文件）：</p><p>​    </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;Integer&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;Long&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.Long&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;HashMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.util.HashMap&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;LinkedHashMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.util.LinkedHashMap&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;ArrayList&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.util.ArrayList&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;LinkedList&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.util.LinkedList&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>mybatis-config.xml 主要是为常用的数据类型设置别名，用于减少类完全限定名的长度，比如：<code>resultType=&quot;Integer&quot;</code><br>完整示例代码如下：</p><p>​    </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllCount&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Integer&quot;</span>&gt;</span><br>    select<br>    count(*)<br>    from t_user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>UserMapper.xml</strong> （业务配置文件）：</p><p>​    </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.interview.mybatislearning.mapper.UserMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.interview.mybatislearning.model.UserEntity&quot;</span> &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;BIGINT&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;userName&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;passWord&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;nick_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;nickName&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Base_Column_List&quot;</span> &gt;</span><br>        id, username, password, nick_name<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Base_Where_List&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;userName != null  and userName != &#x27;&#x27;&quot;</span>&gt;</span><br>            and userName = #&#123;userName&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAll&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>  &gt;</span><br>        SELECT<br>        <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;Base_Column_List&quot;</span> /&gt;</span><br>        FROM t_user<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getOne&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Long&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span> &gt;</span><br>        SELECT<br>        <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;Base_Column_List&quot;</span> /&gt;</span><br>        FROM t_user<br>        WHERE id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.interview.mybatislearning.model.UserEntity&quot;</span> &gt;</span><br>       INSERT INTO<br>               t_user<br>               (username,password,nick_name)<br>           VALUES<br>               (#&#123;userName&#125;, #&#123;passWord&#125;, #&#123;nickName&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.interview.mybatislearning.model.UserEntity&quot;</span> &gt;</span><br>        UPDATE<br>        t_user<br>        SET<br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;userName != null&quot;</span>&gt;</span>username = #&#123;userName&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;passWord != null&quot;</span>&gt;</span>password = #&#123;passWord&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        nick_name = #&#123;nickName&#125;<br>        WHERE<br>        id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;delete&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Long&quot;</span> &gt;</span><br>       DELETE FROM<br>                t_user<br>       WHERE<br>                id =#&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以上配置我们增加了增删改查等基础方法。</p><h4 id="6）增加-Mapper-文件"><a href="#6）增加-Mapper-文件" class="headerlink" title="6）增加 Mapper 文件"></a>6）增加 Mapper 文件</h4><p>此步骤我们需要创建一个与 XML 对应的业务 Mapper 接口，代码如下：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    List&lt;UserEntity&gt; <span class="hljs-title function_">getAll</span><span class="hljs-params">()</span>;<br>    UserEntity <span class="hljs-title function_">getOne</span><span class="hljs-params">(Long id)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(UserEntity user)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(UserEntity user)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Long id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7）添加-Mapper-包扫描"><a href="#7）添加-Mapper-包扫描" class="headerlink" title="7）添加 Mapper 包扫描"></a>7）添加 Mapper 包扫描</h4><p>在启动类中添加 @MapperScan，设置 Spring Boot 启动的时候会自动加载包路径下的 Mapper。</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;com.interview.mybatislearning.mapper&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisLearningApplication</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       SpringApplication.run(MyBatisLearningApplication.class, args);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8）编写测试代码"><a href="#8）编写测试代码" class="headerlink" title="8）编写测试代码"></a>8）编写测试代码</h4><p>经过以上步骤之后，整个 MyBatis 的集成就算完成了。接下来我们写一个单元测试，验证一下。</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatislearningApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testInsert</span><span class="hljs-params">()</span> &#123;<br>        userMapper.insert(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserEntity</span>(<span class="hljs-string">&quot;laowang&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-string">&quot;老王&quot;</span>));<br>        Assert.assertEquals(<span class="hljs-number">1</span>, userMapper.getAll().size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过本文我们知道 MyBatis 是一个优秀和灵活的数据持久化框架，MyBatis 包含 Mapper 配置、Mapper接口、Executor、SqlSession、SqlSessionFactory 等几个重要的组件，知道了 MyBatis 基本流程：MyBatis首先加载 Mapper 配置和 SQL 映射文件，通过创建会话工厂得到 SqlSession 对象，再执行 SQL 语句并返回操作信息。我们也使用 XML的方式，实现了 MyBatis 对数据库的基础操作。</p><blockquote><p>[点击此处下载本文源码](<a href="https://github.com/vipstone/java-">https://github.com/vipstone/java-</a><br>interview/tree/master/mybatislearning-xml)</p></blockquote><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html">聊聊MyBatis缓存机制</a></li><li><a href="https://www.cnblogs.com/shamo89/p/8051397.html">Mybatis(三)：MyBatis缓存详解</a></li><li><a href="http://cnblogs.com/shamo89/p/9957291.html">Mybatis(四)：MyBatis核心组件介绍原理解析和源码解读</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java面试全解析核心知识点与典型面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ORM</tag>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>025--Spring核心功能演示+面试题</title>
    <link href="/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/025--Spring%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E6%BC%94%E7%A4%BA+%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/025--Spring%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E6%BC%94%E7%A4%BA+%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring-核心功能演示-面试题"><a href="#Spring-核心功能演示-面试题" class="headerlink" title="Spring 核心功能演示 + 面试题"></a>Spring 核心功能演示 + 面试题</h2><p>Spring Framework 简称 Spring，是 Java 开发中最常用的框架，地位仅次于 Java API，就连近几年比较流行的微服务框架SpringBoot，也是基于 Spring 实现的，SpringBoot 的诞生是为了让开发者更方便地使用 Spring，因此 Spring 在 Java体系中的地位可谓首屈一指。<br>当然，如果想要把 Spring 所有功能都讲的一清二楚，远远不是一两篇文章能够做到的，但幸运的是，Spring<br>的基础资料可以很轻易的搜索到，那么我们本讲主要的目的就是把 Spring 中的核心知识点和常见面试题分享给大家，希望对大家能有所帮助。</p><h3 id="Spring-介绍"><a href="#Spring-介绍" class="headerlink" title="Spring 介绍"></a>Spring 介绍</h3><p>Spring 是一个开源框架，为了解决企业应用程序开发复杂性而创建的，Spring 的概念诞生于 2002 年，于 2003 年正式发布第一个版本<br>Spring Framework 0.9。下面一起来看 Spring 各个版本的更新特性和它的发展变化吧。</p><h4 id="Spring-1-x"><a href="#Spring-1-x" class="headerlink" title="Spring 1.x"></a>Spring 1.x</h4><p>此版本主要是为了解决企业应用程序开发复杂性而创建的，当时 J2EE 应用的经典架构是分层架构：表现层、业务层、持久层，最流行的组合就是<br>SSH（Struts、Spring、Hibernate）。<br>Spring 1.x 仅支持基于 XML 的配置，确保用户代码不依赖<br>Spring，它主要包含了以下功能模块：aop、beans、ejb、jdbc、jndi、orm、transation、validation、web 等。</p><h4 id="Spring-2-x"><a href="#Spring-2-x" class="headerlink" title="Spring 2.x"></a>Spring 2.x</h4><p>Spring 2.x 的改动并不是很大，主要是在 Spring 1.x 的基础上增加了几个新模块，如<br>ehcache、jms、jmx、scripting、stereotype 等。</p><h4 id="Spring-3-x"><a href="#Spring-3-x" class="headerlink" title="Spring 3.x"></a>Spring 3.x</h4><p>Spring 3.x 开始不止支持 XML 的配置，还扩展了基于 Java 类的配置，还增加了<br>Expression、Instructment、Tomcat、oxm 等组件，同时将原来的 Web 细分为：Portlet、Servlet。</p><h4 id="Spring-4-x"><a href="#Spring-4-x" class="headerlink" title="Spring 4.x"></a>Spring 4.x</h4><p>Spring 4.x 扩充了 Groovy、Messaging、WebMvc、Tiles2、WebSocket 等功能组件，同时 Spring 还适配了<br>Java 版本，全面支持 Java 8.0、Lambda 表达式等。随着 RESTful 架构风格被越来越多的用户所采用，Spring 4.x 也提供了<br>RestController 等注解新特性。</p><h4 id="Spring-5-x"><a href="#Spring-5-x" class="headerlink" title="Spring 5.x"></a>Spring 5.x</h4><p>Spring 5.x 紧跟 Java 相关技术的更新迭代，不断适配 Java 的新版本，同时不断重构优化自身核心框架代码，支持函数式、响应式编程模型等。</p><h3 id="Spring-核心"><a href="#Spring-核心" class="headerlink" title="Spring 核心"></a>Spring 核心</h3><p>Spring 核心包括以下三个方面：</p><ul><li>控制反转（Ioc）</li><li>依赖注入（DI）</li><li>面向切面编程（AOP）</li></ul><p>下面分别来看它的这些特性。</p><h4 id="控制反转（IoC）"><a href="#控制反转（IoC）" class="headerlink" title="控制反转（IoC）"></a>控制反转（IoC）</h4><p>控制反转（Inversion of Control，IoC），顾名思义所谓的控制反转就是把创建对象的权利交给框架去控制，而不需要人为地去创建，这样就实现了可插拔式的接口编程，有效地降低代码的耦合度，降低了扩展和维护的成本。<br>比如，你去某地旅游不再用自己亲自为订购 A 酒店还是 B酒店而发愁了，只需要把住店的需求告诉给某个托管平台，这个托管平台就会帮你订购一个既便宜又舒适的酒店，而这个帮你订购酒店的行为就可以称之为控制反转。</p><h4 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h4><p>依赖注入（Dependency Injection，DI），是组件之间依赖关系由容器在运行期决定，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><h5 id="IoC-和-DI-的关系"><a href="#IoC-和-DI-的关系" class="headerlink" title="IoC 和 DI 的关系"></a>IoC 和 DI 的关系</h5><p>IoC 是 Spring 中一个极为重要的概念，而 DI 则是实现 IoC 的方法和手段。<br>接下来，我们来看依赖注入的常见实现方式有哪些？<br>依赖注入的常见实现方式如下：</p><ol><li>setter 注入</li><li>构造方法注入</li><li>注解注入</li></ol><h5 id="1）setter-注入"><a href="#1）setter-注入" class="headerlink" title="1）setter 注入"></a>1）setter 注入</h5><p>Java 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-comment">// 注入 UserService 对象</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserService</span><span class="hljs-params">(UserService userService)</span>&#123;<br>        <span class="hljs-built_in">this</span>.userService = userService;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>XML 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userController&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.learning.controller.UserController&quot;</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- 依赖注入 --&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userService&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.learning.dao.impl.UserServiceImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>Bean 标签的常用属性说明：</strong></p><ul><li>id：为实例化对象起名称，根据 id 值可以得到我们配置的实例化对象，id 属性的名称原则上可以任意命名，但是能包含任何特殊符号；</li><li>class：创建对象所在类的全路径；</li><li>name：功能和 id 属性一样，但是现在一般不用；与 id 的区别在于：name 属性值里可以包含特殊符号，但是 id 不可以；</li><li>scope：一般最常用的有两个值： Singleton：单例模式，整个应用程序，只创建 bean 的一个实例；Prototype：原型模式，每次注入都会创建一个新的 bean 实例，Spring 默认的是单例模式。</li></ul><h5 id="2）构造方法注入"><a href="#2）构造方法注入" class="headerlink" title="2）构造方法注入"></a>2）构造方法注入</h5><p>Java 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-keyword">private</span> UserService userService;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserController</span><span class="hljs-params">(UserService userService)</span>&#123;<br>        <span class="hljs-built_in">this</span>.userService = userService;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>XML 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userController&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.learning.controller.UserController&quot;</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- 依赖注入 --&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userService&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>  <br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.learning.dao.impl.UserServiceImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>  <br><br></code></pre></td></tr></table></figure><h5 id="3）注解注入"><a href="#3）注解注入" class="headerlink" title="3）注解注入"></a>3）注解注入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-comment">// 使用注解自动注入</span><br>    <span class="hljs-meta">@Autowired()</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br><span class="hljs-comment">// 创建依赖对象</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>   <span class="hljs-comment">// do something </span><br>&#125;<br></code></pre></td></tr></table></figure><p>创建依赖对象的常见注解：@Component、@Controller、@Service、@Repository。</p><p><strong>总结</strong> ：可以看出注解的方式要比传统的 XML（setter 和构造器注入）实现注入更为方便，同时注解方式也是官方力推的依赖注入最佳使用方式。</p><h4 id="面向切面编程（AOP）"><a href="#面向切面编程（AOP）" class="headerlink" title="面向切面编程（AOP）"></a>面向切面编程（AOP）</h4><p>面向切面编程（Aspect Oriented Programming，AOP），它就好比将系统按照功能分类，每一个类别就是一个“切面”，我们再针对不同的切面制定相应的规则，类似开发模式被称为面向切面编程。</p><h5 id="AOP-使用场景"><a href="#AOP-使用场景" class="headerlink" title="AOP 使用场景"></a>AOP 使用场景</h5><ul><li>日志系统</li><li>安全统一效验</li></ul><h5 id="AOP-优点"><a href="#AOP-优点" class="headerlink" title="AOP 优点"></a>AOP 优点</h5><ul><li>集中处理某一类问题，方便维护</li><li>逻辑更加清晰</li><li>降低模块间的耦合度</li></ul><h5 id="AOP-相关概念"><a href="#AOP-相关概念" class="headerlink" title="AOP 相关概念"></a>AOP 相关概念</h5><ul><li>Join point：连接点，程序执行期间的某一个点，例如执行方法或处理异常时候的点，在 Spring AOP 中，连接点总是表示方法的执行。</li><li>Advice：通知，通知分为方法执行前通知，方法执行后通知、环绕通知等。许多 AOP 框架（包括 Spring）都将通知建模为拦截器，在连接点周围维护一系列拦截器（形成拦截器链），对连接点的方法进行增强。</li><li>Pointcut：切点，匹配连接点（Join point）的表达式，是 AOP 的核心，并且 Spring 默认使用 AspectJ 作为切入点表达式语言。</li><li>Aspect：切面，是一个跨越多个类的模块化的关注点，它是通知（Advice）和切点（Pointcut）合起来的抽象，它定义了一个切点（Pointcut）用来匹配连接点（Join point），也就是需要对需要拦截的那些方法进行定义。</li><li>Target object：目标对象，被一个或者多个切面（Aspect）通知的对象，也就是需要被 AOP 进行拦截对方法进行增强（使用通知）的对象，也称为被通知的对象。由于在 AOP 里面使用运行时代理，因而目标对象一直是被代理的对象。</li><li>AOP proxy：AOP 代理，为了实现切面（Aspect）功能使用 AOP 框架创建一个对象，在 Spring 框架里面一个 AOP 代理指的是 JDK 自身的动态代理或 CGLIB 实现的动态代理。</li><li>Weaving：把切面加入到对象，并创建出代理对象的过程。</li><li>Advisor：一个 Advisor 相当于一个小型的切面，不同的是它只有一个通知（Advice），Advisor 在事务管理里面会经常遇到。</li></ul><h5 id="AOP-代码实现"><a href="#AOP-代码实现" class="headerlink" title="AOP 代码实现"></a>AOP 代码实现</h5><p>AOP 的示例我们就以开车为例，开车的完成流程是这样的：巡视车体及周围情况 → 发动 → 开车 → 熄火 → 锁车。</p><p>当然我们的主要目的是“开车”，但在开车之前和开完车之后，我们要做一些其他的工作，这些“其他”的工作，可以理解为 AOP 编程。</p><h5 id="1）创建类和方法"><a href="#1）创建类和方法" class="headerlink" title="1）创建类和方法"></a>1）创建类和方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.learning.aop;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component(&quot;person&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开车&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2）创建-AOP-拦截"><a href="#2）创建-AOP-拦截" class="headerlink" title="2）创建 AOP 拦截"></a>2）创建 AOP 拦截</h5><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.learning.aop;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.After;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CarAop</span> &#123;<br>    <span class="hljs-meta">@Before(&quot;execution(* com.learning.aop.Person.drive())&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;巡视车体及周围情况&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;发动&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@After(&quot;execution(* com.learning.aop.Person.drive())&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;熄火&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;锁车&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3）XML-配置注入扫描包路径"><a href="#3）XML-配置注入扫描包路径" class="headerlink" title="3）XML 配置注入扫描包路径"></a>3）XML 配置注入扫描包路径</h5><p>​</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.learning&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="4）创建测试类"><a href="#4）创建测试类" class="headerlink" title="4）创建测试类"></a>4）创建测试类</h5><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.learning.aop;<br><br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">landlord</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;person&quot;</span>, Person.class);<br>        landlord.drive();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行测试代码，执行结果如下：</p><blockquote><p>巡视车体及周围情况</p></blockquote><blockquote></blockquote><blockquote><p>发动</p></blockquote><blockquote></blockquote><blockquote><p>开车</p></blockquote><blockquote></blockquote><blockquote><p>熄火</p></blockquote><blockquote></blockquote><blockquote><p>锁车</p></blockquote><h5 id="AspectJ-注解说明："><a href="#AspectJ-注解说明：" class="headerlink" title="AspectJ 注解说明："></a>AspectJ 注解说明：</h5><ul><li>@Before — 前置通知，在连接点方法前调用；</li><li>@Around — 环绕通知，它将覆盖原有方法，但是允许你通过反射调用原有方法；</li><li>@After — 后置通知，在连接点方法后调用；</li><li>@AfterReturning — 返回通知，在连接点方法执行并正常返回后调用，要求连接点方法在执行过程中没有发生异常；</li><li>@AfterThrowing — 异常通知，当连接点方法异常时调用。</li></ul><h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="1-Value-注解的作用是什么？"><a href="#1-Value-注解的作用是什么？" class="headerlink" title="1.@Value 注解的作用是什么？"></a>1.@Value 注解的作用是什么？</h4><p>答：基于 @Value 的注解可以读取 properties 配置文件，使用如下:</p><blockquote><p>@Value(“#{configProperties[‘jdbc.username’]}”)</p></blockquote><blockquote></blockquote><blockquote><p>private String userName;</p></blockquote><p>以上为读取 configProperties 下的 jdbc.username 配置。</p><h4 id="2-Spring-通知类型有哪些？"><a href="#2-Spring-通知类型有哪些？" class="headerlink" title="2.Spring 通知类型有哪些？"></a>2.Spring 通知类型有哪些？</h4><p>答：Spring 通知类型总共有 5 种：前置通知、环绕通知、后置通知、异常通知、最终通知。</p><ul><li>前置通知（Before advice）：在目标方法执行之前执行的通知。在某连接点（ join point ）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。</li><li>环绕通知（Around Advice）：在目标方法执行之前和之后都可以执行额外代码的通知，也可以选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。</li><li>后置通知（After (finally) advice）：目标方法执行之后（某连接点退出的时候）执行的通知（不论是正常返回还是异常退出）。</li><li>异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。</li><li>最终通知（After returning advice）：在某连接点（join point）正常完成后执行的通知，例如，一个方法没有抛出任何异常，正常返回。</li></ul><h4 id="3-怎么理解-Spring-中的-IOC-容器？"><a href="#3-怎么理解-Spring-中的-IOC-容器？" class="headerlink" title="3.怎么理解 Spring 中的 IOC 容器？"></a>3.怎么理解 Spring 中的 IOC 容器？</h4><p>答：Spring IOC 就是把创建对象的权利交给框架去控制，而不需要人为的去创建，这样就实现了可插拔式的接口编程，有效地降低代码的耦合度，降低了扩展和维护的成本。</p><p>比如，去某地旅游不再用自己亲自为订购 A 酒店还是 B 酒店而发愁了，只需要把住店的需求告诉给某个托管平台，这个托管平台就会帮你订购一个既便宜又舒适的酒店，而这个帮你订购酒店的行为就可以称之为控制反转。</p><h4 id="4-怎么理解-Spring-中的依赖注入？"><a href="#4-怎么理解-Spring-中的依赖注入？" class="headerlink" title="4.怎么理解 Spring 中的依赖注入？"></a>4.怎么理解 Spring 中的依赖注入？</h4><p>答：依赖注入是指组件之间的依赖关系由容器在运行期决定，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><h4 id="5-IoC-和-DI-有什么关系？"><a href="#5-IoC-和-DI-有什么关系？" class="headerlink" title="5.IoC 和 DI 有什么关系？"></a>5.IoC 和 DI 有什么关系？</h4><p>答：IoC 是 Spring 中一个极为重要的概念，提供了对象管理的功能，从而省去了人为创建麻烦，而 DI 正是实现 IoC 的方法和手段。</p><h4 id="6-Component-和-Bean-有什么区别？"><a href="#6-Component-和-Bean-有什么区别？" class="headerlink" title="6.@Component 和 @Bean 有什么区别？"></a>6.@Component 和 @Bean 有什么区别？</h4><p>答：它们的作用对象不同：@Component 作用于类，而 @Bean 注解作用于方法。</p><p>@Component 通常是通过类路径扫描来自动侦测和装配对象到 Spring 容器中，比如 @ComponentScan 注解就是定义扫描路径中的类装配到Spring 的 Bean 容器中；@Bean 注解是告诉 Spring 这是某个类的实例，当我需要用它的时把它给我，@Bean 注解比<br>@Component 注解自定义性更强，很多地方我们只能通过 @Bean 注解来注册 Bean，比如当我们引用第三方库中的类需要装配到<br>Spring容器时，则只能通过 @Bean 来实现，比如以下示例，只能通过 @Bean 注解来实现：</p><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WireThirdLibClass</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ThirdLibClass <span class="hljs-title function_">getThirdLibClass</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThirdLibClass</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-Spring-中-bean-的作用域有几种类型？"><a href="#7-Spring-中-bean-的作用域有几种类型？" class="headerlink" title="7.Spring 中 bean 的作用域有几种类型？"></a>7.Spring 中 bean 的作用域有几种类型？</h4><p>答：Spring 中 bean 的作用域有四种类型，如下列表：</p><ul><li>单例（Singleton）：整个应用程序，只创建 bean 的一个实例；</li><li>原型（Prototype）：每次注入都会创建一个新的 bean 实例；</li><li>会话（Session）：每个会话创建一个 bean 实例，只在 Web 系统中有效；</li><li>请求（Request）：每个请求创建一个 bean 实例，只在 Web 系统中有效。</li></ul><p>Spring 默认的是单例模式。</p><h4 id="8-什么是-Spring-的内部-bean？"><a href="#8-什么是-Spring-的内部-bean？" class="headerlink" title="8.什么是 Spring 的内部 bean？"></a>8.什么是 Spring 的内部 bean？</h4><p>答：当一个 bean 仅被用作另一个 bean 的属性时，它能被声明为一个内部 bean，为了定义 inner Bean，在 Spring 的基于 XML<br>的配置元数据中，可以在 <code>&lt;property/&gt;</code> 或 <code>&lt;constructor-arg/&gt;</code> 元素内使用 <code>&lt;bean/&gt;</code> 元素，内部 bean通常是匿名的，它们的 Scope 一般是 prototype。</p><h4 id="9-Spring-注入方式有哪些？"><a href="#9-Spring-注入方式有哪些？" class="headerlink" title="9.Spring 注入方式有哪些？"></a>9.Spring 注入方式有哪些？</h4><p>答：Spring 的注入方式包含以下五种：</p><ul><li>setter 注入</li><li>构造方法注入</li><li>注解注入</li><li>静态工厂注入</li><li>实例工厂注入</li></ul><p>其中最常用的是前三种，官方推荐使用的是注解注入，相对使用更简单，维护成本更低，更直观。</p><h4 id="10-在-Spring-中如何操作数据库？"><a href="#10-在-Spring-中如何操作数据库？" class="headerlink" title="10.在 Spring 中如何操作数据库？"></a>10.在 Spring 中如何操作数据库？</h4><p>答：在 Spring 中操作数据库，可以使用 Spring 提供的 JdbcTemplate 对象，JdbcTemplate类提供了很多便利的方法，比如把数据库数据转变成基本数据类型或对象，执行自定义的 SQL 语句，提供了自定义的数据错误处理等，JdbcTemplate使用示例如下：</p><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br><span class="hljs-comment">// 新增</span><br><span class="hljs-meta">@GetMapping(&quot;save&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">save</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;INSERT INTO USER (USER_NAME,PASS_WORD) VALUES (&#x27;laowang&#x27;,&#x27;123&#x27;)&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> jdbcTemplate.update(sql);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;执行成功，影响&quot;</span> + rows + <span class="hljs-string">&quot;行&quot;</span>;<br>&#125;<br><span class="hljs-comment">// 删除</span><br><span class="hljs-meta">@GetMapping(&quot;del&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">del</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>&#123;<br>    <span class="hljs-type">int</span> rows= jdbcTemplate.update(<span class="hljs-string">&quot;DELETE FROM  USER  WHERE ID = ?&quot;</span>,id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;执行成功，影响&quot;</span> + rows + <span class="hljs-string">&quot;行&quot;</span>;<br>&#125;<br><span class="hljs-comment">// 查询</span><br><span class="hljs-meta">@GetMapping(&quot;getMapById&quot;)</span><br><span class="hljs-keyword">public</span> Map <span class="hljs-title function_">getMapById</span><span class="hljs-params">(Integer id)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SELECT * FROM USER WHERE ID = ?&quot;</span>;<br>    Map map= jdbcTemplate.queryForMap(sql,id);<br>    <span class="hljs-keyword">return</span> map;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="11-Spring-的-JdbcTemplate-对象和-JDBC-有什么区别？"><a href="#11-Spring-的-JdbcTemplate-对象和-JDBC-有什么区别？" class="headerlink" title="11.Spring 的 JdbcTemplate 对象和 JDBC 有什么区别？"></a>11.Spring 的 JdbcTemplate 对象和 JDBC 有什么区别？</h4><p>答：Spring 的 JdbcTemplate 是对 JDBC API 的封装，提供更多的功能和更便利的操作，比如 JdbcTemplate 拥有：</p><ul><li>JdbcTemplate 是线程安全的；</li><li>实例化操作比较简单，仅需要传递 DataSource；</li><li>自动完成资源的创建和释放工作；</li><li>创建一次 JdbcTemplate，到处可用，避免重复开发。</li></ul><h4 id="12-Spring-有几种实现事务的方式？"><a href="#12-Spring-有几种实现事务的方式？" class="headerlink" title="12.Spring 有几种实现事务的方式？"></a>12.Spring 有几种实现事务的方式？</h4><p>答：Spring 实现事务有两种方式：编程式事务和声明式事务。<br>编程式事务，使用 TransactionTemplate 或 PlatformTransactionManager 实现，示例代码如下：</p><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TransactionTemplate transactionTemplate;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(User user)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-comment">// Spring编码式事务，回调机制</span><br>    transactionTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionCallback</span>&lt;Object&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">doInTransaction</span><span class="hljs-params">(TransactionStatus status)</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                userMapper.insertSelective(user);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-comment">// 异常，设置为回滚</span><br>                status.setRollbackOnly();<br>                <span class="hljs-keyword">throw</span> e;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果有异常，调用 status.setRollbackOnly() 回滚事务，否则正常执行 doInTransaction() 方法，正常提交事务。<br>如果事务控制的方法不需要返回值，就可以使用 TransactionCallbackWithoutResult（TransactionCallback接口的抽象实现类）示例代码如下：</p><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(User user)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// Spring编码式事务，回调机制</span><br>    transactionTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionCallbackWithoutResult</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doInTransactionWithoutResult</span><span class="hljs-params">(TransactionStatus status)</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                userMapper.insertSelective(user);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-comment">// 异常，设置为回滚</span><br>                status.setRollbackOnly();<br>                <span class="hljs-keyword">throw</span> e;<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>声明式事务，底层是建立在 Spring AOP的基础上，在方式执行前后进行拦截，并在目标方法开始执行前创建新事务或加入一个已存在事务，最后在目标方法执行完后根据情况提交或者回滚事务。<br>声明式事务的优点：不需要编程，减少了代码的耦合，在配置文件中配置并在目标方法上添加 @Transactional 注解来实现，示例代码如下：</p><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;laowang&quot;</span>);<br>    userMapper.insertSelective(user);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;异常&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>抛出异常，事务会自动回滚，如果方法正常执行，则会自动提交事务。</p><h4 id="13-Spring-事务隔离级别有哪些？"><a href="#13-Spring-事务隔离级别有哪些？" class="headerlink" title="13.Spring 事务隔离级别有哪些？"></a>13.Spring 事务隔离级别有哪些？</h4><p>答：Spring 的注入方式包含以下五种：</p><ul><li>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</li><li>ISOLATIONREADUNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</li><li>ISOLATIONREADCOMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</li><li>ISOLATIONREPEATABLEREAD：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</li><li>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li></ul><p>默认值为 ISOLATION_DEFAULT 遵循数据库的事务隔离级别设置。</p><h4 id="14-Spring-声明式事务无效可能的原因有哪些？"><a href="#14-Spring-声明式事务无效可能的原因有哪些？" class="headerlink" title="14.Spring 声明式事务无效可能的原因有哪些？"></a>14.Spring 声明式事务无效可能的原因有哪些？</h4><p>答：可能的原因如下：</p><ul><li>MySQL 使用的是 MyISAM 引擎，而 MyISAM 是不支持事务的；</li><li>@Transactional 使用在非 public 方法上，@Transactional 注解只能支持 public 级别，其他类型声明的事务不会生效；</li><li>@Transactional 在同一个类中无事务方法 A() 内部调用有事务方法 B()，那么此时 B() 事物不会生效。</li></ul><p>Spring 中的 AOP 的底层实现原理是什么？</p><p>答：Spring AOP 的底层实现原理就是动态代理。Spring AOP 的动态代理有两种实现方式，对于接口使用的是 JDK自带的动态代理来实现的，而对比非接口使用的是 CGLib 来实现的，关于动态代理的详细内容，可参考前面【反射和动态代理】的那篇文章。</p><h4 id="15-Spring-中的-Bean-是线程安全的吗？"><a href="#15-Spring-中的-Bean-是线程安全的吗？" class="headerlink" title="15.Spring 中的 Bean 是线程安全的吗？"></a>15.Spring 中的 Bean 是线程安全的吗？</h4><p>答：Spring 中的 Bean 默认是单例模式，Spring 框架并没有对单例 Bean 进行多线程的封装处理，因此默认的情况 Bean<br>并非是安全的，最简单保证 Bean 安全的举措就是设置 Bean 的作用域为 Prototype（原型）模式，这样每次请求都会新建一个 Bean。</p><h4 id="16-说一下-Spring-中-Bean-的生命周期？"><a href="#16-说一下-Spring-中-Bean-的生命周期？" class="headerlink" title="16.说一下 Spring 中 Bean 的生命周期？"></a>16.说一下 Spring 中 Bean 的生命周期？</h4><p>答：Spring 中 Bean 的生命周期如下：</p><ul><li><p>① 实例化 Bean：对于 BeanFactory 容器，当客户向容器请求一个尚未初始化的 Bean 时，或初始化 Bean 的时候需要注入另一个尚未初始化的依赖时，容器就会调用 createBean 进行实例化。对于 ApplicationContext 容器，当容器启动结束后，通过获取 BeanDefinition 对象中的信息，实例化所有的 Bean；</p></li><li><p>② 设置对象属性（依赖注入）：实例化后的对象被封装在 BeanWrapper 对象中，紧接着 Spring 根据 BeanDefinition 中的信息以及通过 BeanWrapper 提供的设置属性的接口完成依赖注入；</p></li><li><p>③ 处理 Aware 接口：Spring 会检测该对象是否实现了 xxxAware 接口，并将相关的 xxxAware 实例注入给 Bean：</p><ul><li>如果这个 Bean 已经实现了 BeanNameAware 接口，会调用它实现的 setBeanName(String BeanId) 方法，此处传递的就是 Spring 配置文件中 Bean 的 id 值；</li><li>如果这个 Bean 已经实现了 BeanFactoryAware 接口，会调用它实现的 setBeanFactory() 方法，传递的是 Spring 工厂自身；</li><li>如果这个 Bean 已经实现了 ApplicationContextAware 接口，会调用 setApplicationContext(ApplicationContext) 方法，传入 Spring 上下文；</li></ul></li><li><p>④ BeanPostProcessor：如果想对 Bean 进行一些自定义的处理，那么可以让 Bean 实现了 BeanPostProcessor 接口，那将会调用 postProcessBeforeInitialization(Object obj, String s) 方法；</p></li><li><p>⑤ InitializingBean 与 init-method：如果 Bean 在 Spring 配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法；</p></li><li><p>⑥ 如果这个 Bean 实现了 BeanPostProcessor 接口，将会调用 postProcessAfterInitialization(Object obj, String s) 方法；由于这个方法是在 Bean 初始化结束时调用的，因而可以被应用于内存或缓存技术；</p></li></ul><p>以上几个步骤完成后，Bean 就已经被正确创建了，之后就可以使用这个 Bean 了。</p><ul><li>⑦ DisposableBean：当 Bean 不再需要时，会经过清理阶段，如果 Bean 实现了 DisposableBean 这个接口，会调用其实现的 destroy() 方法；</li><li>⑧ destroy-method：最后，如果这个 Bean 的 Spring 配置中配置了 destroy-method 属性，会自动调用其配置的销毁方法。</li></ul><h4 id="17-Spring-有哪些优点"><a href="#17-Spring-有哪些优点" class="headerlink" title="17.Spring 有哪些优点?"></a>17.Spring 有哪些优点?</h4><p>答：Spring 优点如下：</p><ul><li>开源免费的热门框架，稳定性高、解决问题成本低；</li><li>方便集成各种优秀的框架；</li><li>降低了代码耦合性，通过 Spring 提供的 IoC 容器，我们可以将对象之间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度程序耦合；</li><li>方便程序测试，在 Spring 里，测试变得非常简单，例如：Spring 对 Junit 的支持，可以通过注解方便的测试 Spring 程序；</li><li>降低 Java EE API 的使用难度，Spring 对很多难用的 Java EE API（如 JDBC、JavaMail、远程调用等）提供了一层封装，通过 Spring 的简易封装，让这些 Java EE API 的使用难度大为降低。</li></ul><h4 id="18-Spring-和-Struts-的区别？"><a href="#18-Spring-和-Struts-的区别？" class="headerlink" title="18.Spring 和 Struts 的区别？"></a>18.Spring 和 Struts 的区别？</h4><p>答：Spring 和 Struts 区别如下：<br>Spring 特性如下：</p><ul><li>具备 IOC/DI、AOP 等通用能力，提高研发效率</li><li>除了支持 Web 层建设以外，还提供了 J2EE 整体服务</li><li>方便与其他不同技术结合使用，如 Hibernate、MyBatis 等</li><li>Spring 拦截机制是方法级别</li></ul><p>Struts 特性如下：</p><ul><li>是一个基于 MVC 模式的一个 Web 层的处理</li><li>Struts 拦截机制是类级别</li></ul><h4 id="19-Spring、SpringBoot、SpringCloud-的区别是什么？"><a href="#19-Spring、SpringBoot、SpringCloud-的区别是什么？" class="headerlink" title="19.Spring、SpringBoot、SpringCloud 的区别是什么？"></a>19.Spring、SpringBoot、SpringCloud 的区别是什么？</h4><p>答：它们的区别如下：</p><ul><li>Spring Framework 简称 Spring，是整个 Spring 生态的基础。</li><li>Spring Boot 是一个快速开发框架，让开发者可以迅速搭建一套基于 Spring 的应用程序，并且将常用的 Spring 模块以及第三方模块，如 MyBatis、Hibernate 等都做了很好的集成，只需要简单的配置即可使用，不需要任何的 XML 配置文件，真正做到了开箱即用，同时默认支持 JSON 格式的数据，使用 Spring Boot 进行前后端分离开发也非常便捷。</li><li>Spring Cloud 是一套整合了分布式应用常用模块的框架，使得开发者可以快速实现微服务应用。作为目前非常热门的技术，有关微服务的话题总是在各种场景下被大家讨论，企业的招聘信息中也越来越多地出现对于微服务架构能力的要求。</li></ul><h4 id="20-Spring-中都是用了哪些设计模式？"><a href="#20-Spring-中都是用了哪些设计模式？" class="headerlink" title="20.Spring 中都是用了哪些设计模式？"></a>20.Spring 中都是用了哪些设计模式？</h4><p>答：Spring 中使用的设计模式如下：</p><ul><li>工厂模式：通过 BeanFactory、ApplicationContext 来创建 bean 都是属于工厂模式；</li><li>单例、原型模式：创建 bean 对象设置作用域时，就可以声明 Singleton（单例模式）、Prototype（原型模式）；</li><li>观察者模式：Spring 可以定义一下监听，如 ApplicationListener 当某个动作触发时就会发出通知；</li><li>责任链模式：AOP 拦截器的执行；</li><li>策略模式：在创建代理类时，如果代理的是接口使用的是 JDK 自身的动态代理，如果不是接口使用的是 CGLIB 实现动态代理。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过本节内容我们充分的了解了 Spring 的核心：IoC、DI、AOP，也是用代码演示了 Spring 核心功能的示例，其中可以发现的是 Spring<br>正在从之前的 XML 配置编程变为 Java 注解编程，注解编程让 Spring 更加轻量化简单化了，这一点在我们后面介绍 SpringBoot的时候，会让你更加感同身受。对于开发者来说，只有真正掌握了 Spring，才能称得上是一名合格的 Java<br>工程师。当然，学习的目的是为了更好的应用，因此现在就一起动手实践起来吧。</p><blockquote><p><a href="https://github.com/vipstone/java-interview/tree/master/springlearning">点击此处下载本文源码</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java面试全解析核心知识点与典型面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>032--MySQL面试题汇总</title>
    <link href="/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/032--MySQL%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/032--MySQL%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL-面试题汇总"><a href="#MySQL-面试题汇总" class="headerlink" title="MySQL 面试题汇总"></a>MySQL 面试题汇总</h2><h4 id="1-说一下-MySQL-执行一条查询语句的内部执行过程？"><a href="#1-说一下-MySQL-执行一条查询语句的内部执行过程？" class="headerlink" title="1.说一下 MySQL 执行一条查询语句的内部执行过程？"></a>1.说一下 MySQL 执行一条查询语句的内部执行过程？</h4><p>答：MySQL 执行一条查询的流程如下：</p><ul><li>客户端先通过连接器连接到 MySQL 服务器；</li><li>连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器；</li><li>分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器；</li><li>优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好；</li><li>优化器执行完就进入执行器，执行器则开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。</li></ul><h4 id="2-MySQL-查询缓存有什么优缺点？"><a href="#2-MySQL-查询缓存有什么优缺点？" class="headerlink" title="2.MySQL 查询缓存有什么优缺点？"></a>2.MySQL 查询缓存有什么优缺点？</h4><p>答：MySQL 查询缓存功能是在连接器之后发生的，它的优点是效率高，如果已经有缓存则会直接返回结果。</p><p>查询缓存的缺点是失效太频繁导致缓存命中率比较低，任何更新表操作都会清空查询缓存，因此导致查询缓存非常容易失效。</p><h4 id="3-MySQL-的常用引擎都有哪些？"><a href="#3-MySQL-的常用引擎都有哪些？" class="headerlink" title="3.MySQL 的常用引擎都有哪些？"></a>3.MySQL 的常用引擎都有哪些？</h4><p>答：MySQL 的常用引擎有 InnoDB、MyISAM、Memory 等，从 MySQL 5.5.5 版本开始 InnoDB 就成为了默认的存储引擎。</p><h4 id="4-常用的存储引擎-InnoDB-和-MyISAM-有什么区别？"><a href="#4-常用的存储引擎-InnoDB-和-MyISAM-有什么区别？" class="headerlink" title="4.常用的存储引擎 InnoDB 和 MyISAM 有什么区别？"></a>4.常用的存储引擎 InnoDB 和 MyISAM 有什么区别？</h4><p>答：InnoDB 和 MyISAM 最大的区别是 InnoDB 支持事务，而 MyISAM 不支持事务，它们其他主要区别如下：</p><ul><li>InnoDB 支持崩溃后安全恢复，MyISAM 不支持崩溃后安全恢复；</li><li>InnoDB 支持行级锁，MyISAM 不支持行级锁，只支持到表锁；</li><li>InnoDB 支持外键，MyISAM 不支持外键；</li><li>MyISAM 性能比 InnoDB 高；</li><li>MyISAM 支持 FULLTEXT 类型的全文索引，InnoDB 不支持 FULLTEXT 类型的全文索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，并且效果更好；</li><li>InnoDB 主键查询性能高于 MyISAM。</li></ul><h4 id="5-什么叫回表查询？"><a href="#5-什么叫回表查询？" class="headerlink" title="5.什么叫回表查询？"></a>5.什么叫回表查询？</h4><p>答：普通索引查询到主键索引后，回到主键索引树搜索的过程，我们称为回表查询。</p><h4 id="6-如果把一个-InnoDB-表的主键删掉，是不是就没有主键，就没办法进行回表查询了？"><a href="#6-如果把一个-InnoDB-表的主键删掉，是不是就没有主键，就没办法进行回表查询了？" class="headerlink" title="6.如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？"></a>6.如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？</h4><p>答：不是，如果把主键删掉了，那么 InnoDB 会自己生成一个长度为 6 字节的 rowid 作为主键。</p><h4 id="7-一张自增表中有三条数据，删除两条数据之后重启数据库，再新增一条数据，此时这条数据的-ID-是几？"><a href="#7-一张自增表中有三条数据，删除两条数据之后重启数据库，再新增一条数据，此时这条数据的-ID-是几？" class="headerlink" title="7.一张自增表中有三条数据，删除两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？"></a>7.一张自增表中有三条数据，删除两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？</h4><p>答：如果这张表的引擎是 MyISAM，那么 ID=4，如果是 InnoDB 那么 ID=2（MySQL 8 之前的版本）。</p><h4 id="8-什么是独立表空间和共享表空间？它们的区别是什么？"><a href="#8-什么是独立表空间和共享表空间？它们的区别是什么？" class="headerlink" title="8.什么是独立表空间和共享表空间？它们的区别是什么？"></a>8.什么是独立表空间和共享表空间？它们的区别是什么？</h4><p>答：共享表空间指的是数据库的所有表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。</p><p>独立表空间：每一个表都将会生成以独立的文件方式来进行存储。</p><p>共享表空间和独立表空间最大的区别是如果把表放再共享表空间，即使表删除了空间也不会删除，因此表依然很大，而独立表空间如果删除表就会清除空间。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 查看当前数据库的表空间管理类型</span><br><span class="hljs-string">show</span> <span class="hljs-string">variables</span> <span class="hljs-string">like</span> <span class="hljs-string">&quot;innodb_file_per_table&quot;</span><span class="hljs-string">;</span><br><span class="hljs-comment"># ON代表独立表空间管理，OFF代表共享表空间管理；（查看单表的表空间管理方式，需要查看每个表是否有单独的数据文件）</span><br><span class="hljs-string">innodb_file_per_table=1</span> <span class="hljs-string">为使用独占表空间</span><br><br><span class="hljs-string">innodb_file_per_table=0</span> <span class="hljs-string">为使用共享表空间</span><br><br></code></pre></td></tr></table></figure><h4 id="9-清空表的所有数据性能最好的语句是？"><a href="#9-清空表的所有数据性能最好的语句是？" class="headerlink" title="9.清空表的所有数据性能最好的语句是？"></a>9.清空表的所有数据性能最好的语句是？</h4><p>A：delete from t<br>B：delete t<br>C：drop table t<br>D：truncate table t</p><p>答：D</p><p>题目解析：truncate 清除表数据不会写日志，delete 要写日志，因此 truncate 的效率要高于 delete。</p><h4 id="10-唯一索引和普通索引哪个性能更好？"><a href="#10-唯一索引和普通索引哪个性能更好？" class="headerlink" title="10.唯一索引和普通索引哪个性能更好？"></a>10.唯一索引和普通索引哪个性能更好？</h4><p>答：唯一索引和普通索引的性能对比分为以下两种情况：</p><ul><li>对于查询来说两者都是从索引树进行查询，性能几乎没有任何区别；</li><li>对于更新操作来说，因为唯一索引需要先将数据读取到内存，然后需要判断是否有冲突，因此比唯一索引要多了判断操作，从而性能就比普通索引性能要低。</li></ul><h4 id="11-left-join-和-right-join-的区别是什么？"><a href="#11-left-join-和-right-join-的区别是什么？" class="headerlink" title="11.left join 和 right join 的区别是什么？"></a>11.left join 和 right join 的区别是什么？</h4><p>答：left join 和 right join 的区别如下：</p><ul><li>left join（左联结），返回左表全部记录和右表联结字段相等的记录；</li><li>right join（右联结），返回右表全部记录和左表联结字段相等的记录。</li></ul><h4 id="12-什么是最左匹配原则？它的生效原则有哪些？"><a href="#12-什么是最左匹配原则？它的生效原则有哪些？" class="headerlink" title="12.什么是最左匹配原则？它的生效原则有哪些？"></a>12.什么是最左匹配原则？它的生效原则有哪些？</h4><p>答：最左匹配原则也叫最左前缀原则，是 MySQL中的一个重要原则，指的是索引以最左边为起点任何连续的索引都能匹配上，当遇到范围查询（&gt;、&lt;、between、like）就会停止匹配。<br>生效原则来看以下示例，比如表中有一个联合索引字段 index(a,b,c)：</p><ul><li>where a=1 只使用了索引 a；</li><li>where a=1 and b=2 只使用了索引 a,b；</li><li>where a=1 and b=2 and c=3 使用a,b,c；</li><li>where b=1 or where c=1 不使用索引；</li><li>where a=1 and c=3 只使用了索引 a；</li><li>where a=3 and b like ‘xx%’ and c=3 只使用了索引 a,b。</li></ul><h4 id="13-以下-or-查询有什么问题吗？该如何优化？"><a href="#13-以下-or-查询有什么问题吗？该如何优化？" class="headerlink" title="13.以下 or 查询有什么问题吗？该如何优化？"></a>13.以下 or 查询有什么问题吗？该如何优化？</h4><blockquote><p>select * from t where num=10 or num=20;</p></blockquote><p>答：如果使用 or 查询会使 MySQL 放弃索引而全表扫描，可以改为：</p><blockquote><p>select * from t where num=10</p></blockquote><blockquote></blockquote><blockquote><p>union</p></blockquote><blockquote></blockquote><blockquote><p>select * from t where num=20;</p></blockquote><h4 id="14-事务是什么？它有什么特性？"><a href="#14-事务是什么？它有什么特性？" class="headerlink" title="14.事务是什么？它有什么特性？"></a>14.事务是什么？它有什么特性？</h4><p>答：事务是一系列的数据库操作，是数据库应用的基本单位。</p><p>在 MySQL 中只有 InnoDB 引擎支持事务，它的四个特性如下：</p><ul><li>原子性（Atomic），要么全部执行，要么全部不执行；</li><li>一致性（Consistency），事务的执行使得数据库从一种正确状态转化为另一种正确状态；</li><li>隔离性（Isolation），在事务正确提交之前，不允许把该事务对数据的任何改变提供给其他事务；</li><li>持久性（Durability），事务提交后，其结果永久保存在数据库中。</li></ul><h4 id="15-MySQL-中有几种事务隔离级别？分别是什么？"><a href="#15-MySQL-中有几种事务隔离级别？分别是什么？" class="headerlink" title="15.MySQL 中有几种事务隔离级别？分别是什么？"></a>15.MySQL 中有几种事务隔离级别？分别是什么？</h4><p>答：MySQL 中有四种事务隔离级别，分别是：</p><ul><li>read uncommited，未提交读，读到未提交数据；</li><li>read committed，读已提交，也叫不可重复读，两次读取到的数据不一致；</li><li>repetable read，可重复读；</li><li>serializable，串行化，读写数据都会锁住整张表，数据操作不会出错，但并发性能极低，开发中很少用到。</li></ul><p>MySQL 默认使用 repetable read 的事务隔离级别。</p><h4 id="16-如何设置-MySQL-的事务隔离级别？"><a href="#16-如何设置-MySQL-的事务隔离级别？" class="headerlink" title="16.如何设置 MySQL 的事务隔离级别？"></a>16.如何设置 MySQL 的事务隔离级别？</h4><p>答：MySQL 事务隔离级别 mysql.cnf 文件里设置的（默认目录 /etc/my.cnf），在文件的文末添加配置：</p><blockquote><p>transaction-isolation = REPEATABLE-READ</p></blockquote><p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p><h4 id="17-MySQL-出现了中文乱码该如何解决？"><a href="#17-MySQL-出现了中文乱码该如何解决？" class="headerlink" title="17.MySQL 出现了中文乱码该如何解决？"></a>17.MySQL 出现了中文乱码该如何解决？</h4><p>答：解决 MySQL 中文乱码的问题，可以设置全局编码或设置某个数据库或表的编码为 utf8。 设置全局编码：</p><p>​    set character_set_client=’utf8’;<br>​    set character_set_connection=’utf8’;<br>​    set character_set_results=’utf8’;</p><p>设置数据库的编码：</p><p>​<br>​    alter database db character set utf8;</p><p>设置表的编码：</p><p>​<br>​    alter table t character set utf8;</p><h4 id="18-InnoDB-为什么要使用-B-树，而不是-B-树、Hash、红黑树或二叉树？"><a href="#18-InnoDB-为什么要使用-B-树，而不是-B-树、Hash、红黑树或二叉树？" class="headerlink" title="18.InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？"></a>18.InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？</h4><p>答：因为 B 树、Hash、红黑树或二叉树存在以下问题。</p><ul><li>B 树：不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致 IO 操作变多，查询性能变低。</li><li>Hash：虽然可以快速定位，但是没有顺序，IO 复杂度高。</li><li>二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且 IO 代价高。</li><li>红黑树：树的高度随着数据量增加而增加，IO 代价高。</li></ul><h4 id="19-MySQL-是如何处理死锁？"><a href="#19-MySQL-是如何处理死锁？" class="headerlink" title="19.MySQL 是如何处理死锁？"></a>19.MySQL 是如何处理死锁？</h4><p>答：MySQL 对待死锁常见的两种策略：</p><ul><li>通过 innodb_lock_wait_timeout 来设置超时时间，一直等待直到超时；</li><li>发起死锁检测，发现死锁之后，主动回滚死锁中的某一个事务，让其他事务继续执行。</li></ul><h4 id="20-什么是全局锁？它的应用场景有哪些？"><a href="#20-什么是全局锁？它的应用场景有哪些？" class="headerlink" title="20.什么是全局锁？它的应用场景有哪些？"></a>20.什么是全局锁？它的应用场景有哪些？</h4><p>答：全局锁就是对整个数据库实例加锁，它的典型使用场景就是做全量逻辑备份，这个时候整个库会处于完全的只读状态。</p><h4 id="21-使用全局锁会导致什么问题？"><a href="#21-使用全局锁会导致什么问题？" class="headerlink" title="21.使用全局锁会导致什么问题？"></a>21.使用全局锁会导致什么问题？</h4><p>答：使用全局锁会使整个系统不能执行更新操作，所有的更新业务会出于等待状态；如果你是在从库进行备份，则会导致主从同步严重延迟。</p><h4 id="22-InnoDB-存储引擎有几种锁算法？"><a href="#22-InnoDB-存储引擎有几种锁算法？" class="headerlink" title="22.InnoDB 存储引擎有几种锁算法？"></a>22.InnoDB 存储引擎有几种锁算法？</h4><p>答：InnoDB 的锁算法包括以下三种：</p><ul><li>Record Lock — 单个行记录上的锁；</li><li>Gap Lock — 间隙锁，锁定一个范围，不包括记录本身；</li><li>Next-Key Lock — 锁定一个范围，包括记录本身。</li></ul><h4 id="23-InnoDB-如何实现行锁？"><a href="#23-InnoDB-如何实现行锁？" class="headerlink" title="23.InnoDB 如何实现行锁？"></a>23.InnoDB 如何实现行锁？</h4><p>答：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则 InnoDB 将使用表锁。使用 for update 来实现行锁，具体脚本如下：</p><blockquote><p>select * from t where id=1 for update</p></blockquote><p>其中 id 字段必须有索引。</p><h4 id="24-MySQL-性能指标都有哪些？如何得到这些指标？"><a href="#24-MySQL-性能指标都有哪些？如何得到这些指标？" class="headerlink" title="24.MySQL 性能指标都有哪些？如何得到这些指标？"></a>24.MySQL 性能指标都有哪些？如何得到这些指标？</h4><p>答：MySQL 最重要的性能指标有以下两个：</p><ul><li>QPS（Queries Per Second），每秒查询数，一台数据库每秒能够处理的查询次数；</li><li>TPS（Transactions Per Second），每秒处理事务数。</li></ul><p>这些性能指标可以通过 show status 来查询当前数据库状态的结果信息中估算出来，show status 会有 300<br>多条状态信息记录，其中以下这些信息 QPS 和 TPS 有关系：</p><ul><li>Uptime，服务器已经运行的时间，单位秒；</li><li>Questions，已经发送给数据库查询数；</li><li>Com_select，查询次数，实际查询次数；</li><li>Com_insert，插入次数；</li><li>Com_delete，删除次数；</li><li>Com_update，更新次数；</li><li>Com_commit，事务次数；</li><li>Com_rollback，回滚次数。</li></ul><h4 id="25-MySQL-中的重要日志分为哪几个？"><a href="#25-MySQL-中的重要日志分为哪几个？" class="headerlink" title="25.MySQL 中的重要日志分为哪几个？"></a>25.MySQL 中的重要日志分为哪几个？</h4><p><strong>① 错误日志</strong> ：用来记录 MySQL 服务器运行过程中的错误信息，比如，无法加载 MySQL数据库的数据文件，或权限不正确等都会被记录在此，还有复制环境下，从服务器进程的信息也会被记录进错误日志。默认情况下，错误日志是开启的，且无法被禁止。默认情况下，错误日志是存储在数据库的数据文件目录中，名称为hostname.err，其中 hostname 为服务器主机名。在 MySQL 5.5.7之前，数据库管理员可以删除很长时间之前的错误日志，以节省服务器上的硬盘空间， MySQL 5.5.7之后，服务器将关闭此项功能，只能使用重命名原来的错误日志文件，手动冲洗日志创建一个新的，命令为：</p><blockquote><p>mv hostname.err hostname.err.old</p></blockquote><blockquote></blockquote><blockquote><p>mysqladmin flush-logs</p></blockquote><p><strong>② 查询日志</strong> ：查询日志在 MySQL 中被称为 general log（通用日志），查询日志里的内容不要被“查询日志”误导，认为里面只存储<br>select 语句，其实不然，查询日志里面记录了数据库执行的所有命令，不管语句是否正确，都会被记录，具体原因如下:</p><ul><li>insert 查询为了避免数据冲突，如果此前插入过数据，则当前插入的数据如果跟主键或唯一键的数据重复那肯定会报错；</li><li>update 时也会查询因为更新的时候很可能会更新某一块数据；</li><li>delete 查询，只删除符合条件的数据；</li></ul><p>因此都会产生日志，在并发操作非常多的场景下，查询信息会非常多，那么如果都记录下来会导致 IO 非常大，影响 MySQL性能。因此如果不是在调试环境下，是不建议开启查询日志功能的。</p><p>查询日志的开启有助于帮助我们分析哪些语句执行密集，执行密集的 select语句对应的数据是否能够被缓存，同时也可以帮助我们分析问题，因此，可以根据自己的实际情况来决定是否开启查询日志。</p><p>查询日志模式是关闭的，可以通过以下命令开启查询日志：</p><blockquote><p>set global general_log=1</p></blockquote><blockquote></blockquote><blockquote><p>set global log_output=’table’;</p></blockquote><p>general_log=1 为开启查询日志，0 为关闭查询日志，这个设置命令即时生效，不用重启 MySQL 服务器。</p><p><strong>③ 慢日志</strong> ：慢查询会导致 CPU、IOPS、内存消耗过高，当数据库遇到性能瓶颈时，大部分时间都是由于慢查询导致的。开启慢查询日志，可以让MySQL记录下查询超过指定时间的语句，之后运维人员通过定位分析，能够很好的优化数据库性能。默认情况下，慢查询日志是不开启的，只有手动开启了，慢查询才会被记录到慢查询日志中。使用如下命令记录当前数据库的慢查询语句：</p><blockquote><p>set global slow_query_log=’ON’;</p></blockquote><p>使用 set global slow_query_log=’ON’ 开启慢查询日志，只是对当前数据库有效，如果 MySQL数据库重启后就会失效。因此如果要永久生效，就要修改配置文件 my.cnf，设置 slow_query_log=1 并重启 MySQL 服务器。</p><p><strong>④ redo log（重做日志）</strong> ：为了最大程度的避免数据写入时，因为 IO 瓶颈造成的性能问题，MySQL采用了这样一种缓存机制，先将数据写入内存中，再批量把内存中的数据统一刷回磁盘。为了避免将数据刷回磁盘过程中，因为掉电或系统故障带来的数据丢失问题，InnoDB采用 redo log 来解决此问题。</p><p><strong>⑤ undo log（回滚日志）</strong> ：用于存储日志被修改前的值，从而保证如果修改出现异常，可以使用 undo log 日志来实现回滚操作。</p><p>undo log 和 redo log 记录物理日志不一样，它是逻辑日志，可以认为当 delete 一条记录时，undo log 中会记录一条对应的<br>insert 记录，反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录，当执行 rollback 时，就可以从 undo<br>log 中的逻辑记录读取到相应的内容并进行回滚。undo log 默认存放在共享表空间中，在 MySQL 5.6 中，undo log的存放位置还可以通过变量 innodb_undo_directory 来自定义存放目录，默认值为“.”表示 datadir 目录。</p><p><strong>⑥ bin log（二进制日志）</strong> ：是一个二进制文件，主要记录所有数据库表结构变更，比如，CREATE、ALTER TABLE等，以及表数据修改，比如，INSERT、UPDATE、DELETE 的所有操作，bin log 中记录了对 MySQL数据库执行更改的所有操作，并且记录了语句发生时间、执行时长、操作数据等其他额外信息，但是它不记录 SELECT、SHOW 等那些不修改数据的 SQL 语句。<br>binlog 的作用如下：</p><ul><li>恢复（recovery）：某些数据的恢复需要二进制日志。比如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行 point-in-time 的恢复；</li><li>复制（replication）：其原理与恢复类似，通过复制和执行二进制日志使一台远程的 MySQL 数据库（一般称为 slave 或者standby）与一台 MySQL 数据库（一般称为 master 或者 primary）进行实时同步；</li><li>审计（audit）：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击。</li></ul><p>除了上面介绍的几个作用外，binlog 对于事务存储引擎的崩溃恢复也有非常重要的作用，在开启 binlog 的情况下，为了保证 binlog 与 redo的一致性，MySQL 将采用事务的两阶段提交协议。当 MySQL 系统发生崩溃时，事务在存储引擎内部的状态可能为 prepared（准备状态）和commit（提交状态）两种，对于 prepared 状态的事务，是进行提交操作还是进行回滚操作，这时需要参考 binlog，如果事务在 binlog中存在，那么将其提交；如果不在 binlog 中存在，那么将其回滚，这样就保证了数据在主库和从库之间的一致性。</p><p>binlog 默认是关闭状态，可以在 MySQL 配置文件（my.cnf）中通过配置参数 log-bin = [base-name] 开启记录 binlog日志，如果不指定 base-name，则默认二进制日志文件名为主机名，并以自增的数字作为后缀，比如：mysql-bin.000001，所在目录为数据库所在目录（datadir）。</p><p>通过以下命令来查询 binlog 是否开启：</p><blockquote><p>show variables like ‘log_%’;</p></blockquote><p><img src="https://images.gitbook.cn/48857550-df7e-11e9-9b80-07a210d8c96e" alt="1"></p><p>binlog 格式分为 STATEMENT、ROW 和 MIXED 三种。</p><ul><li>STATEMENT 格式的 binlog 记录的是数据库上执行的原生 SQL 语句。这种格式的优点是简单，简单地记录和执行这些语句，能够让主备保持同步，在主服务器上执行的 SQL 语句，在从服务器上执行同样的语句。另一个好处是二进制日志里的时间更加紧凑，因此相对而言，基于语句的复制模式不会使用太多带宽，同时也节约磁盘空间，并且通过 mysqlbinlog 工具容易读懂其中的内容。缺点就是同一条 SQL 在主库和从库上执行的时间可能稍微或很大不相同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息，如当前的时间戳。即便如此，还存在着一些无法被正确复制的 SQL，比如，使用 INSERT INTO TB1 VALUE(CUURENT_DATE()) 这一条使用函数的语句插入的数据复制到当前从服务器上来就会发生变化，存储过程和触发器在使用基于语句的复制模式时也可能存在问题；另外一个问题就是基于语句的复制必须是串行化的，比如，InnoDB 的 next-key 锁等，并不是所有的存储引擎都支持基于语句的复制。</li><li>ROW 格式是从 MySQL 5.1 开始支持基于行的复制，也就是基于数据的复制，基于行的更改。这种方式会将实际数据记录在二进制日志中，它有其自身的一些优点和缺点，最大的好处是可以正确地复制每一行数据，一些语句可以被更加有效地复制，另外就是几乎没有基于行的复制模式无法处理的场景，对于所有的 SQL 构造、触发器、存储过程等都能正确执行；它的缺点就是二进制日志可能会很大，而且不直观，因此，你不能使用 mysqlbinlog 来查看二进制日志，也无法通过看二进制日志判断当前执行到那一条 SQL 语句。现在对于 ROW 格式的二进制日志基本是标配了，主要是因为它的优势远远大于缺点，并且由于 ROW 格式记录行数据，因此可以基于这种模式做一些 DBA 工具，比如数据恢复，不同数据库之间数据同步等。</li><li>MIXED 也是 MySQL 默认使用的二进制日志记录方式，但 MIXED 格式默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。比如用到 UUID()、USER()、CURRENT_USER()、ROW_COUNT() 等无法确定的函数。</li></ul><h4 id="26-redo-log-和-binlog-有什么区别？"><a href="#26-redo-log-和-binlog-有什么区别？" class="headerlink" title="26.redo log 和 binlog 有什么区别？"></a>26.redo log 和 binlog 有什么区别？</h4><p>redo log（重做日志）和 binlog（归档日志）都是 MySQL 的重要的日志，它们的区别如下：</p><ul><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；</li><li>binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”；</li><li>redo log 是 InnoDB 引擎特有的，binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用；</li><li>redo log 是循环写的，空间固定会用完，binlog 是可以追加写入的，“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ul><p>最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe能力的，因此 InnoDB 使用另外一套日志系统，也就是 redo log 来实现 crash-safe 能力。</p><h4 id="27-慢查询日志的获取方式有哪些？"><a href="#27-慢查询日志的获取方式有哪些？" class="headerlink" title="27.慢查询日志的获取方式有哪些？"></a>27.慢查询日志的获取方式有哪些？</h4><p>答：慢查询日志的常见获取方式如下。</p><ul><li>使用 MySQL 自带功能，开启慢查询日志，在 MySQL 的安装目录下找到 my.cnf 文件设置 <code>slow-query-log=On</code> 开启慢查询，慢查询默认时长为 10s，默认存储文件名为 host_name-slow.log。</li><li>使用三方开源方案 zabbix，zabbix 是一个基于 Web 界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案，能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。</li></ul><h4 id="28-如何定位慢查询？"><a href="#28-如何定位慢查询？" class="headerlink" title="28.如何定位慢查询？"></a>28.如何定位慢查询？</h4><p>答：使用 MySQL 中的 explain 分析执行语句，比如：</p><blockquote><p>explain select * from t where id=5;</p></blockquote><p>如下图所示：</p><p><img src="https://images.gitbook.cn/5ec8ebd0-df7e-11e9-9b80-07a210d8c96e" alt="2"></p><p>其中：</p><ul><li>id — 选择标识符，id 越大优先级越高，越先被执行</li><li>select_type — 表示查询的类型。</li><li>table — 输出结果集的表</li><li>partitions — 匹配的分区</li><li>type — 表示表的连接类型</li><li>possible_keys — 表示查询时，可能使用的索引</li><li>key — 表示实际使用的索引</li><li>key_len — 索引字段的长度</li><li>ref— 列与索引的比较</li><li>rows — 大概估算的行数</li><li>filtered — 按表条件过滤的行百分比</li><li>Extra — 执行情况的描述和说明</li></ul><p>其中最重要的就是 type 字段，type 值类型如下：</p><ul><li>all — 扫描全表数据</li><li>index — 遍历索引</li><li>range — 索引范围查找</li><li>index_subquery — 在子查询中使用 ref</li><li>unique_subquery — 在子查询中使用 eq_ref</li><li>ref_or_null — 对 null 进行索引的优化的 ref</li><li>fulltext — 使用全文索引</li><li>ref — 使用非唯一索引查找数据</li><li>eq_ref — 在 join 查询中使用主键或唯一索引关联</li><li>const — 将一个主键放置到 where 后面作为条件查询， MySQL 优化器就能把这次查询优化转化为一个常量，如何转化以及何时转化，这个取决于优化器，这个比 eq_ref 效率高一点</li></ul><h4 id="29-MySQL-中常见的读写分离方案有哪些？"><a href="#29-MySQL-中常见的读写分离方案有哪些？" class="headerlink" title="29.MySQL 中常见的读写分离方案有哪些？"></a>29.MySQL 中常见的读写分离方案有哪些？</h4><p>答：MySQL 中常见的读写分离方案通常为以下两种：</p><ul><li>使用 MySQL 官方提供的数据库代理产品 MySql ProxySQL 搭建自动分配的数据库读写分离环境；</li><li>在程序层面配置多数据源使用代码实现读写分离。</li></ul><h4 id="30-怎样保证主备数据库无延迟？"><a href="#30-怎样保证主备数据库无延迟？" class="headerlink" title="30.怎样保证主备数据库无延迟？"></a>30.怎样保证主备数据库无延迟？</h4><p>答：通常保证主备数据库无延迟有以下三种方法。</p><ul><li>每次从库执行查询请求前，先判断 seconds_behind_master 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求，seconds_behind_master 参数是用来衡量主备延迟时间的长短。</li><li>对比位点确保主备无延迟。Master_Log_File 和 Read_Master_Log_Pos，表示的是读到的主库的最新位点，Relay_Master_Log_File 和 Exec_Master_Log_Pos，表示的是备库执行的最新位点。</li><li>对比 GTID 集合确保主备无延迟。Auto_Position=1 ，表示这对主备关系使用了 GTID 协议。Retrieved_Gtid_Set，是备库收到的所有日志的 GTID 集合；Executed_Gtid_Set，是备库所有已经执行完成的 GTID 集合。</li></ul><h4 id="31-什么是-MySQL-多实例，如何配置-MySQL-多实例？"><a href="#31-什么是-MySQL-多实例，如何配置-MySQL-多实例？" class="headerlink" title="31.什么是 MySQL 多实例，如何配置 MySQL 多实例？"></a>31.什么是 MySQL 多实例，如何配置 MySQL 多实例？</h4><p>答：MySQL 多实例就是在同一台服务器上启用多个 MySQL服务，它们监听不同的端口，运行多个服务进程，它们相互独立，互不影响的对外提供服务，便于节约服务器资源与后期架构扩展。 多实例的配置方法有两种：</p><ul><li>一个实例一个配置文件，不同端口；</li><li>同一配置文件（my.cnf）下配置不同实例，基于 MySQL 的 d_multi 工具。</li></ul><h4 id="32-表的优化策略有哪些？"><a href="#32-表的优化策略有哪些？" class="headerlink" title="32.表的优化策略有哪些？"></a>32.表的优化策略有哪些？</h4><p>「参考答案」常见的大表优化策略如下。</p><ul><li>读写分离，主库负责写，从库负责读。</li><li>垂直分区，根据数据属性单独拆表甚至单独拆库。</li><li>水平分区，保持表结构不变，根据策略存储数据分片，这样每一片数据被分散到不同的表或者库中。水平拆分只是解决了单一表数据过大的问题，表数据还在同一台机器上，对于并发能力没有什么意义，因此水平拆分最好分库。另外分片事务难以解决，跨节点 join 性能较差。</li></ul><h4 id="33-数据库分片方案有哪些？"><a href="#33-数据库分片方案有哪些？" class="headerlink" title="33.数据库分片方案有哪些？"></a>33.数据库分片方案有哪些？</h4><p>「参考答案」数据库分片方案有哪些？ 答：数据库创建的分片方案有两种方式：客户端代理方式和中间件代理方式。</p><ul><li>客户端代理 — 分片逻辑在应用端，封装在 jar 包中，通过修改或者封装 JDBC 层来实现，比如 Sharding-JDBC、阿里 TDDL 等。</li><li>中间件代理 — 在应用层和数据层中间加了一个代理层。分片逻辑统一维护在中间件服务中，比如 MyCat、网易的 DDB 都是中间件代理的典型代表。</li></ul><h4 id="34-查询语句的优化方案有哪些？"><a href="#34-查询语句的优化方案有哪些？" class="headerlink" title="34.查询语句的优化方案有哪些？"></a>34.查询语句的优化方案有哪些？</h4><p>「参考答案」常见优化方案如下：</p><ul><li>不做列运算，把计算都放入各个业务系统实现；</li><li>查询语句尽可能简单，大语句拆小语句，减少锁时间；</li><li>不使用 select * 查询；</li><li>or 查询改写成 in 查询；</li><li>不用函数和触发器；</li><li>避免 %xx 查询；</li><li>少用 join 查询；</li><li>使用同类型比较，比如 ‘123’ 和 ‘123’、123 和 123；</li><li>尽量避免在 where 子句中使用 != 或者 &lt;&gt; 操作符，查询引用会放弃索引而进行全表扫描；</li><li>列表数据使用分页查询，每页数据量不要太大。</li></ul><h4 id="35-MySQL-毫无规律的异常重启，可能产生的原因是什么？该如何解决？"><a href="#35-MySQL-毫无规律的异常重启，可能产生的原因是什么？该如何解决？" class="headerlink" title="35.MySQL 毫无规律的异常重启，可能产生的原因是什么？该如何解决？"></a>35.MySQL 毫无规律的异常重启，可能产生的原因是什么？该如何解决？</h4><p>「参考答案」可能是积累的长连接导致内存占用太多，被系统强行杀掉导致的异常重启，因为在 MySQL中长连接在执行过程中使用的临时内存对象，只有在连接断开的时候才会释放，这就会导致内存不断飙升，解决方案如下：</p><ul><li>定期断开空闲的长连接；</li><li>如果是用的是 MySQL 5.7 以上的版本，可以定期执行 mysql_reset_connection 重新初始化连接资源，这个过程会释放之前使用的内存资源，恢复到连接刚初始化的状态。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java面试全解析核心知识点与典型面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池之 ThreadPoolExecutor + 面试题</title>
    <link href="/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/019--%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BThreadPoolExecutor+%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/019--%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BThreadPoolExecutor+%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="线程池介绍"><a href="#线程池介绍" class="headerlink" title="线程池介绍"></a>线程池介绍</h3><p>线程池（Thread Pool）：把一个或多个线程通过统一的方式进行调度和重复使用的技术，避免了因为线程过多而带来使用上的开销。</p><h4 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h4><ul><li>可重复使用已有线程，避免对象创建、消亡和过度切换的性能开销。</li><li>避免创建大量同类线程所导致的资源过度竞争和内存溢出的问题。</li><li>支持更多功能，比如延迟任务线程池（newScheduledThreadPool）和缓存线程池（newCachedThreadPool）等。</li></ul><h3 id="线程池使用"><a href="#线程池使用" class="headerlink" title="线程池使用"></a>线程池使用</h3><p>创建线程池有两种方式：ThreadPoolExecutor 和 Executors，其中 Executors 又可以创建 6<br>种不同的线程池类型，会在下节讲，本节重点来看看 ThreadPoolExecutor 的使用。</p><h4 id="ThreadPoolExecutor-的使用"><a href="#ThreadPoolExecutor-的使用" class="headerlink" title="ThreadPoolExecutor 的使用"></a>ThreadPoolExecutor 的使用</h4><p>线程池使用代码如下：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPoolExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10L</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>(<span class="hljs-number">100</span>));<br>threadPoolExecutor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 执行线程池</span><br>        System.out.println(<span class="hljs-string">&quot;Hello, Java.&quot;</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>Hello, Java.</p></blockquote><h4 id="ThreadPoolExecutor-参数说明"><a href="#ThreadPoolExecutor-参数说明" class="headerlink" title="ThreadPoolExecutor 参数说明"></a>ThreadPoolExecutor 参数说明</h4><p>ThreadPoolExecutor 构造方法有以下四个，如下图所示：</p><p><img src="https://images.gitbook.cn/ce89fc40-d2d4-11e9-b6c4-07be7ef1cd0f" alt="enter image descriptionhere"></p><p>其中最后一个构造方法有 7 个构造参数，包含了前三个方法的构造参数，这 7 个参数名称如下所示：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span> &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其代表的含义如下：</p><h5 id="①-corePoolSize"><a href="#①-corePoolSize" class="headerlink" title="① corePoolSize"></a>① corePoolSize</h5><p>线程池中的核心线程数，默认情况下核心线程一直存活在线程池中，如果将 ThreadPoolExecutor 的 allowCoreThreadTimeOut<br>属性设为 true，如果线程池一直闲置并超过了 keepAliveTime 所指定的时间，核心线程就会被终止。</p><h5 id="②-maximumPoolSize"><a href="#②-maximumPoolSize" class="headerlink" title="② maximumPoolSize"></a>② maximumPoolSize</h5><p>线程池中最大线程数，如果活动的线程达到这个数值以后，后续的新任务将会被阻塞（放入任务队列）。</p><h5 id="③-keepAliveTime"><a href="#③-keepAliveTime" class="headerlink" title="③ keepAliveTime"></a>③ keepAliveTime</h5><p>线程池的闲置超时时间，默认情况下对非核心线程生效，如果闲置时间超过这个时间，非核心线程就会被回收。如果 ThreadPoolExecutor 的<br>allowCoreThreadTimeOut 设为 true 的时候，核心线程如果超过闲置时长也会被回收。</p><h5 id="④-unit"><a href="#④-unit" class="headerlink" title="④ unit"></a>④ unit</h5><p>配合 keepAliveTime 使用，用来标识 keepAliveTime 的时间单位。</p><h5 id="⑤-workQueue"><a href="#⑤-workQueue" class="headerlink" title="⑤ workQueue"></a>⑤ workQueue</h5><p>线程池中的任务队列，使用 execute() 或 submit() 方法提交的任务都会存储在此队列中。</p><h5 id="⑥-threadFactory"><a href="#⑥-threadFactory" class="headerlink" title="⑥ threadFactory"></a>⑥ threadFactory</h5><p>为线程池提供创建新线程的线程工厂。</p><h5 id="⑦-rejectedExecutionHandler"><a href="#⑦-rejectedExecutionHandler" class="headerlink" title="⑦ rejectedExecutionHandler"></a>⑦ rejectedExecutionHandler</h5><p>线程池任务队列超过最大值之后的拒绝策略，RejectedExecutionHandler 是一个接口，里面只有一个 rejectedExecution<br>方法，可在此方法内添加任务超出最大值的事件处理。ThreadPoolExecutor 也提供了 4 种默认的拒绝策略：</p><ul><li>new ThreadPoolExecutor.DiscardPolicy()：丢弃掉该任务，不进行处理</li><li>new ThreadPoolExecutor.DiscardOldestPolicy()：丢弃队列里最近的一个任务，并执行当前任务</li><li>new ThreadPoolExecutor.AbortPolicy()：直接抛出 RejectedExecutionException 异常</li><li>new ThreadPoolExecutor.CallerRunsPolicy()：既不抛弃任务也不抛出异常，直接使用主线程来执行此任务</li></ul><p>包含所有参数的 ThreadPoolExecutor 使用代码：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExecutorTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                <span class="hljs-number">10L</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="hljs-number">2</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThreadFactory</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<br>        threadPool.allowCoreThreadTimeOut(<span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            threadPool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    System.out.println(Thread.currentThread().getName());<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">2000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MyThread&quot;</span> + count.addAndGet(<span class="hljs-number">1</span>);<br>        t.setName(threadName);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线程池执行方法-execute-VS-submit"><a href="#线程池执行方法-execute-VS-submit" class="headerlink" title="线程池执行方法 execute() VS submit()"></a>线程池执行方法 execute() VS submit()</h4><p>execute() 和 submit() 都是用来执行线程池的，区别在于 submit() 方法可以接收线程池执行的返回值。</p><p>下面分别来看两个方法的具体使用和区别：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建线程池</span><br><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPoolExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10L</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>(<span class="hljs-number">100</span>));<br><span class="hljs-comment">// execute 使用</span><br>threadPoolExecutor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, Java.&quot;</span>);<br>    &#125;<br>&#125;);<br><span class="hljs-comment">// submit 使用</span><br>Future&lt;String&gt; future = threadPoolExecutor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, 老王.&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Success&quot;</span>;<br>    &#125;<br>&#125;);<br>System.out.println(future.get());<br></code></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>Hello, Java.</p></blockquote><blockquote></blockquote><blockquote><p>Hello, 老王.</p></blockquote><blockquote></blockquote><blockquote><p>Success</p></blockquote><h4 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h4><p>线程池关闭，可以使用 shutdown() 或 shutdownNow() 方法，它们的区别是：</p><ul><li>shutdown()：不会立即终止线程池，而是要等所有任务队列中的任务都执行完后才会终止。执行完 shutdown 方法之后，线程池就不会再接受新任务了。</li><li>shutdownNow()：执行该方法，线程池的状态立刻变成 STOP 状态，并试图停止所有正在执行的线程，不再处理还在池队列中等待的任务，执行此方法会返回未执行的任务。</li></ul><p>下面用代码来模拟 shutdown() 之后，给线程池添加任务，代码如下：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">threadPoolExecutor.execute(() -&gt; &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>        System.out.println(<span class="hljs-string">&quot;I&#x27;m &quot;</span> + i);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            System.out.println(e.getMessage());<br>        &#125;<br>    &#125;<br>&#125;);<br>threadPoolExecutor.shutdown();<br>threadPoolExecutor.execute(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;I&#x27;m Java.&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>I’m 0</p></blockquote><blockquote></blockquote><blockquote><p>Exception in thread “main” java.util.concurrent.RejectedExecutionException:<br>Task com.interview.chapter5.Section2<code>$$Lambda$2</code>/1828972342@568db2f2 rejected<br>from java.util.concurrent.ThreadPoolExecutor@378bf509[Shutting down, pool size<br>= 1, active threads = 1, queued tasks = 0, completed tasks = 0]</p></blockquote><blockquote></blockquote><blockquote><p>I’m 1</p></blockquote><p>可以看出，shutdown() 之后就不会再接受新的任务了，不过之前的任务会被执行完成。</p><h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="1-ThreadPoolExecutor-有哪些常用的方法？"><a href="#1-ThreadPoolExecutor-有哪些常用的方法？" class="headerlink" title="1.ThreadPoolExecutor 有哪些常用的方法？"></a>1.ThreadPoolExecutor 有哪些常用的方法？</h4><p>答：常用方法如下所示：</p><ul><li>submit()/execute()：执行线程池</li><li>shutdown()/shutdownNow()：终止线程池</li><li>isShutdown()：判断线程是否终止</li><li>getActiveCount()：正在运行的线程数</li><li>getCorePoolSize()：获取核心线程数</li><li>getMaximumPoolSize()：获取最大线程数</li><li>getQueue()：获取线程池中的任务队列</li><li>allowCoreThreadTimeOut(boolean)：设置空闲时是否回收核心线程</li></ul><h4 id="2-以下程序执行的结果是什么？"><a href="#2-以下程序执行的结果是什么？" class="headerlink" title="2.以下程序执行的结果是什么？"></a>2.以下程序执行的结果是什么？</h4><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPoolExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10L</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>());<br>threadPoolExecutor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;I：&quot;</span> + i);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;);<br>threadPoolExecutor.shutdownNow();<br>System.out.println(<span class="hljs-string">&quot;Java&quot;</span>);<br></code></pre></td></tr></table></figure><p>答：程序执行的结果是：</p><blockquote><p>I：0</p></blockquote><blockquote></blockquote><blockquote><p>Java</p></blockquote><blockquote></blockquote><blockquote><p>java.lang.InterruptedException: sleep interrupted（报错信息）</p></blockquote><blockquote></blockquote><blockquote><p>I：1</p></blockquote><p>题目解析：因为程序中使用了 <code>shutdownNow()</code> 会导致程序执行一次之后报错，抛出 <code>sleep interrupted</code> 异常，又因为本身有<br>try/catch，所以程序会继续执行打印 <code>I：1</code> 。</p><h4 id="3-在-ThreadPool-中-submit-和-execute-有什么区别？"><a href="#3-在-ThreadPool-中-submit-和-execute-有什么区别？" class="headerlink" title="3.在 ThreadPool 中 submit() 和 execute() 有什么区别？"></a>3.在 ThreadPool 中 submit() 和 execute() 有什么区别？</h4><p>答：submit() 和 execute() 都是用来执行线程池的，只不过使用 execute() 执行线程池不能有返回方法，而使用 submit()<br>可以使用 Future 接收线程池执行的返回值。</p><p>submit() 方法源码（JDK 8）如下：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br></code></pre></td></tr></table></figure><p>execute() 源码（JDK 8）如下：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">//..... 其他</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-说一下-ThreadPoolExecutor-都需要哪些参数？"><a href="#4-说一下-ThreadPoolExecutor-都需要哪些参数？" class="headerlink" title="4.说一下 ThreadPoolExecutor 都需要哪些参数？"></a>4.说一下 ThreadPoolExecutor 都需要哪些参数？</h4><p>答：ThreadPoolExecutor 最多包含以下七个参数：</p><ul><li>corePoolSize：线程池中的核心线程数</li><li>maximumPoolSize：线程池中最大线程数</li><li>keepAliveTime：闲置超时时间</li><li>unit：keepAliveTime 超时时间的单位（时/分/秒等）</li><li>workQueue：线程池中的任务队列</li><li>threadFactory：为线程池提供创建新线程的线程工厂</li><li>rejectedExecutionHandler：线程池任务队列超过最大值之后的拒绝策略</li></ul><h4 id="5-在线程池中-shutdownNow-和-shutdown-有什么区别？"><a href="#5-在线程池中-shutdownNow-和-shutdown-有什么区别？" class="headerlink" title="5.在线程池中 shutdownNow() 和 shutdown() 有什么区别？"></a>5.在线程池中 shutdownNow() 和 shutdown() 有什么区别？</h4><p>答：shutdownNow() 和 shutdown() 都是用来终止线程池的，它们的区别是，使用 shutdown()<br>程序不会报错，也不会立即终止线程，它会等待线程池中的缓存任务执行完之后再退出，执行了 shutdown()<br>之后就不能给线程池添加新任务了；shutdownNow() 会试图立马停止任务，如果线程池中还有缓存任务正在执行，则会抛出<br>java.lang.InterruptedException: sleep interrupted 异常。</p><h4 id="6-说一说线程池的工作原理？"><a href="#6-说一说线程池的工作原理？" class="headerlink" title="6.说一说线程池的工作原理？"></a>6.说一说线程池的工作原理？</h4><p>答：当线程池中有任务需要执行时，线程池会判断如果线程数量没有超过核心数量就会新建线程池进行任务执行，如果线程池中的线程数量已经超过核心线程数，这时候任务就会被放入任务队列中排队等待执行；如果任务队列超过最大队列数，并且线程池没有达到最大线程数，就会新建线程来执行任务；如果超过了最大线程数，就会执行拒绝执行策略。</p><h4 id="7-以下线程名称被打印了几次？"><a href="#7-以下线程名称被打印了几次？" class="headerlink" title="7.以下线程名称被打印了几次？"></a>7.以下线程名称被打印了几次？</h4><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                <span class="hljs-number">10L</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="hljs-number">2</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.DiscardPolicy());<br>threadPool.allowCoreThreadTimeOut(<span class="hljs-literal">true</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    threadPool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 打印线程名称</span><br>            System.out.println(Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure><p>答：线程名被打印了 3 次。<br>题目解析：线程池第 1 次执行任务时，会新创建任务并执行；第 2 次执行任务时，因为没有空闲线程所以会把任务放入队列；第 3<br>次同样把任务放入队列，因为队列最多可以放两条数据，所以第 4 次之后的执行都会被舍弃（没有定义拒绝策略），于是就打印了 3 次线程名称。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ThreadPoolExecutor<br>是创建线程池最传统和最推荐使用的方式，创建时要设置线程池的核心线程数和最大线程数还有任务队列集合，如果任务量大于队列的最大长度，线程池会先判断当前线程数量是否已经到达最大线程数，如果没有达到最大线程数就新建线程来执行任务，如果已经达到最大线程数，就会执行拒绝策略（拒绝策略可自行定义）。线程池可通过<br>submit() 来调用执行，从而获得线程执行的结果，也可以通过 shutdown() 来终止线程池。</p><blockquote><p>[点击此处下载本文源码](<a href="https://github.com/vipstone/java-">https://github.com/vipstone/java-</a><br>interview/tree/master/interview-code/src/main/java/com/interview)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java面试全解析核心知识点与典型面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>001--Java程序是如何执行的</title>
    <link href="/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/001--Java%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
    <url>/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/001--Java%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h2 id="Java-程序是如何执行的"><a href="#Java-程序是如何执行的" class="headerlink" title="Java 程序是如何执行的"></a>Java 程序是如何执行的</h2><p>了解任何一门语言的精髓都是先俯览其全貌，从宏观的视角把握全局，然后再深入每个知识点逐个击破，这样就可以深入而快速的掌握一项技能。同样学习 Java 也是如此，本节就让我们先从整体来看一下 Java 中的精髓。</p><h3 id="Java-介绍"><a href="#Java-介绍" class="headerlink" title="Java 介绍"></a>Java 介绍</h3><p>Java 诞生于 1991 年，Java 的前身叫做 Oak（橡树），但在注册商标的时候，发现这个名字已经被人注册了，后来团队的人就在咖啡馆讨论这件事该怎么办，有人灵机一动说叫 Java 如何，因为当时他们正在喝着一款叫做 Java 的咖啡。就这样，这个后来家喻户晓的名字，竟以这种“随意”的方式诞生了，并一直沿用至今。</p><p>Java 发展历程：</p><ul><li>1990，Sun 成立了“Green Team”项目小组</li><li>1991，Java 语言前身 Oak（橡树）诞生</li><li>1995，Oak 语言更名为 Java</li><li>1996，Java 1.0 发布</li><li>1997，Java 1.1 发布</li><li>1998，Java 1.2 发布</li><li>2000，Java 1.3 发布</li><li>2000，Java 1.4 发布</li><li>2004，Java 5 发布</li><li>2006，Java 6 发布</li><li>2011，Java 7 发布</li><li>2014，Java 8 发布</li><li>2017，Java 9（非长期支持版）发布</li><li>2018.03，Java 10（非长期支持版） 发布</li><li>2018.09，Java 11（长期支持版）发布</li><li>2019.03，Java  12</li><li>2019.09，Java  13</li><li>2020.03，Java  14</li><li>2020.09，Java  15</li><li>2021.03，Java  16</li><li>2021.09，Java  17</li><li>2022.03，Java  18</li></ul><p>注：长期支持版指的是官方发布版本后的一段时间内，通常以“年”为计数单位，会对此版本进行持续维护和升级。</p><p><strong>版本发布时间</strong></p><p>Java 10 之后，官方表示每半年推出一个大版本，长期支持版本（LTS）每三年发布一次。</p><h3 id="Java-和-JDK-的关系"><a href="#Java-和-JDK-的关系" class="headerlink" title="Java 和 JDK 的关系"></a>Java 和 JDK 的关系</h3><p>JDK（Java Development Kit）Java 开发工具包，它包括：编译器、Java 运行环境（JRE，Java Runtime<br>Environment）、JVM（Java 虚拟机）监控和诊断工具等，而 Java 则表示一种开发语言。</p><h3 id="Java-程序是怎么执行的？"><a href="#Java-程序是怎么执行的？" class="headerlink" title="Java 程序是怎么执行的？"></a>Java 程序是怎么执行的？</h3><p>我们日常的工作中都使用开发工具（IntelliJ IDEA 或 Eclipse 等）可以很方便的调试程序，或者是通过打包工具把项目打包成 jar 包或者<br>war 包，放入 Tomcat 等 Web 容器中就可以正常运行了，但你有没有想过 Java 程序内部是如何执行的？</p><p>其实不论是在开发工具中运行还是在 Tomcat 中运行，Java 程序的执行流程基本都是相同的，它的执行流程如下：</p><ol><li>先把 Java 代码编译成字节码，也就是把 .java 类型的文件编译成 .class 类型的文件。这个过程的大致执行流程：Java 源代码 -&gt; 词法分析器 -&gt; 语法分析器 -&gt; 语义分析器 -&gt; 字节码生成器 -&gt; 最终生成字节码，其中任何一个节点执行失败就会造成编译失败；</li><li>把 class 文件放置到 Java 虚拟机，这个虚拟机通常指的是 Oracle 官方自带的 Hotspot JVM；</li><li>Java 虚拟机使用类加载器（Class Loader）装载 class 文件；</li><li>类加载完成之后，会进行字节码校验，字节码校验通过之后 JVM 解释器会把字节码翻译成机器码交由操作系统执行。但不是所有代码都是解释执行的，JVM 对此做了优化，比如，以 Hotspot 虚拟机来说，它本身提供了 JIT（Just In Time）也就是我们通常所说的动态编译器，它能够在运行时将热点代码编译为机器码，这个时候字节码就变成了编译执行。</li></ol><p>Java 程序执行流程图如下：</p><p><img src="https://images.gitbook.cn/FvSP3G2xXR676FoIvsz-0naYLP2I" alt="avatar"></p><h3 id="Java-虚拟机是如何判定热点代码的？"><a href="#Java-虚拟机是如何判定热点代码的？" class="headerlink" title="Java 虚拟机是如何判定热点代码的？"></a>Java 虚拟机是如何判定热点代码的？</h3><p>Java 虚拟机判定热点代码的方式有两种：</p><ul><li>基于采样的热点判定</li></ul><p>主要是虚拟机会周期性的检查各个线程的栈顶，若某个或某些方法经常出现在栈顶，那这个方法就是“热点方法”。这种判定方式的优点是实现简单；缺点是很难精确一个方法的热度，容易受到线程阻塞或外界因素的影响。</p><ul><li>基于计数器的热点判定</li></ul><p>主要就是虚拟机给每一个方法甚至代码块建立了一个计数器，统计方法的执行次数，超过一定的阀值则标记为此方法为热点方法。</p><p>Hotspot 虚拟机使用的基于计数器的热点探测方法。它使用了两类计数器：方法调用计数器和回边计数器，当到达一定的阀值是就会触发 JIT 编译。</p><p>方法调用计数器：在 client 模式下的阀值是 1500 次，Server 是 10000 次，可以通过虚拟机参数：<br><code>-XX:CompileThreshold=N</code> 对其进行设置。但是JVM还存在热度衰减，时间段内调用方法的次数较少，计数器就减小。</p><p>回边计数器：主要统计的是方法中循环体代码执行的次数。</p><p>由上面的知识我们可以看出， <strong>要想做到对 Java 了如指掌，必须要好好学习 Java 虚拟机</strong> ，那除了 Java<br>虚拟机外，还有哪些知识是面试必考，也是 Java 工程师必须掌握的知识呢？</p><h4 id="1-Java-基础中的核心内容"><a href="#1-Java-基础中的核心内容" class="headerlink" title="1. Java 基础中的核心内容"></a>1. Java 基础中的核心内容</h4><p>字符串和字符串常量池的深入理解、Array 的操作和排序算法、深克隆和浅克隆、各种 IO 操作、反射和动态代理（JDK 自身动态代理和 CGLIB）等。</p><h4 id="2-集合"><a href="#2-集合" class="headerlink" title="2. 集合"></a>2. 集合</h4><p>集合和 String<br>是编程中最常用的数据类型，关于集合的知识也是面试备考的内容，它包含：链表（LinkedList）、TreeSet、栈（Stack）、队列（双端、阻塞、非阻塞队列、延迟队列）、HashMap、TreeMap<br>等，它们的使用和底层存储数据结构都是热门的面试内容。</p><h4 id="3-多线程"><a href="#3-多线程" class="headerlink" title="3. 多线程"></a>3. 多线程</h4><p>多线程使用和线程安全的知识也是必考的面试题目，它包括：死锁、6<br>种线程池的使用与差异、ThreadLocal、synchronized、Lock、JUC（java.util.concurrent包）、CAS（Compare<br>and Swap）、ABA 问题等。</p><h4 id="4-热门框架"><a href="#4-热门框架" class="headerlink" title="4. 热门框架"></a>4. 热门框架</h4><p>Spring、Spring MVC、MyBatis、SpringBoot</p><h4 id="5-分布式编程"><a href="#5-分布式编程" class="headerlink" title="5. 分布式编程"></a>5. 分布式编程</h4><p>消息队列（RabbitMQ、Kafka）、Dubbo、Zookeeper、SpringCloud 等。</p><h4 id="6-数据库"><a href="#6-数据库" class="headerlink" title="6. 数据库"></a>6. 数据库</h4><p>MySQL 常用引擎的掌握、MySQL 前缀索引、回表查询、数据存储结构、最左匹配原则、MySQL 的问题分析和排除方案、MySQL 读写分离的实现原理以及<br>MySQL 的常见优化方案等。 Redis 的使用场景、缓存雪崩和缓存穿透的解决方案、Redis 过期淘汰策略和主从复制的实现方案等。</p><h4 id="7-Java-虚拟机"><a href="#7-Java-虚拟机" class="headerlink" title="7. Java 虚拟机"></a>7. Java 虚拟机</h4><p>虚拟机的组成、垃圾回收算法、各种垃圾回收器的区别、Java 虚拟机分析工具的掌握、垃圾回收器的常用调优参数等。</p><h4 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a>8. 其他</h4><p>常用算法的掌握、设计模式的理解、网络知识和常见 Linux 命令的掌握等。</p><p>值得庆幸的是以上所有内容都包含在本专栏中，接下来就让我们一起学习，一起构建 Java 的认知体系吧!</p><h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="1-Java-语言都有哪些特点？"><a href="#1-Java-语言都有哪些特点？" class="headerlink" title="1. Java 语言都有哪些特点？"></a>1. Java 语言都有哪些特点？</h4><p>答：Java 语言包含以下特点。</p><ul><li>面向对象，程序容易理解、开发简单、方便；</li><li>跨平台，可运行在不同服务器类型上，比如：Linux、Windows、Mac 等；</li><li>执行性能好，运行效率高；</li><li>提供大量的 API 扩展，语言强大；</li><li>有多线程支持，增加了响应和实时交互的能力；</li><li>安全性好，自带验证机制，确保程序的可靠性和安全性。</li></ul><h4 id="2-Java-跨平台实现的原理是什么？"><a href="#2-Java-跨平台实现的原理是什么？" class="headerlink" title="2. Java 跨平台实现的原理是什么？"></a>2. Java 跨平台实现的原理是什么？</h4><p>答：要了解 Java 跨平台实现原理之前，必须先要了解 Java 的执行过程，Java 的执行过程如下：</p><p><img src="https://images.gitbook.cn/bb3215b0-baa6-11e9-8bd3-43e1fddff917" alt="执行过程"></p><p>Java 执行流程：Java 源代码（.java）-&gt; 编译 -&gt; Java 字节码（.class） -&gt;通过 JVM（Java 虚拟机）运行 Java<br>程序。每种类型的服务器都会运行一个 JVM，Java 程序只需要生成 JVM 可以执行的代码即可，JVM<br>底层屏蔽了不同服务器类型之间的差异，从而可以在不同类型的服务器上运行一套 Java 程序。</p><h4 id="3-JDK、JRE、JVM-有哪些区别？"><a href="#3-JDK、JRE、JVM-有哪些区别？" class="headerlink" title="3. JDK、JRE、JVM 有哪些区别？"></a>3. JDK、JRE、JVM 有哪些区别？</h4><p>答：了解了 JDK、JRE、JVM 的定义也就明白了它们之间的区别，如下所述。</p><ul><li>JDK：Java Development Kit（Java 开发工具包）的简称，提供了 Java 的开发环境和运行环境；</li><li>JRE：Java Runtime Environment（Java 运行环境）的简称，为 Java 的运行提供了所需环境；</li><li>JVM：Java Virtual Machine（Java虚拟机）的简称，是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的，简单来说就是所有的 Java 程序都是运行在 JVM（Java 虚拟机）上的。</li></ul><p>总体来说，JDK 提供了一整套的 Java 运行和开发环境，通常使用对象为 Java 的开发者，当然 JDK 也包含了 JRE；而 JRE 为 Java<br>运行的最小运行单元，一般安装在 Java 服务器上，所以 JDK 和 JRE 可以从用途上进行理解和区分。JVM 不同于 JDK 和 JRE，JVM 是<br>Java 程序运行的载体，Java 程序只有通过 JVM 才能正常的运行。</p><h4 id="4-Java-中如何获取明天此刻的时间？"><a href="#4-Java-中如何获取明天此刻的时间？" class="headerlink" title="4. Java 中如何获取明天此刻的时间？"></a>4. Java 中如何获取明天此刻的时间？</h4><p>答：JDK 8 之前使用 <code>Calendar.add()</code> 方法获取，代码如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">Calendar</span> <span class="hljs-string">calendar</span> <span class="hljs-string">=</span> <span class="hljs-string">Calendar.getInstance();</span><br><span class="hljs-string">calendar.add(Calendar.DATE,</span> <span class="hljs-number">1</span><span class="hljs-string">);</span><br><span class="hljs-string">System.out.println(calendar.getTime());</span><br></code></pre></td></tr></table></figure><p>JDK 8 有两种获取明天时间的方法。</p><p>方法一，使用 <code>LocalDateTime.plusDays()</code> 方法获取，代码如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">LocalDateTime</span> <span class="hljs-string">today</span> <span class="hljs-string">=</span> <span class="hljs-string">LocalDateTime.now();</span><br><span class="hljs-string">LocalDateTime</span> <span class="hljs-string">tomorrow</span> <span class="hljs-string">=</span> <span class="hljs-string">today.plusDays(1);</span><br><span class="hljs-string">System.out.println(tomorrow);</span><br></code></pre></td></tr></table></figure><p>方法二，使用 <code>LocalDateTime.minusDays()</code> 方法获取，代码如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">LocalDateTime</span> <span class="hljs-string">today</span> <span class="hljs-string">=</span> <span class="hljs-string">LocalDateTime.now();</span><br><span class="hljs-string">LocalDateTime</span> <span class="hljs-string">tomorrow</span> <span class="hljs-string">=</span> <span class="hljs-string">today.minusDays(-1);</span><br><span class="hljs-string">System.out.println(tomorrow);</span><br></code></pre></td></tr></table></figure><p><code>minusDays()</code> 方法为当前时间减去 n 天，传负值就相当于当前时间加 n 天。</p><h4 id="5-Java-中如何跳出多重嵌套循环？"><a href="#5-Java-中如何跳出多重嵌套循环？" class="headerlink" title="5. Java 中如何跳出多重嵌套循环？"></a>5. Java 中如何跳出多重嵌套循环？</h4><p>答：Java 中跳出多重嵌套循环的两种方式。</p><ul><li>方法一：定义一个标号，使用 break 加标号的方式</li><li>方法二：使用全局变量终止循环</li></ul><h4 id="6-char-变量能不能存贮一个中文汉字？为什么？"><a href="#6-char-变量能不能存贮一个中文汉字？为什么？" class="headerlink" title="6. char 变量能不能存贮一个中文汉字？为什么？"></a>6. char 变量能不能存贮一个中文汉字？为什么？</h4><p>英文字母和中文汉字在不同字符集编码下的字节数</p><p>英文字母：</p><p>字节数 : 1;编码：GB2312</p><p>字节数 : 1;编码：GBK</p><p>字节数 : 1;编码：GB18030</p><p>字节数 : 1;编码：ISO-8859-1</p><p>字节数 : 1;编码：UTF-8</p><p>字节数 : 4;编码：UTF-16</p><p>字节数 : 2;编码：UTF-16BE</p><p>字节数 : 2;编码：UTF-16LE</p><p>中文汉字：</p><p>字节数 : 2;编码：GB2312</p><p>字节数 : 2;编码：GBK</p><p>字节数 : 2;编码：GB18030</p><p>字节数 : 1;编码：ISO-8859-1</p><p>字节数 : 3;编码：UTF-8</p><p>字节数 : 4;编码：UTF-16</p><p>字节数 : 2;编码：UTF-16BE</p><p>字节数 : 2;编码：UTF-16LE</p><h4 id="7-Java-中会存在内存泄漏吗？请简单描述一下。"><a href="#7-Java-中会存在内存泄漏吗？请简单描述一下。" class="headerlink" title="7. Java 中会存在内存泄漏吗？请简单描述一下。"></a>7. Java 中会存在内存泄漏吗？请简单描述一下。</h4><p>答：一个不再被程序使用的对象或变量一直被占据在内存中就造成了内存泄漏。</p><p>Java 中的内存泄漏的常见情景如下：</p><ul><li>长生命周期对象持有短生命的引用，比如，缓存系统，我们加载了一个对象放在缓存中，然后一直不使用这个缓存，由于缓存的对象一直被缓存引用得不到释放，就造成了内存泄漏；</li><li>各种连接未调用关闭方法，比如，数据库 Connection 连接，未显性地关闭，就会造成内存泄漏；</li><li>内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露；</li><li>改变哈希值，当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希值就不同了，在这种情况下，即使在 contains 方法使用该对象的当前引用作为的参数去 HashSet 集合中检索对象，也将返回找不到对象的结果，这也会导致无法从 HashSet 集合中单独删除当前对象，造成内存泄露。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java面试全解析核心知识点与典型面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构之队列的使用 + 面试题</title>
    <link href="/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/015--%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8+%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/015--%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8+%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>队列（Queue）：与栈相对的一种数据结构，<br>集合（Collection）的一个子类。队列允许在一端进行插入操作，而在另一端进行删除操作的线性表，栈的特点是后进先出，而队列的特点是先进先出。队列的用处很大，比如实现消息队列。</p><p>Queue 类关系图，如下图所示：</p><p><img src="https://images.gitbook.cn/64fedb10-cebf-11e9-956a-e59402c7f15a" alt="enter image descriptionhere"></p><p>注：为了让读者更直观地理解，上图为精简版的 Queue 类关系图。本文如无特殊说明，内容都是基于 Java 1.8 版本。</p><h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><h4 id="1）Queue-分类"><a href="#1）Queue-分类" class="headerlink" title="1）Queue 分类"></a>1）Queue 分类</h4><p>从上图可以看出 Queue 大体可分为以下三类。</p><ul><li>双端队列：双端队列（Deque）是 Queue 的子类也是 Queue 的补充类，头部和尾部都支持元素插入和获取。</li><li>阻塞队列：阻塞队列指的是在元素操作时（添加或删除），如果没有成功，会阻塞等待执行。例如，当添加元素时，如果队列元素已满，队列会阻塞等待直到有空位时再插入。</li><li>非阻塞队列：非阻塞队列和阻塞队列相反，会直接返回操作的结果，而非阻塞等待。双端队列也属于非阻塞队列。</li></ul><h4 id="2）Queue-方法说明"><a href="#2）Queue-方法说明" class="headerlink" title="2）Queue 方法说明"></a>2）Queue 方法说明</h4><p>Queue 常用方法，如下图所示：</p><p><img src="https://images.gitbook.cn/78539610-cebf-11e9-956a-e59402c7f15a" alt="enter image descriptionhere"></p><p>方法说明：</p><ul><li>add(E)：添加元素到队列尾部，成功返回 true，队列超出时抛出异常；</li><li>offer(E)：添加元素到队列尾部，成功返回 true，队列超出时返回 false；</li><li>remove()：删除元素，成功返回 true，失败返回 false；</li><li>poll()：获取并移除此队列的第一个元素，若队列为空，则返回 null；</li><li>peek()：获取但不移除此队列的第一个元素，若队列为空，则返回 null；</li><li>element()：获取但不移除此队列的第一个元素，若队列为空，则抛异常。</li></ul><h4 id="3）Queue-使用实例"><a href="#3）Queue-使用实例" class="headerlink" title="3）Queue 使用实例"></a>3）Queue 使用实例</h4><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;String&gt; linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>linkedList.add(<span class="hljs-string">&quot;Dog&quot;</span>);<br>linkedList.add(<span class="hljs-string">&quot;Camel&quot;</span>);<br>linkedList.add(<span class="hljs-string">&quot;Cat&quot;</span>);<br><span class="hljs-keyword">while</span> (!linkedList.isEmpty()) &#123;<br>    System.out.println(linkedList.poll());<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行结果：</p><blockquote><p>Dog</p></blockquote><blockquote></blockquote><blockquote><p>Camel</p></blockquote><blockquote></blockquote><blockquote><p>Cat</p></blockquote><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><h4 id="1）BlockingQueue"><a href="#1）BlockingQueue" class="headerlink" title="1）BlockingQueue"></a>1）BlockingQueue</h4><p>BlockingQueue 在 java.util.concurrent 包下，其他阻塞类都实现自 BlockingQueue接口，BlockingQueue提供了线程安全的队列访问方式，当向队列中插入数据时，如果队列已满，线程则会阻塞等待队列中元素被取出后再插入；当从队列中取数据时，如果队列为空，则线程会阻塞等待队列中有新元素再获取。</p><p>BlockingQueue 核心方法</p><p>插入方法：</p><ul><li>add(E)：添加元素到队列尾部，成功返回 true，队列超出时抛出异常；</li><li>offer(E)：添加元素到队列尾部，成功返回 true，队列超出时返回 false ；</li><li>put(E)：将元素插入到队列的尾部，如果该队列已满，则一直阻塞。 删除方法：</li><li>remove(Object)：移除指定元素，成功返回 true，失败返回 false；</li><li>poll()： 获取并移除队列的第一个元素，如果队列为空，则返回 null；</li><li>take()：获取并移除队列第一个元素，如果没有元素则一直阻塞。 检查方法：</li><li>peek()：获取但不移除队列的第一个元素，若队列为空，则返回 null。</li></ul><h4 id="2）LinkedBlockingQueue"><a href="#2）LinkedBlockingQueue" class="headerlink" title="2）LinkedBlockingQueue"></a>2）LinkedBlockingQueue</h4><p>LinkedBlockingQueue 是一个由链表实现的有界阻塞队列，容量默认值为Integer.MAX_VALUE，也可以自定义容量，建议指定容量大小，默认大小在添加速度大于删除速度情况下有造成内存溢出的风险，LinkedBlockingQueue是先进先出的方式存储元素。</p><h4 id="3）ArrayBlockingQueue"><a href="#3）ArrayBlockingQueue" class="headerlink" title="3）ArrayBlockingQueue"></a>3）ArrayBlockingQueue</h4><p>ArrayBlockingQueue是一个有边界的阻塞队列，它的内部实现是一个数组。它的容量是有限的，我们必须在其初始化的时候指定它的容量大小，容量大小一旦指定就不可改变。</p><p>ArrayBlockingQueue 也是先进先出的方式存储数据，ArrayBlockingQueue 内部的阻塞队列是通过重入锁 ReenterLock和 Condition 条件队列实现的，因此 ArrayBlockingQueue中的元素存在公平访问与非公平访问的区别，对于公平访问队列，被阻塞的线程可以按照阻塞的先后顺序访问队列，即先阻塞的线程先访问队列。而非公平队列，当队列可用时，阻塞的线程将进入争夺访问资源的竞争中，也就是说谁先抢到谁就执行，没有固定的先后顺序。</p><p>示例代码如下：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认非公平阻塞队列</span><br><span class="hljs-type">ArrayBlockingQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>(<span class="hljs-number">6</span>);<br><span class="hljs-comment">// 公平阻塞队列</span><br><span class="hljs-type">ArrayBlockingQueue</span> <span class="hljs-variable">queue2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>(<span class="hljs-number">6</span>,<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// ArrayBlockingQueue 源码展示</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    <span class="hljs-built_in">this</span>(capacity, <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">boolean</span> fair)</span> &#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-built_in">this</span>.items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>    lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(fair);<br>    notEmpty = lock.newCondition();<br>    notFull =  lock.newCondition();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4）DelayQueue"><a href="#4）DelayQueue" class="headerlink" title="4）DelayQueue"></a>4）DelayQueue</h4><p>DelayQueue 是一个支持延时获取元素的无界阻塞队列，队列中的元素必须实现 Delayed接口，在创建元素时可以指定延迟时间，只有到达了延迟的时间之后，才能获取到该元素。</p><p>实现了 Delayed 接口必须重写两个方法 ，getDelay(TimeUnit) 和 compareTo(Delayed)，如下代码所示：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayElement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Delayed</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-comment">// 获取剩余时间</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> &#123;<br>            <span class="hljs-comment">// do something</span><br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-comment">// 队列里元素的排序依据</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed o)</span> &#123;<br>            <span class="hljs-comment">// do something</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>DelayQueue 使用的完整示例</strong> ，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">DelayQueue</span> <span class="hljs-variable">delayQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayQueue</span>();<br>        delayQueue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayElement</span>(<span class="hljs-number">1000</span>));<br>        delayQueue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayElement</span>(<span class="hljs-number">3000</span>));<br>        delayQueue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayElement</span>(<span class="hljs-number">5000</span>));<br>        System.out.println(<span class="hljs-string">&quot;开始时间：&quot;</span> +  DateFormat.getDateTimeInstance().format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));<br>        <span class="hljs-keyword">while</span> (!delayQueue.isEmpty())&#123;<br>            System.out.println(delayQueue.take());<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;结束时间：&quot;</span> +  DateFormat.getDateTimeInstance().format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayElement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Delayed</span> &#123;<br>        <span class="hljs-comment">// 延迟截止时间（单面：毫秒）</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">delayTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DelayElement</span><span class="hljs-params">(<span class="hljs-type">long</span> delayTime)</span> &#123;<br>            <span class="hljs-built_in">this</span>.delayTime = (<span class="hljs-built_in">this</span>.delayTime + delayTime);<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-comment">// 获取剩余时间</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> &#123;<br>            <span class="hljs-keyword">return</span> unit.convert(delayTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-comment">// 队列里元素的排序依据</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed o)</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS)) &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> DateFormat.getDateTimeInstance().format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(delayTime));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行结果：</p><blockquote><p>开始时间：2019-6-13 20:40:38</p></blockquote><blockquote></blockquote><blockquote><p>2019-6-13 20:40:39</p></blockquote><blockquote></blockquote><blockquote><p>2019-6-13 20:40:41</p></blockquote><blockquote></blockquote><blockquote><p>2019-6-13 20:40:43</p></blockquote><blockquote></blockquote><blockquote><p>结束时间：2019-6-13 20:40:43</p></blockquote><h3 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h3><p><strong>ConcurrentLinkedQueue</strong><br>是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部；当我们获取一个元素时，它会返回队列头部的元素。</p><p>它的入队和出队操作均利用 CAS（Compare And Set）更新，这样允许多个线程并发执行，并且不会因为加锁而阻塞线程，使得并发性能更好。</p><p>ConcurrentLinkedQueue 使用示例：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ConcurrentLinkedQueue</span> <span class="hljs-variable">concurrentLinkedQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>();<br>concurrentLinkedQueue.add(<span class="hljs-string">&quot;Dog&quot;</span>);<br>concurrentLinkedQueue.add(<span class="hljs-string">&quot;Cat&quot;</span>);<br><span class="hljs-keyword">while</span> (!concurrentLinkedQueue.isEmpty()) &#123;<br>    System.out.println(concurrentLinkedQueue.poll());<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><blockquote><p>Dog</p></blockquote><blockquote></blockquote><blockquote><p>Cat</p></blockquote><p>可以看出不管是阻塞队列还是非阻塞队列，使用方法都是类似的，区别是底层的实现方式。</p><h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p><strong>PriorityQueue</strong> 一个基于优先级堆的无界优先级队列。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator进行排序，具体取决于所使用的构造方法。优先级队列不允许使用 null 元素。</p><p><strong>PriorityQueue 代码使用示例</strong> ：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;Integer&gt; priorityQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>        <span class="hljs-comment">// 非自然排序，数字倒序</span><br>        <span class="hljs-keyword">return</span> o2 - o1;<br>    &#125;<br>&#125;);<br>priorityQueue.add(<span class="hljs-number">3</span>);<br>priorityQueue.add(<span class="hljs-number">1</span>);<br>priorityQueue.add(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">while</span> (!priorityQueue.isEmpty()) &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> priorityQueue.poll();<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行的结果是：</p><blockquote><p>3</p></blockquote><blockquote></blockquote><blockquote><p>2</p></blockquote><blockquote></blockquote><blockquote><p>1</p></blockquote><p><strong>PriorityQueue 注意的点</strong> ：</p><ul><li>PriorityQueue 是非线程安全的，在多线程情况下可使用 PriorityBlockingQueue 类替代；</li><li>PriorityQueue 不允许插入 null 元素。</li></ul><h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="1-ArrayBlockingQueue-和-LinkedBlockingQueue-的区别是什么？"><a href="#1-ArrayBlockingQueue-和-LinkedBlockingQueue-的区别是什么？" class="headerlink" title="1.ArrayBlockingQueue 和 LinkedBlockingQueue 的区别是什么？"></a>1.ArrayBlockingQueue 和 LinkedBlockingQueue 的区别是什么？</h4><p>答：ArrayBlockingQueue 和 LinkedBlockingQueue 都实现自阻塞队列BlockingQueue，它们的区别主要体现在以下几个方面：</p><ul><li>ArrayBlockingQueue 使用时必须指定容量值，LinkedBlockingQueue 可以不用指定；</li><li>ArrayBlockingQueue 的最大容量值是使用时指定的，并且指定之后就不允许修改；而 LinkedBlockingQueue 最大的容量为 Integer.MAX_VALUE；</li><li>ArrayBlockingQueue 数据存储容器是采用数组存储的；而 LinkedBlockingQueue 采用的是 Node 节点存储的。</li></ul><h4 id="2-LinkedList-中-add-和-offer-有什么关系？"><a href="#2-LinkedList-中-add-和-offer-有什么关系？" class="headerlink" title="2.LinkedList 中 add() 和 offer() 有什么关系？"></a>2.LinkedList 中 add() 和 offer() 有什么关系？</h4><p>答：add() 和 offer() 都是添加元素到队列尾部。offer 方法是基于 add 方法实现的，Offer 的源码如下：</p><p>​<br>    public boolean offer(E e) {<br>        return add(e);<br>    }</p><h4 id="3-Queue-和-Deque-有什么区别？"><a href="#3-Queue-和-Deque-有什么区别？" class="headerlink" title="3.Queue 和 Deque 有什么区别？"></a>3.Queue 和 Deque 有什么区别？</h4><p>答：Queue 属于一般队列，Deque 属于双端队列。一般队列是先进先出，也就是只有先进的才能先出；而双端队列则是两端都能插入和删除元素。</p><h4 id="4-LinkedList-属于一般队列还是双端队列？"><a href="#4-LinkedList-属于一般队列还是双端队列？" class="headerlink" title="4.LinkedList 属于一般队列还是双端队列？"></a>4.LinkedList 属于一般队列还是双端队列？</h4><p>答：LinkedList 实现了 Deque 属于双端队列，因此拥有 addFirst(E)、addLast(E)、getFirst()、getLast()等方法。</p><h4 id="5-以下说法错误的是？"><a href="#5-以下说法错误的是？" class="headerlink" title="5.以下说法错误的是？"></a>5.以下说法错误的是？</h4><p>A：DelayQueue 内部是基于 PriorityQueue 实现的<br>B：PriorityBlockingQueue 不是先进先出的数据存储方式<br>C：LinkedBlockingQueue 默认容量是无限大的<br>D：ArrayBlockingQueue 内部的存储单元是数组，初始化时必须指定队列容量</p><p>答：C</p><p>题目解析：LinkedBlockingQueue 默认容量是 Integer.MAX_VALUE，并不是无限大的。</p><h4 id="6-关于-ArrayBlockingQueue-说法不正确的是？"><a href="#6-关于-ArrayBlockingQueue-说法不正确的是？" class="headerlink" title="6.关于 ArrayBlockingQueue 说法不正确的是？"></a>6.关于 ArrayBlockingQueue 说法不正确的是？</h4><p>A：ArrayBlockingQueue 是线程安全的<br>B：ArrayBlockingQueue 元素允许为 null<br>C：ArrayBlockingQueue 主要应用场景是“生产者-消费者”模型<br>D：ArrayBlockingQueue 必须显示地设置容量</p><p>答：B</p><p>题目解析：ArrayBlockingQueue 不允许元素为 null，如果添加一个 null 元素，会抛 NullPointerException 异常。</p><h4 id="7-以下程序执行的结果是什么？"><a href="#7-以下程序执行的结果是什么？" class="headerlink" title="7.以下程序执行的结果是什么？"></a>7.以下程序执行的结果是什么？</h4><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">PriorityQueue</span> <span class="hljs-variable">priorityQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>();<br>priorityQueue.add(<span class="hljs-literal">null</span>);<br>System.out.println(priorityQueue.size());<br></code></pre></td></tr></table></figure><p>答：程序执行报错，PriorityQueue 不能插入 null。</p><h4 id="8-Java-中常见的阻塞队列有哪些？"><a href="#8-Java-中常见的阻塞队列有哪些？" class="headerlink" title="8.Java 中常见的阻塞队列有哪些？"></a>8.Java 中常见的阻塞队列有哪些？</h4><p>答：Java 中常见的阻塞队列如下：</p><ul><li>ArrayBlockingQueue，由数组结构组成的有界阻塞队列；</li><li>PriorityBlockingQueue，支持优先级排序的无界阻塞队列；</li><li>SynchronousQueue，是一个不存储元素的阻塞队列，会直接将任务交给消费者，必须等队列中的添加元素被消费后才能继续添加新的元素；</li><li>LinkedBlockingQueue，由链表结构组成的阻塞队列；</li><li>DelayQueue，支持延时获取元素的无界阻塞队列。</li></ul><h4 id="9-有界队列和无界队列有哪些区别？"><a href="#9-有界队列和无界队列有哪些区别？" class="headerlink" title="9.有界队列和无界队列有哪些区别？"></a>9.有界队列和无界队列有哪些区别？</h4><p>答：有界队列和无界队列的区别如下。</p><ul><li>有界队列：有固定大小的队列叫做有界队列，比如：new ArrayBlockingQueue(6)，6 就是队列的大小。</li><li>无界队列：指的是没有设置固定大小的队列，这些队列的特点是可以直接入列，直到溢出。它们并不是真的无界，它们最大值通常为 Integer.MAX_VALUE，只是平常很少能用到这么大的容量（超过 Integer.MAX_VALUE），因此从使用者的体验上，就相当于 “无界”。</li></ul><h4 id="10-如何手动实现一个延迟消息队列？"><a href="#10-如何手动实现一个延迟消息队列？" class="headerlink" title="10.如何手动实现一个延迟消息队列？"></a>10.如何手动实现一个延迟消息队列？</h4><p>答：说到延迟消息队列，我们应该可以第一时间想到要使用 DelayQueue延迟队列来解决这个问题。实现思路，消息队列分为生产者和消费者，生产者用于增加消息，消费者用于获取并消费消息，我们只需要生产者把消息放入到DelayQueue 队列并设置延迟时间，消费者循环使用 take() 阻塞获取消息即可。完整的实现代码如下：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomDelayQueue</span> &#123;<br>    <span class="hljs-comment">// 消息编号</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">MESSAGENO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        DelayQueue&lt;DelayedElement&gt; delayQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayQueue</span>&lt;&gt;();<br>        <span class="hljs-comment">// 生产者1</span><br>        producer(delayQueue, <span class="hljs-string">&quot;生产者1&quot;</span>);<br>        <span class="hljs-comment">// 生产者2</span><br>        producer(delayQueue, <span class="hljs-string">&quot;生产者2&quot;</span>);<br>        <span class="hljs-comment">// 消费者</span><br>        consumer(delayQueue);<br>    &#125;<br><br>    <span class="hljs-comment">//生产者</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">producer</span><span class="hljs-params">(DelayQueue&lt;DelayedElement&gt; delayQueue, String name)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-comment">// 产生 1~5 秒的随机数</span><br>                    <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000L</span> * (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">5</span>) + <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(time);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    <span class="hljs-comment">// 组合消息体</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s，消息编号：%s 发送时间：%s 延迟：%s 秒&quot;</span>,<br>                            name, MESSAGENO.getAndIncrement(), DateFormat.getDateTimeInstance().format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()), time / <span class="hljs-number">1000</span>);<br>                    <span class="hljs-comment">// 生产消息</span><br>                    delayQueue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedElement</span>(message, time));<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br><br>    <span class="hljs-comment">//消费者</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">(DelayQueue&lt;DelayedElement&gt; delayQueue)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-type">DelayedElement</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 消费消息</span><br>                        element = delayQueue.take();<br>                        System.out.println(element);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br><br>    <span class="hljs-comment">// 延迟队列对象</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayedElement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Delayed</span> &#123;<br>        <span class="hljs-comment">// 过期时间（单位：毫秒）</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">// 消息体</span><br>        String message;<br>        <span class="hljs-comment">// 参数：delayTime 延迟时间（单位毫秒）</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DelayedElement</span><span class="hljs-params">(String message, <span class="hljs-type">long</span> delayTime)</span> &#123;<br>            <span class="hljs-built_in">this</span>.time += delayTime;<br>            <span class="hljs-built_in">this</span>.message = message;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-comment">// 获取过期时间</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> &#123;<br>            <span class="hljs-keyword">return</span> unit.convert(time - System.currentTimeMillis(), TimeUnit.MILLISECONDS);<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-comment">// 队列元素排序</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed o)</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS))<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS))<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 打印消息</span><br>            <span class="hljs-keyword">return</span> message + <span class="hljs-string">&quot; |执行时间：&quot;</span> + DateFormat.getDateTimeInstance().format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上程序支持多生产者，执行的结果如下：</p><blockquote><p>生产者1，消息编号：1 发送时间：2019-6-12 20:38:37 延迟：2 秒 |执行时间：2019-6-12 20:38:39</p></blockquote><blockquote></blockquote><blockquote><p>生产者2，消息编号：2 发送时间：2019-6-12 20:38:37 延迟：2 秒 |执行时间：2019-6-12 20:38:39</p></blockquote><blockquote></blockquote><blockquote><p>生产者1，消息编号：3 发送时间：2019-6-12 20:38:41 延迟：4 秒 |执行时间：2019-6-12 20:38:45</p></blockquote><blockquote></blockquote><blockquote><p>生产者1，消息编号：5 发送时间：2019-6-12 20:38:43 延迟：2 秒 |执行时间：2019-6-12 20:38:45</p></blockquote><blockquote></blockquote><blockquote><p>……</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>队列（Queue）按照是否阻塞可分为：阻塞队列 BlockingQueue 和 非阻塞队列。其中，双端队列 Deque也属于非阻塞队列，双端队列除了拥有队列的先进先出的方法之外，还拥有自己独有的方法，如addFirst()、addLast()、getFirst()、getLast() 等，支持首未插入和删除元素。</p><p>队列中比较常用的两个队列还有PriorityQueue（优先级队列）和DelayQueue（延迟队列），可使用延迟队列来实现延迟消息队列，这也是面试中比较常考的问题之一。需要面试朋友对延迟队列一定要做到心中有数，动手写一个消息队列也是非常有必要的。</p><blockquote><p>[点击此处下载本文源码](<a href="https://github.com/vipstone/java-">https://github.com/vipstone/java-</a><br>interview/tree/master/interview-code/src/main/java/com/interview)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java面试全解析核心知识点与典型面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>win10终端设置代理</title>
    <link href="/2022/06/06/windows/win10%E7%BB%88%E7%AB%AF%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
    <url>/2022/06/06/windows/win10%E7%BB%88%E7%AB%AF%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="走代理前"><a href="#走代理前" class="headerlink" title="走代理前"></a>走代理前</h3><p><img src="1.png"></p><h3 id="走代理后"><a href="#走代理后" class="headerlink" title="走代理后"></a>走代理后</h3><p><img src="2.png"></p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p><em>窗口一旦关闭,代理会失效,如需长期使用则考虑配置环境变量</em></p><h4 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> <span class="hljs-attribute">http_proxy</span>=http://172.16.11.39:7890<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">https_proxy</span>=http://172.16.11.39:7890<br></code></pre></td></tr></table></figure><h4 id="powershell"><a href="#powershell" class="headerlink" title="powershell"></a>powershell</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">Env:http_proxy=<span class="hljs-string">&quot;http://127.0.0.1:7890&quot;</span>;<span class="hljs-variable">$Env</span>:https_proxy=<span class="hljs-string">&quot;http://127.0.0.1:7890&quot;</span></span><br><br></code></pre></td></tr></table></figure><h4 id="git-bash"><a href="#git-bash" class="headerlink" title="git bash"></a>git bash</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export http_proxy=http://172.16.11.39:7890<br>export https_proxy=http://172.16.11.39:7890<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代理</tag>
      
      <tag>windows</tag>
      
      <tag>命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Oh My Posh插件美化PowerShell</title>
    <link href="/2022/06/04/%E4%BD%BF%E7%94%A8Oh%20My%20Posh%E6%8F%92%E4%BB%B6%E7%BE%8E%E5%8C%96PowerShell/"/>
    <url>/2022/06/04/%E4%BD%BF%E7%94%A8Oh%20My%20Posh%E6%8F%92%E4%BB%B6%E7%BE%8E%E5%8C%96PowerShell/</url>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>PowerShell 输入以下命令进行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">winget install oh-my-posh<br></code></pre></td></tr></table></figure><h4 id="设置自动启动初始化oh-my-posh"><a href="#设置自动启动初始化oh-my-posh" class="headerlink" title="设置自动启动初始化oh-my-posh"></a>设置自动启动初始化oh-my-posh</h4><p>安装完成后，为了使每次启动PowerShell后自动初始化oh-my-posh,继续在当前命令输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">notepad <span class="hljs-variable">$Profile</span><br></code></pre></td></tr></table></figure><p>添加以下内容至打开的记事本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">oh-my-posh init pwsh --config <span class="hljs-string">&quot;<span class="hljs-variable">$env</span>:POSH_THEMES_PATH\jandedobbeleer.omp.json&quot;</span> | Invoke-Expression<br></code></pre></td></tr></table></figure><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>输入以下命令查看主题列表:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Get-PoshThemes<br></code></pre></td></tr></table></figure><p>在PowerShell终端下使用 notepad $Profile 命令打开记事本,修改完主题名称后<br>继续在当前目录 执行 .$Profile 命令 使之生效<br><img src="2.png"></p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><h4 id="ZLocation"><a href="#ZLocation" class="headerlink" title="ZLocation"></a>ZLocation</h4><p>使用ZLocation命令可以用关键字直接跳到想去的資料夾,比使用 cd 更快速</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Install-Module ZLocation -Scope CurrentUser<br></code></pre></td></tr></table></figure><h4 id="PSReadLine"><a href="#PSReadLine" class="headerlink" title="PSReadLine"></a>PSReadLine</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Install-Module PSReadLine<br></code></pre></td></tr></table></figure><h4 id="TERMINAL-ICONS"><a href="#TERMINAL-ICONS" class="headerlink" title="TERMINAL-ICONS"></a>TERMINAL-ICONS</h4><p>使输出的目录或文件带颜色</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Install-Module -Name Terminal-Icons -Repository PSGallery<br></code></pre></td></tr></table></figure><p>安装完以上插件后修改配置文件使之生效:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Set-PSReadLineOption -PredictionSource History # 设置预测文本来源为历史记录<br><br>Import-Module -Name Terminal-Icons<br><br>Import-Module ZLocation<br></code></pre></td></tr></table></figure><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="1-PowerShell显示图标会乱码"><a href="#1-PowerShell显示图标会乱码" class="headerlink" title="1.PowerShell显示图标会乱码"></a>1.PowerShell显示图标会乱码</h4><p>安裝Patched字体</p><ul><li><a href="https://github.com/romkatv/dotfiles-public/raw/master/.local/share/fonts/NerdFonts/MesloLGS%20NF%20Regular.ttf">MesloLGS NF Regular.ttf</a></li><li><a href="https://github.com/romkatv/dotfiles-public/raw/master/.local/share/fonts/NerdFonts/MesloLGS%20NF%20Bold.ttf">MesloLGS NF Bold.ttf</a></li><li><a href="https://github.com/romkatv/dotfiles-public/raw/master/.local/share/fonts/NerdFonts/MesloLGS%20NF%20Italic.ttf">MesloLGS NF Italic.ttf</a></li><li><a href="https://github.com/romkatv/dotfiles-public/raw/master/.local/share/fonts/NerdFonts/MesloLGS%20NF%20Bold%20Italic.ttf">MesloLGS NF Bold Italic.ttf</a></li></ul><p>修改PowerShell的字体为刚安装的字体(MesloLGS NF),使字体生效<br><img src="1.png"></p><h4 id="2-出现以下信息显示模块安装的oh-my-posh不再支持"><a href="#2-出现以下信息显示模块安装的oh-my-posh不再支持" class="headerlink" title="2.出现以下信息显示模块安装的oh-my-posh不再支持"></a>2.出现以下信息显示模块安装的oh-my-posh不再支持</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">Hey friend<br>In an effort to grow oh-my-posh, the decision was made to no<br>longer support the PowerShell module. Over the past year, the<br>added benefit of the module disappeared, while the burden of<br>maintaining it increased.<br>However, this doesn&#x27;t mean oh-my-posh disappears from your<br>terminal, it just means that you&#x27;ll have to use a different<br>tool to install it.<br>All you need to do, is follow the migration guide here:<br>https://ohmyposh.dev/docs/migrating<br></code></pre></td></tr></table></figure><p>表示你过去是用 Install-Module 的方式安裝 Oh My Posh<br>根据迁移建议，彻底卸载，然后使用官方建议安装方式安装<br>卸载命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Uninstall-Module oh-my-posh -AllVersions<br></code></pre></td></tr></table></figure><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://ohmyposh.dev/docs/installation/windows">Install Oh My Posh on Windows</a></li><li><a href="https://www.kwchang0831.dev/dev-env/pwsh/oh-my-posh">安裝新版 Oh My Posh 與插件來美化 PowerShell</a></li><li><a href="https://www.hanselman.com/blog/my-ultimate-powershell-prompt-with-oh-my-posh-and-the-windows-terminal">My Ultimate PowerShell prompt with Oh My Posh and the Windows Terminal</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Posh</tag>
      
      <tag>PowerShell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s重启pod方式</title>
    <link href="/2022/06/04/k8s/k8s%E9%87%8D%E5%90%AFpod%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/06/04/k8s/k8s%E9%87%8D%E5%90%AFpod%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="Rolling-Restart-Method"><a href="#Rolling-Restart-Method" class="headerlink" title="Rolling Restart Method"></a>Rolling Restart Method</h3><p>Kubernetes now allows you to execute a rolling restart of your deployment as of version 1.15. This is the quickest restart mechanism in Kubernetes, as it is a new addition. The command given above shuts down and restarts each container in your deployment one by one. Because most of the containers are still functioning, your app will be accessible.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl rollout restart deployment nginx-deploy<br></code></pre></td></tr></table></figure><h3 id="Environment-Variable-Method"><a href="#Environment-Variable-Method" class="headerlink" title="Environment Variable Method"></a>Environment Variable Method</h3><p>Another option is to force pods to restart and sync with your changes by setting or changing an environment variable. You can, for instance, alter the date of container deployment:</p><p>In the scenario above, set env modifies the environment variables, deployment [deployment name] selects your deployment, and DEPLOY DATE=”$(date)” modifies the deployment date and causes the pod to resume.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl set env deployment nginx-deploy DEPLOY_DATE=&quot;$(date)&quot;<br></code></pre></td></tr></table></figure><h3 id="Scale-Command-to-Change-Replicas"><a href="#Scale-Command-to-Change-Replicas" class="headerlink" title="Scale Command to Change Replicas"></a>Scale Command to Change Replicas</h3><p>You can modify the number of clones of the defective pod by using the scale command. When you set this value to 0, the pod is effectively turned off:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl scale --replicas=0 deployment nginx-deploy<br></code></pre></td></tr></table></figure><p>To restart the pod, provide the following command with a number of replicas greater than zero:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl scale --replicas=N deployment nginx-deploy<br></code></pre></td></tr></table></figure><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://linuxhint.com/kubectl-rollout-restart/">What is Kubectl Rollout Restart?</a></li><li><a href="https://vqiu.cn/kubectl-rollout-restart/">如何使用Kubectl 滚动重启应用</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>pod</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BeanFactory</title>
    <link href="/2022/06/03/spring/BeanFactory/"/>
    <url>/2022/06/03/spring/BeanFactory/</url>
    
    <content type="html"><![CDATA[<p><img src="beanFactory.png"></p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>BeanFactory interface provides a simple, yet flexible configuration mechanism to manage objects of any nature via the Spring IoC container.</p><h3 id="The-BeanFactory-Interface"><a href="#The-BeanFactory-Interface" class="headerlink" title="The BeanFactory Interface"></a>The BeanFactory Interface</h3><p>It’s interesting to start by having a look at the <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-beans/src/main/java/org/springframework/beans/factory/BeanFactory.java">interface definition</a> in org.springframework.beans.factory package and discuss some of its important APIs here.</p><h4 id="The-getBean-APIs"><a href="#The-getBean-APIs" class="headerlink" title="The getBean() APIs"></a>The getBean() APIs</h4><p>Various versions of <a href="https://docs.spring.io/spring-framework/docs/5.0.x/javadoc-api/org/springframework/beans/factory/BeanFactory.html#getBean-java.lang.String-">getBean()</a> method return an instance of the specified bean, which may be shared or independent across the application.</p><h4 id="The-containsBean-API"><a href="#The-containsBean-API" class="headerlink" title="The containsBean() API"></a>The containsBean() API</h4><p>This method confirms if this bean factory contains a bean with the given name. More specifically, it confirms if the <a href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/beans/factory/BeanFactory.html#getBean-java.lang.String-">getBean(java.lang.String)</a> able to obtain a bean instance with the given name.</p><h4 id="The-isSingleton-API"><a href="#The-isSingleton-API" class="headerlink" title="The isSingleton() API"></a>The isSingleton() API</h4><p>The isSingleton API can be used to query if this bean is a shared singleton. That is if <a href="https://docs.spring.io/spring-framework/docs/5.0.x/javadoc-api/org/springframework/beans/factory/BeanFactory.html#getBean-java.lang.String-">getBean(java.lang.String)</a> will always return the same instance.</p><h4 id="The-isPrototype-API"><a href="#The-isPrototype-API" class="headerlink" title="The isPrototype() API"></a>The isPrototype() API</h4><p>This API will confirm if <a href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/beans/factory/BeanFactory.html#getBean-java.lang.String-">getBean(java.lang.String)</a> returns independent instances – meaning a bean configured with the prototype scope, or not.</p><p>The important thing to note is this method returning false does not clearly indicate a singleton object. It indicates non-independent instances, which may correspond to other scopes as well.</p><p>We need to use the <a href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/beans/factory/BeanFactory.html#isSingleton-java.lang.String-">isSingleton(java.lang.String)</a> operation to explicitly check for a shared singleton instance.</p><h4 id="Other-APIs"><a href="#Other-APIs" class="headerlink" title="Other APIs"></a>Other APIs</h4><p>While the isTypeMatch(String name, Class targetType) method checks whether the bean with the given name matches the specified type, getType(String name) is useful in identifying the type of the bean with the given name.</p><p>Finally, getAliases(String name) return the aliases for the given bean name, if any.</p><h3 id="BeanFactory-API"><a href="#BeanFactory-API" class="headerlink" title="BeanFactory API"></a>BeanFactory API</h3><p>BeanFactory holds bean definitions and instantiates them whenever asked for by the client application – which means:</p><ul><li>It takes care of the lifecycle of a bean by instantiating it and calling appropriate destruction methods</li><li>It is capable of creating associations between dependent object while instantiating them</li><li>It is important to point that BeanFactory does not support the Annotation-based dependency Injection whereas ApplicationContext, a superset of BeanFactory does</li></ul><p>Do have a read on <a href="https://docs.spring.io/spring-framework/docs/3.0.0.M3/reference/html/ch04s08.html">Application Context</a> to find out what it can do extra.</p><h3 id="Defining-the-Bean"><a href="#Defining-the-Bean" class="headerlink" title="Defining the Bean"></a>Defining the Bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-comment">// standard constructors, getters and setters</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Configuring-the-BeanFactory-with-XML"><a href="#Configuring-the-BeanFactory-with-XML" class="headerlink" title="Configuring the BeanFactory with XML"></a>Configuring the BeanFactory with XML</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;employee&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baeldung.beanfactory.Employee&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Hello! My name is Java&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <br><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;employee&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;empalias&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="BeanFactory-with-ClassPathResource"><a href="#BeanFactory-with-ClassPathResource" class="headerlink" title="BeanFactory with ClassPathResource"></a>BeanFactory with ClassPathResource</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanFactoryWithClassPathResourceTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createBeanFactoryAndCheckEmployeeBean</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Resource</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;beanfactory-example.xml&quot;</span>);<br>        <span class="hljs-type">BeanFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanFactory</span>(res);<br>        <span class="hljs-type">Employee</span> <span class="hljs-variable">emp</span> <span class="hljs-operator">=</span> (Employee) factory.getBean(<span class="hljs-string">&quot;employee&quot;</span>);<br><br>        assertTrue(factory.isSingleton(<span class="hljs-string">&quot;employee&quot;</span>));<br>        assertTrue(factory.getBean(<span class="hljs-string">&quot;employee&quot;</span>) <span class="hljs-keyword">instanceof</span> Employee);<br>        assertTrue(factory.isTypeMatch(<span class="hljs-string">&quot;employee&quot;</span>, Employee.class));<br>        assertTrue(factory.getAliases(<span class="hljs-string">&quot;employee&quot;</span>).length &gt; <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul><li><a href="https://www.baeldung.com/spring-beanfactory">Guide to the Spring BeanFactory</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>BeanFactory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git高阶用法</title>
    <link href="/2022/06/02/git/git%E9%AB%98%E9%98%B6%E7%94%A8%E6%B3%95/"/>
    <url>/2022/06/02/git/git%E9%AB%98%E9%98%B6%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="1.jpg"></p><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><h4 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能:"></a>常用功能:</h4><ul><li>从上游分支获取最新commit信息，并有机的将当前分支和上游分支进行合并</li><li>对当前分支的历史commit进行修改，合并，删除等操作</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>你的分支和master冲突<ul><li>如果你git merge master就会留下一个merge的commit。在这种情况下，我们推荐使用git rebase master，就能不留commit将当前分支和master有机的合并。</li></ul></li><li>之前某次提交，改错了一个变量<ul><li>如果你修改那个变量然后再提交一个commit，这显然不是最优的。如果能将某次的提交挑出来修改就好了。</li><li>当然git提供了这个功能，你可以使用git rebase -i [git-hash| head~n],其中git-hash是你要开始进行rebase的commit的hash，而head~n则是从HEAD向前推n个commit.</li></ul></li></ul><h3 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h3><h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><p>暂存当前没有提交的更改</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">save</span> <span class="hljs-string">保存当前更改</span><br><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">保存当前更改</span><br><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">pop</span> <span class="hljs-string">推出之前stash的内容更改</span><br><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">apply</span> <span class="hljs-string">推出之前stash的内容更改</span><br><br><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">save</span> <span class="hljs-string">--keep-index</span> <span class="hljs-string">只stash没有被add的内容</span><br><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">save</span> <span class="hljs-string">--include-untracked</span> <span class="hljs-string">stash还未加入git记录的文件</span><br><br><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">list</span> <span class="hljs-string">--stat</span> <span class="hljs-string">显示stash堆栈</span><br><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">show</span> <span class="hljs-string">stash@&#123;0&#125;</span> <span class="hljs-string">显示第x次的更改</span><br><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">show</span> <span class="hljs-string">显示最近一次stash的更改</span><br><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">show</span> <span class="hljs-string">--patch</span> <span class="hljs-string">显示最近一次stash的详细更改</span><br><br><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">save</span> <span class="hljs-string">&quot;stash msg&quot;</span><br><br><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">branch</span> <span class="hljs-string">new_brach</span> <span class="hljs-string">stash@&#123;0&#125;</span><br></code></pre></td></tr></table></figure><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>当做了更改之后没有编辑完，这个时候发现线上有个bug，你需要停下当前分支去修bug，这个时候你可以提一个commit到当前分支，或则使用git stash</p><h3 id="filter-branch"><a href="#filter-branch" class="headerlink" title="filter-branch"></a>filter-branch</h3><h4 id="主要功能-1"><a href="#主要功能-1" class="headerlink" title="主要功能"></a>主要功能</h4><p>过滤所有提交记录，进行相应的操作</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">git</span> <span class="hljs-string">filter-branch</span> <span class="hljs-string">--tree-filter</span> <span class="hljs-string">&#x27;rm -rf .vscode&#x27;</span> <span class="hljs-string">删除所有分支的.vscode文件夹</span><br><span class="hljs-string">git</span> <span class="hljs-string">filter-branch</span> <span class="hljs-string">--tree-filter</span> <span class="hljs-string">&#x27;rm -f xxx&#x27;</span> <span class="hljs-string">xxx不存在，不报错</span><br><span class="hljs-string">git</span> <span class="hljs-string">filter-branch</span> <span class="hljs-string">--tree-filter</span> <span class="hljs-string">&#x27;rm -rf .vscoe&#x27;</span> <span class="hljs-string">--</span> <span class="hljs-string">--all(所有分支所有提交)</span><br><br><span class="hljs-string">git</span> <span class="hljs-string">filter-branch</span> <span class="hljs-string">--index-filter</span> <span class="hljs-string">&#x27;git rm --cached --ignore-unmatch password.txt&#x27;</span> <span class="hljs-string">(只检查password.txt</span> <span class="hljs-string">一个文件)</span><br><span class="hljs-string">git</span> <span class="hljs-string">filter-branch</span> <span class="hljs-string">-f</span> <span class="hljs-string">--prune-empty</span> <span class="hljs-string">--</span> <span class="hljs-string">--all</span><br></code></pre></td></tr></table></figure><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>当发现你错误的将一个不应该提交的文件提交，然后已经过了很久，已经累计了无数次提交。<br>这个时候就可以使用git filter-branch将所有提交全部过滤一遍删除掉那个不应该提交的文件</p><h3 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h3><h4 id="主要功能-2"><a href="#主要功能-2" class="headerlink" title="主要功能"></a>主要功能</h4><p>从任何分支，抽取提交到当前分支</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">git</span> <span class="hljs-string">cherry-pick</span> <span class="hljs-string">git-hash</span> <br><br><span class="hljs-string">git</span> <span class="hljs-string">cherry-pick</span> <span class="hljs-string">--edit</span> <span class="hljs-string">git-hash</span><br><br><span class="hljs-string">pick</span> <span class="hljs-string">多个</span><br><span class="hljs-string">git</span> <span class="hljs-string">cherry-pick</span> <span class="hljs-string">--no-commit</span> <span class="hljs-string">git-hash</span> <span class="hljs-string">git-hash</span><br><br><span class="hljs-string">git</span> <span class="hljs-string">cherry-pick</span> <span class="hljs-string">-x</span> <span class="hljs-string">git-hash</span> <span class="hljs-string">(添加cherry</span> <span class="hljs-string">pick</span> <span class="hljs-string">from</span> <span class="hljs-string">那个branch)</span><br><span class="hljs-string">git</span> <span class="hljs-string">cherry-pick</span> <span class="hljs-string">--signoff</span> <span class="hljs-string">git-hash不修改author</span><br></code></pre></td></tr></table></figure><h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><p>当需要将多个分支上的提交合在一个分支合并到master的时候，显然如果这3个分支有关联，一次合并更为合理。<br>这个时候就可以使用git cherry-pick进行精细化的commit的操作。</p><h3 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h3><p>☐ submodule<br>☐ reflog </p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="http://hiluluke.cn/2017/07/23/git-senior/">git 高阶用法</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker网络模式</title>
    <link href="/2022/06/02/docker/docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/06/02/docker/docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="Bridge模式"><a href="#Bridge模式" class="headerlink" title="Bridge模式"></a>Bridge模式</h3><p>当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。<br>虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。<br>从docker0子网中分配一个 IP 给容器使用，并设置 docker0 的 IP 地址为容器的默认网关。<br>在主机上创建一对虚拟网卡veth pair设备，Docker 将 veth pair 设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到 docker0 网桥中。<br>bridge模式是 docker 的默认网络模式，不写–net参数，就是bridge模式。使用docker run -p时，docker 实际是在iptables做了DNAT规则，实现端口转发功能。</p><p>bridge模式如下图所示：<br><img src="1.png"></p><h3 id="Host-模式"><a href="#Host-模式" class="headerlink" title="Host 模式"></a>Host 模式</h3><p>如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个 Network Namespace。<br>容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p><p>Host模式如下图所示：<br><img src="2.png"></p><h3 id="Container-模式"><a href="#Container-模式" class="headerlink" title="Container 模式"></a>Container 模式</h3><p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p><p>Container模式示意图：<br><img src="3.png"></p><h3 id="None模式"><a href="#None模式" class="headerlink" title="None模式"></a>None模式</h3><p>使用none模式，Docker 容器拥有自己的 Network Namespace，但是，并不为Docker 容器进行任何网络配置。也就是说，这个 Docker 容器没有网卡、IP、路由等信息。需要我们自己为 Docker 容器添加网卡、配置 IP 等。</p><p>None模式示意图:<br><img src="4.png"></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.qikqiak.com/k8s-book/docs/7.Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F.html">Docker 的网络模式</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker网络</tag>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql索引</title>
    <link href="/2022/06/01/mysql/mysql%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/06/01/mysql/mysql%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>通过使用索引(非主键索引)查询到数据后,仍需通过主键id在主键索引上查询数据的过程,称为回表</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>通过使用索引(非主键索引)查询到数据后,不需通过主键id在主键索引上查询数据,索引已经“覆盖了”我们的查询需求,我们称为覆盖索引<br><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段</strong></p><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>按照最左匹配原则进行判断是否使用索引<br>创建索引（name）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">select * from user where name like &#x27;张%&#x27;; # 使用索引<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">select * from user where name like &#x27;%张&#x27;; # 未使用索引<br></code></pre></td></tr></table></figure><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>创建联合索引（name, age）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">select * from user where name like &#x27;张%&#x27; and age=10 and isMale=1;<br></code></pre></td></tr></table></figure><p>在 MySQL 5.6 之前，待找到第一个符合张前缀的用户后开始一个个回表。到主键索引上找出数据行，再对比字段值<br><img src="1.jpg"><br>而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数<br><img src="2.jpg"></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>MySQL实战45讲</li><li><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualizations</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mockito 指南</title>
    <link href="/2022/05/31/Mockito-%E6%8C%87%E5%8D%97/"/>
    <url>/2022/05/31/Mockito-%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>Mockito 是一个模拟测试框架，主要功能是在单元测试中模拟类/对象的行为。</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://www.letianbiji.com/java-mockito/">Mockito 指南</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mockito</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
