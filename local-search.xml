<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Developing Apps With GPT-4 and ChatGPT</title>
    <link href="/2024/03/12/book/Developing%20Apps%20With%20GPT-4%20and%20ChatGPT/"/>
    <url>/2024/03/12/book/Developing%20Apps%20With%20GPT-4%20and%20ChatGPT/</url>
    
    <content type="html"><![CDATA[<h2 id="Cover-picture"><a href="#Cover-picture" class="headerlink" title="Cover picture"></a>Cover picture</h2><p><img src="img.png"></p><h2 id="Preview"><a href="#Preview" class="headerlink" title="Preview"></a>Preview</h2><div class="row">    <embed src="DevelopingAppsWithGpt-4andChatGPT.pdf" width="100%" height="550" type="application/pdf"></div><p>This minibook is a comprehensive guide for Python developers who want to learn how to build applications with large language models. Authors Olivier Caelen and Marie-Alice Blete cover the main features and benefits of GPT-4 and ChatGPT and explain how they work. You’ll also get a step-by-step guide for developing applications using the GPT-4 and ChatGPT Python library, including text generation, Q&amp;A, and content summarization tools.</p><p>Written in clear and concise language, Developing Apps with GPT-4 and ChatGPT includes easy-to-follow examples to help you understand and apply the concepts to your projects. Python code examples are available in a GitHub repository, and the book includes a glossary of key terms. Ready to harness the power of large language models in your applications? This book is a must.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.amazon.com/Developing-Apps-GPT-4-ChatGPT-Intelligent/dp/1098152484">amazon</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GPT</tag>
      
      <tag>ChatGPT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL中的schemas介绍</title>
    <link href="/2024/02/28/postgresql/PostgreSQL%E4%B8%AD%E7%9A%84schemas%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/02/28/postgresql/PostgreSQL%E4%B8%AD%E7%9A%84schemas%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>在 PostgreSQL 中，information_schema、pg_catalog、pg_toast 和 public 是预定义的特殊 schemas，每个都有其特定用途：</p><h2 id="information-schema"><a href="#information-schema" class="headerlink" title="information_schema:"></a>information_schema:</h2><ul><li>这个 schema 是标准的 SQL schema，它提供关于数据库元数据的信息，比如表、列、数据类型和视图等。</li><li>通过查询 information_schema 中的视图，可以获取数据库对象的结构化信息。</li><li>例如，你可以查询 information_schema.tables 来获取关于数据库表的信息。</li></ul><h2 id="pg-catalog"><a href="#pg-catalog" class="headerlink" title="pg_catalog:"></a>pg_catalog:</h2><ul><li>pg_catalog 是 PostgreSQL 的系统目录，包含了所有系统表和视图，存储着 PostgreSQL 内部对象的信息，如数据类型、函数、索引等。</li><li>可以查询 pg_catalog 来获取底层的系统信息。开发者和管理员通常会使用这个 schema 来进行故障排除和性能优化。</li></ul><h2 id="pg-toast"><a href="#pg-toast" class="headerlink" title="pg_toast:"></a>pg_toast:</h2><ul><li>pg_toast 用来存储“超大对象”，对于一些数据行过长无法存储在常规数据页中的情况，这些数据会被压缩并存储在 pg_toast schema 中的特殊表里。</li><li>一般情况下，普通用户不需要直接与 pg_toast schema 交互，因为 PostgreSQL 会自动处理与 TOAST 相关的操作。</li></ul><h2 id="public"><a href="#public" class="headerlink" title="public:"></a>public:</h2><ul><li>public schema 是 PostgreSQL 中默认的 schema，当创建新表或其他对象而没有指定具体的 schema 时，它们通常会被创建在 public schema 里。</li><li>这相当于数据库的“共享空间”，任何用户（除非受到权限限制）都可以在此创建或访问对象。</li><li>如果没有特定的权限设置，新用户默认可以访问 public schema。</li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PostgreSQL</tag>
      
      <tag>schema</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux笔记本关闭合上盖子自动休眠</title>
    <link href="/2024/02/23/linux/linux%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%85%B3%E9%97%AD%E5%90%88%E4%B8%8A%E7%9B%96%E5%AD%90%E8%87%AA%E5%8A%A8%E4%BC%91%E7%9C%A0/"/>
    <url>/2024/02/23/linux/linux%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%85%B3%E9%97%AD%E5%90%88%E4%B8%8A%E7%9B%96%E5%AD%90%E8%87%AA%E5%8A%A8%E4%BC%91%E7%9C%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="编辑配置文件"><a href="#编辑配置文件" class="headerlink" title="编辑配置文件"></a>编辑配置文件</h1><pre><code class="hljs">sudo vim /etc/systemd/logind.conf</code></pre><p>将其中的：<br>#HandleLidSwitch=suspend<br>取消注释，并修改为 ignore，如下：<br>HandleLidSwitch=ignore</p><h1 id="重启-login-服务"><a href="#重启-login-服务" class="headerlink" title="重启 login 服务"></a>重启 login 服务</h1><p>   sudo systemctl restart systemd-logind</p>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssh</tag>
      
      <tag>linux笔记本</tag>
      
      <tag>自动休眠</tag>
      
      <tag>休眠</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式概念和七大原则</title>
    <link href="/2024/02/21/design-patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E5%BF%B5%E5%92%8C%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <url>/2024/02/21/design-patterns/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E5%BF%B5%E5%92%8C%E4%B8%83%E5%A4%A7%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><p>在GoF(Gang of Four)的书籍《Design Patterns - Elements of Reusable Object-Oriented Software(设计模式-可复用面向对象软件的基础)》中是这样定义设计模式的：Christopher Alexander说过：“每一个模式描述了一个在我们周围不断重复发生的问题以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动” [AIS+77，第10页]。尽管Alexander所指的是城市和建筑模式，但他的思想也同样适用于面向对象设计模式，只是在面向对象的解决方案里， 我们用对象和接口代替了墙壁和门窗。两类模式的核心都在于提供了相关问题的解决方案。一般而言，设计模式有四个基本要素：</p><ol><li> 模式名称(pattern name)：一个助记名，它用一两个词来描述模式的问题、解决方案和效果。</li><li> 问题(problem)：描述了应该在何时使用模式。</li><li> 解决方案(solution)：描述了设计的组成成分，它们之间的相关关系以及各自的职责和协作方案。</li><li> 效果(consequences)：描述了模式应用的效果以及使用模式应该权衡的问题。</li></ol><p>设计模式的创始人很明确地指出了设计模式的基本要素，但是由于现实中浮躁、偏向过度设计等因素的干扰，开发者很多时候会重点关注第1和第3点要素(过度关注设计模式和设计模式的实现)，忽略第2和第4点要素(忽视使用设计模式的场景和目标)，导致设计出来的编码逻辑可能过于复杂或者达不到预期的效果。</p><p>总的来说，设计模式(Design Pattern)是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。也就是本来并不存在所谓设计模式，用的人多了，也便成了设计模式。</p><h3 id="设计模式的七大原则"><a href="#设计模式的七大原则" class="headerlink" title="设计模式的七大原则"></a>设计模式的七大原则</h3><p>面向对象的设计模式有七大基本原则：</p><ul><li>  开闭原则（Open Closed Principle，OCP）</li><li>  单一职责原则（Single Responsibility Principle, SRP）</li><li>  里氏代换原则（Liskov Substitution Principle，LSP）</li><li>  依赖倒转原则（Dependency Inversion Principle，DIP）</li><li>  接口隔离原则（Interface Segregation Principle，ISP）</li><li>  合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）</li><li>  最少知识原则（Least Knowledge Principle，LKP）或者迪米特法则（Law of Demeter，LOD）</li></ul><hr><table><thead><tr><th>标记</th><th>设计模式原则名称</th><th>简单定义</th></tr></thead><tbody><tr><td>OCP</td><td>开闭原则</td><td>对扩展开放，对修改关闭</td></tr><tr><td>SRP</td><td>单一职责原则</td><td>一个类只负责一个功能领域中的相应职责</td></tr><tr><td>LSP</td><td>里氏代换原则</td><td>所有引用基类的地方必须能透明地使用其子类的对象</td></tr><tr><td>DIP</td><td>依赖倒转原则</td><td>依赖于抽象，不能依赖于具体实现</td></tr><tr><td>ISP</td><td>接口隔离原则</td><td>类之间的依赖关系应该建立在最小的接口上</td></tr><tr><td>CARP</td><td>合成/聚合复用原则</td><td>尽量使用合成/聚合，而不是通过继承达到复用的目的</td></tr><tr><td>LOD</td><td>迪米特法则</td><td>一个软件实体应当尽可能少的与其他实体发生相互作用</td></tr></tbody></table><p>其中，单一职责原则、开闭原则、迪米特法则、里氏代换原则和接口隔离原则就是我们平常熟知的<strong>SOLID</strong>。</p><p>这个表格看起来有点抽象，下面逐条分析。</p><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p>开闭原则（Open Closed Principle，OCP）的定义是：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。模块应尽量在不修改原（是”原”，指原来的代码）代码的情况下进行扩展。</p><h4 id="开闭原则的意义"><a href="#开闭原则的意义" class="headerlink" title="开闭原则的意义"></a>开闭原则的意义</h4><p>在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p><h4 id="如何实现对扩展开放，对修改关闭"><a href="#如何实现对扩展开放，对修改关闭" class="headerlink" title="如何实现对扩展开放，对修改关闭"></a>如何实现对扩展开放，对修改关闭</h4><p>要实现对扩展开放，对修改关闭，即遵循开闭原则，需要对系统进行抽象化设计，抽象可以基于抽象类或者接口。一般来说需要做到几点：</p><ol><li> 通过接口或者抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法，也就是扩展必须添加具体实现而不是改变具体的方法。</li><li> 参数类型、引用对象尽量使用接口或者抽象类，而不是实现类，这样就能尽量保证抽象层是稳定的。</li><li> 一般抽象模块设计完成(例如接口的方法已经敲定)，不允许修改接口或者抽象方法的定义。</li></ol><p>下面通过一个例子遵循开闭原则进行设计，场景是这样：某系统的后台需要监测业务数据展示图表，如柱状图、折线图等，在未来需要支持图表的着色操作。在开始设计的时候，代码可能是这样的：</p><pre><code class="hljs">public class BarChart &#123;    public void draw()&#123;        System.out.println(&quot;Draw bar chart...&quot;);    &#125;&#125;public class LineChart &#123;    public void draw()&#123;        System.out.println(&quot;Draw line chart...&quot;);    &#125;&#125;public class App &#123;    public void drawChart(String type)&#123;        if (type.equalsIgnoreCase(&quot;line&quot;))&#123;            new LineChart().draw();        &#125;else if (type.equalsIgnoreCase(&quot;bar&quot;))&#123;            new BarChart().draw();        &#125;    &#125;&#125;</code></pre><p>这样做在初期是能满足业务需要的，开发效率也十分高，但是当后面需要新增一个饼状图的时候，既要添加一个饼状图的类，原来的客户端<code>App</code>类的<code>drawChart()</code>方法也要新增一个else if分支，这样做就是修改了原有客户端类库的方法，是十分不合理的。如果这个时候，在图中加入一个颜色属性，复杂性也大大提高。基于此，需要引入一个抽象<code>Chart</code>类<code>AbstractChart</code>，<code>App</code>类在画图的时候总是把相关的操作委托到具体的<code>AbstractChart</code>的派生类实例，这样的话<code>App</code>类的代码就不用修改：</p><pre><code class="hljs">public abstract class AbstractChart &#123;    public abstract void draw();&#125;public class BarChart extends AbstractChart&#123;    @Override    public void draw() &#123;        System.out.println(&quot;Draw bar chart...&quot;);    &#125;&#125;public class LineChart extends AbstractChart &#123;    @Override    public void draw() &#123;        System.out.println(&quot;Draw line chart...&quot;);    &#125;&#125;public class App &#123;    public void drawChart(AbstractChart chart)&#123;        chart.draw();    &#125;&#125;</code></pre><p>如果新加一种图，只需要新增一个<code>AbstractChart</code>的子类即可。客户端类<code>App</code>不需要改变原来的逻辑。修改后的设计符合开闭原则，因为整个系统在扩展时原有的代码没有做任何修改。</p><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p>单一职责原则（Single Responsibility Principle, SRP）的定义是：指一个类或者模块应该有且只有一个改变的原因。如果一个类承担的职责过多，就等于把这些职责耦合在一起了。一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当发生变化时，设计会遭受到意想不到的破坏。而如果想要避免这种现象的发生，就要尽可能的遵守单一职责原则。此原则的核心就是解耦和增强内聚性。</p><h4 id="单一职责原则的意义"><a href="#单一职责原则的意义" class="headerlink" title="单一职责原则的意义"></a>单一职责原则的意义</h4><p>单一职责原则告诉我们：一个类不能做太多的东西。在软件系统中，一个类(一个模块、或者一个方法)承担的职责越多，那么其被复用的可能性就会越低。一个很典型的例子就是万能类。其实可以说一句大实话：任何一个常规的MVC项目，在极端的情况下，可以用一个类(甚至一个方法)完成所有的功能。但是这样做就会严重耦合，甚至牵一发动全身。一个类承(一个模块、或者一个方法)担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。</p><p>不过说实话，其实有的时候很难去衡量一个类的职责，主要是很难确定职责的粒度。这一点不仅仅体现在一个类或者一个模块中，也体现在采用微服务的分布式系统中。这也就是为什么我们在实施微服务拆分的时候经常会撕逼：”这个功能不应该发在A服务中，它不做这个领域的东西，应该放在B服务中”诸如此类的争论。存在争论是合理的，不过最好不要不了了之，而应该按照领域定义好每个服务的职责(职责的粒度最好找业务和架构专家咨询)，得出相对合理的职责分配。</p><p>下面通过一个很简单的实例说明一下单一职责原则：</p><p>在一个项目系统代码编写的时候，由于历史原因和人为的不规范，导致项目没有分层，一个<code>Service</code>类的伪代码是这样的：</p><pre><code class="hljs">public class Service &#123;        public UserDTO findUser(String name)&#123;        Connection connection = getConnection();        PreparedStatement preparedStatement = connection.prepareStatement(&quot;SELECT * FROM t_user WHERE name = ?&quot;);        preparedStatement.setObject(1, name);        User user = //处理结果        UserDTO dto = new UserDTO();        //entity值拷贝到dto        return dto;    &#125;&#125;</code></pre><p>这里出现一个问题，<code>Service</code>做了太多东西，包括数据库连接的管理，Sql的执行这些业务层不应该接触到的逻辑，更可怕的是，例如到时候如果数据库换成了<code>Oracle</code>，这个方法将会大改。因此，拆分出新的<code>DataBaseUtils</code>类用于专门管理数据库资源，<code>Dao</code>类用于专门执行查询和查询结果封装，改造后<code>Service</code>类的伪代码如下：</p><pre><code class="hljs">public class Service &#123;    private Dao dao;        public UserDTO findUser(String name)&#123;       User user =  dao.findUserByName(name);       UserDTO dto = new UserDTO();        //entity值拷贝到dto       return dto;    &#125;&#125;</code></pre><p>​<br>    public class Dao{</p><pre><code class="hljs">    public User findUserByName(String name)&#123;       Connection connection = DataBaseUtils.getConnnection();       PreparedStatement preparedStatement = connection.prepareStatement(&quot;SELECT * FROM t_user WHERE name = ?&quot;);        preparedStatement.setObject(1, name);        User user = //处理结果        return user;    &#125;&#125;</code></pre><p>现在，如果有查询封装的变动只需要修改<code>Dao</code>类，数据库相关变动只需要修改<code>DataBaseUtils</code>类，每个类的职责分明。这个时候，如果我们要把底层的存储结构缓成<code>Redis</code>或者<code>MongoDB</code>怎么办，这样显然要重建整个<code>Dao</code>类，这种情况下，需要进行接口隔离，下面分析接口隔离原则的时候再详细分析。</p><h3 id="里氏代换原则"><a href="#里氏代换原则" class="headerlink" title="里氏代换原则"></a>里氏代换原则</h3><p>里氏代换原则（Liskov Substitution Principle，LSP）的定义是：所有引用基类的地方必须能透明地使用其子类的对象，也可以简单理解为任何基类可以出现的地方，子类一定可以出现。</p><h4 id="里氏代换原则的意义"><a href="#里氏代换原则的意义" class="headerlink" title="里氏代换原则的意义"></a>里氏代换原则的意义</h4><p>只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对”开-闭”原则的补充。实现”开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。当然，如果反过来，软件单位使用的是一个子类对象的话，那么它不一定能够使用基类对象。举个很简单的例子说明这个问题：如果一个方法接收<code>Map</code>类型参数，那么它一定可以接收<code>Map</code>的子类参数例如<code>HashMap</code>、<code>LinkedHashMap</code>、<code>ConcurrentHashMap</code>类型的参数；但是反过来，如果另一个方法只接收<code>HashMap</code>类型的参数，那么它一定不能接收所有<code>Map</code>类型的参数，否则它可以接收<code>LinkedHashMap</code>、<code>ConcurrentHashMap</code>类型的参数。</p><h4 id="子类为什么可以替换基类的位置"><a href="#子类为什么可以替换基类的位置" class="headerlink" title="子类为什么可以替换基类的位置"></a>子类为什么可以替换基类的位置</h4><p>其实原因很简单，只要存在继承关系，基类的所有非私有属性或者方法，子类都可以通过继承获得(白箱复用)，反过来不成立，因为子类很有可能扩充自身的非私有属性或者方法，这个时候不能用基类获取子类新增的这些属性或者方法。</p><p>里氏代换原则是实现开闭原则的基础，它告诉我们在设计程序的时候进可能使用基类进行对象的定义和引用，在运行时再决定基类的具体子类型。</p><p>举个简单的例子，假设一种会呼吸的动物作为父类，子类猪和鸟也有自身的呼吸方式：</p><pre><code class="hljs">public abstract class Animal &#123;    protected abstract void breathe();&#125;public class Bird extends Animal &#123;    @Override    public void breathe() &#123;        System.out.println(&quot;Bird breathes...&quot;);    &#125;&#125;public class Pig extends Animal &#123;    @Override    public void breathe() &#123;        System.out.println(&quot;Pig breathes...&quot;);    &#125;&#125;public class App &#123;    public static void main(String[] args) throws Exception &#123;        Animal bird = new Bird();        bird.breathe();        Animal pig = new Pig();        pig.breathe();    &#125;&#125;    </code></pre><h3 id="依赖倒转原则"><a href="#依赖倒转原则" class="headerlink" title="依赖倒转原则"></a>依赖倒转原则</h3><p>依赖倒转原则（Dependency Inversion Principle，DIP）的定义：程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p><h4 id="依赖倒转原则的意义"><a href="#依赖倒转原则的意义" class="headerlink" title="依赖倒转原则的意义"></a>依赖倒转原则的意义</h4><p>依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。</p><h4 id="依赖倒转原则的注意事项"><a href="#依赖倒转原则的注意事项" class="headerlink" title="依赖倒转原则的注意事项"></a>依赖倒转原则的注意事项</h4><ul><li>  高层模块不应该依赖低层模块，高层模块和低层模块都应该依赖于抽象。</li><li>  抽象不应该依赖于具体，具体应该依赖于抽象。</li></ul><p>在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。Spring的IOC是此实现的典范。</p><p>从Java角度看待依赖倒转原则的本质就是：面向接口(抽象)编程。</p><ul><li>  每个具体的类都应该有其接口或者基类，或者两者都具备。</li><li>  类中的引用对象应该是接口或者基类。</li><li>  任何具体类都不应该派生出子类。</li><li>  尽量不要覆写基类中的方法。</li><li>  结合里氏代换原则使用。</li></ul><p>遵循依赖倒转原则的一个例子，场景是司机开车：</p><pre><code class="hljs">public interface Driver &#123;    void drive();    void setCar(Car car);&#125;public interface Car &#123;    void run();&#125;public class DefaultDriver implements Driver &#123;    private Car car;    @Override    public void drive() &#123;        car.run();    &#125;    @Override    public void setCar(Car car) &#123;        this.car = car;    &#125;&#125;public class Bmw implements Car &#123;    @Override    public void run() &#123;        System.out.println(&quot;Bmw runs...&quot;);    &#125;&#125;public class Benz implements Car &#123;    @Override    public void run() &#123;        System.out.println(&quot;Benz runs...&quot;);    &#125;&#125;public class App &#123;    public static void main(String[] args) throws Exception &#123;        Driver driver = new DefaultDriver();        Car car = new Benz();        driver.setCar(car);        driver.drive();        car = new Bmw();        driver.setCar(car);        driver.drive();    &#125;&#125;</code></pre><p>这样实现了一个司机可以开各种类型的车，如果还有其他类型的车，只需要新加一个<code>Car</code>的实现即可。</p><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p>接口隔离原则（Interface Segregation Principle，ISP）的定义是客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上。简单来说就是建立单一的接口，不要建立臃肿庞大的接口。也就是接口尽量细化，同时接口中的方法尽量少。</p><h4 id="如何看待接口隔离原则和单一职责原则"><a href="#如何看待接口隔离原则和单一职责原则" class="headerlink" title="如何看待接口隔离原则和单一职责原则"></a>如何看待接口隔离原则和单一职责原则</h4><p>单一职责原则注重的是类和接口的职责单一，这里职责是从业务逻辑上划分的，但是在接口隔离原则要求当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。也就是说，我们在设计接口的时候有可能满足单一职责原则但是不满足接口隔离原则。</p><h4 id="接口隔离原则的规范"><a href="#接口隔离原则的规范" class="headerlink" title="接口隔离原则的规范"></a>接口隔离原则的规范</h4><ul><li>  使用接口隔离原则前首先需要满足单一职责原则。</li><li>  接口需要高内聚，也就是提高接口、类、模块的处理能力，少对外发布<code>public</code>的方法。</li><li>  定制服务，只提供访问者需要的方法。</li><li>  接口设计是有限度的，接口的设计粒度越小，系统越灵活，但是值得注意不能过小，否则变成”字节码编程”。</li></ul><p>如果有用过<code>spring-data-redis</code>的人就知道，RedisTemplate中持有一些列的基类，分别是<code>ValueOperations</code>(处理K-V)、<code>ListOperations</code>(处理Hash)、<code>SetOperations</code>(处理集合)等等。</p><pre><code class="hljs">public interface ValueOperations&lt;K, V&gt; &#123;    void set(K key, V value);    void set(K key, V value, long timeout, TimeUnit unit);    //....&#125;</code></pre><h3 id="合成-聚合复用原则"><a href="#合成-聚合复用原则" class="headerlink" title="合成/聚合复用原则"></a>合成/聚合复用原则</h3><p>合成/聚合复用原则（Composite/Aggregate Reuse Principle，CARP）一般也叫合成复用原则(Composite Reuse Principle, CRP)，定义是：<strong>尽量使用合成/聚合，而不是通过继承达到复用的目的</strong>。</p><p>合成/聚合复用原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新的对象通过向内部持有的这些对象的委派达到复用已有功能的目的，而不是通过继承来获得已有的功能。</p><h4 id="聚合-Aggregate-的概念"><a href="#聚合-Aggregate-的概念" class="headerlink" title="聚合(Aggregate)的概念"></a>聚合(Aggregate)的概念</h4><p>聚合表示一种弱的”拥有”关系，一般表现为松散的整体和部分的关系，其实，所谓整体和部分也可以是完全不相关的。例如A对象持有B对象，B对象并不是A对象的一部分，也就是B对象的生命周期是B对象自身管理，和A对象不相关。</p><h4 id="合成-Composite-的概念"><a href="#合成-Composite-的概念" class="headerlink" title="合成(Composite)的概念"></a>合成(Composite)的概念</h4><p>合成表示一种强的”拥有”关系，一般表现为严格的整体和部分的关系，部分和整体的生命周期是一样的。</p><h4 id="聚合和合成的关系"><a href="#聚合和合成的关系" class="headerlink" title="聚合和合成的关系"></a>聚合和合成的关系</h4><p>这里用山羊举例说明聚合和合成的关系：</p><p><img src="img.png"></p><h4 id="为什么要用合成-聚合来替代继承达到复用的目的"><a href="#为什么要用合成-聚合来替代继承达到复用的目的" class="headerlink" title="为什么要用合成/聚合来替代继承达到复用的目的"></a>为什么要用合成/聚合来替代继承达到复用的目的</h4><p>继承复用破坏包装，因为继承将基类的实现细节暴露给派生类，基类的内部细节通常对子类来说是可见的，这种复用也称为”白箱复用”。这里有一个明显的问题是：派生类继承自基类，如果基类的实现发生改变，将会影响到所有派生类的实现；如果从基类继承而来的实现是静态的，不可能在运行时发生改变，不够灵活。</p><p>由于合成或聚合关系可以将已有的对象，一般叫成员对象，纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使得成员对象的内部实现细节对于新对象不可见，所以这种复用又称为”黑箱”复用，相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作；合成/聚合复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。</p><p>如果有阅读过《Effective Java 2nd》的同学就知道，此书也建议慎用继承。一般情况下，只有明确知道派生类和基类满<code>IS A</code>的时候才选用继承，当满足<code>HAS A</code>或者不能判断的情况下应该选用合成/聚合。</p><p>下面举个很极端的例子说明一下如果在非<code>IS A</code>的情况下使用继承会出现什么问题：</p><p>先定义一个抽象手，手有一个摇摆的方法，然后定义左右手继承抽象手，实现摇摆方法：</p><pre><code class="hljs">public abstract class AbstractHand &#123;    protected abstract void swing();&#125;public class LeftHand extends AbstractHand &#123;    @Override    public void swing() &#123;        System.out.println(&quot;Left hand swings...&quot;);    &#125;&#125;public class RightHand extends AbstractHand &#123;    @Override    public void swing() &#123;        System.out.println(&quot;Right hand swings...&quot;);    &#125;&#125;</code></pre><p>现在看起来没有任何问题，实现也十分正确，现在出现了人(<code>Person</code>)这个类，具备摇左右手的功能，如果不考虑<code>IS A</code>的关系，很有可能有人会这样做：</p><pre><code class="hljs">public abstract class AbstractSwingHand extends AbstractHand&#123;    @Override    protected void swing() &#123;        System.out.println(&quot; hand swings...&quot;);    &#125;&#125;public class Person extends AbstractSwingHand &#123;    public void swingLeftHand()&#123;        System.out.print(&quot;Left &quot;);        super.swing();    &#125;    public void swingRightHand()&#123;        System.out.print(&quot;Right &quot;);        super.swing();    &#125;&#125;</code></pre><p>上面<code>Person</code>的实现让人觉得百思不得其解，但是往往这会出现在真实的环境中，因为<code>Hand</code>不是<code>Person</code>，所以<code>Person</code>继承Hand一定会出现曲线实现等奇葩逻辑。<code>Hand</code>和<code>Person</code>是严格的部分和整体的关系，或者说<code>Person</code>和<code>Hand</code>是<code>HAS A</code>的关系，如果使用合成，逻辑将会十分清晰：</p><pre><code class="hljs">public class Person  &#123;    private AbstractHand leftHand;    private AbstractHand rightHand;    public Person() &#123;        leftHand = new LeftHand();        rightHand = new RightHand();    &#125;    public void swingLeftHand()&#123;        leftHand.swing();    &#125;    public void swingRightHand()&#123;        rightHand.swing();    &#125;&#125;</code></pre><p>这里使用了合成，说明了<code>Person</code>和<code>AbstractHand</code>实例的生命周期是一致的。</p><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>迪米特法则（Law of Demeter，LOD），有时候也叫做最少知识原则（Least Knowledge Principle，LKP），它的定义是：一个软件实体应当尽可能少地与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望能通过它的友元类（中间类或者跳转类）来转达。</p><h4 id="迪米特法则的规则"><a href="#迪米特法则的规则" class="headerlink" title="迪米特法则的规则"></a>迪米特法则的规则</h4><ul><li>  Only talk to your immediate friends(只与直接的朋友通讯)，一个对象的”朋友”包括他本身(this)、它持有的成员对象、入参对象、它所创建的对象。</li><li>  尽量少发布public的变量和方法，一旦公开的属性和方法越多，修改的时候影响的范围越大。</li><li>  “是自己的就是自己的”，如果一个方法放在本类中，既不产生新的类间依赖，也不造成负面的影响，那么次方法就应该放在本类中。</li></ul><h4 id="迪米特法则的意义"><a href="#迪米特法则的意义" class="headerlink" title="迪米特法则的意义"></a>迪米特法则的意义</h4><p>迪米特法则的核心观念就是类间解耦，也就降低类之间的耦合，只有类处于弱耦合状态，类的复用率才会提高。所谓降低类间耦合，实际上就是尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。但是这样会引发一个问题，有可能产生大量的中间类或者跳转类，导致系统的复杂性提高，可维护性降低。如果一味追求极度解耦，那么最终有可能变成面向字节码编程甚至是面向二进制的0和1编程。</p><p>举个很简单的例子，体育老师要知道班里面女生的人数，他委托体育课代表点清女生的人数：</p><pre><code class="hljs">public class Girl &#123;    &#125;public class GroupLeader &#123;    private final List&lt;Girl&gt; girls;    public GroupLeader(List&lt;Girl&gt; girls) &#123;        this.girls = girls;    &#125;    public void countGirls() &#123;        System.out.println(&quot;The sum of girls is &quot; + girls.size());    &#125;&#125;public class Teacher &#123;    public void command(GroupLeader leader)&#123;        leader.countGirls();    &#125;&#125;public class App &#123;    public static void main(String[] args) throws Exception &#123;        Teacher teacher = new Teacher();        GroupLeader groupLeader = new GroupLeader(Arrays.asList(new Girl(), new Girl()));        teacher.command(groupLeader);    &#125;&#125;</code></pre><p>这个例子中，体育课代表就是中间类，体育课代表对于体育老师来说就是”直接的朋友”，如果去掉体育课代表这个中间类，体育老师必须亲自清点女生的人数(实际上就数人数这个功能，体育老师是不必要获取所有女生的对象列表)，这样做会违反迪米特法则。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>说实话，设计模式的七大原则理解是比较困难的，我们在设计模式的学习和应用中经常会听到或者看到”XXX模式符合XXX原则”、”YYY模式不符合YYY原则”这样的语句。因此，为了分析设计模式的合理性和完善我们日常的编码，掌握和理解这七大原则是十分必要的。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li>  《Java设计模式》</li><li>  《设计模式之禅-2nd》</li><li>  《设计模式-可复用面向对象软件的基础》</li><li> <a href="https://cloud.tencent.com/developer/article/1650116">设计模式概念和七大原则</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>设计模式概念和七大原则</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>设计模式原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git Merge VS Git Rebase</title>
    <link href="/2024/02/21/git/Git%20Merge%20VS%20Git%20Rebase/"/>
    <url>/2024/02/21/git/Git%20Merge%20VS%20Git%20Rebase/</url>
    
    <content type="html"><![CDATA[<p>git rebase 和 git merge 都是Git中用于将不同分支的更改合并到一起的命令，但它们的工作方式和结果不同。</p><h2 id="Git-Merge"><a href="#Git-Merge" class="headerlink" title="Git Merge"></a>Git Merge</h2><ul><li>merge 是将两个分支的历史合并在一起的方式。</li><li>当你执行 merge 时，Git会创建一个新的“合并提交”（merge commit），这个提交有两个父提交：一个是当前分支的末端提交，另一个是要合并进来的分支的末端提交。</li><li>merge 保留了项目历史的真实结构，因为它不会改变已有的提交历史。<br>合并完成后，合并的分支将保留其历史上的所有提交。</li></ul><h2 id="Git-Rebase"><a href="#Git-Rebase" class="headerlink" title="Git Rebase"></a>Git Rebase</h2><ul><li>rebase 是一个重新排列提交历史的过程，它将一个分支的提交“移植”到另一个分支的末端。</li><li>rebase 会复制一系列的提交并在目标分支上重新应用它们，这个过程可以创建一个线性的提交历史。</li><li>使用 rebase 可以使得项目历史更加清洁和直线式，因为它消除了分支合并时的多余的实际合并提交。</li><li>然而，rebase 可以改变存在的提交历史，这在某些情况下可能会导致复杂的冲突解决和其他问题。 </li></ul><p>总的来说，merge 命令会保留历史分支结构，而 rebase 会创建一个更清晰的直线式历史。使用哪一个命令通常取决于具体的工作流程和团队的偏好。在协作环境中慎用 rebase，特别是不建议在共享的分支上进行 rebase，因为它可能会给其他成员带来困扰。</p>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>archlinux安装注意事项</title>
    <link href="/2024/02/20/linux/install-archlinux/"/>
    <url>/2024/02/20/linux/install-archlinux/</url>
    
    <content type="html"><![CDATA[<p><img src="img.png"></p><h2 id="archlinux-introduce"><a href="#archlinux-introduce" class="headerlink" title="archlinux introduce"></a>archlinux introduce</h2><p>Arch Linux is an independently developed, x86-64 general-purpose Linux distribution that is known for its simplicity and minimalism. It follows a rolling-release model which means that it does not have “major releases” of completely new versions of its system; regular system updates will allow users to obtain the latest Arch software. The default installation is a minimal base system, allowing users to add only the packages they need purposefully.</p><p>It uses pacman, a package manager written specifically for Arch Linux, to install, remove, and update software packages. The distribution is known for its comprehensive documentation, provided by a community-run wiki called the ArchWiki.</p><p>Arch Linux was started by Judd Vinet in March 2002, inspired by another minimalist distribution called CRUX. The name “Arch” was chosen because it means “the principal,” as in “arch-enemy.” Initially available only for 32-bit x86 CPUs, it released its first x86_64 installation ISO in April 2006.</p><p>The project has seen a transition of leadership and significant changes over time, including the adoption of systemd as its init system in 2012, the end of support for i686 architecture in 2017 (with Arch Linux 32 available as a community derivative for i686 hardware), and the introduction of Pacman 6.0 in late 2021 which enabled parallel downloads. As of February 2022, the distribution also began offering debug packages.</p><h2 id="archlinux介绍"><a href="#archlinux介绍" class="headerlink" title="archlinux介绍"></a>archlinux介绍</h2><p>Arch Linux (/ɑːrtʃ/) 是一个独立开发的 x86-64 架构通用 GNU/Linux 发行版，它致力于通过滚动更新来提供大多数软件的最新稳定版本。默认安装是一个最小的基本系统，用户可以根据需要自行添加所需的软件。Arch Linux 使用 pacman 作为其包管理器。</p><p>Arch Linux 采用滚动更新模式，努力为用户维护软件的最新稳定版本，除非需要合理地避免系统包损坏。同时，Arch Linux 以社区 Wiki 的形式提供文档，称为 ArchWiki，供用户查阅各种信息和教程。</p><p>Arch Linux 的历史可以追溯到加拿大程序设计师兼吉他手 Judd Vinet，他从 2001 年早期开始开发 Arch Linux，并在 2002 年 3月 11 日正式发行了 0.1 版本。2007 年下半年，Judd Vinet 退出了 Arch Linux 的开发，由 Aaron Griffin 接手。2012 年 7 月发行的 Arch Linux 安装 ISO 映像开始放弃旧的安装框架转为使用不同的辅助脚本，并逐步开始将初始化系统迁移至 systemd。</p><h2 id="安装常用软件"><a href="#安装常用软件" class="headerlink" title="安装常用软件"></a>安装常用软件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S docker  #安装docker<br>sudo systemctl start docker<br>sudo systemctl enable docker<br>sudo usermod -aG docker $&#123;USER&#125; # 将当前用户添加至docker用户组,注 需要退出当前登录状态,后重新登录<br><br>pacman -S firefox # 安装firefox<br>pacman -S firefox-i18n-zh-cn # 安装firefox 中文语言包<br><br>ssh-keygen -t rsa <br> <br>curl -sSL https://raw.githubusercontent.com/version-fox/vfox/main/install.sh | bash # 安装vfox<br><br>sudo pacman -S openssh<br><br>sudo pacman -S man-db<br><br>sudo pacman -S net-tools<br><br>sudo pacman -S iftop<br><br>sudo pacman -S sysstat<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">安装yay,注 此过程需要设置代理,否则很慢 <span class="hljs-built_in">export</span> https_proxy=http://192.168.124.21:7890 &amp;&amp; <span class="hljs-built_in">export</span> http_proxy=http://192.168.124.21:7890</span><br>sudo pacman -S git<br>cd /opt<br>sudo git clone https://aur.archlinux.org/yay.git<br>sudo chown -R $&#123;USER&#125;:users ./yay<br>cd yay<br>makepkg -si<br>yay<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">Arch Linux 中配置 xrdp 远程桌面 注不要使用root账户安装xrdp,创建一个普通用户,具备sudo权限</span><br>yay -S xrdp<br>yay -S xorgxrdp<br>pacman -S xorg-xinit<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在/etc/X11/Xwrapper.config中加入以下内容：</span><br>    allowed_users=anybody<br>    needs_root_rights=no<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在~/.xinitrc中写入以下内容：</span><br>    #!/bin/sh<br>    unset SESSION_MANAGER<br>    unset DBUS_SESSION_BUS_ADDRESS<br>    export XDG_SESSION_TYPE=x11<br>    export GDK_BACKEND=x11<br>    exec dbus-launch gnome-session<br>chmod +x ~/.xinitrc<br>sudo systemctl enable xrdp.service<br>sudo systemctl enable xrdp-sesman.service<br>sudo reboot<br><br>sudo systemclt set-default multi-user.target<br></code></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="xrdp"><a href="#xrdp" class="headerlink" title="xrdp"></a>xrdp</h3><p>查看 /var/log/xrdp.log 和 /var/log/xrdp-sesman.log。前者是 xrdp 程序本身的日志，而后者是 xrdp-sesman（会话管理器）的日志。前者负责处理 RDP 协议本身，通常不太可能出现问题（如果出问题，systemd 应该会报告启动失败）；后者负责启动 Xorg 服务器及桌面管理器，问题一般都会出在这一环。如果遇到问题，应该首先查看 xrdp-sesman.log，检查是否成功启动了 Xorg 服务器。<br>Steps to fix:</p><ul><li>Run these commands on the target system<br>  sudo systemclt set-default multi-user.target<br>  sudo reboot</li><li>Attempt to reconnect using your RD client</li></ul><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li><a href="https://en.wikipedia.org/wiki/Arch_Linux">Arch Linux</a></li><li><a href="https://zh.wikipedia.org/wiki/Arch_Linux">Arch Linux</a></li><li><a href="https://linux.cn/article-14846-1.html">如何在 Arch Linux 中安装 Yay AUR 助手</a></li><li><a href="https://mostima.blog/blog/xrdp-arch-linux/">Arch Linux 中配置 xrdp 远程桌面</a></li><li><a href="https://www.bilibili.com/read/cv27332967/">利用Archinstall超简单快速在虚拟机中安装图形化ArchLinux的小白向流程笔记</a></li><li><a href="https://loac.cc/archives/archmanjaro%E5%AE%89%E8%A3%85%E8%BE%93%E5%85%A5%E6%B3%95fcitx5">Arch/Manjaro 安装输入法（Fcitx5）</a></li><li><a href="https://blog.t123yh.xyz:3/index.php/archives/982">在 Linux 下配置 xrdp 的一些经验</a></li><li><a href="https://github.com/neutrinolabs/xrdp/issues/2258">XRDP session close immediately </a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>os</tag>
      
      <tag>archlinux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ansible简单介绍及使用</title>
    <link href="/2024/01/12/linux/Ansible%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%20/"/>
    <url>/2024/01/12/linux/Ansible%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E5%8F%8A%E4%BD%BF%E7%94%A8%20/</url>
    
    <content type="html"><![CDATA[<h2 id="Ansible-的特性"><a href="#Ansible-的特性" class="headerlink" title="Ansible 的特性"></a>Ansible 的特性</h2><ul><li>  低学习成本</li><li>  无需在服务器中安装客户端，基于 SSH 工作，可并行执行</li><li>  无需服务端，直接终端命令即可</li><li>  管理的对象可以包括物理机，虚拟机，容器等等</li><li>  使用 YAML 格式文件编排 playbook</li></ul><h2 id="Ansible-的组成元素"><a href="#Ansible-的组成元素" class="headerlink" title="Ansible 的组成元素"></a>Ansible 的组成元素</h2><p>Ansible 中的一些概念。</p><ul><li>  <strong>control node</strong>: 控制节点，可以在任何安装了 Python 环境的机器中使用 ansible，两个重要的可执行文件在 <code>/usr/bin/ansible</code> 和 <code>/usr/bin/ansible-playbook</code></li><li>  <strong>managed node</strong>: 被控制的节点</li><li>  <strong>inventory</strong>: 需要管理的节点，通常配置成 <code>hostfile</code> 文件 <a href="#fn:inventory">1</a></li><li>  modules: ansible 进行自动化任务时调用的模块，社区提供了非常多 <a href="https://docs.ansible.com/ansible/latest/modules/list_of_all_modules.html">modules</a></li><li>  <strong>Task</strong>: Ansible 的执行单元</li><li>  <strong>playbook</strong>: 编排多个任务</li><li>  <strong>roles</strong>: roles 是将 playbook 划分多个部分的机制</li><li>  <strong>plugins</strong>: ansible 插件</li></ul><p>工作流程：</p><ul><li>  读取配置</li><li>  获取机器列表及分组配置</li><li>  确定执行模块和配置，modules 目录动态读取</li><li>  Runner 执行</li><li>  输出</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Ansible 的安装方法非常多，PPA，源码安装都可以。<a href="#fn:install">2</a></p><p>Ubuntu 下安装：</p><pre><code class="hljs">sudo apt updatesudo apt install software-properties-commonsudo apt-add-repository --yes --update ppa:ansible/ansiblesudo apt install ansible</code></pre><p>如果不想 PPA，也可以直接安装：</p><pre><code class="hljs">sudo apt-get install -y ansible# orsudo pip install ansible</code></pre><p>在 macOS 上：</p><pre><code class="hljs">brew install ansible</code></pre><h3 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h3><p>从源码安装：</p><pre><code class="hljs">sudo apt-get install -y libffi-dev libssl-dev python-devsudo pip install paramiko PyYAML Jinja2 httplib2 six pycryptogit clone https://github.com/ansible/ansible.git --recursivecd ansiblegit pull --rebasegit submodule update --init --recursive</code></pre><p>配置 Bash：</p><pre><code class="hljs">source ./hacking/env-setup</code></pre><h3 id="通过-Python-pip-安装"><a href="#通过-Python-pip-安装" class="headerlink" title="通过 Python pip 安装"></a>通过 Python pip 安装</h3><pre><code class="hljs">sudo pip install --trusted-host mirrors.aliyun.com --index-url=http://mirrors.aliyun.com/pypi/simple/  ansible==2.7.1</code></pre><h2 id="相关配置"><a href="#相关配置" class="headerlink" title="相关配置"></a>相关配置</h2><h3 id="ansible-cfg"><a href="#ansible-cfg" class="headerlink" title="ansible.cfg"></a>ansible.cfg</h3><p><code>ansible.cfg</code> 文件是 Ansible 中最主要的配置文件，ansible 寻找配置文件按照如下的优先级进行：</p><ul><li>  由环境变量 <code>ANSIBLE_CONFIG</code> 指定的文件</li><li>  <code>./ansible.cfg</code> (<code>ansible.cfg</code> in the current directory)</li><li>  <code>~/.ansible.cfg</code> (<code>.ansible.cfg</code> in your home directory)</li><li>  <code>/etc/ansible/ansible.cfg</code></li></ul><p>最简单的 <code>ansible.cfg</code> 配置示例：</p><pre><code class="hljs">[defaults]hostfile = hostsremote_user = rootremote_port = 22host_key_checking = False</code></pre><p>说明：</p><ul><li><code>hostfile</code> 文件指定了当前文件夹下的 hosts 文件。hosts 文件中会配置需要管理的机器 host<ul><li>  配置 SSH 免密登录的文章可以参考之前的<a href="/post/2016/06/ssh-copy-id.html">文章</a>.</li></ul></li><li>  <code>remote_user</code> 配置默认操作的用户，如果没有配置，默认会使用当前用户</li><li>  <code>host_key_checking</code>: 禁用 SSH key host checking</li></ul><h3 id="inventory"><a href="#inventory" class="headerlink" title="inventory"></a>inventory</h3><p>在上面的配置中可以看到 <code>inventory</code> 指定了一个 hosts 文件，这个文件用来对远程服务器 Hosts 进行管理。</p><p>默认的文件路径在 <code>/etc/ansible/hosts</code>。</p><p>这里的 inventory 可以看成需要管理的节点的配置，可以直接配置到全局，然后使用 <code>all</code> 来引用，也可以用分组的形式来引用。</p><h4 id="未分组形式"><a href="#未分组形式" class="headerlink" title="未分组形式"></a>未分组形式</h4><p>比如，未分组形式定义：</p><pre><code class="hljs">xxx.einverne.infoeinverne.info12.12.12.12192.168.2.1192.168.2.20010.0.0.1</code></pre><h4 id="分组形式"><a href="#分组形式" class="headerlink" title="分组形式"></a>分组形式</h4><p>或者采用分组形式，用方括号表示下面的 HOST 都属于 webserver 这个组：</p><pre><code class="hljs">[webserver]127.0.0.1foo.example.com</code></pre><h4 id="配置范围"><a href="#配置范围" class="headerlink" title="配置范围"></a>配置范围</h4><p>如果有多个 HOST 可以用如下语法添加多个：</p><pre><code class="hljs">[webservers]www[001:006].example.com[dbservers]db-[99:101]-node.example.com</code></pre><p>或者配置别名：</p><pre><code class="hljs">dbserver1 ansible_ssh_host=127.0.0.1 ansible_ssh_port=22 color=reddbserver2 ansible_ssh_host=127.0.0.2 ansible_ssh_port=220</code></pre><p>​<br>​    [dbserver] #group<br>​    dbserver1<br>​    dbserver2<br>​<br>    [forum:children] #groups of groups<br>    webserver<br>    dbserver</p><p>inventory 中可以配置使用别名，但是推荐在 <code>ssh config</code> 中进行配置管理，编辑 <code>vi ~/.ssh/config</code>:</p><pre><code class="hljs">Host ds    HostName einverne.info    Port 22    User usernameHost aws1    HostName aws.einverne.info    Post 22    User demo-usernameHost oracle1    HostName 140.1.1.1    Port 22    User some-username</code></pre><p>我个人使用 <a href="/post/2020/07/advanced-ssh-config-management.html">assh</a> 来对 SSH config 进行管理。</p><p>然后就可以在 Ansible 的 inventory 中配置使用 <code>ds</code>, <code>aws1</code> 或者 <code>oracle1</code> 来指定 host。</p><p>更多 inventory 的配置可以参考<a href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html">官方文档</a></p><p>inventory 同样配置用来管理 AWS EC2，或者 OpenStack。<a href="#fn:in">3</a></p><h2 id="Ansible-使用"><a href="#Ansible-使用" class="headerlink" title="Ansible 使用"></a>Ansible 使用</h2><p>ansible 命令的基本使用方法：</p><pre><code class="hljs">ansible &lt;pattern&gt; -m &lt;module_name&gt; -a &lt;module_arguments&gt;</code></pre><p>说明：这一行命令会定义并在一系列 host 上执行一个 <code>playbook</code> 任务。</p><h2 id="ad-hoc-command"><a href="#ad-hoc-command" class="headerlink" title="ad-hoc command"></a>ad-hoc command</h2><p>ad-hoc 命令可以执行单一的任务，ad-hoc 命令很简单，但不能复用，在了解 playbook 之前可以先体验一下 ad-hoc，感受一下 Ansible 的强大。</p><p>简单示例：</p><pre><code class="hljs"># 在指定的 host1 节点上执行ansible host1 -a &quot;/bin/echo hello&quot;# 在多个节点执行ansible host1,host2 -a &quot;/bin/echo hello&quot;ansible host1:host2 -a &quot;/bin/echo hello&quot;# ping 全部节点ansible all -m ping# 一组节点ansible webservers -m service -a &quot;name=httpd state=restarted&quot;# 多组节点ansible webservers:dbservers -m ping# 排除节点，在 groupA 但不在 groupBansible groupA:!groupB -m ping# 多组节点的交集，既在 groupA 也在 groupB 中的节点ansible groupA:&amp;groupB -m ping</code></pre><p>这里选择节点的方式可以有很多种，甚至可以选择组节点中的第几个，或者用正则匹配一些等等。<a href="#fn:host">4</a></p><h2 id="Ansible-module"><a href="#Ansible-module" class="headerlink" title="Ansible module"></a>Ansible module</h2><p><code>-m</code> 选项后面的就是 Ansible 的 module，常见的 module，比如上面例子中的 ping，就是用来检测连通性的。</p><p>下面介绍一下常用的 module 方便快速进入 Ansible 的世界，理解了下面这些 module 也比较方便之后学习更加复杂的模块。</p><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p>setup module 用来查看远程主机信息：</p><pre><code class="hljs">ansible all -m setup</code></pre><p>每个被管理的节点在接受并运行管理命令之前都会将自己的信息报告给 Ansible 主机。</p><h3 id="command"><a href="#command" class="headerlink" title="command"></a>command</h3><p>command 命令模块用于在远程主机执行命令，但是不能使用变量，管道等。</p><p>执行命令：</p><pre><code class="hljs">ansible all -m command -a &quot;ls -al .&quot;ansible all -m command -a &quot;date&quot;# 切换到 sub-dir 目录，创建文件ansible all -m command -a &quot;chdir=sub-dir creates=test.file ls&quot;# 删除文件ansible all -m command -a &quot;chdir=sub-dir removes=test.file ls&quot;</code></pre><h3 id="cron"><a href="#cron" class="headerlink" title="cron"></a>cron</h3><p>cron 模块用于配置 crontab 定时任务：</p><pre><code class="hljs">ansible host -m cron -a &#39;minute=&quot;*/10&quot; job=&quot;/bin/echo hello&quot; name=&quot;test cron job&quot;&#39;</code></pre><p>执行这以命令之后就会给 host 主机的 crontab 中写入</p><pre><code class="hljs">#Ansible: test cron job*/10 * * * * /bin/echo hello</code></pre><p>可以通过如下命令验证：</p><pre><code class="hljs">ansible host -a &#39;crontab -l&#39;</code></pre><p>如果要移除 cron 可以：</p><pre><code class="hljs">ansible host -m cron -a &#39;minute=&quot;*/10&quot; job=&quot;/bin/echo hello&quot; name=&quot;test cron job&quot; state=absent&#39;</code></pre><h3 id="user"><a href="#user" class="headerlink" title="user"></a>user</h3><p>user 模块用来管理用户账户。</p><pre><code class="hljs"># 新增用户ansible all -m user -a &#39;name=&quot;einverne&quot;&#39;# 删除用户ansible all -m user -a &#39;name=&quot;einverne&quot; state=absent&#39;</code></pre><p>和用户相关的字段：</p><pre><code class="hljs">name    用户名uid     uidstate   状态  group   属于哪个组groups  附加组home    家目录createhome  是否创建家目录comment 注释信息system  是否是系统用户</code></pre><p>user module 更多的说明可以参考<a href="https://docs.ansible.com/ansible/2.9/modules/user_module.html">官网</a></p><h3 id="group"><a href="#group" class="headerlink" title="group"></a>group</h3><p>组管理同样拥有这些配置：</p><pre><code class="hljs">gid     gid      name    组名              state   状态          system  是否是系统组</code></pre><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>file module 可以用来设置文件属性。</p><pre><code class="hljs"># 创建 soft linkansible all -m file -a &quot;src=/etc/resolv.conf dest=/tmp/resolv.conf state=link&quot;# 删除 soft linkansible all -m file -a &quot;path=/tmp/resolv.conf state=absent&quot;</code></pre><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>复制本地文件到远程主机指定位置</p><pre><code class="hljs"># 复制本地文件到远程主机，并授予权限ansible host -m copy -a &quot;src=/etc/ansible/ansible.cfg dest=/tmp/ansible.cfg owner=root group=root mode=644&quot;# 直接使用 contentansible host -m copy -a &#39;content=&quot;test content&quot; dest=/tmp/test&#39;</code></pre><h3 id="shell"><a href="#shell" class="headerlink" title="shell"></a>shell</h3><p>在远程执行 shell 脚本，可以使用管道等</p><pre><code class="hljs">ansible all -m shell -a &quot;~/setup.sh&quot;ansible all -m shell -a &#39;echo demo &gt; /tmp/demo&#39;</code></pre><p>更多 module 可以使用 <code>ansible-doc -l</code> 查看。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>看到这里的话，相信对 ansible 的 module 已经有了一个大致的了解，Ansible 官网提供了非常多的 <a href="https://docs.ansible.com/ansible/2.9/modules/modules_by_category.html">module 使用说明</a>。</p><p>但是你会发现一个问题，所有的这些命令都是一次性使用的，而无法做到复用，除非你拷贝这一行命令执行多次。所以 Ansible 也可以通过配置文件的方式，将这些操作记录下来，以文本的方式进行管理，这就是下面要说到的 Ansible playbook。</p><h2 id="Ansible-playbook"><a href="#Ansible-playbook" class="headerlink" title="Ansible playbook"></a>Ansible playbook</h2><p>上面提到 <code>ad-hoc</code> 可以执行一次性的命令，但如果要把多个 task 组织起来，那就不得不提到 playbook, playbook 可以编排有序的任务，可以在多组主机间，有序执行任务，可以选择同步或者异步发起任务。</p><p>下面以一个安装 Docker 的例子做演示：</p><p>定义了变量的文件 <code>var/default.yml</code>:</p><pre><code class="hljs">---create_containers: 4default_container_name: dockerdefault_container_image: ubuntudefault_container_command: sleep 1d</code></pre><p><code>playbook.yml</code> 文件：</p><pre><code class="hljs">---- hosts: all  become: true  vars_files:    - vars/default.yml  tasks:    - name: Install aptitude using apt      apt: name=aptitude state=latest update_cache=yes force_apt_get=yes    - name: Install required system packages      apt: name= state=latest update_cache=yes      loop: [ &#39;apt-transport-https&#39;, &#39;ca-certificates&#39;, &#39;curl&#39;, &#39;software-properties-common&#39;, &#39;python3-pip&#39;, &#39;virtualenv&#39;, &#39;python3-setuptools&#39;]    - name: Add Docker GPG apt Key      apt_key:        url: https://download.docker.com/linux/ubuntu/gpg        state: present    - name: Add Docker Repository      apt_repository:        repo: deb https://download.docker.com/linux/ubuntu bionic stable        state: present    - name: Update apt and install docker-ce      apt: update_cache=yes name=docker-ce state=latest    - name: Install Docker Module for Python      pip:        name: docker    - name: Pull default Docker image      docker_image:        name: &quot;&quot;        source: pull    # Creates the number of containers defined by the variable create_containers, using values from vars file    - name: Create default containers      docker_container:        name: &quot;&quot;        image: &quot;&quot;        command: &quot;&quot;        state: present      with_sequence: count=</code></pre><p>说明：</p><ul><li>  hosts: 指定了哪些服务器执行该 playbook 中的 tasks</li><li>  tasks: 一系列执行的任务，在上面的例子中就是安装必要的依赖，然后安装 Docker，随后 pull 镜像，并启动容器</li></ul><p>使用如下命令执行 playbook</p><pre><code class="hljs">ansible-playbook playbook.yml -f 10</code></pre><p><code>-f</code> 表示的是指定并发进程来执行任务。</p><h3 id="when-语句"><a href="#when-语句" class="headerlink" title="when 语句"></a>when 语句</h3><p>在 task 后面可以增加 when 用于条件，比如只有系统是 <code>Debian</code> 才执行命令：</p><pre><code class="hljs">tasks:  - name &#39;test when&#39;    command: /bin/echo hello    when: ansible_os_family == &#39;Debian&#39;</code></pre><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>如果需要重复执行一个任务，可以使用循环，将需要循环的内容定义为 item，然后通过 <code>with_items</code> 语句指定列表，比如新建两个用户：</p><pre><code class="hljs">- name: add user  user: name= state=present  with_items:    - user1    - user2</code></pre><p>上面语句的功能等同于下面的语句：</p><pre><code class="hljs">- name: add user testuser1 user: name=user1 state=present- name: add user testuser2 user: name=user2 state=present</code></pre><p>如果还要定义 group，可以使用 key-value 键值对:</p><pre><code class="hljs">- name: add multiple item  user: name= state=present groups=  with_items:    - &#123; name: &#39;user1&#39;, groups: &#39;g1&#39;&#125;    - &#123; name: &#39;user2&#39;, groups: &#39;root&#39;&#125;</code></pre><h3 id="role"><a href="#role" class="headerlink" title="role"></a>role</h3><p>再来看一个例子：</p><pre><code class="hljs">- hosts:webservers  roles:    - tmux</code></pre><p>这里 role 定义了 tmux(tmux 编译安装），则表示用 tmux 执行了一系列的命令。role 由其他一些组件组成：</p><pre><code class="hljs">roles/   tmux/     tasks/     handlers/     files/     templates/     vars/     defaults/     meta/</code></pre><p>在 tasks 目录下新建 <code>mail.yml</code>:</p><pre><code class="hljs">- name: install tmux package  package:    name:      - libevent      - ncurses      - tmux    state: latest</code></pre><p>如果想了解更多拆分 playbook 的方法，可以到官网查看更多 include, role 相关的内容。</p><h3 id="Check-Mode-dry-run"><a href="#Check-Mode-dry-run" class="headerlink" title="Check Mode (dry-run)"></a>Check Mode (dry-run)</h3><p>当使用 check mode 运行 ansible-playbook 时，Ansible 不会在远程服务器上执行任何命令。</p><pre><code class="hljs">ansible-playbook foo.yml --check</code></pre><h2 id="ansible-galaxy"><a href="#ansible-galaxy" class="headerlink" title="ansible-galaxy"></a>ansible-galaxy</h2><h3 id="创建-role"><a href="#创建-role" class="headerlink" title="创建 role"></a>创建 role</h3><p><code>ansible-galaxy</code> 命令和 Ansible 命令绑定到了一起，可以通过 <code>ansible-galaxy</code> 来初始化 role.</p><pre><code class="hljs">ansible-galaxy init pyenv</code></pre><p>得到：</p><pre><code class="hljs">➜ tree pyenvpyenv├── defaults│   └── main.yml├── files├── handlers│   └── main.yml├── meta│   └── main.yml├── README.md├── tasks│   └── main.yml├── templates├── tests│   ├── inventory│   └── test.yml└── vars    └── main.yml</code></pre><p>在使用时，每一个目录都需要包含一个 <code>mail.yml</code> 文件：</p><ul><li>  <code>tasks</code>: 包含 role 需要执行的任务清单</li><li>  <code>handlers</code>: 包含 handlers, 可能被 role 用到</li><li>  <code>defaults</code>: 默认变量，<a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#playbooks-variables">Using Variables</a></li><li>  <code>vars</code>: 其他被 role 用到的变量 <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.html#playbooks-variables">Variable</a></li><li>  <code>files</code>: 包含可能被 role 用到的文件</li><li>  <code>templates</code>: 包含可能被 role 用到的 templates</li><li>  <code>meta</code>: 定义 role 的 meta data</li></ul><p>YAML 文件可以被引入，比如不同的系统版本：</p><pre><code class="hljs"># roles/example/tasks/main.yml- name: added in 2.4, previously you used &#39;include&#39;  import_tasks: redhat.yml  when: ansible_facts[&#39;os_family&#39;]|lower == &#39;redhat&#39;- import_tasks: debian.yml  when: ansible_facts[&#39;os_family&#39;]|lower == &#39;debian&#39;# roles/example/tasks/redhat.yml- yum:    name: &quot;httpd&quot;    state: present# roles/example/tasks/debian.yml- apt:    name: &quot;apache2&quot;    state: present</code></pre><h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><p>其他的运维管理工具 puppet、cfengine、chef、func、fabric.</p><p>Redhat 给 Ansible 做了一套 GUI，叫做 Ansible Tower，感兴趣可以了解一下。</p><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li><a href="https://einverne.github.io/post/2020/05/ansible-introduction.html">Ansible 入门篇一：简单介绍及使用</a></li><li><a href="https://docs.ansible.com/">https://docs.ansible.com/</a></li><li><a href="http://www.ansible.com.cn/docs/">http://www.ansible.com.cn/docs/</a></li><li><a href="https://galaxy.ansible.com/docs/">https://galaxy.ansible.com/docs/</a></li><li><a href="https://www.ansible.com/overview/how-ansible-works">https://www.ansible.com/overview/how-ansible-works</a></li><li><a href="https://spacelift.io/blog/ansible-playbooks">https://spacelift.io/blog/ansible-playbooks</a></li><li> <a href="https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html#intro-inventory">https://docs.ansible.com/ansible/latest/user_guide/intro_inventory.html#intro-inventory</a> <a href="#fnref:inventory">↩</a></li><li> <a href="https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html">https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html</a> <a href="#fnref:install">↩</a></li><li> <a href="https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html">https://docs.ansible.com/ansible/latest/user_guide/intro_dynamic_inventory.html</a> <a href="#fnref:in">↩</a></li><li>  <a href="https://docs.ansible.com/ansible/latest/user_guide/intro_patterns.html">https://docs.ansible.com/ansible/latest/user_guide/intro_patterns.html</a> <a href="#fnref:host">↩</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ansible</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CentOS 7安装fail2ban + Firewalld防止爆破与CC攻击</title>
    <link href="/2024/01/08/linux/CentOS%207%E5%AE%89%E8%A3%85fail2ban%20+%20Firewalld%E9%98%B2%E6%AD%A2%E7%88%86%E7%A0%B4/"/>
    <url>/2024/01/08/linux/CentOS%207%E5%AE%89%E8%A3%85fail2ban%20+%20Firewalld%E9%98%B2%E6%AD%A2%E7%88%86%E7%A0%B4/</url>
    
    <content type="html"><![CDATA[<p>fail2ban可以监视你的系统日志，然后匹配日志的错误信息执行相应的屏蔽动作。网上大部分教程都是关于fail2ban + iptables组合，考虑到CentOS 7已经自带Firewalld，并且使用Firewalld作为网络防火墙更加简单方便，分享下fail2ban + Firewalld使用方法。</p><p><img src="img.png"></p><h3 id="检查Firewalld是否启用"><a href="#检查Firewalld是否启用" class="headerlink" title="检查Firewalld是否启用"></a>检查Firewalld是否启用</h3><pre><code class="hljs">#如果您已经安装iptables建议先关闭service iptables stop#查看Firewalld状态firewall-cmd --state#启动firewalldsystemctl start firewalld#设置开机启动systemctl enable firewalld.service</code></pre><p>启用Firewalld后会禁止所有端口连接，因此请务必放行常用的端口，以免被阻挡在外，以下是放行SSH端口（80）示例，供参考：</p><pre><code class="hljs">#放行80端口firewall-cmd --zone=public --add-port=80/tcp --permanent#重载配置firewall-cmd --reload#查看已放行端口firewall-cmd --zone=public --list-ports</code></pre><h3 id="安装fail2ban"><a href="#安装fail2ban" class="headerlink" title="安装fail2ban"></a>安装fail2ban</h3><p>fail2ban可以监控系统日志，并且根据一定规则匹配异常IP后使用Firewalld将其屏蔽，尤其是针对一些爆破/扫描等非常有效。</p><pre><code class="hljs">#CentOS内置源并未包含fail2ban，需要先安装epel源yum -y install epel-release#安装fial2banyum -y install fail2ban</code></pre><p>安装成功后fail2ban配置文件位于<code>/etc/fail2ban</code>，其中<code>jail.conf</code>为主配置文件，相关的匹配规则位于<code>filter.d</code>目录，其它目录/文件一般很少用到，如果需要详细了解可自行搜索。</p><h3 id="配置规则"><a href="#配置规则" class="headerlink" title="配置规则"></a>配置规则</h3><p>新建<code>jail.local</code>来覆盖fail2ban的一些默认规则：</p><pre><code class="hljs">#新建配置vi /etc/fail2ban/jail.local#默认配置[DEFAULT]ignoreip = 127.0.0.1/8bantime  = 86400findtime = 600maxretry = 5#这里banaction必须用firewallcmd-ipset,这是fiewalll支持的关键，如果是用Iptables请不要这样填写banaction = firewallcmd-ipsetaction = %(action_mwl)s</code></pre><ul><li>  ignoreip：IP白名单，白名单中的IP不会屏蔽，可填写多个以（,）分隔</li><li>  bantime：屏蔽时间，单位为秒（s）</li><li>  findtime：时间范围</li><li>  maxretry：最大次数</li><li>  banaction：屏蔽IP所使用的方法，上面使用firewalld屏蔽端口</li></ul><h3 id="防止SSH爆破"><a href="#防止SSH爆破" class="headerlink" title="防止SSH爆破"></a>防止SSH爆破</h3><p>如果您还在使用默认SSH端口（22），可能每天都会被扫描，强烈建议先参考《<a href="https://blog.xiaoz.org/archives/8223">Linux服务器之登录安全</a>》加强服务器防护，或者可以使用fail2ban将恶意IP屏蔽。</p><p>继续修改<code>jail.local</code>这个配置文件，在后面追加如下内容：</p><pre><code class="hljs">[sshd]enabled = truefilter  = sshdport    = 22action = %(action_mwl)slogpath = /var/log/secure</code></pre><ul><li>  [sshd]：名称，可以随便填写</li><li>  filter：规则名称，必须填写位于<code>filter.d</code>目录里面的规则，sshd是fail2ban内置规则</li><li>  port：对应的端口</li><li>  action：采取的行动</li><li>  logpath：需要监视的日志路径</li></ul><p>到这一步，我们<code>jail.local</code>的规则看起来可能像下面这样子：</p><pre><code class="hljs">[DEFAULT]ignoreip = 127.0.0.1/8bantime  = 86400findtime = 600maxretry = 5banaction = firewallcmd-ipsetaction = %(action_mwl)s[sshd]enabled = truefilter  = sshdport    = 22action = %(action_mwl)slogpath = /var/log/secure</code></pre><p>上面的配置意思是如果同一个IP，在10分钟内，如果连续超过5次错误，则使用Firewalld将他IP ban了。输入<code>systemctl start fail2ban</code>启动fail2ban来试试效果。</p><p>使用另一台服务器不断尝试连接SSH，并且不断的将密码输入错误，你会发现连续超过5次后直接连不上，说明IP被ban了，可以输入：<code>fail2ban-client status sshd</code>查看被ban的IP，如下截图。</p><p><img src="img_1.png"></p><h3 id="防止CC攻击"><a href="#防止CC攻击" class="headerlink" title="防止CC攻击"></a>防止CC攻击</h3><p>这里仅以Nginx为例，使用fail2ban来监视nginx日志，匹配短时间内频繁请求的IP，并使用firewalld将其IP屏蔽，达到CC防护的作用。</p><pre><code class="hljs">#需要先新建一个nginx日志匹配规则vi /etc/fail2ban/filter.d/nginx-cc.conf#填写如下内容[Definition]failregex = &lt;HOST&gt; -.*- .*HTTP/1.* .* .*$ignoreregex =</code></pre><p>继续修改<code>vi /etc/fail2ban/jail.local</code>追加如下内容：</p><pre><code class="hljs">[nginx-cc]enabled = trueport = http,httpsfilter = nginx-ccaction = %(action_mwl)smaxretry = 20findtime = 60bantime = 3600logpath = /usr/local/nginx/logs/access.log</code></pre><p>上面的配置意思是如果在60s内，同一IP达到20次请求，则将其IP ban 1小时，上面只是为了测试，请根据自己的实际情况修改。logpath为nginx日志路径。</p><h3 id="防止Wordpress爆破"><a href="#防止Wordpress爆破" class="headerlink" title="防止Wordpress爆破"></a>防止Wordpress爆破</h3><p>如果您经常分析日志会发现有大量机器人在扫描wordpress登录页面<code>wp-login.php</code>，虽然对方可能没成功，但是为了避免万一还是将他IP干掉为好。</p><pre><code class="hljs">#需要先新建一个nginx日志匹配规则vi /etc/fail2ban/filter.d/wordpress.conf#填写如下内容[Definition]failregex = ^&lt;HOST&gt; -.* /wp-login.php.* HTTP/1\..&quot;ignoreregex =</code></pre><p>继续修改<code>jail.local</code>追加如下内容：</p><pre><code class="hljs">[wordpress]enabled = trueport = http,httpsfilter = wordpressaction = %(action_mwl)smaxretry = 20findtime = 60bantime = 3600logpath = /usr/local/nginx/logs/access.log</code></pre><p>当然，别忘记输入<code>systemctl restart fail2ban</code>重启fail2ban使其生效。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><pre><code class="hljs">#启动systemctl start fail2ban#停止systemctl stop fail2ban#开机启动systemctl enable fail2ban#查看被ban IP，其中sshd为名称，比如上面的[wordpress]fail2ban-client status sshd#删除被ban IPfail2ban-client set sshd unbanip 192.168.111.111#查看日志tail /var/log/fail2ban.log</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>fail2ban已经内置很多匹配规则，位于<code>filter.d</code>目录下，包含了常见的SSH/FTP/Nginx/Apache等日志匹配，如果都还无法满足您的需求，您也可以自行新建规则来匹配异常IP。使用fail2ban + Firewalld来阻止恶意IP是行之有效的办法，可极大提高服务器安全。</p><blockquote><p>此文部分内容参考了：<a href="https://www.ifshow.com/centos-7-install-fail2ban-with-firewalld-to-defend-brute-force-password/" title="CentOS 7安装Fail2ban防御暴力破解密码（配合FirewallD）">CentOS 7安装Fail2ban防御暴力破解密码（配合FirewallD）</a>  </p></blockquote><h3 id="references"><a href="#references" class="headerlink" title="references"></a>references</h3><ul><li><a href="https://blog.xiaoz.org/archives/9831">CentOS 7安装fail2ban + Firewalld防止爆破与CC攻击</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>firewalld</tag>
      
      <tag>fail2ban</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CAS单点登录原理解析</title>
    <link href="/2023/11/27/CAS%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/11/27/CAS%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><img src="./img.png" alt="CAS单点登录"></p><p><img src="./img_1.png" alt="CAS单点登录"></p><p>CAS（Central Authentication Service）是一种单点登录（Single Sign-On）协议和认证系统。它的工作原理如下：</p><ol><li>用户访问一个需要认证的应用程序（称为服务提供者）。</li><li>服务提供者检测到用户未经认证，将用户重定向到 CAS 服务器。</li><li>用户在 CAS 服务器上输入其凭据（例如用户名和密码）进行认证。</li><li>CAS 服务器验证用户凭据的有效性。如果凭据有效，则颁发一个票据（Ticket）给用户。</li><li>CAS 服务器将用户重定向回服务提供者，并将票据作为参数附加在重定向 URL 中。</li><li>服务提供者接收到重定向请求，并从 URL 中获取票据。</li><li>服务提供者将票据发送给 CAS 服务器以验证票据的有效性。</li><li>CAS 服务器验证票据的有效性，并返回一个身份验证成功的响应给服务提供者。</li><li>服务提供者通过接受 CAS 服务器的响应来确认用户的身份，并为用户提供相应的服务。</li></ol><p>在 CAS 单点登录中，CAS 服务器充当身份验证的中心，负责验证用户的凭据并颁发票据。服务提供者负责检测用户是否已经认证，并将用户重定向到 CAS 服务器以进行认证。通过这种方式，用户只需要在 CAS 服务器上进行一次认证，然后就可以在多个服务提供者应用程序中无需再次输入凭据进行访问。</p><p>CAS 协议基于 OAuth 2.0 授权框架，使用了重定向和票据的方式来实现单点登录。它提供了一种安全、可扩展的认证解决方案，广泛应用于各种 Web 应用程序和系统中。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://juejin.cn/post/6844903651320791048">终于搞明白了，CAS单点登录原理解析！！</a></li><li><a href="https://ushell.me/2019/05/25/CAS%E5%8D%8F%E8%AE%AE/">CAS协议</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cas</tag>
      
      <tag>单点登录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟线程极简入门</title>
    <link href="/2023/11/21/java/%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E6%9E%81%E7%AE%80%E5%85%A5%E9%97%A8/"/>
    <url>/2023/11/21/java/%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E6%9E%81%E7%AE%80%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是虚拟线程？"><a href="#什么是虚拟线程？" class="headerlink" title="什么是虚拟线程？"></a>什么是虚拟线程？</h2><p>虚拟线程（Virtual Thread）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），由 JVM 调度。许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。</p><h2 id="虚拟线程和平台线程有什么关系？"><a href="#虚拟线程和平台线程有什么关系？" class="headerlink" title=" 虚拟线程和平台线程有什么关系？"></a> 虚拟线程和平台线程有什么关系？</h2><p>在引入虚拟线程之前，<code>java.lang.Thread</code> 包已经支持所谓的平台线程（Platform Thread），也就是没有虚拟线程之前，我们一直使用的线程。JVM 调度程序通过平台线程（载体线程）来管理虚拟线程，一个平台线程可以在不同的时间执行不同的虚拟线程（多个虚拟线程挂载在一个平台线程上），当虚拟线程被阻塞或等待时，平台线程可以切换到执行另一个虚拟线程。</p><p>虚拟线程、平台线程和系统内核线程的关系图如下所示（图源：<a href="https://medium.com/javarevisited/how-to-use-java-19-virtual-threads-c16a32bad5f7">How to Use Java 19 Virtual Threadsopen in new window</a>）：</p><p><img src="img.png" alt="虚拟线程、平台线程和系统内核线程的关系"></p><p>关于平台线程和系统内核线程的对应关系多提一点：在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，也就是一个平台线程对应一个系统内核线程。Solaris 系统是一个特例，HotSpot VM 在 Solaris 上支持多对多和一对一。具体可以参考 R 大的回答: <a href="https://www.zhihu.com/question/23096638/answer/29617153">JVM 中的线程模型是用户级的么？open in new window</a>。</p><h2 id="虚拟线程有什么优点和缺点？"><a href="#虚拟线程有什么优点和缺点？" class="headerlink" title=" 虚拟线程有什么优点和缺点？"></a> 虚拟线程有什么优点和缺点？</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>  非常轻量级：可以在单个线程中创建成百上千个虚拟线程而不会导致过多的线程创建和上下文切换。</li><li>  简化异步编程： 虚拟线程可以简化异步编程，使代码更易于理解和维护。它可以将异步代码编写得更像同步代码，避免了回调地狱（Callback Hell）。</li><li>  减少资源开销： 相比于操作系统线程，虚拟线程的资源开销更小。本质上是提高了线程的执行效率，从而减少线程资源的创建和上下文切换。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>  不适用于计算密集型任务： 虚拟线程适用于 I/O 密集型任务，但不适用于计算密集型任务，因为密集型计算始终需要 CPU 资源作为支持。</li><li>  依赖于语言或库的支持： 协程需要编程语言或库提供支持。不是所有编程语言都原生支持协程。比如 Java 实现的虚拟线程。</li></ul><h2 id="四种创建虚拟线程的方法"><a href="#四种创建虚拟线程的方法" class="headerlink" title="四种创建虚拟线程的方法"></a>四种创建虚拟线程的方法</h2><p>Java 21 已经正式支持虚拟线程，大家可以在官网下载使用，在使用上官方为了降低使用门槛，尽量复用原有的 <code>Thread</code> 类，让大家可以更加平滑的使用。</p><p>官方提供了以下四种方式创建虚拟线程：</p><ol><li> 使用 <code>Thread.startVirtualThread()</code> 创建</li><li> 使用 <code>Thread.ofVirtual()</code> 创建</li><li> 使用 <code>ThreadFactory</code> 创建</li></ol><h4 id="使用-Thread-startVirtualThread-创建"><a href="#使用-Thread-startVirtualThread-创建" class="headerlink" title="使用 Thread.startVirtualThread()创建"></a>使用 Thread.startVirtualThread()创建</h4><pre><code class="hljs">public class VirtualThreadTest &#123;   public static void main(String[] args) &#123;     CustomThread customThread = new CustomThread();    Thread.startVirtualThread(customThread);   &#125;&#125;static class CustomThread implements Runnable &#123;   @Override   public void run() &#123;     System.out.println(&quot;CustomThread run&quot;);   &#125; &#125;</code></pre><h4 id="使用-Thread-ofVirtual-创建"><a href="#使用-Thread-ofVirtual-创建" class="headerlink" title="使用 Thread.ofVirtual()创建"></a>使用 Thread.ofVirtual()创建</h4><pre><code class="hljs">public class VirtualThreadTest &#123;    public static void main(String[] args) &#123;     CustomThread customThread = new CustomThread();    // 创建不启动    Thread unStarted = Thread.ofVirtual().unstarted(customThread);    unStarted.start();     // 创建直接启动    Thread.ofVirtual().start(customThread);   &#125;&#125;static class CustomThread implements Runnable &#123;   @Override  public void run() &#123;     System.out.println(&quot;CustomThread run&quot;);   &#125;&#125;</code></pre><h4 id="使用-ThreadFactory-创建"><a href="#使用-ThreadFactory-创建" class="headerlink" title="使用 ThreadFactory 创建"></a>使用 ThreadFactory 创建</h4><pre><code class="hljs">public class VirtualThreadTest &#123;   public static void main(String[] args) &#123;     CustomThread customThread = new CustomThread();    ThreadFactory factory = Thread.ofVirtual().factory();    Thread thread = factory.newThread(customThread);    thread.start();   &#125;&#125;static class CustomThread implements Runnable &#123;  @Override  public void run() &#123;    System.out.println(&quot;CustomThread run&quot;);  &#125;&#125;</code></pre><h4 id="使用-Executors-newVirtualThreadPerTaskExecutor-创建"><a href="#使用-Executors-newVirtualThreadPerTaskExecutor-创建" class="headerlink" title="使用 Executors.newVirtualThreadPerTaskExecutor()创建"></a>使用 Executors.newVirtualThreadPerTaskExecutor()创建</h4><pre><code class="hljs">public class VirtualThreadTest &#123;  public static void main(String[] args) &#123;    CustomThread customThread = new CustomThread();    ExecutorService executor = Executors.newVirtualThreadPerTaskExecutor();    executor.submit(customThread);  &#125;&#125;static class CustomThread implements Runnable &#123;  @Override  public void run() &#123;    System.out.println(&quot;CustomThread run&quot;);  &#125; &#125;</code></pre><h2 id="虚拟线程和平台线程性能对比"><a href="#虚拟线程和平台线程性能对比" class="headerlink" title="虚拟线程和平台线程性能对比"></a>虚拟线程和平台线程性能对比</h2><p>通过多线程和虚拟线程的方式处理相同的任务，对比创建的系统线程数和处理耗时。</p><p><strong>说明</strong>：统计创建的系统线程中部分为后台线程（比如 GC 线程），两种场景下都一样，所以并不影响对比。</p><p><strong>测试代码</strong>：</p><pre><code class="hljs">public class VirtualThreadTest &#123;    static List&lt;Integer&gt; list = new ArrayList&lt;&gt;();    public static void main(String[] args) &#123;        // 开启线程 统计平台线程数        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(1);        scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;            ThreadMXBean threadBean = ManagementFactory.getThreadMXBean();            ThreadInfo[] threadInfo = threadBean.dumpAllThreads(false, false);            updateMaxThreadNum(threadInfo.length);        &#125;, 10, 10, TimeUnit.MILLISECONDS);        long start = System.currentTimeMillis();        // 虚拟线程        ExecutorService executor =  Executors.newVirtualThreadPerTaskExecutor();        // 使用平台线程        // ExecutorService executor =  Executors.newFixedThreadPool(200);        for (int i = 0; i &lt; 10000; i++) &#123;            executor.submit(() -&gt; &#123;                try &#123;                    // 线程睡眠 0.5 s，模拟业务处理                    TimeUnit.MILLISECONDS.sleep(500);                &#125; catch (InterruptedException ignored) &#123;                &#125;            &#125;);        &#125;        executor.close();        System.out.println(&quot;max：&quot; + list.get(0) + &quot; platform thread/os thread&quot;);        System.out.printf(&quot;totalMillis：%dms\n&quot;, System.currentTimeMillis() - start);    &#125;    // 更新创建的平台最大线程数    private static void updateMaxThreadNum(int num) &#123;        if (list.isEmpty()) &#123;            list.add(num);        &#125; else &#123;            Integer integer = list.get(0);            if (num &gt; integer) &#123;                list.add(0, num);            &#125;        &#125;    &#125;&#125;</code></pre><p><strong>请求数 10000 单请求耗时 1s</strong>：</p><pre><code class="hljs">// Virtual Threadmax：22 platform thread/os threadtotalMillis：1806ms// Platform Thread  线程数200max：209 platform thread/os threadtotalMillis：50578ms// Platform Thread  线程数500max：509 platform thread/os threadtotalMillis：20254ms// Platform Thread  线程数1000max：1009 platform thread/os threadtotalMillis：10214ms// Platform Thread  线程数2000max：2009 platform thread/os threadtotalMillis：5358ms</code></pre><p><strong>请求数 10000 单请求耗时 0.5s</strong>：</p><pre><code class="hljs">// Virtual Threadmax：22 platform thread/os threadtotalMillis：1316ms// Platform Thread  线程数200max：209 platform thread/os threadtotalMillis：25619ms// Platform Thread  线程数500max：509 platform thread/os threadtotalMillis：10277ms// Platform Thread  线程数1000max：1009 platform thread/os threadtotalMillis：5197ms// Platform Thread  线程数2000max：2009 platform thread/os threadtotalMillis：2865ms</code></pre><ul><li>  可以看到在密集 IO 的场景下，需要创建大量的平台线程异步处理才能达到虚拟线程的处理速度。</li><li>  因此，在密集 IO 的场景，虚拟线程可以大幅提高线程的执行效率，减少线程资源的创建以及上下文切换。</li></ul><p><strong>注意</strong>：有段时间 JDK 一直致力于 Reactor 响应式编程来提高 Java 性能，但响应式编程难以理解、调试、使用，最终又回到了同步编程，最终虚拟线程诞生。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://javaguide.cn/java/concurrent/virtual-thread.html">虚拟线程极简入门</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>虚线程</tag>
      
      <tag>java21</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java编译到执行的过程</title>
    <link href="/2023/11/17/java/Java%E7%BC%96%E8%AF%91%E5%88%B0%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <url>/2023/11/17/java/Java%E7%BC%96%E8%AF%91%E5%88%B0%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>面试官</strong>：今天从基础先问起吧，<strong>你是怎么理解Java是一门「跨平台」的语言，也就是「一次编译，到处运行的」？</strong></p><p><strong>候选者</strong>：很好理解啊，因为我们有JVM。</p><p><strong>候选者</strong>：Java源代码会被编译为class文件，class文件是运行在JVM之上的。</p><p><strong>候选者</strong>：当我们日常开发安装JDK的时候，可以发现JDK是分「不同的操作系统」，JDK里是包含JVM的，所以Java依赖着JVM实现了『跨平台』</p><p><strong>候选者</strong>：JVM是面向操作系统的，它负责把Class字节码解释成系统所能识别的指令并执行，同时也负责程序运行时内存的管理。</p><p><img src="https://p.ipic.vip/izyyrd.jpg"></p><p><strong>面试官</strong>：<strong>那要不你来聊聊从源码文件(.java)到代码执行的过程呗？</strong></p><p><strong>候选者</strong>：嗯，没问题的</p><p><strong>候选者</strong>：简单总结的话，我认为就4个步骤：编译-&gt;加载-&gt;解释-&gt;执行</p><p><strong>候选者</strong>：编译：将源码文件编译成JVM可以解释的class文件。</p><p><strong>候选者</strong>：编译过程会对源代码程序做 「语法分析」「语义分析」「注解处理」等等处理，最后才生成字节码文件。</p><p><strong>候选者</strong>：比如对泛型的擦除和我们经常用的Lombok就是在编译阶段干的。</p><p><img src="https://p.ipic.vip/8ih2mf.jpg"></p><p><strong>候选者</strong>：加载：将编译后的class文件加载到JVM中。</p><p><strong>候选者</strong>：在加载阶段又可以细化几个步骤：装载-&gt;连接-&gt;初始化</p><p><strong>候选者</strong>：下面我对这些步骤又细说下哈。</p><p><img src="https://p.ipic.vip/etud79.jpg"></p><p><strong>候选者</strong>：【装载时机】为了节省内存的开销，并不会一次性把所有的类都装载至JVM，而是等到「有需要」的时候才进行装载（比如new和反射等等）</p><p><strong>候选者</strong>：【装载发生】class文件是通过「类加载器」装载到jvm中的，为了防止内存中出现多份同样的字节码，使用了双亲委派机制（它不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上）</p><p><strong>候选者</strong>：【装载规则】JDK 中的本地方法类一般由根加载器（Bootstrp loader）装载，JDK 中内部实现的扩展类一般由扩展加载器（ExtClassLoader ）实现装载，而程序中的类文件则由系统加载器（AppClassLoader ）实现装载。</p><p><strong>候选者</strong>：装载这个阶段它做的事情可以总结为：查找并加载类的二进制数据，在JVM「堆」中创建一个java.lang.Class类的对象，并将类相关的信息存储在JVM「方法区」中</p><p><strong>面试官</strong>：嗯…</p><p><strong>候选者</strong>：通过「装载」这个步骤后，现在已经把class文件装载到JVM中了，并创建出对应的Class对象以及类信息存储至方法区了。</p><p><strong>候选者</strong>：「连接」这个阶段它做的事情可以总结为：对class的信息进行验证、为「类变量」分配内存空间并对其赋默认值。</p><p><strong>候选者</strong>：连接又可以细化为几个步骤：验证-&gt;准备-&gt;解析</p><p><strong>候选者</strong>：1. 验证：验证类是否符合 Java 规范和 JVM 规范</p><p><strong>候选者</strong>：2. 准备：为类的静态变量分配内存，初始化为系统的初始值</p><p><strong>候选者</strong>：3. 解析：将符号引用转为直接引用的过程</p><p><strong>面试官</strong>：嗯…</p><p><strong>候选者</strong>：通过「连接」这个步骤后，现在已经对class信息做校验并分配了内存空间和默认值了。</p><p><strong>候选者</strong>：接下来就是「初始化」阶段了，这个阶段可以总结为：为类的静态变量赋予正确的初始值。</p><p><strong>候选者</strong>：过程大概就是收集class的静态变量、静态代码块、静态方法至()方法，随后从上往下开始执行。</p><p><strong>候选者</strong>：如果「实例化对象」则会调用方法对实例变量进行初始化，并执行对应的构造方法内的代码。</p><p><img src="https://p.ipic.vip/boqkgm.jpg"></p><p><strong>候选者</strong>：扯了这么多，现在其实才完成至(编译-&gt;加载-&gt;解释-&gt;执行)中的加载阶段，下面就来说下【解释阶段】做了什么</p><p><strong>候选者</strong>：初始化完成之后，当我们尝试执行一个类的方法时，会找到对应方法的字节码的信息，然后解释器会把字节码信息解释成系统能识别的指令码。</p><p><strong>候选者</strong>：「解释」这个阶段它做的事情可以总结为：把字节码转换为操作系统识别的指令</p><p><strong>候选者</strong>：在解释阶段会有两种方式把字节码信息解释成机器指令码，一个是字节码解释器、一个是即时编译器(JIT)。</p><p><img src="https://p.ipic.vip/2suk8c.jpg"></p><p><strong>候选者</strong>：JVM会对「热点代码」做编译，非热点代码直接进行解释。当JVM发现某个方法或代码块的运行特别频繁的时候，就有可能把这部分代码认定为「热点代码」</p><p><strong>候选者</strong>：使用「热点探测」来检测是否为热点代码。「热点探测」一般有两种方式，计数器和抽样。HotSpot使用的是「计数器」的方式进行探测，为每个方法准备了两类计数器：方法调用计数器和回边计数器</p><p><strong>候选者</strong>：这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译。</p><p><strong>候选者</strong>：即时编译器把热点方法的指令码保存起来，下次执行的时候就无需重复的进行解释，直接执行缓存的机器语言</p><p><strong>面试官</strong>：嗯…</p><p><strong>候选者</strong>：解释阶段结束后，最后就到了执行阶段。</p><p><strong>候选者</strong>：「执行」这个阶段它做的事情可以总结为：操作系统把解释器解析出来的指令码，调用系统的硬件执行最终的程序指令。</p><p><strong>候选者</strong>：上面就是我对从源码文件(.java)到代码执行的过程的理解了。</p><p><strong>面试官</strong>：嗯…我还想问下你刚才提到的双亲委派模型…</p><p><strong>候选者</strong>：下次一定！</p><p><img src="https://p.ipic.vip/89ndlk.jpg"></p><p>本文总结：</p><ul><li>  Java跨平台因为有JVM屏蔽了底层操作系统</li><li>Java源码到执行的过程，从JVM的角度看可以总结为四个步骤：编译-&gt;加载-&gt;解释-&gt;执行<ul><li>  「编译」经过 语法分析、语义分析、注解处理 最后才生成会class文件</li><li>  「加载」又可以细分步骤为：装载-&gt;连接-&gt;初始化。装载则把class文件装载至JVM，连接则校验class信息、分配内存空间及赋默认值，初始化则为变量赋值为正确的初始值。连接里又可以细化为：验证、准备、解析</li><li>  「解释」则是把字节码转换成操作系统可识别的执行指令，在JVM中会有字节码解释器和即时编译器。在解释时会对代码进行分析，查看是否为「热点代码」，如果为「热点代码」则触发JIT编译，下次执行时就无需重复进行解释，提高解释速度</li><li>  「执行」调用系统的硬件执行最终的程序指令</li></ul></li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://javainterview.gitee.io/luffy/2021/08/19/04-Java%E8%99%9A%E6%8B%9F%E6%9C%BA/01.%20Java%E7%BC%96%E8%AF%91%E5%88%B0%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B/">01. Java编译到执行的过程</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>编译</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中equals和hashCode理解</title>
    <link href="/2023/10/17/java/Java%E4%B8%ADequals%E5%92%8ChashCode%E7%90%86%E8%A7%A3/"/>
    <url>/2023/10/17/java/Java%E4%B8%ADequals%E5%92%8ChashCode%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>在Java中，<code>equals()</code>和<code>equals()</code>是两个常用的方法，用于处理对象的相等性和哈希码。</p><p><code>equals()</code>方法是用于比较两个对象是否相等。默认情况下，它比较的是对象的引用是否相同，即是否指向同一个内存地址。然而，通常我们需要根据对象的内容来判断它们是否相等。因此，我们可以在类中重写<code>equals()</code>方法，根据自定义的逻辑来比较对象的内容。重写<code>equals()</code>方法时，通常还需要重写<code>hashCode()</code>方法。</p><p><code>hashCode()</code>方法返回对象的哈希码，它是一个整数值。哈希码用于在哈希表等数据结构中快速查找对象。在重写<code>equals()</code>方法时，根据对象的内容来判断相等性，需要保证相等的对象具有相同的哈希码。因此，当重写<code>equals()</code>方法时，也需要同时重写<code>hashCode()</code>方法，以确保相等的对象具有相同的哈希码。</p><p>在重写<code>equals()</code>和<code>hashCode()</code>方法时，需要遵循一些规则：</p><ol><li>如果两个对象相等（根据自定义的相等逻辑），它们的哈希码必须相等。</li><li>如果两个对象的哈希码相等，它们不一定相等（根据自定义的相等逻辑）。</li></ol><p>这些方法的正确实现可以确保对象在集合类（如<code>HashSet</code>、<code>HashMap</code>等）中的正确行为，例如正确查找、删除和比较对象。</p><p>总而言之，<code>equals()</code>方法用于比较对象的内容是否相等，而<code>hashCode()</code>方法用于计算对象的哈希码，以支持高效的数据结构操作。在重写这两个方法时，需要保证它们的行为一致，以避免潜在的问题。</p>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>equals</tag>
      
      <tag>hashCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java面向对象理解</title>
    <link href="/2023/10/17/java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%A7%A3/"/>
    <url>/2023/10/17/java/Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>⾯向对象因为有了封装继承多态的特性，可以设计出低耦合的系统，使得系统更灵活、容易维护。</p><ul><li>封装是指封装成抽象的类，并且对于可信的类或者对象，是可以操作的，对于不可信的进⾏隐藏。</li><li>继承是指可以使⽤现有类的所有功能，⽽且还可以在现有功能的基础上做拓展。</li><li>多态是基于继承的，他是指⽗类中定义的属性和⽅法被⼦类继承之后，可以具有不同的数据类型或者表现出不同的⾏为，使得同⼀个属性在⽗类及其⼦类中具有不同的含义。</li></ul><p>重载就是多态的⼀个例⼦，是编译时的多态。其实我们所说的多态是运⾏时多态，也就是说编译的时候不确定调⽤哪个具体⽅法，⼀直延迟到运⾏时才可以确定，所以多态又叫延迟⽅法。</p><p>Jva实现多态有3个必要条件：继承、重写和向上转型。只有满足这3个条件，开发人员才能够在同一个继承结构中使用统一的逻辑实现代码处理不同的对象，从而执行不同的行为。</p><ul><li>继承：在多态中必须存在有继承关系的子类和父类。</li><li>重写：子类对父类中某些方法进行重新定义，在调用这些方法时就会调用子类的方法。</li><li>向上转型：在多态中需要将子类的引用赋给父类对象，只有这样该引用才既能可以调用父类的方法，又能调用子类的方法。</li></ul><p>重载和重写都是实现多态的⽅式，区别是啥？</p><blockquote><p>区别在于重载是编译时多态，重写是运⾏时多态。</p></blockquote><ul><li>重载(overloading)是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。<br>最常用的地方就是构造器的重载。</li><li>重写发生在子类与父类之间，重写方法返回值和形参都不能改变，与方法返回值和访问修饰符无关，即重载的方法不能根据返回类型进行区分。即外壳不变，核心重写！</li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>多态</tag>
      
      <tag>继承</tag>
      
      <tag>重写</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>新华三 NX30 PRO 关闭IPV6防火墙</title>
    <link href="/2023/10/13/other/%E6%96%B0%E5%8D%8E%E4%B8%89NX30PRO%E5%85%B3%E9%97%ADIPV6%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    <url>/2023/10/13/other/%E6%96%B0%E5%8D%8E%E4%B8%89NX30PRO%E5%85%B3%E9%97%ADIPV6%E9%98%B2%E7%81%AB%E5%A2%99/</url>
    
    <content type="html"><![CDATA[<blockquote><p>也可直接通过微信客服找默认关闭ipv6的固件下载升级即可</p></blockquote><p>最近入手了新华三NX30PRO，发现没法IPV6远程电脑，就去问了下官方的客服，然后给出了NX15的开启方案，我试了一下可行，但是还是有点区别。</p><h2 id="1-确认路由器IP地址"><a href="#1-确认路由器IP地址" class="headerlink" title="1. 确认路由器IP地址"></a>1. 确认路由器IP地址</h2><p>用电脑连接NX30PRO的网络，确认自己的路由器IP，也就是后台地址，官方默认的是 <code>192.168.124.1</code></p><blockquote><p>注意如果是<code>mesh</code>组网需要在子路由上重复操作</p></blockquote><h2 id="2-进入telnet"><a href="#2-进入telnet" class="headerlink" title="2. 进入telnet"></a>2. 进入telnet</h2><p>打开CMD命令，输入命令 <code>telnet+空格+IP+空格+99</code>，<code>99</code>是端口号<br>如果是官方默认的<code>192.168.124.1</code>，输入命令</p><pre><code class="hljs">telnet 192.168.124.1 99</code></pre><p>否则根据自己的后台地址输入，比如我自己的是<code>192.168.123.1</code>,就输入</p><pre><code class="hljs">telnet 192.168.123.1 99</code></pre><p>然后回车，后面会让输入用户名和密码 用户名是 H3C 密码是路由器后台的登录密码  </p><p>输入后回车，登录成功  </p><h2 id="3-防火墙放行"><a href="#3-防火墙放行" class="headerlink" title="3. 防火墙放行"></a>3. 防火墙放行</h2><p>然后输入两行防火墙放行IPV6的命令，注意大小写不要错了</p><pre><code class="hljs">ip6tables -Fip6tables -Xip6tables -P INPUT ACCEPTip6tables -P OUTPUT ACCEPTip6tables -P FORWARD ACCEPT</code></pre><p>执行命令时中间可能会出现下面的提示，忽略即可</p><blockquote><p>ip6tables bad rule (does a matching rule exist in that chain )</p></blockquote><h2 id="4-持久化防火墙配置"><a href="#4-持久化防火墙配置" class="headerlink" title="4. 持久化防火墙配置"></a>4. 持久化防火墙配置</h2><p>路由器重启ip6tables配置的内容会失效,可以使用下面的方法持久化<br>输入命令保存防火墙规则</p><pre><code class="hljs">ip6tables-save &gt; /etc/firewall.user</code></pre><p>然后使用命令编辑 <code>vi /etc/rc.local</code><br>进入后输入 <code>i</code> 进入编辑模式<br>然后添加一行内容</p><pre><code class="hljs">ip6tables-restore &lt; /etc/firewall.user</code></pre><p>然后按 <code>ESC</code> 再输入 <code>:wq</code> 保存退出</p><p>后续路由器重启也会自动恢复配置的IPV6规则了</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="获取到了-ipv6-地址，为什么不能通过公网访问？"><a href="#获取到了-ipv6-地址，为什么不能通过公网访问？" class="headerlink" title="获取到了 ipv6 地址，为什么不能通过公网访问？"></a>获取到了 ipv6 地址，为什么不能通过公网访问？</h3><ul><li>光猫改成桥接，并且开启 ipv6 选项</li><li>路由器打开 ipv6 功能，并关闭路由器 ipv6 的防火墙，大多数路由器的 ipv6 入站都是关着的，而且好多路由器不能改</li><li>此时一切正常的话，电脑上就已经分配 ipv6 的地址了，<a href="http://test-ipv6.com/">http://test-ipv6.com</a> 可以测</li><li>找一台手机，打开 <a href="http://test-ipv6.com/">http://test-ipv6.com</a> 如果也是 ipv6 的话，就可以通过 ipv6 地址访问了<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2></li><li><a href="https://www.bzqll.com/2023/05/367.html">新华三 NX30 PRO 关闭IPV6防火墙</a></li><li><a href="https://www.v2ex.com/t/814699">获取到了 ipv6 地址，为什么不能通过公网访问？</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>H3C NX30Pro</tag>
      
      <tag>路由器</tag>
      
      <tag>ipv6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>openwrt</title>
    <link href="/2023/10/08/other/openwrt/"/>
    <url>/2023/10/08/other/openwrt/</url>
    
    <content type="html"><![CDATA[<h2 id="通过命令安装-aliyundrive-webdav"><a href="#通过命令安装-aliyundrive-webdav" class="headerlink" title="通过命令安装 aliyundrive-webdav"></a>通过命令安装 aliyundrive-webdav</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/messense/aliyundrive-webdav/releases/download/v2.3.3/aliyundrive-webdav_2.3.3-1_aarch64_generic.ipk<br>wget https://github.com/messense/aliyundrive-webdav/releases/download/v2.3.3/luci-app-aliyundrive-webdav_2.3.3_all.ipk<br>wget https://github.com/messense/aliyundrive-webdav/releases/download/v2.3.3/luci-i18n-aliyundrive-webdav-zh-cn_2.3.3-1_all.ipk<br>opkg install aliyundrive-webdav_2.3.3-1_aarch64_generic.ipk<br>opkg install luci-app-aliyundrive-webdav_2.3.3_all.ipk<br>opkg install luci-i18n-aliyundrive-webdav-zh-cn_2.3.3-1_all.ipk<br></code></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://github.com/messense/aliyundrive-webdav">aliyundrive-webdav</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>openwrt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis核心技术与实战</title>
    <link href="/2023/10/08/redis/Redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
    <url>/2023/10/08/redis/Redis%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<p>Redis数据类型和底层数据结构的对应关系<br><img src="img.png"></p><p><img src="img_2.png"></p><p>渐进式rehash<br><img src="img_1.png"></p><h2 id="单线程Redis为什么那么快"><a href="#单线程Redis为什么那么快" class="headerlink" title="单线程Redis为什么那么快"></a>单线程Redis为什么那么快</h2><p>一方面，Rdis的大部分操作在内存上完成，再加上它采用了高效的数据结构，例如哈希表和跳表，这是它实现高性能的一个重要原因。<br>另一方面，就是Rdis采用了多路复用机制，使其在网络IO操作中能并发处理大量的客户端请求，实现高吞吐率。</p><h2 id="AOF配置项appendfsync-的三个可选值-即三种写回策略"><a href="#AOF配置项appendfsync-的三个可选值-即三种写回策略" class="headerlink" title="AOF配置项appendfsync 的三个可选值,即三种写回策略"></a>AOF配置项appendfsync 的三个可选值,即三种写回策略</h2><ul><li><strong>Always</strong> 同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</li><li><strong>Everysec</strong> 每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</li><li><strong>No</strong> 操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</li></ul><p><img src="img_3.png"></p><blockquote><p>日志文件太大了怎么办-&gt;AOF重写机制(重写过程是由后台线程 bgrewriteaof 来完成的，这也是为了避免阻塞主线程)<br><img src="img_4.png"></p></blockquote><p><img src="img_5.png"></p><p>Redis 对事务原子性属性的保证情况:</p><ul><li>命令入队时就报错，会放弃事务执行，保证原子性；</li><li>命令入队时没报错，实际执行时报错，不保证原子性；</li><li>EXEC 命令执行时实例故障，如果开启了 AOF 日志，可以保证原子性</li></ul><p><img src="img_6.png"></p>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
      <category>极客时间</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从零开始带你成为MySQL实战优化高手</title>
    <link href="/2023/09/28/mysql/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%B8%A6%E4%BD%A0%E6%88%90%E4%B8%BAMySQL%E5%AE%9E%E6%88%98%E4%BC%98%E5%8C%96%E9%AB%98%E6%89%8B/"/>
    <url>/2023/09/28/mysql/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%B8%A6%E4%BD%A0%E6%88%90%E4%B8%BAMySQL%E5%AE%9E%E6%88%98%E4%BC%98%E5%8C%96%E9%AB%98%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<p>redo日志刷盘策略: <code>innodb_flush_log_at_trx_commit</code> 0/1/2 通常是1,即提交事务的时候，redo日志必须是刷入磁盘文件</p><p>binlog日志刷盘策略: <code>sync_binlog</code>  </p><p><img src="img.png"><br><img src="img_1.png"></p><h2 id="哪些情况下会触发MySQL的预读机制"><a href="#哪些情况下会触发MySQL的预读机制" class="headerlink" title="哪些情况下会触发MySQL的预读机制"></a>哪些情况下会触发MySQL的预读机制</h2><ul><li>有一个参数是<code>innodb_read_ahead_threshold</code>，他的默认值是56，意思就是如果顺序的访问了一个区里的多个 数据页，访问的数据页的数量超过了这个阈值，此时就会触发预读机制，把下一个相邻区中的所有数据页都加载到缓 存里去</li><li>如果Buffer Pool里缓存了一个区里的13个连续的数据页，而且这些数据页都是比较频繁会被访问的，此时就会直接触发预读机制，把这个区里的其他的数据页都加载到缓(这个机制是通过参数<code>innodb_random_read_ahead</code>来控制的，他默认是OFF，也就是这个规则是关闭的)存里去</li></ul><p><code>全表扫描</code>可能导致频繁被访问的缓存页被淘汰</p><h2 id="mysql性能调优"><a href="#mysql性能调优" class="headerlink" title="mysql性能调优"></a>mysql性能调优</h2><p>设置多个Buffer Pool</p><p>#MySQL服务器端的配置。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">[server]<br>innodb_buffer_pool_size = 8589934592<br>innodb_buffer_pool_instances = 4<br></code></pre></td></tr></table></figure><p>我们给buffer pool设置了8GB的总内存，然后设置了他应该有4个Buffer Pool，此时就是说，每个buffer pool的大小就是2GB`</p>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
      <category>儒猿课堂</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jenkins设置针对不同job的用户权限设置</title>
    <link href="/2023/09/28/jenkins/jenkins%E8%AE%BE%E7%BD%AE%E9%92%88%E5%AF%B9%E4%B8%8D%E5%90%8Cjob%E7%9A%84%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE/"/>
    <url>/2023/09/28/jenkins/jenkins%E8%AE%BE%E7%BD%AE%E9%92%88%E5%AF%B9%E4%B8%8D%E5%90%8Cjob%E7%9A%84%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="jenkins设置针对不同job的用户权限设置"><a href="#jenkins设置针对不同job的用户权限设置" class="headerlink" title="jenkins设置针对不同job的用户权限设置"></a>jenkins设置针对不同job的用户权限设置</h1><h2 id="1-在Jenkins安装好后，需要先安装Role-based-Authorization-Strategy-这个插件"><a href="#1-在Jenkins安装好后，需要先安装Role-based-Authorization-Strategy-这个插件" class="headerlink" title="1.在Jenkins安装好后，需要先安装Role-based Authorization Strategy  这个插件"></a>1.在Jenkins安装好后，需要先安装Role-based Authorization Strategy  这个插件</h2><p><img src="https://www.yoyoask.com/wp-content/uploads/2021/09/image.png"></p><h2 id="2-然后在系统管理—-gt-全局安全配置中："><a href="#2-然后在系统管理—-gt-全局安全配置中：" class="headerlink" title="2. 然后在系统管理—&gt;全局安全配置中："></a>2. 然后在系统管理—&gt;全局安全配置中：</h2><p><img src="https://www.yoyoask.com/wp-content/uploads/2021/09/image-1.png"></p><h2 id="3-然后再从系统管理—-gt-Manage-and-Assign-Roles"><a href="#3-然后再从系统管理—-gt-Manage-and-Assign-Roles" class="headerlink" title="3. 然后再从系统管理—&gt;Manage and Assign Roles"></a>3. 然后再从系统管理—&gt;Manage and Assign Roles</h2><p><img src="https://www.yoyoask.com/wp-content/uploads/2021/09/image-2.png"></p><h2 id="4-然后点击Manage-Roles"><a href="#4-然后点击Manage-Roles" class="headerlink" title="4. 然后点击Manage Roles"></a>4. 然后点击Manage Roles</h2><p><img src="https://www.yoyoask.com/wp-content/uploads/2021/09/image-3.png"></p><h2 id="5-然后在item-roles栏目里-新建一个php项目组权限，这个组里包含了php相关的项目。以及所属项目的权限。"><a href="#5-然后在item-roles栏目里-新建一个php项目组权限，这个组里包含了php相关的项目。以及所属项目的权限。" class="headerlink" title="5.然后在item roles栏目里,新建一个php项目组权限，这个组里包含了php相关的项目。以及所属项目的权限。"></a>5.然后在item roles栏目里,新建一个php项目组权限，这个组里包含了php相关的项目。以及所属项目的权限。</h2><p><img src="https://www.yoyoask.com/wp-content/uploads/2021/09/image-12.png"></p><blockquote><p>Pattern正则示例: jianguan.*||mobile||zhuji_web</p></blockquote><p>总结：(系统权限组和项目权限组不搭噶，两码事，这两个不挨着，各是各)</p><p><img src="https://www.yoyoask.com/wp-content/uploads/2021/09/image-11.png"></p><h2 id="6-然后进行分配角色"><a href="#6-然后进行分配角色" class="headerlink" title="6. 然后进行分配角色"></a>6. 然后进行分配角色</h2><p><img src="https://www.yoyoask.com/wp-content/uploads/2021/09/image-5.png"></p><h2 id="7-给新用户分配用户组，没创建用户的，需要创建用户"><a href="#7-给新用户分配用户组，没创建用户的，需要创建用户" class="headerlink" title="7.给新用户分配用户组，没创建用户的，需要创建用户"></a>7.给新用户分配用户组，没创建用户的，需要创建用户</h2><p><img src="https://www.yoyoask.com/wp-content/uploads/2021/09/image-6.png"></p><h2 id="8-添加用户张三，勾选php组权限"><a href="#8-添加用户张三，勾选php组权限" class="headerlink" title="8. 添加用户张三，勾选php组权限"></a>8. 添加用户张三，勾选php组权限</h2><p><img src="https://www.yoyoask.com/wp-content/uploads/2021/09/image-7.png"></p><h2 id="9-给张三配置项目-job-权限"><a href="#9-给张三配置项目-job-权限" class="headerlink" title="9.给张三配置项目(job)权限"></a>9.给张三配置项目(job)权限</h2><p><img src="https://www.yoyoask.com/wp-content/uploads/2021/09/image-8.png"></p><p><img src="https://www.yoyoask.com/wp-content/uploads/2021/09/image-9.png"></p><p>点击保存，然后用zhnagsan的账号登录查看项目</p><p><img src="https://www.yoyoask.com/wp-content/uploads/2021/09/image-10.png"></p><p>可以看到,组内配置的项目对张三可见了</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.yoyoask.com/?p=6668">jenkins设置针对不同job的用户权限设置</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JOOR反射库</title>
    <link href="/2023/09/13/java/JOOR%E5%8F%8D%E5%B0%84%E5%BA%93/"/>
    <url>/2023/09/13/java/JOOR%E5%8F%8D%E5%B0%84%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>JOOR 是什么？</p></blockquote><p>JOOR 是 Java 的一个很好用的反射相关的库。源码地址： <a href="https://github.com/jOOQ/jOOR">https://github.com/jOOQ/jOOR</a></p><h1 id="一、引入依赖"><a href="#一、引入依赖" class="headerlink" title="一、引入依赖"></a>一、引入依赖</h1><p>JOOR有三种实现。如果 maven 作为构建工具：</p><p>对于 Java 6 或者更高版本，可以用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jooq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>joor-java-6<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对于 Java 8 或者更高版本，可以用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jooq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>joor-java-8<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>对于 Java 9 或者更高版本，可以用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jooq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>joor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.9.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>接口都是一样的用，主要是用新版本 Java 特性对代码进行了优化。</p><p>gradle 可以按照类似如下方式引入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">compile group: &#x27;org.jooq&#x27;, name: &#x27;joor-java-8&#x27;, version: &#x27;0.9.7&#x27;<br></code></pre></td></tr></table></figure><h1 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h1><p>首先import Reflect 类下的静态方法（也可以只import Reflect 类）：</p><pre><code class="hljs">import static org.joor.Reflect.*;</code></pre><p>编写一个 NameInterface 接口：</p><pre><code class="hljs">package demo01;public interface NameInterface &#123;    String getName();&#125;</code></pre><p>再写个 Person 类，注意，未实现 NameInterface 接口：</p><pre><code class="hljs">package demo01;@Datapublic class Person &#123;    public static String STATIC_VALUE = &quot;Hello World&quot;;    private String name;    private int score;    public Person() &#123;    &#125;    public Person(String name, int score) &#123;        this.name = name;        this.score = score;    &#125;&#125;</code></pre><h2 id="获取-static-变量"><a href="#获取-static-变量" class="headerlink" title="获取 static 变量"></a>获取 static 变量</h2><pre><code class="hljs">String value = on(Person.class).get(&quot;STATIC_VALUE&quot;);System.out.println(value);</code></pre><p>运行后输出：</p><pre><code class="hljs">Hello World</code></pre><h2 id="设置-static-变量值"><a href="#设置-static-变量值" class="headerlink" title="设置 static 变量值"></a>设置 static 变量值</h2><pre><code class="hljs">on(Person.class).set(&quot;STATIC_VALUE&quot;, &quot;你好&quot;);String value = on(Person.class).get(&quot;STATIC_VALUE&quot;);System.out.println(value);</code></pre><p>运行后输出：</p><pre><code class="hljs">你好</code></pre><h2 id="用有参构造函数初始化一个对象"><a href="#用有参构造函数初始化一个对象" class="headerlink" title="用有参构造函数初始化一个对象"></a>用有参构造函数初始化一个对象</h2><pre><code class="hljs">Person p = on(Person.class).create(&quot;xiaosi&quot;, 99).get();System.out.println(p);</code></pre><p>运行后输出：</p><pre><code class="hljs">Person&#123;name=&#39;xiaosi&#39;, score=99&#125;</code></pre><h2 id="用类的字符串名和它的有参构造函数初始化一个对象"><a href="#用类的字符串名和它的有参构造函数初始化一个对象" class="headerlink" title="用类的字符串名和它的有参构造函数初始化一个对象"></a>用类的字符串名和它的有参构造函数初始化一个对象</h2><pre><code class="hljs">Person p = on(&quot;demo01.Person&quot;).create(&quot;xiaosi&quot;, 99).get();System.out.println(p);</code></pre><p>运行后输出：</p><pre><code class="hljs">Person&#123;name=&#39;xiaosi&#39;, score=99&#125;</code></pre><h2 id="用无参构造函数初始化一个对象"><a href="#用无参构造函数初始化一个对象" class="headerlink" title="用无参构造函数初始化一个对象"></a>用无参构造函数初始化一个对象</h2><pre><code class="hljs">Person p = on(Person.class).create().get();on(p).set(&quot;name&quot;, &quot;xiaosi&quot;);  // 直接给私有变量设值on(p).call(&quot;setScore&quot;, 99);  // 通过set方法给私有变量设值System.out.println(p);</code></pre><p>运行后输出：</p><pre><code class="hljs">Person&#123;name=&#39;xiaosi&#39;, score=99&#125;</code></pre><h2 id="获取-name-字段的值"><a href="#获取-name-字段的值" class="headerlink" title="获取 name 字段的值"></a>获取 name 字段的值</h2><pre><code class="hljs">Person p = on(Person.class).create(&quot;xiaosi&quot;, 99).get();// 方式1String name = on(p).get(&quot;name&quot;);System.out.println(name);// 方式2name = on(p).call(&quot;getName&quot;).get();System.out.println(name);</code></pre><p>运行后输出：</p><pre><code class="hljs">xiaosixiaosi</code></pre><h2 id="调用-addScore-方法，传入参数，获取返回值"><a href="#调用-addScore-方法，传入参数，获取返回值" class="headerlink" title="调用 addScore 方法，传入参数，获取返回值"></a>调用 addScore 方法，传入参数，获取返回值</h2><pre><code class="hljs">Person p = new Person(&quot;xiaosi&quot;, 99);int result = on(p).call(&quot;addScore&quot;, 1).get();System.out.println(result);</code></pre><p>运行后输出：</p><pre><code class="hljs">100</code></pre><h2 id="实现一个-NameInterface-代理对象包装-Person"><a href="#实现一个-NameInterface-代理对象包装-Person" class="headerlink" title="实现一个 NameInterface 代理对象包装 Person"></a>实现一个 NameInterface 代理对象包装 Person</h2><pre><code class="hljs">Person p = new Person(&quot;xiaosi&quot;, 99);NameInterface nameInterface = on(p).as(NameInterface.class);System.out.println(nameInterface instanceof Person); // 返回 falseSystem.out.println(nameInterface instanceof NameInterface); // 返回 trueSystem.out.println(nameInterface.getName());</code></pre><p>运行后输出：</p><pre><code class="hljs">falsetruexiaosi</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://www.letianbiji.com/article/101065.html">Java JOOR 反射库</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JAVA</tag>
      
      <tag>JOOR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>FAQ</title>
    <link href="/2023/09/13/other/FAQ/"/>
    <url>/2023/09/13/other/FAQ/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>FAQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FAQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用docker-compose快速部署Prometheus+grafana环境</title>
    <link href="/2023/09/08/other/%E4%BD%BF%E7%94%A8docker-compose%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2Prometheus+grafana%E7%8E%AF%E5%A2%83/"/>
    <url>/2023/09/08/other/%E4%BD%BF%E7%94%A8docker-compose%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2Prometheus+grafana%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<blockquote><p>注意: docker和docker-compose请自行下载安装</p></blockquote><p>创建相关目录并给予权限，持久化目录需要给777权限，否则容器启动失败</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> ~ &amp;&amp; <span class="hljs-built_in">mkdir</span> prometheus &amp;&amp; <span class="hljs-built_in">chmod</span> 777 prometheus<br><span class="hljs-built_in">cd</span> prometheus &amp;&amp; <span class="hljs-built_in">mkdir</span> grafana_data prometheus_data &amp;&amp; <span class="hljs-built_in">chmod</span> 777 grafana_data prometheus_data<br></code></pre></td></tr></table></figure><p>vim docker-compose.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3.7&quot;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">node-exporter:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">prom/node-exporter:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">&quot;node-exporter0&quot;</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9100:9100&quot;</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>  <span class="hljs-attr">prometheus:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">prom/prometheus:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">&quot;prometheus0&quot;</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9090:9090&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./prometheus.yml:/etc/prometheus/prometheus.yml&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./prometheus_data:/prometheus&quot;</span><br>  <span class="hljs-attr">grafana:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">grafana/grafana</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">&quot;grafana0&quot;</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3000:3000&quot;</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;./grafana_data:/var/lib/grafana&quot;</span><br></code></pre></td></tr></table></figure><p>注：prometheus主机需要部署以上容器，其他被监控主机只需要部署node-exporter</p><p>3.prometheus配置文件(根据自己的服务器ip进行修改targets内容)</p><p>vim prometheus.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">global:</span><br>  <span class="hljs-attr">scrape_interval:</span>     <span class="hljs-string">15s</span> <span class="hljs-comment"># 默认抓取周期</span><br>  <span class="hljs-attr">external_labels:</span><br>    <span class="hljs-attr">monitor:</span> <span class="hljs-string">&#x27;codelab-monitor&#x27;</span><br><span class="hljs-attr">scrape_configs:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">job_name:</span> <span class="hljs-string">&#x27;node-exporter&#x27;</span> <span class="hljs-comment">#服务的名称</span><br>    <span class="hljs-attr">scrape_interval:</span> <span class="hljs-string">5s</span><br>    <span class="hljs-attr">metrics_path:</span> <span class="hljs-string">/metrics</span>  <span class="hljs-comment">#获取指标的url</span><br>    <span class="hljs-attr">static_configs:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">targets:</span> [<span class="hljs-string">&#x27;139.224.224.229:9100&#x27;</span>] <span class="hljs-comment"># 这个为监听指定服务服务的ip和port，需要修改为自己的ip，貌似云服务必须用公网ip</span><br></code></pre></td></tr></table></figure><p>4.docker-compose启动</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker-compose up -d <span class="hljs-comment"># 挂载目录给权限，不然会启动失败</span><br></code></pre></td></tr></table></figure><p>如果启动报如下的”没有权限”错误：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh">grafana0         | You may have issues with file permissions, more information here: http://docs.grafana.org/installation/docker/<span class="hljs-comment">#migrate-to-v51-or-later</span><br>grafana0         | <span class="hljs-built_in">mkdir</span>: can<span class="hljs-string">&#x27;t create directory &#x27;</span>/var/lib/grafana/plugins<span class="hljs-string">&#x27;: Permission denied</span><br><span class="hljs-string">grafana0         | GF_PATHS_DATA=&#x27;</span>/var/lib/grafana<span class="hljs-string">&#x27; is not writable.</span><br><span class="hljs-string">grafana0         | You may have issues with file permissions, more information here: http://docs.grafana.org/installation/docker/#migrate-to-v51-or-later</span><br><span class="hljs-string">grafana0         | mkdir: can&#x27;</span>t create directory <span class="hljs-string">&#x27;/var/lib/grafana/plugins&#x27;</span>: Permission denied<br>grafana0         | GF_PATHS_DATA=<span class="hljs-string">&#x27;/var/lib/grafana&#x27;</span> is not writable.<br>grafana0         | You may have issues with file permissions, more information here: http://docs.grafana.org/installation/docker/<span class="hljs-comment">#migrate-to-v51-or-later</span><br>grafana0         | <span class="hljs-built_in">mkdir</span>: can<span class="hljs-string">&#x27;t create directory &#x27;</span>/var/lib/grafana/plugins<span class="hljs-string">&#x27;: Permission denied</span><br><span class="hljs-string">grafana0         | GF_PATHS_DATA=&#x27;</span>/var/lib/grafana<span class="hljs-string">&#x27; is not writable.</span><br><span class="hljs-string">grafana0         | You may have issues with file permissions, more information here: http://docs.grafana.org/installation/docker/#migrate-to-v51-or-later</span><br><span class="hljs-string">grafana0         | mkdir: can&#x27;</span>t create directory <span class="hljs-string">&#x27;/var/lib/grafana/plugins&#x27;</span>: Permission denied<br>grafana0         | GF_PATHS_DATA=<span class="hljs-string">&#x27;/var/lib/grafana&#x27;</span> is not writable.<br>grafana0         | You may have issues with file permissions, more information here: http://docs.grafana.org/installation/docker/<span class="hljs-comment">#migrate-to-v51-or-later</span><br>grafana0         | <span class="hljs-built_in">mkdir</span>: can<span class="hljs-string">&#x27;t create directory &#x27;</span>/var/lib/grafana/plugins<span class="hljs-string">&#x27;: Permission denied</span><br></code></pre></td></tr></table></figure><p>则需要将挂载目录赋予权限，即：<br>    <code>chmod 777 grafana_data/ prometheus_data/ #个人根据配置文件中具体的挂在目录进行权限修改</code></p><p>5.访问主机的9090端口可以查到Prometheus监控到的数据，访问3000端口是grafana的界面，账密admin/admin</p><p>6.配置监控，点击齿轮，选择Data Sources<br><img src="img.png" alt="image"></p><p>7.点击Add data source<br><img src="img_1.png" alt="image"></p><p>8.填写prometheus地址 ip+端口或者主机名+端口（需要配置hosts）<br><img src="img_2.png" alt="image"></p><p>9.点击save&amp;test<br><img src="img_3.png" alt="image"></p><p>10.点击+号，选择import<br><img src="img_4.png" alt="image"></p><p>11.输入模板号9276，点击load!<br><img src="img_5.png" alt="image"><br><img src="img_6.png" alt="image"></p><p>11.导入模板完成<br><img src="img_7.png" alt="image"></p><h2 id="Refenences"><a href="#Refenences" class="headerlink" title="Refenences"></a>Refenences</h2><ul><li><a href="https://www.cnblogs.com/boci/p/15802939.html">使用docker-compose快速部署Prometheus+grafana环境</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Prometheus</tag>
      
      <tag>grafana</tag>
      
      <tag>监控</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Command failed with error 18 (AuthenticationFailed)</title>
    <link href="/2023/09/07/other/Command%20failed%20with%20error%2018%20(AuthenticationFailed)/"/>
    <url>/2023/09/07/other/Command%20failed%20with%20error%2018%20(AuthenticationFailed)/</url>
    
    <content type="html"><![CDATA[<p>Learn the root cause and solution to fix the authentication error caused when connecting with MongoDB from a Spring boot application.</p><h2 id="1-Problem"><a href="#1-Problem" class="headerlink" title="1 Problem"></a>1 Problem</h2><p>We get the <em>AuthenticationFailed</em> error when we are trying to connect to MongoDB either running standalone or inside a <a href="https://howtodoinjava.com/java/library/docker-hello-world-example/">docker</a> container from a <a href="https://howtodoinjava.com/series/spring-boot/">Spring boot application</a> using the following properties. The property values might be different in your case:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">spring.data.mongodb.host=localhost</span><br><span class="hljs-string">spring.data.mongodb.port=27017</span><br><span class="hljs-string">spring.data.mongodb.database=testdb</span><br><span class="hljs-string">spring.data.mongodb.username=mongoadmin</span><br><span class="hljs-string">spring.data.mongodb.password=secret</span><br></code></pre></td></tr></table></figure><p>Note that we started the mongo docker container with the following command in our case:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker run -d -p 27017:27017 --name mongo-on-docker \<br>-e MONGO_INITDB_ROOT_USERNAME=mongoadmin \<br>-e MONGO_INITDB_ROOT_PASSWORD=secret \<br>-e MONGO_INITDB_DATABASE=testdb \<br>mongo<br></code></pre></td></tr></table></figure><p>This command creates a new user with the name “_mongoadmin_” and password “_secret_” into the default database “admin”. <strong>The main purpose of this ‘_admin_‘ database is to store system collections and user authentication and authorization data, which includes the administrator and user’s usernames, passwords, and roles.</strong></p><p>In our <em>application.properties</em> file, we have not mentioned the database name where the user details are located for authentication, we get the authentication failed error.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh">org.springframework.data.mongodb.UncategorizedMongoDbException: Exception authenticating <br>MongoCredential&#123;mechanism=SCRAM-SHA-1, userName=<span class="hljs-string">&#x27;mongoadmin&#x27;</span>, <span class="hljs-built_in">source</span>=<span class="hljs-string">&#x27;testdb&#x27;</span>, password=&lt;hidden&gt;, mechanismProperties=&lt;hidden&gt;&#125;<br><br>...<br>...<br><br>Caused by: com.mongodb.MongoCommandException: Command failed with error 18 (AuthenticationFailed): <br><span class="hljs-string">&#x27;Authentication failed.&#x27;</span> on server localhost:27017. The full response is <br>&#123;<span class="hljs-string">&quot;ok&quot;</span>: 0.0, <span class="hljs-string">&quot;errmsg&quot;</span>: <span class="hljs-string">&quot;Authentication failed.&quot;</span>, <span class="hljs-string">&quot;code&quot;</span>: 18, <span class="hljs-string">&quot;codeName&quot;</span>: <span class="hljs-string">&quot;AuthenticationFailed&quot;</span>&#125;<br><br>...<br>...<br></code></pre></td></tr></table></figure><p>var adpushup = window.adpushup = window.adpushup || {}; adpushup.que = adpushup.que || []; adpushup.que.push(function() { adpushup.triggerAd(“4f41e429-fdc3-445a-ae1b-2547bb0bb694”); });</p><h2 id="2-Solution"><a href="#2-Solution" class="headerlink" title="2 Solution"></a>2 Solution</h2><h3 id="2-1-Use-Admin-Database"><a href="#2-1-Use-Admin-Database" class="headerlink" title="2.1. Use Admin Database"></a>2.1. Use Admin Database</h3><p>To fix this error, we need to, additionally, provide the ‘_authentication-database_‘ property in the configuration as follows:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">spring.data.mongodb.authentication-database=admin<br></code></pre></td></tr></table></figure><p>The complete set of properties for authentication is:</p><pre><code class="hljs">spring.data.mongodb.host=localhostspring.data.mongodb.port=27017spring.data.mongodb.database=testdbspring.data.mongodb.username=mongoadminspring.data.mongodb.password=secretspring.data.mongodb.authentication-database=admin </code></pre><p>After providing this property, we will not get the error and authentication will be successful.</p><h3 id="2-2-Verify-Username-and-Password-in-Mongo-Shell"><a href="#2-2-Verify-Username-and-Password-in-Mongo-Shell" class="headerlink" title="2.2. Verify Username and Password in Mongo Shell"></a>2.2. Verify Username and Password in Mongo Shell</h3><p>If you are still getting the authentication issues, then it is worth verifying the username and password values. For this, you can connect to MongoDB using these credentials from the command line/terminal.</p><p>To connect to the mongo shell and authenticate, run the following commands. The large number is the container id.</p><pre><code class="hljs">$ docker exec -it 3248a6f47cebdd25aaab3a9244e85918e2339c07ffd78967b63a5d7bd8766618 mongosh$ use admin$ db.auth( &#39;mongoadmin&#39;, &#39;secret&#39; )</code></pre><p><img src="https://howtodoinjava.com/wp-content/uploads/2023/03/MongoDB-Authentication-Failed-Error-1024x406.jpg"></p><p>If the credentials are not correct, we will get the respective errors.</p><h2 id="3-Conclusion"><a href="#3-Conclusion" class="headerlink" title="3 Conclusion"></a>3 Conclusion</h2><p>In this short Java tutorial, we learned the possible causes and solutions for authentication failed error when connecting to MongoDB from a Spring boot application.</p><p>Happy Learning !!</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://howtodoinjava.com/mongodb/command-failed-with-error-18/">[Solved] MongoDB: Command failed with error 18 (AuthenticationFailed)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mongodb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>车险怎么买才最划算</title>
    <link href="/2023/09/06/other/%E8%BD%A6%E9%99%A9%E6%80%8E%E4%B9%88%E4%B9%B0%E6%89%8D%E6%9C%80%E5%88%92%E7%AE%97/"/>
    <url>/2023/09/06/other/%E8%BD%A6%E9%99%A9%E6%80%8E%E4%B9%88%E4%B9%B0%E6%89%8D%E6%9C%80%E5%88%92%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<p><img src="img_2.png" alt="img_1.png"></p><h2 id="车险种类有哪些？"><a href="#车险种类有哪些？" class="headerlink" title="车险种类有哪些？"></a>车险种类有哪些？</h2><p>车改之后，车险分为交强险与商业险，商业险分为3大主险与11个附加险。</p><p>下表是所有车险险种，大家可以收藏，买车险的时候方便拿出来对照参考。<br><img src="img.png" alt="img.png"><br><img src="img_1.png" alt="img_1.png"></p><h2 id="老司机一般买哪些？"><a href="#老司机一般买哪些？" class="headerlink" title="老司机一般买哪些？"></a>老司机一般买哪些？</h2><p>那这么多车险产品，到底哪些真正有用？哪些纯属鸡肋呢？懂保君下面就介绍老司机都怎么买，如果不了解的，照着买，也不会出错。</p><h3 id="1、交强险：必买，不买不能上路"><a href="#1、交强险：必买，不买不能上路" class="headerlink" title="1、交强险：必买，不买不能上路"></a>1、交强险：必买，不买不能上路</h3><p>交强险三个特点：强制购买，不买无法上路；全国统一收费；对第三方的伤害最高赔付20万元。</p><p>交强险只能赔付他人的损失，主要保障因事故造成对方的死伤、医疗费用和财产损失。自己车辆的维修费、车内人员受伤等，都是不赔的；当然你的损失也是由造成你受伤的人的交强险来赔。</p><p>简单说就是，你和别人撞车了，你的交强险赔别人，别人的交强险赔你。</p><p>交强险的赔偿是按照项目计算的，每个项目都有固定的赔付额度，超过额度的部分就要自己承担了。</p><p><img src="img_3.png" alt="img_1.png"></p><p>大家注意这个无责赔偿费用，简单说，假如老王的车撞到你的车，老王受伤了，虽然是他全责，这时候你的交强险还要赔他医药费。难受，被人撞了还得给人赔钱（虽然是保险公司赔）。</p><p>交强险费率：</p><p>车险2020年的改革，大家交强险对5折优惠非常期待，但是仅有4个地区能够实现，这多少让人有些失望。</p><p>影响交强险费率的因素主要是无赔款优待系数，不同地区执行标准不一样。</p><p><img src="img_4.png" alt="img_1.png"></p><p>以E区的上海为例，最多能优惠30%，保险费用6座以下的能减到665元，6座以上的能减到770，当然，能优惠的条件是连续三年不出险。</p><p><img src="img_5.png" alt="img_1.png"></p><p>只要出险，之前积累的优惠就没有了，所以各位车主面对两三百的小损失，个人觉得可以自掏腰包的，没必要报保险。</p><p>一般情况下，交强险有垫付义务，如果驾车造成受害人受伤需要抢救，无论你有没有责任，救人要紧，在医院产生的费用可以让保险公司先垫付。</p><h3 id="2、商业险：数据告诉我们，建议买，用得上也赔的到"><a href="#2、商业险：数据告诉我们，建议买，用得上也赔的到" class="headerlink" title="2、商业险：数据告诉我们，建议买，用得上也赔的到"></a>2、商业险：数据告诉我们，建议买，用得上也赔的到</h3><p>以2020年为例, 全国商业险投保率（商业险投保率=商业险保单件数/交强险保单件数）为84.9%，也就是说100个人里面有85个人买了商业险。</p><p>那这85个人为什么买呢：</p><p>从出险频率看，一年有超过1/5的概率用得上商业险：全国商业险平均出险频度（出险频度=立案件数/满期车年）为22.1%</p><p>从出险后赔款看，赔款远高于保费：全国商业险案均已结赔款（案均已结赔款=已结赔款/已结件数）为5279元，对比2020年商业险单均保费为2759元。</p><p><img src="img_6.png" alt="img_1.png"></p><p>###（1）三者险：只要上路就必买！</p><p>简单来说，第三者责任险的意思就是你的车子撞人了或者撞坏了别人的东西，就可以用第三者责任险来赔，作用跟交强险类似，可作为交强险的补充，超出交强险的部分用三责险来承担。</p><p>这其中的第三者，是除了你和保险公司之外的第三方，可以是一辆车，一个人，一棵树，赔付的范围比较广泛。</p><p>那三者险买多少保额好呢？</p><h2 id="三者险充足保额-当地死亡事故责任赔偿费用-交强险死亡赔偿限额（18万）。"><a href="#三者险充足保额-当地死亡事故责任赔偿费用-交强险死亡赔偿限额（18万）。" class="headerlink" title="三者险充足保额= 当地死亡事故责任赔偿费用 - 交强险死亡赔偿限额（18万）。"></a>三者险充足保额= 当地死亡事故责任赔偿费用 - 交强险死亡赔偿限额（18万）。</h2><p>其中，当地死亡事故责任赔偿费用 = 死亡赔偿金 + 丧葬费 + 精神抚慰金+扶养人生活费 = 上一年度居民人均可支配收入 × 20 年 + 上一年居民人均可支配收入 × 0. 5 年 + 5万精神抚慰金+上一年度城镇居民人均消费性支出 × 15 年。</p><p>例如上海市2021年人均可支配收入=78027元，消费支出48879元。</p><p>那么，三者险充足保额=78027*20+78027*0.5+50000+48879*15-180000=220万元，建议上海车主至少买200万以上的三者险。</p><p><img src="img_7.png" alt="img_1.png"></p><p><img src="img_8.png" alt="img_1.png"></p><p>上面是懂保君统计的各地最新死亡赔偿金，供大家购买三者险时参考。</p><p>###（2）车损险：担心车辆受损可以购买</p><p><img src="img_11.png" alt="img_1.png"></p><p>顾名思义，车损险就是赔付自己车辆损失的保险。如果你是刚买了新车，可以考虑这个险种，毕竟新车刮了擦了，还是有点心痛的。</p><p>经过2020年的改革之后，盗抢险、自燃险、玻璃破碎险等险种不需要单独购买，统统并入车损险保障范围。</p><p>生活中绝大部分的事故都可以用车损险来赔，最常见的交通事故车辆碰撞导致的本车的损失，车损险也可以买单。</p><p>车损险保的是自己的车，保额一般是自己车的价值。如果发生双方事故，导致自己和对方的车都受损了，是自己全责或者部分责任，那么自己的车辆走车损险，对方的车辆走交强险和第三者责任险；若是自己无责任，那么所有费用都是对方保险公司出。</p><p>###（3）座位险/驾乘险：重视车上人员安全可以购买</p><p><img src="img_12.png" alt="img_1.png"></p><p>座位险即车上人员责任险，其本质是责任险，在车辆使用过程中，因驾驶人员的责任，导致意外事故发生造成车上人员受伤，座位险可以理赔。</p><p>驾乘险即驾乘意外险，其本质是意外险，对车上的驾驶员以及乘客做出保障，当发生意外事故时，保险公司会对司机以及乘客的人身安全进行赔偿。</p><p>驾乘险和座位险两个险种不能相互替代，车主朋友们要仔细区分，结合自己的实际情况，决定是否购买。</p><p>如果大家一会坐A车，一会又开B车，经常要更换驾乘车辆，建议购买“跟人”的驾乘险。可以对大家的出行提供保障。</p><p>如果自己的车经常载不同的人，建议在座位险与“跟车”的驾乘险中间二选一，如果想要买更高保额可以买驾乘险，如果认为10万元以内保额足够，可以买座位险。</p><p>下图是座位险与驾乘险的区别：</p><p><img src="img_9.png" alt="img_1.png"></p><p>###（4）附加医保外医疗费用责任险</p><p><img src="img_10.png" alt="img_1.png"></p><p>懂保君朋友买车险的时候，最后这个险种，保险业内寿险资深核保专家，同时也是十几年的老车主，千叮咛万嘱咐，一定要买这个险种。说实在话，以前他对这个险种真的是听都没听过，不过当他听完核保老师的分析，觉得还是很有道理：</p><p>当造成人伤事故（第三者和车上人员）时候，若产生治疗费用，在医保外的项目，保险公司不承担，必须投保附加医保外医疗费用责任险才可。</p><p>一般医保外费用，在伤者救治医疗费用金额的15%左右，若造成较大事故，比例可能更高，考虑到交通事故容易造成骨折以及骨科耗材的价格，建议购买商业险的车主购买这个附加险。</p><p>不过要注意的是，想买这个险种，必须购买三者险或者车损险之后才可附加。</p><p>最后，懂保君还要再唠叨一句：道路千万条，安全最重要，保险只是事后补救，只有安全驾驶才能保证我们平安到达目的地。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.dongchedi.com/article/7075609334671016460">2022年车险怎么买才最划算？老司机都这样买，省钱又省心</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>车险</tag>
      
      <tag>保险</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>htop安装</title>
    <link href="/2023/09/01/linux/htop/"/>
    <url>/2023/09/01/linux/htop/</url>
    
    <content type="html"><![CDATA[<p>htop是Linux系统下一个基本文本模式的、交互式的进程查看器，主要用于控制台或shell中，可以替代top，或者说是top的高级版。</p><p>1.首先，在CentOS 7上启用epel版本</p><blockquote><p>有些系统不包含该源,需要手动安装</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install epel-release<br></code></pre></td></tr></table></figure><p>2.使用yum install命令安装CentOS htop</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum -y install htop<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux command</tag>
      
      <tag>htop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一键安装docker</title>
    <link href="/2023/09/01/docker/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85docker/"/>
    <url>/2023/09/01/docker/%E4%B8%80%E9%94%AE%E5%AE%89%E8%A3%85docker/</url>
    
    <content type="html"><![CDATA[<h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun<br></code></pre></td></tr></table></figure><h2 id="然后启动docker服务"><a href="#然后启动docker服务" class="headerlink" title="然后启动docker服务"></a>然后启动docker服务</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl start docker<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>centos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES 常用查询命令汇总</title>
    <link href="/2023/08/31/es/ES%20%E5%B8%B8%E7%94%A8%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/"/>
    <url>/2023/08/31/es/ES%20%E5%B8%B8%E7%94%A8%E6%9F%A5%E8%AF%A2%E5%91%BD%E4%BB%A4%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="cat系列"><a href="#cat系列" class="headerlink" title="_cat系列"></a>_cat系列</h2><p>_cat系列提供了一系列查询elasticsearch集群状态的接口。你可以通过执行 <code>curl -XGET localhost:9200/_cat</code>获取所有_cat系列的操作</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/_cat/</span>allocation<br><br><span class="hljs-regexp">/_cat/</span>shards<br><br><span class="hljs-regexp">/_cat/</span>shards/&#123;index&#125;<br><br><span class="hljs-regexp">/_cat/m</span>aster<br><br><span class="hljs-regexp">/_cat/</span>nodes<br><br><span class="hljs-regexp">/_cat/i</span>ndices<br><br><span class="hljs-regexp">/_cat/i</span>ndices/&#123;index&#125;<br><br><span class="hljs-regexp">/_cat/</span>segments<br><br><span class="hljs-regexp">/_cat/</span>segments/&#123;index&#125;<br><br><span class="hljs-regexp">/_cat/</span><span class="hljs-keyword">count</span><br><br><span class="hljs-regexp">/_cat/</span><span class="hljs-keyword">count</span>/&#123;index&#125;<br><br><span class="hljs-regexp">/_cat/</span>recovery<br><br><span class="hljs-regexp">/_cat/</span>recovery/&#123;index&#125;<br><br><span class="hljs-regexp">/_cat/</span>health<br><br><span class="hljs-regexp">/_cat/</span>pending_tasks<br><br><span class="hljs-regexp">/_cat/</span>aliases<br><br><span class="hljs-regexp">/_cat/</span>aliases/&#123;alias&#125;<br><br><span class="hljs-regexp">/_cat/</span>thread_pool<br><br><span class="hljs-regexp">/_cat/</span>plugins<br><br><span class="hljs-regexp">/_cat/</span>fielddata<br><br><span class="hljs-regexp">/_cat/</span>fielddata/&#123;fields&#125;<br></code></pre></td></tr></table></figure><p>你也可以后面加一个v，让输出内容表格显示表头，举例:<code>_cat/allocation?v</code></p><h2 id="cluster系列"><a href="#cluster系列" class="headerlink" title="_cluster系列"></a>_cluster系列</h2><p>1、查询设置集群状态</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">curl -XGET localhost:<span class="hljs-number">9200</span><span class="hljs-regexp">/_cluster/</span>health?pretty=<span class="hljs-keyword">true</span>&amp;level=indices&amp;level=shards<br></code></pre></td></tr></table></figure><p>pretty=true表示格式化输出</p><p>level=indices 表示显示索引状态</p><p>level=shards 表示显示分片信息</p><p>2、显示集群系统信息，包括CPU JVM等等</p><p><code>curl -XGET localhost:9200/_cluster/stats?pretty=true</code></p><p>3、集群的详细信息。包括节点、分片等。</p><p><code>curl -XGET localhost:9200/_cluster/state?pretty=true</code></p><p>3、获取集群堆积的任务</p><p><code>curl -XGET localhost:9200/_cluster/pending_tasks?pretty=true</code></p><p>3、修改集群配置</p><p>举例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css">curl -XPUT localhost:<span class="hljs-number">9200</span>/_cluster/settings -d ‘&#123;<br><br>“persistent” : &#123;<br><br>“discovery<span class="hljs-selector-class">.zen</span><span class="hljs-selector-class">.minimum_master_nodes</span>” : <span class="hljs-number">2</span><br><br>&#125;<br><br>&#125;’<br></code></pre></td></tr></table></figure><p>transient 表示临时的，persistent表示永久的</p><p>4、<code>curl -XPOST ‘localhost:9200/_cluster/reroute’ -d ‘xxxxxx’</code></p><p>对shard的手动控制，参考<a href="http://zhaoyanblog.com/archives/687.html">http://zhaoyanblog.com/archives/687.html</a></p><p>5、关闭节点</p><p>关闭指定192.168.1.1节点</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -XPOST ‘http:<span class="hljs-regexp">//</span><span class="hljs-number">192.168</span>.<span class="hljs-number">1.1</span>:<span class="hljs-number">9200</span><span class="hljs-regexp">/_cluster/</span>nodes<span class="hljs-regexp">/_local/</span>_shutdown’<br><br>curl -XPOST ‘http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">9200</span><span class="hljs-regexp">/_cluster/</span>nodes<span class="hljs-regexp">/192.168.1.1/</span>_shutdown’<br></code></pre></td></tr></table></figure><p>关闭主节点</p><p><code>curl -XPOST ‘http://localhost:9200/_cluster/nodes/_master/_shutdown’</code></p><p>关闭整个集群</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -XPOST ‘http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">9200</span>/_shutdown?delay=<span class="hljs-number">10</span>s’<br><br>curl -XPOST ‘http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">9200</span><span class="hljs-regexp">/_cluster/</span>nodes/_shutdown’<br><br>curl -XPOST ‘http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">9200</span><span class="hljs-regexp">/_cluster/</span>nodes<span class="hljs-regexp">/_all/</span>_shutdown’<br></code></pre></td></tr></table></figure><p>delay=10s表示延迟10秒关闭</p><h2 id="nodes系列"><a href="#nodes系列" class="headerlink" title="_nodes系列"></a>_nodes系列</h2><p>1、查询节点的状态</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -XGET ‘http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">9200</span><span class="hljs-regexp">/_nodes/</span>stats?pretty=true’<br><br>curl -XGET ‘http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">9200</span><span class="hljs-regexp">/_nodes/</span><span class="hljs-number">192.168</span>.<span class="hljs-number">1.2</span>/stats?pretty=true’<br><br>curl -XGET ‘http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">9200</span><span class="hljs-regexp">/_nodes/</span>process’<br><br>curl -XGET ‘http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">9200</span><span class="hljs-regexp">/_nodes/</span>_all/process’<br><br>curl -XGET ‘http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">9200</span><span class="hljs-regexp">/_nodes/</span><span class="hljs-number">192.168</span>.<span class="hljs-number">1.2</span>,<span class="hljs-number">192.168</span>.<span class="hljs-number">1.3</span>/jvm,process’<br><br>curl -XGET ‘http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">9200</span><span class="hljs-regexp">/_nodes/</span><span class="hljs-number">192.168</span>.<span class="hljs-number">1.2</span>,<span class="hljs-number">192.168</span>.<span class="hljs-number">1.3</span><span class="hljs-regexp">/info/</span>jvm,process’<br><br>curl -XGET ‘http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">9200</span><span class="hljs-regexp">/_nodes/</span><span class="hljs-number">192.168</span>.<span class="hljs-number">1.2</span>,<span class="hljs-number">192.168</span>.<span class="hljs-number">1.3</span>/_all<br><br>curl -XGET ‘http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">9200</span><span class="hljs-regexp">/_nodes/</span>hot_threads<br></code></pre></td></tr></table></figure><h2 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h2><p>1、获取索引</p><p><code>curl -XGET ‘http://localhost:9200/&#123;index&#125;/&#123;type&#125;/&#123;id&#125;’</code><br><code>curl -XGET ‘http://localhost:9200/&#123;index&#125;’</code></p><p>1.1 、获取索引结构<br><code>curl -XGET ‘http://localhost:9200/&#123;index&#125;/_mapping’</code></p><p>2、索引数据</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scilab">curl -XGET <span class="hljs-string">&quot;http:/10.0.27.14:9200/easyes_document/_search&quot;</span> -H <span class="hljs-string">&quot;Content-Type: application/json&quot;</span> -H <span class="hljs-string">&quot;Authorization:Basic ZWxhc3RpYzpDWVdqOFBNSmdM&quot;</span> -d <span class="hljs-string">&#x27;</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">  &quot;</span>query<span class="hljs-string">&quot;: &#123;</span><br><span class="hljs-string">    &quot;</span>match<span class="hljs-string">&quot;: &#123;</span><br><span class="hljs-string">      &quot;</span>title<span class="hljs-string">&quot;: &quot;</span>测试文档<span class="hljs-string">&quot;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><p>2.1 查询某个index下所有数据</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scilab">curl -XGET <span class="hljs-string">&quot;http:/10.0.27.14:9200/easyes_document/_search&quot;</span> -H <span class="hljs-string">&quot;Content-Type: application/json&quot;</span> -H <span class="hljs-string">&quot;Authorization:Basic ZWxhc3RpYzpDWVdqOFBNSmdM&quot;</span> -d <span class="hljs-string">&#x27;</span><br><span class="hljs-string">&#123;</span><br><span class="hljs-string">  &quot;</span>query<span class="hljs-string">&quot;: &#123;</span><br><span class="hljs-string">    &quot;</span>match_all<span class="hljs-string">&quot;: &#123;&#125;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#x27;</span><br></code></pre></td></tr></table></figure><p>2.2 查询所有索引别名<br><code>curl -XGET &quot;http://10.0.27.14:9200/_alias&quot;  -H &quot;Content-Type: application/json&quot; -H &quot;Authorization:Basic ZWxhc3RpYzpDWVdqOFBNSmdM&quot; </code><br>2.3 查询指定别名信息</p><p><code>curl -XGET &quot;http://10.0.27.14:9200/_alias/ee_default_alias&quot;  -H &quot;Content-Type: application/json&quot; -H &quot;Authorization:Basic ZWxhc3RpYzpDWVdqOFBNSmdM&quot;</code></p><p>3、删除索引</p><p><code>curl -XDELETE ‘http://localhost:9200/&#123;index&#125;/&#123;type&#125;/&#123;id&#125;’</code></p><p>4、设置mapping</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs ada">curl -XPUThttp://localhost:<span class="hljs-number">9200</span>/&#123;index&#125;/&#123;<span class="hljs-keyword">type</span>&#125;/_mapping-d ‘&#123;<br><br>“&#123;<span class="hljs-keyword">type</span>&#125;” : &#123;<br><br>“properties” : &#123;<br><br>“date” : &#123;<br><br>“<span class="hljs-keyword">type</span>” : “<span class="hljs-type">long</span>”<br><br>&#125;,<br><br>“name” : &#123;<br><br>“<span class="hljs-keyword">type</span>” : “<span class="hljs-type">string</span>”,<br><br>“index” : “<span class="hljs-type">not_analyzed</span>”<br><br>&#125;,<br><br>“status” : &#123;<br><br>“<span class="hljs-keyword">type</span>” : “<span class="hljs-type">integer</span>”<br><br>&#125;,<br><br>“<span class="hljs-keyword">type</span>” : &#123;<br><br>“<span class="hljs-keyword">type</span>” : “<span class="hljs-type">integer</span>”<br><br>&#125;<br><br>&#125;<br><br>&#125;<br><br>&#125;’<br></code></pre></td></tr></table></figure><p>5、获取mapping</p><p><code>curl -XGET http://localhost:9200/&#123;index&#125;/&#123;type&#125;/_mapping</code></p><p>6、搜索</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs ada">curl -XGET ‘http://localhost:<span class="hljs-number">9200</span>/&#123;index&#125;/&#123;<span class="hljs-keyword">type</span>&#125;/_search’ -d &#x27;&#123;<br><br>“query” : &#123;<br><br>“term” : &#123; “<span class="hljs-type">user</span>” : “<span class="hljs-type">kimchy</span>” &#125; //查所有 “match_all”: &#123;&#125;<br><br>&#125;,<br><br>“sort” : &#123; “<span class="hljs-type">age</span>” : &#123;“<span class="hljs-type">order</span>” : “<span class="hljs-type">asc</span>”&#125;&#125;,&#123; “name” : “<span class="hljs-type">desc</span>” &#125; ,<br><br>“from”:<span class="hljs-number">0</span>,<br><br>“size”:<span class="hljs-number">100</span><br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">curl -XGET ‘http://localhost:9200/</span><span class="hljs-template-variable">&#123;index&#125;</span><span class="language-xml">/</span><span class="hljs-template-variable">&#123;type&#125;</span><span class="language-xml">/_search’ -d &#x27;</span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable"></span><br><span class="hljs-template-variable">“filter”: &#123;“and”:&#123;“filters”:&#123;“term”:&#123;“age”:“123”&#125;</span><span class="language-xml">&#125;,</span><span class="hljs-template-variable">&#123;“term”:&#123;“name”:“张三”&#125;</span><span class="language-xml">&#125;&#125;,</span><br><span class="language-xml"></span><br><span class="language-xml">“sort” : </span><span class="hljs-template-variable">&#123; “age” : &#123;“order” : “asc”&#125;</span><span class="language-xml">&#125;,</span><span class="hljs-template-variable">&#123; “name” : “desc” &#125;</span><span class="language-xml"> ,</span><br><span class="language-xml"></span><br><span class="language-xml">“from”:0,</span><br><span class="language-xml"></span><br><span class="language-xml">“size”:100</span><br><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br></code></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例:"></a>示例:</h2><h3 id="DSL查询示例"><a href="#DSL查询示例" class="headerlink" title="DSL查询示例"></a>DSL查询示例</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;bool&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;must&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;term&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;title.keyword&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;测试文档3&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;boost&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1.0</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;adjust_pure_negative&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;boost&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1.0</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;track_total_hits&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2147483647</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;highlight&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;pre_tags&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;&lt;em&gt;&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;post_tags&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;&lt;/em&gt;&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;fragment_size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">2</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;fields&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;content&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;unified&quot;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><ol><li><code>query</code>：这是一个查询对象，用于指定要执行的查询操作。</li><li><code>bool</code>：这是一个布尔查询，用于组合多个子查询条件。</li><li><code>must</code>：这是一个必须匹配的子查询条件数组。在这个示例中，我们只有一个子查询条件。</li><li><code>term</code>：这是一个术语查询，用于精确匹配字段的值。</li><li><code>title.keyword</code>：这是要匹配的字段名。<code>.keyword</code>表示使用关键字字段进行匹配，这意味着不会进行分词。</li><li><code>value</code>：这是要匹配的具体值，这里是”测试文档3”。</li><li><code>boost</code>：这是一个可选的权重值，用于调整查询的相关性得分。</li></ol><p>接下来是一些其他参数：</p><ol start="8"><li><code>adjust_pure_negative</code>：这是一个布尔值，指示是否调整纯负面（不匹配）的查询得分。</li><li><code>boost</code>：这是整个查询的权重值。</li></ol><p>然后是一些可选的参数：</p><ol start="10"><li><code>track_total_hits</code>：这是一个整数值，用于指定要返回的总命中数。在这个示例中，设置为2147483647，表示返回所有命中的文档数。</li><li><code>highlight</code>：这是一个高亮对象，用于对匹配的字段进行突出显示。</li><li><code>pre_tags</code>：这是一个字符串数组，用于指定高亮文本的前置标签。</li><li><code>post_tags</code>：这是一个字符串数组，用于指定高亮文本的后置标签。</li><li><code>fragment_size</code>：这是一个整数值，用于指定每个高亮片段的最大长度。</li><li><code>fields</code>：这是一个字段对象，用于指定要高亮的字段及其类型。</li></ol><p>总体而言，该DSL查询的目的是在”title.keyword”字段中精确匹配值为”测试文档3”的文档，并返回所有匹配的文档。同时，还会对”content”字段进行高亮处理。</p><h3 id="mappings示例"><a href="#mappings示例" class="headerlink" title="mappings示例"></a>mappings示例</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;easyes_document&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;mappings&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>        <span class="hljs-attr">&quot;big_num&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;scaled_float&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;scaling_factor&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">101.0</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;case_test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;normalizer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;lowercase_normalizer&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;comment_content&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_smart&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;content&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_smart&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;creator&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;fields&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;keyword&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;ignore_above&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">256</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_smart&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;english&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;fields&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;keyword&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;ignore_above&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">256</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;filed_data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;fielddata&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;geo_location&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;geo_shape&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;gmt_create&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;date&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;format&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;ip_address&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ip&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;join_field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;join&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;eager_global_ordinals&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;relations&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;document&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;comment&quot;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;location&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;geo_point&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;null_field&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;fields&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;keyword&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;ignore_above&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">256</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;star_num&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;sub_title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;fields&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;keyword&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;ignore_above&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">256</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;fields&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;keyword&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;ignore_above&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">256</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-attr">&quot;users&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>          <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;nested&quot;</span><span class="hljs-punctuation">,</span><br>          <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;integer&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;faqs&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;nested&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;properties&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;answer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>                  <span class="hljs-attr">&quot;fields&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;keyword&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>                      <span class="hljs-attr">&quot;ignore_above&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">256</span><br>                    <span class="hljs-punctuation">&#125;</span><br>                  <span class="hljs-punctuation">&#125;</span><br>                <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;faq_name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>                  <span class="hljs-attr">&quot;fields&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;keyword&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><span class="hljs-punctuation">,</span><br>                      <span class="hljs-attr">&quot;ignore_above&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">256</span><br>                    <span class="hljs-punctuation">&#125;</span><br>                  <span class="hljs-punctuation">&#125;</span><br>                <span class="hljs-punctuation">&#125;</span><br>              <span class="hljs-punctuation">&#125;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;password&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;keyword&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;user_name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>              <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;text&quot;</span><span class="hljs-punctuation">,</span><br>              <span class="hljs-attr">&quot;analyzer&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ik_smart&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>          <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>      <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>以上json信息是一个 Elasticsearch 索引的 Mapping 结构。Mapping 定义了索引中文档的字段和其属性。</p><p>以下是对该 Mapping 结构的解释：</p><ul><li>“easyes_document” 是索引的名称。</li><li>“mappings” 是索引的 Mapping 部分。</li><li>“properties” 是索引中的字段定义部分。</li></ul><p>具体字段的解释如下：</p><ul><li>“big_num” 是一个 scaled_float 类型的字段，用于存储一个大数值。它使用了一个缩放因子为 101.0。</li><li>“case_test” 是一个 keyword 类型的字段，用于存储一个不分词的关键字。它使用了一个名为 “lowercase_normalizer” 的正规化器，将值统一转换为小写。</li><li>“comment_content” 和 “content” 是 text 类型的字段，用于存储文本内容。它们使用了 “ik_smart” 分析器，用于中文分词。</li><li>“creator” 是一个 text 类型的字段，它包含一个名为 “keyword” 的子字段，用于进行精确匹配。它使用了 “ik_smart” 分析器。</li><li>“english” 是一个 text 类型的字段，它包含一个名为 “keyword” 的子字段，用于进行精确匹配。</li><li>“filed_data” 是一个 text 类型的字段，用于进行字段数据（fielddata）分析。</li><li>“geo_location” 是一个 geo_shape 类型的字段，用于存储地理形状数据。</li><li>“gmt_create” 是一个 date 类型的字段，用于存储日期和时间。它使用了指定的日期格式。</li><li>“ip_address” 是一个 ip 类型的字段，用于存储 IP 地址。</li><li>“join_field” 是一个 join 类型的字段，用于实现父子关系。它指定了与 “document” 类型的 “comment” 关联。</li><li>“location” 是一个 geo_point 类型的字段，用于存储地理坐标点。</li><li>“null_field” 是一个 text 类型的字段，它包含一个名为 “keyword” 的子字段，用于进行精确匹配。</li><li>“star_num” 是一个 integer 类型的字段，用于存储整数值。</li><li>“sub_title”、”title” 和 “users” 都是 nested 类型的字段，用于存储嵌套的文档结构。</li><li>“users” 字段下有多个子字段，包括 “age”（integer 类型）、”faqs”（nested 类型）和 “user_name”（text 类型，使用 “ik_smart” 分析器）。</li><li>“faqs” 字段下有多个子字段，包括 “answer” 和 “faq_name”，它们都是 text 类型，包含一个名为 “keyword” 的子字段。</li></ul><h2 id="other"><a href="#other" class="headerlink" title="other"></a>other</h2><h3 id="RefreshPolicy"><a href="#RefreshPolicy" class="headerlink" title="RefreshPolicy"></a>RefreshPolicy</h3><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Don&#x27;t refresh after this request. The default.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-constructor">NONE(<span class="hljs-string">&quot;false&quot;</span>)</span>,<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Force a refresh as part of this request. This refresh policy does not scale for high indexing or search throughput but is useful</span><br><span class="hljs-comment"> * to present a consistent view to for indices with very low traffic. And it is wonderful for tests!</span><br><span class="hljs-comment"> */</span><br><span class="hljs-constructor">IMMEDIATE(<span class="hljs-string">&quot;true&quot;</span>)</span>,<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Leave this request open until a refresh has made the contents of this request visible to search. This refresh policy is</span><br><span class="hljs-comment"> * compatible with high indexing and search throughput but it causes the request to wait to reply until a refresh occurs.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-constructor">WAIT_UNTIL(<span class="hljs-string">&quot;wait_for&quot;</span>)</span>;<br></code></pre></td></tr></table></figure><p>在Elasticsearch中，RefreshPolicy（刷新策略）用于控制索引的刷新行为。刷新是将索引中的写入操作（如索引、更新和删除）应用到搜索操作之前的过程。默认情况下，Elasticsearch会自动定期刷新索引，以确保最新的写入操作可立即被搜索到。</p><p>RefreshPolicy定义了何时以及如何执行索引的刷新操作。以下是一些常见的RefreshPolicy选项：</p><ol><li><p><code>RefreshPolicy.NONE</code>：不执行刷新操作。这意味着写入操作将在内存中缓冲，直到发生显式刷新或达到自动刷新的条件。这是最高效的选项，但可能导致搜索结果不包含最新的写入操作。</p></li><li><p><code>RefreshPolicy.IMMEDIATE</code>：立即执行刷新操作。写入操作将立即应用到搜索操作之前，确保搜索结果包含最新的写入操作。这是最方便的选项，但可能会对性能产生一定影响。</p></li><li><p><code>RefreshPolicy.WAIT_UNTIL</code>：等待直到刷新操作完成。写入操作将被缓冲，直到刷新操作完成后再应用到搜索操作。这可以确保搜索结果包含最新的写入操作，并且在刷新完成前不会返回响应。这是一个比较保守的选项，适用于需要确保数据一致性的场景。</p></li></ol><p>你可以根据具体需求选择适当的刷新策略。默认情况下，如果没有显式指定刷新策略，Elasticsearch会使用<code>RefreshPolicy.AUTO</code>，它会根据写入操作的频率和数据量来自动决定刷新时间点。</p><p>刷新策略在索引写入和搜索的一致性、性能和延迟之间提供了权衡。根据应用程序的需求，你可以选择不同的刷新策略来平衡这些因素。</p><h3 id="DSL是什么"><a href="#DSL是什么" class="headerlink" title="DSL是什么?"></a>DSL是什么?</h3><p>在Elasticsearch中，DSL代表”Domain Specific Language”，即领域特定语言。DSL是一种用于构建结构化查询的语言，用于在Elasticsearch中定义搜索和分析操作。</p><p>Elasticsearch的查询DSL提供了一种灵活且强大的方式来构建各种查询。它使用JSON（JavaScript Object Notation）格式来表示查询和过滤条件，以及其他与搜索相关的操作。</p><p>使用DSL，你可以编写复杂的查询来搜索和过滤文档，执行聚合操作，进行分页和排序，以及执行其他与搜索相关的任务。DSL提供了许多不同类型的查询，例如全文搜索、精确匹配、范围查询、布尔查询等。</p><p>以下是一个示例，展示了使用DSL进行全文搜索的查询：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;query&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;match&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;elasticsearch&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>在上述示例中，我们使用DSL的<code>match</code>查询来搜索具有”title”字段中包含”elasticsearch”关键词的文档。</p><p>通过使用Elasticsearch的DSL，你可以以一种更结构化和可读性更高的方式定义查询和操作，而无需手动构建复杂的查询字符串。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.jianshu.com/p/c7deb6555978">ES 常用查询命令汇总</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>es</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>把socks5代理转化为http代理</title>
    <link href="/2023/08/25/linux/%E5%A6%82%E4%BD%95%E6%8A%8Asocks5%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8C%96%E4%B8%BAhttp%E4%BB%A3%E7%90%86/"/>
    <url>/2023/08/25/linux/%E5%A6%82%E4%BD%95%E6%8A%8Asocks5%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8C%96%E4%B8%BAhttp%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>如果客户端使用SSR、Clash等软件一般本地可以开启一个http代理端口使用，但是在服务器上，或许我们不使用这些软件。</p><p><strong>问：有一个现成的远程socks5代理，想转化成为本地的http代理，在ubuntu上有什么办法</strong></p><blockquote><p>同样适用与centos系统</p></blockquote><blockquote><p>在Ubuntu上，您可以使用privoxy工具将远程的SOCKS5代理转换为本地的HTTP代理。Privoxy是一个功能强大的代理服务器，可以充当本地HTTP代理并过滤和修改传入和传出的HTTP流量。</p></blockquote><p>下面是在Ubuntu上将远程的SOCKS5代理转换为本地HTTP代理的步骤：</p><ol><li><p>首先，确保您的系统上已经安装了Privoxy。如果尚未安装，可以使用以下命令进行安装：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo apt update<br>sudo apt <span class="hljs-keyword">install</span> privoxy<br></code></pre></td></tr></table></figure></li><li><p>安装完成后，编辑Privoxy的配置文件。使用以下命令打开配置文件：</p> <figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo nano <span class="hljs-regexp">/etc/</span>privoxy/config<br></code></pre></td></tr></table></figure></li><li><p>在配置文件中，找到以下行，并做相应修改：</p> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">listen-<span class="hljs-selector-tag">address</span>  <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8118</span><br>forward-socks5 / xxx<span class="hljs-selector-class">.xxx</span><span class="hljs-selector-class">.xxx</span><span class="hljs-selector-class">.xxx</span>:<span class="hljs-number">1080</span> .<br></code></pre></td></tr></table></figure></li></ol><p>保存并关闭文件。</p><p>配置说明：<br>listen-address 本地监听的http代理端口<br>forward-socks5 远程socks5代理的地址<br>forward-socks5t 也是相同的功能，区别是forward-socks5t不使用代理解析DNS，所以不用它，改为使用forward-socks5</p><ol start="3"><li><p>启动Privoxy服务：</p> <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">sudo systemctl <span class="hljs-literal">start</span> privoxy<br></code></pre></td></tr></table></figure></li></ol><p>现在，您的本地HTTP代理已经在Ubuntu上运行，并将传入的HTTP流量转发到远程的SOCKS5代理</p><ol start="4"><li><p>加入开机自启</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl enable privoxy<br><span class="hljs-params">system</span>ctl start privoxy<br></code></pre></td></tr></table></figure></li><li><p>测试例子</p> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">curl -x <span class="hljs-string">&#x27;http://127.0.0.1:8118&#x27;</span> myip<span class="hljs-selector-class">.ipip</span><span class="hljs-selector-class">.net</span><br>curl -x <span class="hljs-string">&#x27;socks5://xxx.xxx.xxx.xxx:1080&#x27;</span> myip<span class="hljs-selector-class">.ipip</span>.net<br></code></pre></td></tr></table></figure></li></ol><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li>  <a href="https://www.jianshu.com/p/f6cacb8e8e75">如何把socks5代理转化为http代理</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代理</tag>
      
      <tag>socks5</tag>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>卸载腾讯云安全组件</title>
    <link href="/2023/08/25/other/%E5%8D%B8%E8%BD%BD%E8%85%BE%E8%AE%AF%E4%BA%91%E5%AE%89%E5%85%A8%E7%BB%84%E4%BB%B6/"/>
    <url>/2023/08/25/other/%E5%8D%B8%E8%BD%BD%E8%85%BE%E8%AE%AF%E4%BA%91%E5%AE%89%E5%85%A8%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天早上收到一条提醒，用来做梯子的腾讯云机器被提示封禁了。</p><blockquote><p>尊敬的腾讯云用户，您好！<br>您的腾讯云账号（账号ID: *********， 昵称: ******）下的Lighthouse服务存在违规信息，涉嫌违反相关法律法规和政策，101.32.26.12已被限制访问，感谢您理解和支持！<br>违规类型：存在通过技术手段使其成为跨境访问节点等行为<br>违规URL：N/A<br>违规域名：N/A<br>违规标识：101.32.26.12</p></blockquote><p>遂怀疑是腾讯云可能存在和阿里云类似的监控用户隐私的类云盾功能，结果确实检索到了相关信息。</p><h1 id="处理腾讯云安全（审查）组件"><a href="#处理腾讯云安全（审查）组件" class="headerlink" title="处理腾讯云安全（审查）组件"></a>处理腾讯云安全（审查）组件</h1><p>理论上，现在新创建的所有服务器，包括轻量都预装了这个组件。通过以下命令检查是否被插了后门。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> -A | <span class="hljs-keyword">grep</span> agent<br></code></pre></td></tr></table></figure><p>这时候你会看到</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">root</span>@VM-<span class="hljs-number">4</span>-<span class="hljs-number">9</span>-debian:~# ps -A | grep agent<br>   <span class="hljs-attribute">1229</span> ?        <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> sgagent<br>   <span class="hljs-attribute">1282</span> ?        <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> barad_agent<br>   <span class="hljs-attribute">1288</span> ?        <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> barad_agent<br>   <span class="hljs-attribute">1289</span> ?        <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span> barad_agent<br></code></pre></td></tr></table></figure><p>果然是插满了后门啊。</p><p>解决方法很简单，参考 hostloc 论坛帖子提供的方法，直接在ssh执行</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo -i<br>systemctl stop tat_agent<br>systemctl disable tat_agent<br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/qcloud/</span>stargate<span class="hljs-regexp">/admin/u</span>ninstall.sh<br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/qcloud/</span>YunJing/uninst.sh<br><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/qcloud/m</span>onitor<span class="hljs-regexp">/barad/</span>admin/uninstall.sh<br>rm -f <span class="hljs-regexp">/etc/</span>systemd<span class="hljs-regexp">/system/</span>tat_agent.service<br>rm -rf <span class="hljs-regexp">/usr/</span>local/qcloud<br>rm -rf <span class="hljs-regexp">/usr/</span>local/sa<br>rm -rf <span class="hljs-regexp">/usr/</span>local/agenttools<br>rm -rf <span class="hljs-regexp">/usr/</span>local/qcloud<br>process=(sap100 secu-tcs-agent sgagent64 barad_agent agent agentPlugInD pvdriver )<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-variable">$&#123;process[@]&#125;</span><br><span class="hljs-keyword">do</span><br>  <span class="hljs-keyword">for</span> A <span class="hljs-keyword">in</span> $(ps aux | grep <span class="hljs-variable">$i</span> | grep -v grep | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>)<br>  <span class="hljs-keyword">do</span><br>    kill -<span class="hljs-number">9</span> <span class="hljs-variable">$A</span><br>  done<br>done<br></code></pre></td></tr></table></figure><p>即可。最后再使用 <code>ps -A | grep agent</code> 检查一次。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li>  <a href="https://hostloc.com/thread-1004087-1-1.html">https://hostloc.com/thread-1004087-1-1.html</a></li><li>  <a href="https://wasteland.touko.moe/blog/2022/05/uninst-txagent/">卸载腾讯云安全组件</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>腾讯云</tag>
      
      <tag>agent</tag>
      
      <tag>云盾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDEA HTTP Client 内置变量</title>
    <link href="/2023/08/24/idea/IDEA%20HTTP%20Client%20%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F/"/>
    <url>/2023/08/24/idea/IDEA%20HTTP%20Client%20%E5%86%85%E7%BD%AE%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="时间类"><a href="#时间类" class="headerlink" title="时间类"></a>时间类</h2><h3 id="Unix-时间戳"><a href="#Unix-时间戳" class="headerlink" title="Unix 时间戳"></a>Unix 时间戳</h3><p>精确到秒级别。</p><pre><code class="hljs">&#123;&#123;$timestamp&#125;&#125;</code></pre><p>输出：</p><pre><code class="hljs">1671591225</code></pre><h3 id="毫秒级时间戳"><a href="#毫秒级时间戳" class="headerlink" title="毫秒级时间戳"></a>毫秒级时间戳</h3><p>手动添加<code>000</code>即可。</p><pre><code class="hljs">&#123;&#123;$timestamp&#125;&#125;000</code></pre><p>输出：</p><pre><code class="hljs">1671591316000</code></pre><h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><p>请求头中可以不加双引号（获取时使用<code>getHeader()</code>，不同语言实现不同），在请求体中如果是以<code>String</code>字符串对象接收，则需要添加双引号。</p><pre><code class="hljs">&lt; &#123;%    let timestamp = Date.now();    request.variables.set("ts", timestamp.toString());    %&#125;POST http://localhost:8080/api/loginContent-Type: application/jsonX-Timestamp: &#123;&#123;ts&#125;&#125;&#123;  &quot;ts&quot;: &quot;&#123;&#123;ts&#125;&#125;&quot;&#125;</code></pre><p><code>&#123;&#123;ts&#125;&#125;</code>输出：</p><pre><code class="hljs">1671591225116</code></pre><h3 id="ISO-时间戳"><a href="#ISO-时间戳" class="headerlink" title="ISO 时间戳"></a>ISO 时间戳</h3><pre><code class="hljs">&#123;&#123;$isoTimestamp&#125;&#125;</code></pre><p>输出：</p><pre><code class="hljs">2022-12-20T09:27:39.089053Z</code></pre><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><h3 id="uuid"><a href="#uuid" class="headerlink" title="uuid"></a>uuid</h3><pre><code class="hljs">&#123;&#123;$uuid&#125;&#125;</code></pre><p>输出：</p><pre><code class="hljs">1603714f-e234-4dc2-ad19-0de310ce6bd3</code></pre><h3 id="random-uuid"><a href="#random-uuid" class="headerlink" title="random uuid"></a>random uuid</h3><pre><code class="hljs">&#123;&#123;$random.uuid&#125;&#125;</code></pre><p>输出：</p><pre><code class="hljs">dbe991fb-3b4e-448b-9572-01ef130df339</code></pre><h3 id="数字-大小写字母"><a href="#数字-大小写字母" class="headerlink" title="数字 + 大小写字母"></a>数字 + 大小写字母</h3><p>参数为生成的字符串长度，此处示例为<code>10</code>。</p><pre><code class="hljs">&#123;&#123;$random.alphanumeric(10)&#125;&#125;</code></pre><p>输出：</p><pre><code class="hljs">LD3BqMUSbA</code></pre><h3 id="纯大小写字母"><a href="#纯大小写字母" class="headerlink" title="纯大小写字母"></a>纯大小写字母</h3><p>参数为生成的字符串长度，此处示例为<code>10</code>。</p><pre><code class="hljs">&#123;&#123;$random.alphabetic(10)&#125;&#125;</code></pre><p>输出：</p><pre><code class="hljs">wipSKmoMcA</code></pre><h3 id="邮件地址"><a href="#邮件地址" class="headerlink" title="邮件地址"></a>邮件地址</h3><pre><code class="hljs">&#123;&#123;$random.email&#125;&#125;</code></pre><p>输出：</p><pre><code class="hljs">[email protected]</code></pre><h3 id="int-值"><a href="#int-值" class="headerlink" title="int 值"></a>int 值</h3><pre><code class="hljs">&#123;&#123;$randomInt&#125;&#125;</code></pre><p>输出：</p><pre><code class="hljs">415</code></pre><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://www.zhangbj.com/p/1490.html">IDEA HTTP Client 内置变量</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idea</tag>
      
      <tag>HTTP Client</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iftop</title>
    <link href="/2023/08/16/linux/iftop/"/>
    <url>/2023/08/16/linux/iftop/</url>
    
    <content type="html"><![CDATA[<blockquote><p>一款实时流量监控工具</p></blockquote><p><strong>iftop命令</strong> 是一款实时流量监控工具，监控TCP/IP连接等，缺点就是无报表功能。必须以root身份才能运行。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code class="hljs">iftop(选项)</code></pre><h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><pre><code class="hljs">iftop: display bandwidth usage on an interface by hostSynopsis: iftop -h | [-npblNBP] [-i interface] [-f filter code]    [-F net/mask] [-G net6/mask6]   -h                  display this message   -n                  don&#39;t do hostname lookups   -N                  don&#39;t convert port numbers to services   -p                  run in promiscuous mode (show traffic between other                       hosts on the same network segment)   -b                  don&#39;t display a bar graph of traffic   -B                  Display bandwidth in bytes   -i interface        listen on named interface   -f filter code      use filter code to select packets to count                      (default: none, but only IP packets are counted)   -F net/mask         show traffic flows in/out of IPv4 network   -G net6/mask6       show traffic flows in/out of IPv6 network   -l                  display and count link-local IPv6 traffic (default: off)   -P                  show ports as well as hosts   -m limit            sets the upper limit for the bandwidth scale   -c config file      specifies an alternative configuration file   -t                  use text interface without ncurses      Sorting orders:   -o 2s                Sort by first column (2s traffic average)   -o 10s               Sort by second column (10s traffic average) [default]   -o 40s               Sort by third column (40s traffic average)   -o source            Sort by source address   -o destination       Sort by destination address      The following options are only available in combination with -t   -s num              print one single text output afer num seconds, then quit   -L num              number of lines to print</code></pre><h3 id="界面说明"><a href="#界面说明" class="headerlink" title="界面说明"></a>界面说明</h3><blockquote><p>第一行为带宽，这里为1Mbit,不是字节哦. 连接列表，最后三列分别是2秒，10秒和40秒的平均流量 <code>=&gt;</code> 代表发送<br><code>&lt;=</code> 代表接收 最后三行表示发送，接收和全部的流量， 第二列为你运行iftop到目前流量，第三列为高峰值，第四列为平均值。</p></blockquote><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><pre><code class="hljs">iftop           # 默认是监控第一块网卡的流量iftop -i eth1   # 监控eth1iftop -n        # 直接显示IP, 不进行DNS反解析iftop -N        # 直接显示连接埠编号, 不显示服务名称iftop -F 192.168.1.0/24 or 192.168.1.0/255.255.255.0  # 显示某个网段进出封包流量</code></pre><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://wangchujiang.com/linux-command/c/iftop.html">iftop</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux command</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用Certbot自动获取https证书</title>
    <link href="/2023/08/10/other/%E7%94%A8Certbot%E8%87%AA%E5%8A%A8%E8%8E%B7%E5%8F%96https%E8%AF%81%E4%B9%A6/"/>
    <url>/2023/08/10/other/%E7%94%A8Certbot%E8%87%AA%E5%8A%A8%E8%8E%B7%E5%8F%96https%E8%AF%81%E4%B9%A6/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="Let’s-Encrypt"><a href="#Let’s-Encrypt" class="headerlink" title=" Let’s Encrypt"></a> Let’s Encrypt</h1><p>Let’s Encrypt 是一家全球性的证书颁发机构（CA），作为一个非营利性组织，它的任务是通过推广 HTTPS 来创建一个更加安全和尊重隐私的 Web 环境。Let’s Encrypt 提供了<strong>免费</strong>的 SSL 证书供每个人使用。</p><p>Let’s Encrypt 使用自动化证书管理环境（ACME）协议来验证域名控制权以及颁发证书，使用 Certbot 首次连接 Let’s Encrypt 服务器时会要求输入邮箱等信息来自动创建账户，帐户 ID 可以在 <code>/etc/letsencrypt/accounts/acme-v02.api.letsencrypt.org/directory/&lt;ID&gt;</code> 路径中找到，如果在使用中遇到问题，可以提供账户 ID 信息进行反馈。</p><h1 id="SSL证书类型"><a href="#SSL证书类型" class="headerlink" title="SSL证书类型"></a>SSL证书类型</h1><p>目前主流的 SSL 证书有以下三种：</p><ul><li>  域名验证型（DV）证书：通过验证域名所有权即可签发证书，只验证网站域名所有权，适合个人和小微企业申请，能起到加密传输的作用，但是证书中无法显示企业信息。</li><li>  组织验证型（OV）证书：通过验证域名所有权和申请企业的真实身份信息才能签发证书，适合中型企业和互联网业务申请，能通过证书查看到企业相关信息。</li><li>  扩展验证型（EV）证书：在 OV 证书的基础上额外验证企业的其他相关信息，比如 GoDaddy 会在在授予企业 EV 证书前验证企业是否符合以下条件：已合法注册、目前正常运营、位于所列地址、所列电话号码有效、拥有网站域名。多使用于银行、金融、证券、支付等高安全标准行业。</li></ul><p>Let’s Encrypt 提供的是域名验证型（DV）证书，不提供组织验证型（OV）或扩展验证型（EV）证书。</p><h1 id="Certbot安装流程"><a href="#Certbot安装流程" class="headerlink" title="Certbot安装流程"></a>Certbot安装流程</h1><p>Let’s Encrypt 官方推荐使用 Cerbot 来自动执行证书的颁发和安装，Cerbot 团队建议大多数用户通过 snap 这个包管理工具来安装 Certbot，以避免其他包管理系统上发行的 Cerbot 因为未及时更新而存在问题。因此 Certbot 的安装分为两步：</p><ol><li> 安装 snap；</li><li> 通过 snap 安装 Certbot。</li></ol><p>如果使用的是其他 Linux 发行版可以查阅 <a href="https://certbot.eff.org/instructions">certbot instructions</a> 。</p><p>下面简单介绍下 Certbot 在 CentOS 7 和 Denian 系统下的安装流程。</p><h2 id="安装snap"><a href="#安装snap" class="headerlink" title="安装snap"></a>安装snap</h2><h3 id="CentOS-7"><a href="#CentOS-7" class="headerlink" title="CentOS 7"></a>CentOS 7</h3><p>CentOS 7 下 snap 的安装过程参考自官方教程：<a href="https://snapcraft.io/docs/installing-snap-on-centos">Installing snap on CentOS</a> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将EPEL扩展库添加到CentOS 7</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum install epel-release</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装snapd</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum install snapd</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用snapd.socket</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">systemctl <span class="hljs-built_in">enable</span> --now snapd.socket</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建软链接，用来启用classic snap支持</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ln</span> -s /var/lib/snapd/snap /snap</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">确保snapd版本是最新的</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">snap install core</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">snap refresh core</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">移除yum上的certbot，进一步确保certbot是通过snap安装的</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">yum remove certbot</span><br></code></pre></td></tr></table></figure><h3 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a>Debian</h3><p>Debian 下可以直接通过 <code>apt</code> 安装 <code>snap</code>：</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>apt update<br><span class="hljs-variable">$ </span>apt install snapd<br><span class="hljs-variable">$ </span>snap install core<br><span class="hljs-variable">$ </span>snap refresh core<br></code></pre></td></tr></table></figure><h2 id="安装Certbot"><a href="#安装Certbot" class="headerlink" title="安装Certbot"></a><a href="#%E5%AE%89%E8%A3%85Certbot" title="安装Certbot"></a>安装Certbot</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 安装Certbot</span><br>$ snap install --classic certbot<br><br><span class="hljs-comment"># 创建软链接，使certbot命令可以正常使用</span><br>$ ln -s <span class="hljs-regexp">/snap/</span>bin<span class="hljs-regexp">/certbot /u</span>sr<span class="hljs-regexp">/bin/</span>certbot<br></code></pre></td></tr></table></figure><ol start="5"><li> 访问网站，验证是否启用 HTTPS：</li></ol><h1 id="使用Certbot"><a href="#使用Certbot" class="headerlink" title="使用Certbot"></a>使用Certbot</h1><p>Certbot 提供了两个功能：</p><ol><li> 获取证书：自动验证对域名的控制，将证书保存到 <code>/etc/letsencrypt/live/</code> 并定期更新。</li><li> 安装证书：通过自动修改服务器的配置，将该证书安装到受支持的 Web 服务器（如 Apache 或 Nginx）和其他类型的服务器。</li></ol><p>申请证书时常见的两种场景：</p><ol><li> 为每个域名申请独立的证书：Nginx 中配置了一个或多个域名，为每个域名（包括子域名）申请独立的证书并启用 HTTPS；</li><li> 主域名和多个子域名共用同一个通配符证书：Nginx 中除了主域名还配置了多个子域名，比如 <code>sannaha.moe</code>、<code>watermelonrank.sannaha.moe</code>、<code>bigwatermelon.sannaha.moe</code>，申请一个通配符证书可以用于所有子域名。</li></ol><h2 id="独立证书"><a href="#独立证书" class="headerlink" title="独立证书"></a>独立证书</h2><h3 id="申请独立证书"><a href="#申请独立证书" class="headerlink" title="申请独立证书"></a>申请独立证书</h3><p>Certbot 可以读取 Nginx 配置，列出这些域名并让用户选择为哪些域名申请证书。这里为 <code>sannaha.moe</code> 和 <code>thinklong.me</code> 两个域名分别申请证书：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta"># 为运行在Nginx上的网站配置HTTPS</span><br><span class="hljs-meta"># 申请后Certbot会自动修改Nginx配置，建议在使用该命令前备份Nginx配置文件</span><br>$ certbot --nginx<br><span class="hljs-meta"># 首次访问Let’s Encrypt服务器时需要根据提示创建账户</span><br>Saving <span class="hljs-keyword">debug</span> <span class="hljs-built_in">log</span> to /var/<span class="hljs-built_in">log</span>/letsencrypt/letsencrypt.log<br>Enter email <span class="hljs-built_in">address</span> (used <span class="hljs-keyword">for</span> urgent renewal and security notices)<br> (Enter &#x27;c&#x27; to cancel): &lt;email<span class="hljs-comment">@sannaha.moe&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="hljs-comment">Please read the Terms of Service at</span><br><span class="hljs-comment">https://letsencrypt.org/documents/LE-SA-v1.3-September-21-2022.pdf. You must</span><br><span class="hljs-comment">agree in order to register with the ACME server. Do you agree?</span><br><span class="hljs-comment">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="hljs-comment">(Y)es/(N)o: Y</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="hljs-comment">Would you be willing, once your first certificate is successfully issued, to</span><br><span class="hljs-comment">share your email address with the Electronic Frontier Foundation, a founding</span><br><span class="hljs-comment">partner of the Let&#x27;s Encrypt project and the non-profit organization that</span><br><span class="hljs-comment">develops Certbot? We&#x27;d like to send you email about our work encrypting the web,</span><br><span class="hljs-comment">EFF news, campaigns, and ways to support digital freedom.</span><br><span class="hljs-comment">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="hljs-comment">(Y)es/(N)o: N</span><br><span class="hljs-comment">Account registered.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"># 选择要申请证书的域名</span><br><span class="hljs-comment">Which names would you like to activate HTTPS for?</span><br><span class="hljs-comment">We recommend selecting either all domains, or all domains in a VirtualHost/server block.</span><br><span class="hljs-comment">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="hljs-comment">1: sannaha.moe</span><br><span class="hljs-comment">2: thinklong.me</span><br><span class="hljs-comment">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="hljs-comment">Select the appropriate numbers separated by commas and/or spaces, or leave input</span><br><span class="hljs-comment">blank to select all options shown (Enter &#x27;c&#x27; to cancel): 1,2</span><br><span class="hljs-comment">Requesting a certificate for sannaha.moe and thinklong.me</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Successfully received certificate.</span><br><span class="hljs-comment">Certificate is saved at: /etc/letsencrypt/live/sannaha.moe/fullchain.pem</span><br><span class="hljs-comment">Key is saved at:         /etc/letsencrypt/live/sannaha.moe/privkey.pem</span><br><span class="hljs-comment">This certificate expires on 2023-02-15.</span><br><span class="hljs-comment">These files will be updated when the certificate renews.</span><br><span class="hljs-comment">Certbot has set up a scheduled task to automatically renew this certificate in the background.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Deploying certificate</span><br><span class="hljs-comment">Successfully deployed certificate for sannaha.moe to /etc/nginx/conf.d/sannaha.conf</span><br><span class="hljs-comment">Successfully deployed certificate for thinklong.me to /etc/nginx/conf.d/thinklong.conf</span><br><span class="hljs-comment">Congratulations! You have successfully enabled HTTPS on https://sannaha.moe and https://thinklong.me</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br><span class="hljs-comment">If you like Certbot, please consider supporting our work by:</span><br><span class="hljs-comment"> * Donating to ISRG / Let&#x27;s Encrypt:   https://letsencrypt.org/donate</span><br><span class="hljs-comment"> * Donating to EFF:                    https://eff.org/donate-le</span><br><span class="hljs-comment">- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -</span><br></code></pre></td></tr></table></figure><h3 id="Nginx配置改动"><a href="#Nginx配置改动" class="headerlink" title="Nginx配置改动"></a>Nginx配置改动</h3><p>申请后 Certbot 会自动对 Nginx 配置进行修改：配置 SSL 证书路径、添加对 443 端口的监听、将 80 端口的访问请求 301 重定向到 HTTPS：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs awk">server &#123;<br>    server_name  sannaha.moe;<br>    root <span class="hljs-regexp">/home/gi</span>t<span class="hljs-regexp">/www/</span>hexo/;<br>    index index.html;<br>    error_page <span class="hljs-number">404</span> =<span class="hljs-number">301</span> https:<span class="hljs-regexp">//</span>sannaha.moe;<br><br>-   listen <span class="hljs-number">80</span> default_server;<br>-   listen [::]:<span class="hljs-number">80</span> default_server;<br>+   listen [::]:<span class="hljs-number">443</span> ssl; <span class="hljs-comment"># managed by Certbot</span><br>+   listen <span class="hljs-number">443</span> ssl; <span class="hljs-comment"># managed by Certbot</span><br>+   ssl_certificate <span class="hljs-regexp">/etc/</span>letsencrypt<span class="hljs-regexp">/live/</span>sannaha.moe/fullchain.pem; <span class="hljs-comment"># managed by Certbot</span><br>+   ssl_certificate_key <span class="hljs-regexp">/etc/</span>letsencrypt<span class="hljs-regexp">/live/</span>sannaha.moe/privkey.pem; <span class="hljs-comment"># managed by Certbot</span><br>+   include <span class="hljs-regexp">/etc/</span>letsencrypt/options-ssl-nginx.conf; <span class="hljs-comment"># managed by Certbot</span><br>+   ssl_dhparam <span class="hljs-regexp">/etc/</span>letsencrypt/ssl-dhparams.pem; <span class="hljs-comment"># managed by Certbot</span><br>&#125;<br><br>+ server &#123;<br>+    <span class="hljs-keyword">if</span> (<span class="hljs-variable">$host</span> = sannaha.moe) &#123;<br>+        return <span class="hljs-number">301</span> https:<span class="hljs-regexp">//</span><span class="hljs-variable">$host</span><span class="hljs-variable">$request_uri</span>;<br>+    &#125; <span class="hljs-comment"># managed by Certbot</span><br>+    server_name  sannaha.moe;<br>+    listen <span class="hljs-number">80</span> default_server;<br>+    listen [::]:<span class="hljs-number">80</span> default_server;<br>+    return <span class="hljs-number">404</span>; <span class="hljs-comment"># managed by Certbot</span><br>+ &#125;<br></code></pre></td></tr></table></figure><h2 id="通配符证书"><a href="#通配符证书" class="headerlink" title="通配符证书"></a>通配符证书</h2><p>通配符证书的使用过程要麻烦一些，需要根据域名选用的 DNS 提供商安装对应的 DNS 插件，授权 Certbot 访问 DNS 提供商，验证对域名的控制权。</p><h3 id="安装DNS插件"><a href="#安装DNS插件" class="headerlink" title="安装DNS插件"></a>安装DNS插件</h3><p>Certbot 支持的 DNS 插件列表可以查阅 <a href="https://eff-certbot.readthedocs.io/en/stable/using.html#dns-plugins">dns-plugins</a> 。比如 DNS 提供商是 cloudflare，需要安装 <a href="https://certbot-dns-cloudflare.readthedocs.io/en/stable/">certbot-dns-cloudflare</a> ：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">$ snap <span class="hljs-keyword">install</span> certbot-dns-cloudflare<br></code></pre></td></tr></table></figure><h3 id="获取token"><a href="#获取token" class="headerlink" title="获取token"></a>获取token</h3><p>访问 <a href="https://dash.cloudflare.com/profile/api-tokens">cloudflare 控制台</a> 获取 token。出于安全考虑，建议不要使用秘钥，而是为 Certbot 创建单独的 API 令牌。</p><ol><li><p> 创建 API 令牌</p></li><li><p> 选择 API 令牌模板为“编辑区域 DNS”</p></li><li><p> 填写令牌信息，选择要管理的域名</p></li><li><p> 确认摘要信息</p></li><li><p> 创建成功</p></li></ol><h3 id="创建凭据文件"><a href="#创建凭据文件" class="headerlink" title="创建凭据文件"></a>创建凭据文件</h3><p>Certbot 是通过 <code>ini</code> 凭据文件读取 token 的，因此需要编写一个下面这样的文件：</p><p>/root/cf.ini</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># Cloudflare API token used by Certbot</span><br><span class="hljs-attr">dns_cloudflare_api_token</span> = <span class="hljs-number">0123456789</span>abcdef0123456789abcdef01234567<br></code></pre></td></tr></table></figure><p>修改凭据文件的权限，限制其他用户的访问：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">限制其他用户对凭据文件的访问</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果Certbot检测到凭据文件可以被其他用户访问，它会显示警告信息</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> 600 /root/cf.ini</span> <br></code></pre></td></tr></table></figure><h3 id="申请通配符证书"><a href="#申请通配符证书" class="headerlink" title="申请通配符证书"></a>申请通配符证书</h3><p>申请通配符证书但不安装（不修改 Nginx 配置），填写 cloudflare 凭据文件路径，指定申请的域名：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">  certbot certonly \<br>  --dns-cloudflare \<br>  --dns-cloudflare-credentials <span class="hljs-regexp">/root/</span>cf.ini \<br>  -d sannaha.moe \<br>  -d *.sannaha.moe<br>  <br>  <br>Successfully received certificate.<br>Certificate is saved at: <span class="hljs-regexp">/etc/</span>letsencrypt<span class="hljs-regexp">/live/</span>sannaha.moe/fullchain.pem<br>Key is saved at:         <span class="hljs-regexp">/etc/</span>letsencrypt<span class="hljs-regexp">/live/</span>sannaha.moe/privkey.pem<br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">certbot certonly \<br>  <span class="hljs-attr">--dns-cloudflare</span> \<br>  <span class="hljs-attr">--dns-cloudflare-credentials</span> /root/<span class="hljs-number">21535</span><span class="hljs-selector-class">.xyz</span><span class="hljs-selector-class">.cf</span><span class="hljs-selector-class">.ini</span> \<br>  -d *.<span class="hljs-number">215315</span><span class="hljs-selector-class">.xyz</span><br><br></code></pre></td></tr></table></figure><h3 id="修改Nginx配置"><a href="#修改Nginx配置" class="headerlink" title="修改Nginx配置"></a>修改Nginx配置</h3><p>申请到证书后需要手动修改 Nginx 配置，修改内容可以参考上面的 <a href="#Nginx%E9%85%8D%E7%BD%AE%E6%94%B9%E5%8A%A8">Nginx配置改动</a> ，多个子域名共用刚才申请到的同一个证书。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># Game</span><br>server &#123;<br>    server_name  bigwatermelon.sannaha.moe;<br>    root <span class="hljs-regexp">/data/</span>website<span class="hljs-regexp">/bigwatermelon/</span>;<br>    index index.html;<br>    <br>    listen [::]:<span class="hljs-number">443</span> ssl;<br>    listen <span class="hljs-number">443</span> ssl;<br>    ssl_certificate <span class="hljs-regexp">/etc/</span>letsencrypt<span class="hljs-regexp">/live/</span>sannaha.moe/fullchain.pem;<br>    ssl_certificate_key <span class="hljs-regexp">/etc/</span>letsencrypt<span class="hljs-regexp">/live/</span>sannaha.moe/privkey.pem;<br>    include <span class="hljs-regexp">/etc/</span>letsencrypt/options-ssl-nginx.conf;<br>    ssl_dhparam <span class="hljs-regexp">/etc/</span>letsencrypt/ssl-dhparams.pem;<br>    error_page <span class="hljs-number">404</span> =<span class="hljs-number">301</span> https:<span class="hljs-regexp">//</span>bigwatermelon.sannaha.moe;<br>&#125;<br><br>server &#123;<br>    server_name  bigwaterlemon.sannaha.moe prpr.sannaha.moe;<br>    listen [::]:<span class="hljs-number">443</span> ssl;<br>    listen <span class="hljs-number">443</span> ssl;<br>    ssl_certificate <span class="hljs-regexp">/etc/</span>letsencrypt<span class="hljs-regexp">/live/</span>sannaha.moe/fullchain.pem;<br>    ssl_certificate_key <span class="hljs-regexp">/etc/</span>letsencrypt<span class="hljs-regexp">/live/</span>sannaha.moe/privkey.pem;<br>    include <span class="hljs-regexp">/etc/</span>letsencrypt/options-ssl-nginx.conf;<br>    ssl_dhparam <span class="hljs-regexp">/etc/</span>letsencrypt/ssl-dhparams.pem;<br>    return <span class="hljs-number">301</span> https:<span class="hljs-regexp">//</span>bigwatermelon.sannaha.moe<span class="hljs-variable">$request_uri</span>;<br>&#125;<br><br>server &#123;<br>    server_name  bigwatermelon.sannaha.moe bigwaterlemon.sannaha.moe prpr.sannaha.moe;<br>    listen       <span class="hljs-number">80</span>;<br>    listen       [::]:<span class="hljs-number">80</span>;<br>    return <span class="hljs-number">301</span> https:<span class="hljs-regexp">//</span>bigwatermelon.sannaha.moe<span class="hljs-variable">$request_uri</span>;<br>&#125;<br><br><span class="hljs-comment"># Rank</span><br>server &#123;<br>    server_name  watermelonrank.sannaha.moe;<br>    root <span class="hljs-regexp">/data/</span>website<span class="hljs-regexp">/watermelonrank/</span>;<br>    index index.html;<br>    <br>    listen [::]:<span class="hljs-number">443</span> ssl;<br>    listen <span class="hljs-number">443</span> ssl;<br>    ssl_certificate <span class="hljs-regexp">/etc/</span>letsencrypt<span class="hljs-regexp">/live/</span>sannaha.moe/fullchain.pem;<br>    ssl_certificate_key <span class="hljs-regexp">/etc/</span>letsencrypt<span class="hljs-regexp">/live/</span>sannaha.moe/privkey.pem;<br>    include <span class="hljs-regexp">/etc/</span>letsencrypt/options-ssl-nginx.conf;<br>    ssl_dhparam <span class="hljs-regexp">/etc/</span>letsencrypt/ssl-dhparams.pem;<br>    error_page <span class="hljs-number">404</span> =<span class="hljs-number">301</span> https:<span class="hljs-regexp">//</span>watermelonrank.sannaha.moe;<br>&#125;<br><br>server &#123;<br>    server_name  watermelon.sannaha.moe;<br>    listen [::]:<span class="hljs-number">443</span> ssl;<br>    listen <span class="hljs-number">443</span> ssl;<br>    ssl_certificate <span class="hljs-regexp">/etc/</span>letsencrypt<span class="hljs-regexp">/live/</span>sannaha.moe/fullchain.pem;<br>    ssl_certificate_key <span class="hljs-regexp">/etc/</span>letsencrypt<span class="hljs-regexp">/live/</span>sannaha.moe/privkey.pem;<br>    include <span class="hljs-regexp">/etc/</span>letsencrypt/options-ssl-nginx.conf;<br>    ssl_dhparam <span class="hljs-regexp">/etc/</span>letsencrypt/ssl-dhparams.pem;<br>    return <span class="hljs-number">301</span> https:<span class="hljs-regexp">//</span>watermelonrank.sannaha.moe<span class="hljs-variable">$request_uri</span>;<br>&#125;<br><br>server &#123;<br>    server_name  watermelonrank.sannaha.moe watermelon.sannaha.moe;<br>    listen       <span class="hljs-number">80</span>;<br>    listen       [::]:<span class="hljs-number">80</span>;<br>    return <span class="hljs-number">301</span> https:<span class="hljs-regexp">//</span>watermelonrank.sannaha.moe<span class="hljs-variable">$request_uri</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="管理证书"><a href="#管理证书" class="headerlink" title="管理证书"></a>管理证书</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 显示从Certbot获得的证书的信息</span><br>$ certbot certificates<br><br><span class="hljs-comment"># 撤销证书</span><br>$ certbot revoke --cert-name sannaha.moe<br><br><span class="hljs-comment"># 在不保存任何证书的情况下测试证书续订功能</span><br>$ certbot renew --dry-run<br>Saving debug log to <span class="hljs-regexp">/var/</span>log<span class="hljs-regexp">/letsencrypt/</span>letsencrypt.log<br><br>- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -<br>Processing <span class="hljs-regexp">/etc/</span>letsencrypt<span class="hljs-regexp">/renewal/</span>sannaha.moe.conf<br>- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -<br>Account registered.<br>Simulating renewal of an existing certificate <span class="hljs-keyword">for</span> sannaha.moe and *.sannaha.moe<br>Waiting <span class="hljs-number">10</span> seconds <span class="hljs-keyword">for</span> DNS changes to propagate<br><br>- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -<br>Processing <span class="hljs-regexp">/etc/</span>letsencrypt<span class="hljs-regexp">/renewal/</span>thinklong.me.conf<br>- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -<br>Simulating renewal of an existing certificate <span class="hljs-keyword">for</span> thinklong.me<br><br>- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -<br>Congratulations, all simulated renewals succeeded: <br>  <span class="hljs-regexp">/etc/</span>letsencrypt<span class="hljs-regexp">/live/</span>sannaha.moe/fullchain.pem (success)<br>  <span class="hljs-regexp">/etc/</span>letsencrypt<span class="hljs-regexp">/live/</span>thinklong.me/fullchain.pem (success)<br>- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -<br></code></pre></td></tr></table></figure><h2 id="常用参数说明"><a href="#常用参数说明" class="headerlink" title="常用参数说明"></a>常用参数说明</h2><p><code>certbot</code> 命令详见：<a href="https://eff-certbot.readthedocs.io/en/stable/using.html#certbot-commands">certbot-commands</a> 。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-comment"># 获取证书，并安装</span><br><span class="hljs-variable">$ </span>certbot<br><br><span class="hljs-comment"># certonly:只申请证书，不安装</span><br><span class="hljs-variable">$ </span>certbot certonly<br><br><span class="hljs-comment"># -d:指定域名</span><br><span class="hljs-variable">$ </span>certbot --nginx -d sannaha.moe -d thinklong.me<br></code></pre></td></tr></table></figure><h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><h2 id="启用HTTPS后无法打开网站"><a href="#启用HTTPS后无法打开网站" class="headerlink" title="启用HTTPS后无法打开网站"></a>启用HTTPS后无法打开网站</h2><ol><li>检查服务器防火墙 443 端口是否打开。</li><li>查看服务器端口能否被外部访问 <a href="https://www.yougetsignal.com/tools/open-ports/">open-ports</a> 。</li></ol><h2 id="无法安装DNS插件"><a href="#无法安装DNS插件" class="headerlink" title="无法安装DNS插件"></a>无法安装DNS插件</h2><p>在 Debian 11 上安装 DNS 插件时报错，按照提示操作即可：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ snap install certbot-dns-cloudflare<br><span class="hljs-keyword">error</span>: cannot perform <span class="hljs-keyword">the</span> following tasks:<br>- Run hook prepare-plug-plugin <span class="hljs-keyword">of</span> snap <span class="hljs-string">&quot;certbot&quot;</span> (<span class="hljs-built_in">run</span> hook <span class="hljs-string">&quot;prepare-plug-plugin&quot;</span>: <br><span class="hljs-comment">-----</span><br>Only connect this interface <span class="hljs-keyword">if</span> you trust <span class="hljs-keyword">the</span> plugin author <span class="hljs-keyword">to</span> have root <span class="hljs-keyword">on</span> <span class="hljs-keyword">the</span> system.<br>Run `snap <span class="hljs-keyword">set</span> certbot trust-plugin-<span class="hljs-keyword">with</span>-root=ok` <span class="hljs-keyword">to</span> acknowledge this <span class="hljs-keyword">and</span> <span class="hljs-keyword">then</span> <span class="hljs-built_in">run</span> this command again <span class="hljs-keyword">to</span> perform <span class="hljs-keyword">the</span> connection.<br>If <span class="hljs-keyword">that</span> doesn&#x27;t work, you may need <span class="hljs-keyword">to</span> remove all certbot-dns-* plugins <span class="hljs-keyword">from</span> <span class="hljs-keyword">the</span> system, <span class="hljs-keyword">then</span> <span class="hljs-keyword">try</span> installing <span class="hljs-keyword">the</span> certbot snap again.<br><span class="hljs-comment">-----)</span><br>$ snap <span class="hljs-keyword">set</span> certbot trust-plugin-<span class="hljs-keyword">with</span>-root=ok<br>$ snap install certbot-dns-cloudflare<br>certbot-dns-cloudflare <span class="hljs-number">1.32</span><span class="hljs-number">.2</span> <span class="hljs-keyword">from</span> Certbot Project (certbot-eff✓) installed<br></code></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://sannaha.moe/Certbot/">用Certbot自动获取Let’s Encrypt证书</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssl</tag>
      
      <tag>dns-cloudflare</tag>
      
      <tag>cloudflare</tag>
      
      <tag>certbot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring</title>
    <link href="/2023/08/08/spring/Spring/"/>
    <url>/2023/08/08/spring/Spring/</url>
    
    <content type="html"><![CDATA[<h1 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h1><p>本部分从最基本的Spring开始。配置文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span>    <br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;base.SimpleBean&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>启动代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;config.xml&quot;</span>);<br>    <span class="hljs-type">SimpleBean</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> context.getBean(SimpleBean.class);<br>    bean.send();<br>    context.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>SimpleBean:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleBean</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;I am send method from SimpleBean!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h2><p>整个继承体系如下:</p><p><img src="ResourceLoader.jpg" alt="ResourceLoader继承体系"></p><p>ResourceLoader代表了<strong>加载资源的一种方式，正是策略模式的实现</strong>。</p><p>构造器源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ClassPathXmlApplicationContext</span><span class="hljs-params">(String[] configLocations, <span class="hljs-type">boolean</span> refresh, ApplicationContext          parent)</span> &#123;<br>    <span class="hljs-comment">//null</span><br>    <span class="hljs-built_in">super</span>(parent);<br>    setConfigLocations(configLocations);<br>    <span class="hljs-comment">//默认true</span><br>    <span class="hljs-keyword">if</span> (refresh) &#123;<br>        refresh();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>首先看父类构造器，沿着继承体系一直向上调用，直到AbstractApplicationContext:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">AbstractApplicationContext</span><span class="hljs-params">(ApplicationContext parent)</span> &#123;<br>    <span class="hljs-built_in">this</span>();<br>    setParent(parent);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">AbstractApplicationContext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.resourcePatternResolver = getResourcePatternResolver();<br>&#125;<br></code></pre></td></tr></table></figure><p>getResourcePatternResolver:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> ResourcePatternResolver <span class="hljs-title function_">getResourcePatternResolver</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PathMatchingResourcePatternResolver</span>(<span class="hljs-built_in">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>PathMatchingResourcePatternResolver支持Ant风格的路径解析。</p><h3 id="设置配置文件路径"><a href="#设置配置文件路径" class="headerlink" title="设置配置文件路径"></a>设置配置文件路径</h3><p>即AbstractRefreshableConfigApplicationContext.setConfigLocations:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setConfigLocations</span><span class="hljs-params">(String... locations)</span> &#123;<br>    <span class="hljs-keyword">if</span> (locations != <span class="hljs-literal">null</span>) &#123;<br>        Assert.noNullElements(locations, <span class="hljs-string">&quot;Config locations must not be null&quot;</span>);<br>        <span class="hljs-built_in">this</span>.configLocations = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[locations.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; locations.length; i++) &#123;<br>            <span class="hljs-built_in">this</span>.configLocations[i] = resolvePath(locations[i]).trim();<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.configLocations = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>resolvePath:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> String <span class="hljs-title function_">resolvePath</span><span class="hljs-params">(String path)</span> &#123;<br>    <span class="hljs-keyword">return</span> getEnvironment().resolveRequiredPlaceholders(path);<br>&#125;<br></code></pre></td></tr></table></figure><p>此方法的目的在于将占位符(placeholder)解析成实际的地址。比如可以这么写: <code>new ClassPathXmlApplicationContext(&quot;classpath:config.xml&quot;);</code>那么classpath:就是需要被解析的。</p><p>getEnvironment方法来自于ConfigurableApplicationContext接口，源码很简单，如果为空就调用createEnvironment创建一个。AbstractApplicationContext.createEnvironment:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> ConfigurableEnvironment <span class="hljs-title function_">createEnvironment</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StandardEnvironment</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Environment接口"><a href="#Environment接口" class="headerlink" title="Environment接口"></a>Environment接口</h4><p>继承体系:</p><p><img src="Environment.jpg" alt="Environment继承体系"></p><p>Environmen接口<strong>代表了当前应用所处的环境。</strong> 从此接口的方法可以看出，其主要和profile、Property相关。</p><h5 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h5><p>Spring Profile特性是从3.1开始的，其主要是为了解决这样一种问题: 线上环境和测试环境使用不同的配置或是数据库或是其它。有了Profile便可以在 不同环境之间无缝切换。<strong>Spring容器管理的所有bean都是和一个profile绑定在一起的。</strong> 使用了Profile的配置文件示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">profile</span>=<span class="hljs-string">&quot;develop&quot;</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath*:jdbc-develop.properties&quot;</span>/&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">profile</span>=<span class="hljs-string">&quot;production&quot;</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath*:jdbc-production.properties&quot;</span>/&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">profile</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath*:jdbc-test.properties&quot;</span>/&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在启动代码中可以用如下代码设置活跃(当前使用的)Profile:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">context.getEnvironment().setActiveProfiles(<span class="hljs-string">&quot;dev&quot;</span>);<br></code></pre></td></tr></table></figure><p>当然使用的方式还有很多(比如注解)，参考:</p><p><a href="http://radiumxie.iteye.com/blog/1851919">spring3.1 profile 配置不同的环境</a></p><p><a href="http://www.mkyong.com/spring/spring-profiles-example/">Spring Profiles example</a></p><h5 id="Property"><a href="#Property" class="headerlink" title="Property"></a>Property</h5><p>这里的Property指的是程序运行时的一些参数，引用注释:</p><blockquote><blockquote><p>properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc Properties objects,Maps, and so on.</p></blockquote></blockquote><h4 id="Environment构造器"><a href="#Environment构造器" class="headerlink" title="Environment构造器"></a>Environment构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">MutablePropertySources</span> <span class="hljs-variable">propertySources</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutablePropertySources</span>(<span class="hljs-built_in">this</span>.logger);<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">AbstractEnvironment</span><span class="hljs-params">()</span> &#123;<br>    customizePropertySources(<span class="hljs-built_in">this</span>.propertySources);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="PropertySources接口"><a href="#PropertySources接口" class="headerlink" title="PropertySources接口"></a>PropertySources接口</h5><p>继承体系:</p><p><img src="PropertySources.jpg" alt="PropertySources继承体系"></p><p>此接口实际上是PropertySource的容器，默认的MutablePropertySources实现内部含有一个CopyOnWriteArrayList作为存储载体。</p><p>StandardEnvironment.customizePropertySources:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** System environment property source name: &#123;<span class="hljs-doctag">@value</span>&#125; */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;systemEnvironment&quot;</span>;<br><span class="hljs-comment">/** JVM system properties property source name: &#123;<span class="hljs-doctag">@value</span>&#125; */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;systemProperties&quot;</span>;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">customizePropertySources</span><span class="hljs-params">(MutablePropertySources propertySources)</span> &#123;<br>    propertySources.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MapPropertySource</span><br>        (SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties()));<br>    propertySources.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SystemEnvironmentPropertySource</span><br>        (SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="PropertySource接口"><a href="#PropertySource接口" class="headerlink" title="PropertySource接口"></a>PropertySource接口</h5><p>PropertySource接口代表了键值对的Property来源。继承体系：</p><p><img src="PropertySource.jpg" alt="PropertySource继承体系"></p><p>AbstractEnvironment.getSystemProperties:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title function_">getSystemProperties</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> (Map) System.getProperties();<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (AccessControlException ex) &#123;<br>        <span class="hljs-keyword">return</span> (Map) <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReadOnlySystemAttributesMap</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">protected</span> String <span class="hljs-title function_">getSystemAttribute</span><span class="hljs-params">(String attributeName)</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">return</span> System.getProperty(attributeName);<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (AccessControlException ex) &#123;<br>                    <span class="hljs-keyword">if</span> (logger.isInfoEnabled()) &#123;<br>                        logger.info(format(<span class="hljs-string">&quot;Caught AccessControlException when accessing system &quot;</span> +<br>                                <span class="hljs-string">&quot;property [%s]; its value will be returned [null]. Reason: %s&quot;</span>,<br>                                attributeName, ex.getMessage()));<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的实现很有意思，如果安全管理器阻止获取全部的系统属性，那么会尝试获取单个属性的可能性，如果还不行就抛异常了。</p><p>getSystemEnvironment方法也是一个套路，不过最终调用的是System.getenv，可以获取jvm和OS的一些版本信息。</p><h4 id="路径Placeholder处理"><a href="#路径Placeholder处理" class="headerlink" title="路径Placeholder处理"></a>路径Placeholder处理</h4><p>AbstractEnvironment.resolveRequiredPlaceholders:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">resolveRequiredPlaceholders</span><span class="hljs-params">(String text)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException &#123;<br>    <span class="hljs-comment">//text即配置文件路径，比如classpath:config.xml</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.propertyResolver.resolveRequiredPlaceholders(text);<br>&#125;<br></code></pre></td></tr></table></figure><p>propertyResolver是一个PropertySourcesPropertyResolver对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ConfigurablePropertyResolver</span> <span class="hljs-variable">propertyResolver</span> <span class="hljs-operator">=</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertySourcesPropertyResolver</span>(<span class="hljs-built_in">this</span>.propertySources);<br></code></pre></td></tr></table></figure><h5 id="PropertyResolver接口"><a href="#PropertyResolver接口" class="headerlink" title="PropertyResolver接口"></a>PropertyResolver接口</h5><p>PropertyResolver继承体系(排除Environment分支):</p><p><img src="PropertyResolver.jpg" alt="PropertyResolver继承体系"></p><p>此接口正是用来解析PropertyResource。</p><h5 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h5><p>AbstractPropertyResolver.resolveRequiredPlaceholders:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">resolveRequiredPlaceholders</span><span class="hljs-params">(String text)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.strictHelper == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-built_in">this</span>.strictHelper = createPlaceholderHelper(<span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> doResolvePlaceholders(text, <span class="hljs-built_in">this</span>.strictHelper);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> PropertyPlaceholderHelper <span class="hljs-title function_">createPlaceholderHelper</span><span class="hljs-params">(<span class="hljs-type">boolean</span> ignoreUnresolvablePlaceholders)</span> &#123;<br>    <span class="hljs-comment">//三个参数分别是$&#123;, &#125;, :</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyPlaceholderHelper</span>(<span class="hljs-built_in">this</span>.placeholderPrefix, <span class="hljs-built_in">this</span>.placeholderSuffix,<br>        <span class="hljs-built_in">this</span>.valueSeparator, ignoreUnresolvablePlaceholders);<br>&#125;<br></code></pre></td></tr></table></figure><p>doResolvePlaceholders：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> String <span class="hljs-title function_">doResolvePlaceholders</span><span class="hljs-params">(String text, PropertyPlaceholderHelper helper)</span> &#123;<br>    <span class="hljs-comment">//PlaceholderResolver接口依然是策略模式的体现</span><br>    <span class="hljs-keyword">return</span> helper.replacePlaceholders(text, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertyPlaceholderHelper</span>.PlaceholderResolver() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">resolvePlaceholder</span><span class="hljs-params">(String placeholderName)</span> &#123;<br>            <span class="hljs-keyword">return</span> getPropertyAsRawString(placeholderName);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>其实代码执行到这里的时候还没有进行xml配置文件的解析，那么这里的解析placeHolder是什么意思呢，原因在于可以这么写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.setProperty(<span class="hljs-string">&quot;spring&quot;</span>, <span class="hljs-string">&quot;classpath&quot;</span>);<br><span class="hljs-type">ClassPathXmlApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;$&#123;spring&#125;:config.xml&quot;</span>);<br><span class="hljs-type">SimpleBean</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> context.getBean(SimpleBean.class);<br></code></pre></td></tr></table></figure><p>这样就可以正确解析。placeholder的替换其实就是字符串操作，这里只说一下正确的属性是怎么来的。实现的关键在于PropertySourcesPropertyResolver.getProperty:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> String <span class="hljs-title function_">getPropertyAsRawString</span><span class="hljs-params">(String key)</span> &#123;<br>    <span class="hljs-keyword">return</span> getProperty(key, String.class, <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-keyword">protected</span> &lt;T&gt; T <span class="hljs-title function_">getProperty</span><span class="hljs-params">(String key, Class&lt;T&gt; targetValueType, <span class="hljs-type">boolean</span> resolveNestedPlaceholders)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.propertySources != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (PropertySource&lt;?&gt; propertySource : <span class="hljs-built_in">this</span>.propertySources) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> propertySource.getProperty(key);<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>很明显了，就是从System.getProperty和System.getenv获取，但是由于环境变量是无法自定义的，所以其实此处只能通过System.setProperty指定。</p><p>注意，classpath:XXX这种写法的classpath前缀到目前为止还没有被处理。</p><h2 id="refresh"><a href="#refresh" class="headerlink" title="refresh"></a>refresh</h2><p>Spring bean解析就在此方法，所以单独提出来。</p><p>AbstractApplicationContext.refresh:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException &#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.startupShutdownMonitor) &#123;<br>        <span class="hljs-comment">// Prepare this context for refreshing.</span><br>        prepareRefresh();<br>        <span class="hljs-comment">// Tell the subclass to refresh the internal bean factory.</span><br>        <span class="hljs-type">ConfigurableListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> obtainFreshBeanFactory();<br>        <span class="hljs-comment">// Prepare the bean factory for use in this context.</span><br>        prepareBeanFactory(beanFactory);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// Allows post-processing of the bean factory in context subclasses.</span><br>            postProcessBeanFactory(beanFactory);<br>            <span class="hljs-comment">// Invoke factory processors registered as beans in the context.</span><br>            invokeBeanFactoryPostProcessors(beanFactory);<br>            <span class="hljs-comment">// Register bean processors that intercept bean creation.</span><br>            registerBeanPostProcessors(beanFactory);<br>            <span class="hljs-comment">// Initialize message source for this context.</span><br>            initMessageSource();<br>            <span class="hljs-comment">// Initialize event multicaster for this context.</span><br>            initApplicationEventMulticaster();<br>            <span class="hljs-comment">// Initialize other special beans in specific context subclasses.</span><br>            onRefresh();<br>            <span class="hljs-comment">// Check for listener beans and register them.</span><br>            registerListeners();<br>            <span class="hljs-comment">// Instantiate all remaining (non-lazy-init) singletons.</span><br>            finishBeanFactoryInitialization(beanFactory);<br>            <span class="hljs-comment">// Last step: publish corresponding event.</span><br>            finishRefresh();<br>        &#125; <span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br>            <span class="hljs-comment">// Destroy already created singletons to avoid dangling resources.</span><br>            destroyBeans();<br>            <span class="hljs-comment">// Reset &#x27;active&#x27; flag.</span><br>            cancelRefresh(ex);<br>            <span class="hljs-comment">// Propagate exception to caller.</span><br>            <span class="hljs-keyword">throw</span> ex;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// Reset common introspection caches in Spring&#x27;s core, since we</span><br>            <span class="hljs-comment">// might not ever need metadata for singleton beans anymore...</span><br>            resetCommonCaches();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="prepareRefresh"><a href="#prepareRefresh" class="headerlink" title="prepareRefresh"></a>prepareRefresh</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareRefresh</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.startupDate = System.currentTimeMillis();<br>    <span class="hljs-built_in">this</span>.closed.set(<span class="hljs-literal">false</span>);<br>    <span class="hljs-built_in">this</span>.active.set(<span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// Initialize any placeholder property sources in the context environment</span><br>    <span class="hljs-comment">//空实现</span><br>    initPropertySources();<br>    <span class="hljs-comment">// Validate that all properties marked as required are resolvable</span><br>    <span class="hljs-comment">// see ConfigurablePropertyResolver#setRequiredProperties</span><br>    getEnvironment().validateRequiredProperties();<br>    <span class="hljs-comment">// Allow for the collection of early ApplicationEvents,</span><br>    <span class="hljs-comment">// to be published once the multicaster is available...</span><br>    <span class="hljs-built_in">this</span>.earlyApplicationEvents = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;ApplicationEvent&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="属性校验"><a href="#属性校验" class="headerlink" title="属性校验"></a>属性校验</h4><p>AbstractEnvironment.validateRequiredProperties:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validateRequiredProperties</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MissingRequiredPropertiesException &#123;<br>    <span class="hljs-built_in">this</span>.propertyResolver.validateRequiredProperties();<br>&#125;<br></code></pre></td></tr></table></figure><p>AbstractPropertyResolver.validateRequiredProperties:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validateRequiredProperties</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">MissingRequiredPropertiesException</span> <span class="hljs-variable">ex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MissingRequiredPropertiesException</span>();<br>    <span class="hljs-keyword">for</span> (String key : <span class="hljs-built_in">this</span>.requiredProperties) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.getProperty(key) == <span class="hljs-literal">null</span>) &#123;<br>            ex.addMissingRequiredProperty(key);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!ex.getMissingRequiredProperties().isEmpty()) &#123;<br>        <span class="hljs-keyword">throw</span> ex;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>requiredProperties是通过setRequiredProperties方法设置的，保存在一个list里面，默认是空的，也就是不需要校验任何属性。</p><h3 id="BeanFactory创建"><a href="#BeanFactory创建" class="headerlink" title="BeanFactory创建"></a>BeanFactory创建</h3><p>由obtainFreshBeanFactory调用AbstractRefreshableApplicationContext.refreshBeanFactory:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refreshBeanFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-comment">//如果已经存在，那么销毁之前的</span><br>    <span class="hljs-keyword">if</span> (hasBeanFactory()) &#123;<br>        destroyBeans();<br>        closeBeanFactory();<br>    &#125;<br>    <span class="hljs-comment">//创建了一个DefaultListableBeanFactory对象</span><br>    <span class="hljs-type">DefaultListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> createBeanFactory();<br>    beanFactory.setSerializationId(getId());<br>    customizeBeanFactory(beanFactory);<br>    loadBeanDefinitions(beanFactory);<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.beanFactoryMonitor) &#123;<br>        <span class="hljs-built_in">this</span>.beanFactory = beanFactory;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="BeanFactory接口"><a href="#BeanFactory接口" class="headerlink" title="BeanFactory接口"></a>BeanFactory接口</h4><p>此接口实际上就是Bean容器，其继承体系:</p><p><img src="BeanFactory.jpg" alt="BeanFactory继承体系"></p><h4 id="BeanFactory定制"><a href="#BeanFactory定制" class="headerlink" title="BeanFactory定制"></a>BeanFactory定制</h4><p>AbstractRefreshableApplicationContext.customizeBeanFactory方法用于给子类提供一个自由配置的机会，默认实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">customizeBeanFactory</span><span class="hljs-params">(DefaultListableBeanFactory beanFactory)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.allowBeanDefinitionOverriding != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//默认false，不允许覆盖</span><br>        beanFactory.setAllowBeanDefinitionOverriding(<span class="hljs-built_in">this</span>.allowBeanDefinitionOverriding);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.allowCircularReferences != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//默认false，不允许循环引用</span><br>        beanFactory.setAllowCircularReferences(<span class="hljs-built_in">this</span>.allowCircularReferences);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Bean加载"><a href="#Bean加载" class="headerlink" title="Bean加载"></a>Bean加载</h4><p>AbstractXmlApplicationContext.loadBeanDefinitions，这个便是核心的bean加载了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(DefaultListableBeanFactory beanFactory)</span> &#123;<br>    <span class="hljs-comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span><br>    <span class="hljs-type">XmlBeanDefinitionReader</span> <span class="hljs-variable">beanDefinitionReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanDefinitionReader</span>(beanFactory);<br>    <span class="hljs-comment">// Configure the bean definition reader with this context&#x27;s</span><br>    <span class="hljs-comment">// resource loading environment.</span><br>    beanDefinitionReader.setEnvironment(<span class="hljs-built_in">this</span>.getEnvironment());<br>    beanDefinitionReader.setResourceLoader(<span class="hljs-built_in">this</span>);<br>    beanDefinitionReader.setEntityResolver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceEntityResolver</span>(<span class="hljs-built_in">this</span>));<br>    <span class="hljs-comment">// Allow a subclass to provide custom initialization of the reader,</span><br>    <span class="hljs-comment">// then proceed with actually loading the bean definitions.</span><br>    <span class="hljs-comment">//默认空实现</span><br>    initBeanDefinitionReader(beanDefinitionReader);<br>    loadBeanDefinitions(beanDefinitionReader);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="EntityResolver"><a href="#EntityResolver" class="headerlink" title="EntityResolver"></a>EntityResolver</h5><p>此处只说明用到的部分继承体系:</p><p><img src="EntityResolver.jpg" alt="EntityResolver继承体系"></p><p>EntityResolver接口在org.xml.sax中定义。DelegatingEntityResolver用于schema和dtd的解析。</p><h5 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h5><p>继承体系:</p><p><img src="BeanDefinitionReader.jpg" alt="BeanDefinitionReader继承体系"></p><h5 id="路径解析-Ant"><a href="#路径解析-Ant" class="headerlink" title="路径解析(Ant)"></a>路径解析(Ant)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(XmlBeanDefinitionReader reader)</span> &#123;<br>    Resource[] configResources = getConfigResources();<br>    <span class="hljs-keyword">if</span> (configResources != <span class="hljs-literal">null</span>) &#123;<br>        reader.loadBeanDefinitions(configResources);<br>    &#125;<br>    String[] configLocations = getConfigLocations();<br>    <span class="hljs-comment">//here</span><br>    <span class="hljs-keyword">if</span> (configLocations != <span class="hljs-literal">null</span>) &#123;<br>        reader.loadBeanDefinitions(configLocations);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AbstractBeanDefinitionReader.loadBeanDefinitions:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(String... locations)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br>    Assert.notNull(locations, <span class="hljs-string">&quot;Location array must not be null&quot;</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (String location : locations) &#123;<br>        counter += loadBeanDefinitions(location);<br>    &#125;<br>    <span class="hljs-keyword">return</span> counter;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第二个参数为空</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(String location, Set&lt;Resource&gt; actualResources)</span> &#123;<br>    <span class="hljs-type">ResourceLoader</span> <span class="hljs-variable">resourceLoader</span> <span class="hljs-operator">=</span> getResourceLoader();<br>    <span class="hljs-comment">//参见ResourceLoader类图，ClassPathXmlApplicationContext实现了此接口</span><br>    <span class="hljs-keyword">if</span> (resourceLoader <span class="hljs-keyword">instanceof</span> ResourcePatternResolver) &#123;<br>        <span class="hljs-comment">// Resource pattern matching available.</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">loadCount</span> <span class="hljs-operator">=</span> loadBeanDefinitions(resources);<br>            <span class="hljs-keyword">if</span> (actualResources != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">for</span> (Resource resource : resources) &#123;<br>                    actualResources.add(resource);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> loadCount;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionStoreException</span>(<br>                    <span class="hljs-string">&quot;Could not resolve bean definition resource pattern [&quot;</span> + location + <span class="hljs-string">&quot;]&quot;</span>, ex);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Can only load single resources by absolute URL.</span><br>        <span class="hljs-type">Resource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> resourceLoader.getResource(location);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">loadCount</span> <span class="hljs-operator">=</span> loadBeanDefinitions(resource);<br>        <span class="hljs-keyword">if</span> (actualResources != <span class="hljs-literal">null</span>) &#123;<br>            actualResources.add(resource);<br>        &#125;<br>        <span class="hljs-keyword">return</span> loadCount;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>getResource的实现在AbstractApplicationContext：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Resource[] getResources(String locationPattern) <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">//构造器中初始化，PathMatchingResourcePatternResolver对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.resourcePatternResolver.getResources(locationPattern);<br>&#125;<br></code></pre></td></tr></table></figure><p>PathMatchingResourcePatternResolver是ResourceLoader继承体系的一部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Resource[] getResources(String locationPattern) <span class="hljs-keyword">throws</span> IOException &#123;<br>    Assert.notNull(locationPattern, <span class="hljs-string">&quot;Location pattern must not be null&quot;</span>);<br>    <span class="hljs-comment">//classpath:</span><br>    <span class="hljs-keyword">if</span> (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123;<br>        <span class="hljs-comment">// a class path resource (multiple resources for same name possible)</span><br>        <span class="hljs-comment">//matcher是一个AntPathMatcher对象</span><br>        <span class="hljs-keyword">if</span> (getPathMatcher().isPattern(locationPattern<br>            .substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123;<br>            <span class="hljs-comment">// a class path resource pattern</span><br>            <span class="hljs-keyword">return</span> findPathMatchingResources(locationPattern);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// all class path resources with the given name</span><br>            <span class="hljs-keyword">return</span> findAllClassPathResources(locationPattern<br>                .substring(CLASSPATH_ALL_URL_PREFIX.length()));<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Only look for a pattern after a prefix here</span><br>        <span class="hljs-comment">// (to not get fooled by a pattern symbol in a strange prefix).</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">prefixEnd</span> <span class="hljs-operator">=</span> locationPattern.indexOf(<span class="hljs-string">&quot;:&quot;</span>) + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123;<br>            <span class="hljs-comment">// a file pattern</span><br>            <span class="hljs-keyword">return</span> findPathMatchingResources(locationPattern);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// a single resource with the given name</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resource</span>[] &#123;getResourceLoader().getResource(locationPattern)&#125;;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>isPattern:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isPattern</span><span class="hljs-params">(String path)</span> &#123;<br>    <span class="hljs-keyword">return</span> (path.indexOf(<span class="hljs-string">&#x27;*&#x27;</span>) != -<span class="hljs-number">1</span> || path.indexOf(<span class="hljs-string">&#x27;?&#x27;</span>) != -<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出配置文件路径是支持ant风格的，也就是可以这么写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;con*.xml&quot;</span>);<br></code></pre></td></tr></table></figure><p>具体怎么解析ant风格的就不写了。</p><h5 id="配置文件加载"><a href="#配置文件加载" class="headerlink" title="配置文件加载"></a>配置文件加载</h5><p>入口方法在AbstractBeanDefinitionReader的217行:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//加载</span><br>Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);<br><span class="hljs-comment">//解析</span><br><span class="hljs-type">int</span> <span class="hljs-variable">loadCount</span> <span class="hljs-operator">=</span> loadBeanDefinitions(resources);<br></code></pre></td></tr></table></figure><p>最终逐个调用XmlBeanDefinitionReader的loadBeanDefinitions方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(Resource resource)</span> &#123;<br>    <span class="hljs-keyword">return</span> loadBeanDefinitions(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EncodedResource</span>(resource));<br>&#125;<br></code></pre></td></tr></table></figure><p>Resource是代表一种资源的接口，其类图:</p><p><img src="Resource.jpg" alt="Resource类图"></p><p>EncodedResource扮演的其实是一个装饰器的模式，为InputStreamSource添加了字符编码(虽然默认为null)。这样为我们自定义xml配置文件的编码方式提供了机会。</p><p>之后关键的源码只有两行:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">(EncodedResource encodedResource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException &#123;<br>    <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> encodedResource.getResource().getInputStream();<br>    <span class="hljs-type">InputSource</span> <span class="hljs-variable">inputSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InputSource</span>(inputStream);<br>    <span class="hljs-keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());<br>&#125;<br></code></pre></td></tr></table></figure><p>InputSource是org.xml.sax的类。</p><p>doLoadBeanDefinitions：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doLoadBeanDefinitions</span><span class="hljs-params">(InputSource inputSource, Resource resource)</span> &#123;<br>    <span class="hljs-type">Document</span> <span class="hljs-variable">doc</span> <span class="hljs-operator">=</span> doLoadDocument(inputSource, resource);<br>    <span class="hljs-keyword">return</span> registerBeanDefinitions(doc, resource);<br>&#125;<br></code></pre></td></tr></table></figure><p>doLoadDocument:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Document <span class="hljs-title function_">doLoadDocument</span><span class="hljs-params">(InputSource inputSource, Resource resource)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="hljs-built_in">this</span>.errorHandler,<br>        getValidationModeForResource(resource), isNamespaceAware());<br>&#125;<br></code></pre></td></tr></table></figure><p>documentLoader是一个DefaultDocumentLoader对象，此类是DocumentLoader接口的唯一实现。getEntityResolver方法返回ResourceEntityResolver，上面说过了。errorHandler是一个SimpleSaxErrorHandler对象。</p><p>校验模型其实就是确定xml文件使用xsd方式还是dtd方式来校验，忘了的话左转度娘。Spring会通过读取xml文件的方式判断应该采用哪种。</p><p>NamespaceAware默认false，因为默认配置了校验为true。</p><p>DefaultDocumentLoader.loadDocument:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Document <span class="hljs-title function_">loadDocument</span><span class="hljs-params">(InputSource inputSource, EntityResolver entityResolver,</span><br><span class="hljs-params">    ErrorHandler errorHandler, <span class="hljs-type">int</span> validationMode, <span class="hljs-type">boolean</span> namespaceAware)</span> &#123;<br>    <span class="hljs-comment">//这里就是老套路了，可以看出，Spring还是使用了dom的方式解析，即一次全部load到内存</span><br>    <span class="hljs-type">DocumentBuilderFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> createDocumentBuilderFactory(validationMode, namespaceAware);<br>    <span class="hljs-type">DocumentBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> createDocumentBuilder(factory, entityResolver, errorHandler);<br>    <span class="hljs-keyword">return</span> builder.parse(inputSource);<br>&#125;<br></code></pre></td></tr></table></figure><p>createDocumentBuilderFactory比较有意思:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> DocumentBuilderFactory <span class="hljs-title function_">createDocumentBuilderFactory</span><span class="hljs-params">(<span class="hljs-type">int</span> validationMode, <span class="hljs-type">boolean</span> namespaceAware&#123;</span><br><span class="hljs-params">    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance()</span>;<br>    factory.setNamespaceAware(namespaceAware);<br>    <span class="hljs-keyword">if</span> (validationMode != XmlValidationModeDetector.VALIDATION_NONE) &#123;<br>        <span class="hljs-comment">//此方法设为true仅对dtd有效，xsd(schema)无效</span><br>        factory.setValidating(<span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">if</span> (validationMode == XmlValidationModeDetector.VALIDATION_XSD) &#123;<br>            <span class="hljs-comment">// Enforce namespace aware for XSD...</span><br>             <span class="hljs-comment">//开启xsd(schema)支持</span><br>            factory.setNamespaceAware(<span class="hljs-literal">true</span>);<br>             <span class="hljs-comment">//这个也是Java支持Schema的套路，可以问度娘</span><br>            factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> factory;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Bean解析"><a href="#Bean解析" class="headerlink" title="Bean解析"></a>Bean解析</h5><p>XmlBeanDefinitionReader.registerBeanDefinitions:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(Document doc, Resource resource)</span> &#123;<br>    <span class="hljs-type">BeanDefinitionDocumentReader</span> <span class="hljs-variable">documentReader</span> <span class="hljs-operator">=</span> createBeanDefinitionDocumentReader();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">countBefore</span> <span class="hljs-operator">=</span> getRegistry().getBeanDefinitionCount();<br>    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));<br>    <span class="hljs-keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;<br>&#125;<br></code></pre></td></tr></table></figure><p>createBeanDefinitionDocumentReader:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> BeanDefinitionDocumentReader <span class="hljs-title function_">createBeanDefinitionDocumentReader</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> BeanDefinitionDocumentReader.class.cast<br>      <span class="hljs-comment">//反射</span><br>      (BeanUtils.instantiateClass(<span class="hljs-built_in">this</span>.documentReaderClass));<br>&#125;<br></code></pre></td></tr></table></figure><p>documentReaderClass默认是DefaultBeanDefinitionDocumentReader，这其实也是策略模式，通过setter方法可以更换其实现。</p><p>注意cast方法，代替了强转。</p><p>createReaderContext：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> XmlReaderContext <span class="hljs-title function_">createReaderContext</span><span class="hljs-params">(Resource resource)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlReaderContext</span>(resource, <span class="hljs-built_in">this</span>.problemReporter, <span class="hljs-built_in">this</span>.eventListener,<br>        <span class="hljs-built_in">this</span>.sourceExtractor, <span class="hljs-built_in">this</span>, getNamespaceHandlerResolver());<br>&#125;<br></code></pre></td></tr></table></figure><p>problemReporter是一个FailFastProblemReporter对象。</p><p>eventListener是EmptyReaderEventListener对象，此类里的方法都是空实现。</p><p>sourceExtractor是NullSourceExtractor对象，直接返回空，也是空实现。</p><p>getNamespaceHandlerResolver默认返回DefaultNamespaceHandlerResolver对象，用来获取xsd对应的处理器。</p><p>XmlReaderContext的作用感觉就是这一堆参数的容器，糅合到一起传给DocumentReader，并美其名为Context。可以看出，Spring中到处都是策略模式，大量操作被抽象成接口。</p><p>DefaultBeanDefinitionDocumentReader.registerBeanDefinitions:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(Document doc, XmlReaderContext readerContext)</span> &#123;<br>    <span class="hljs-built_in">this</span>.readerContext = readerContext;<br>    <span class="hljs-type">Element</span> <span class="hljs-variable">root</span> <span class="hljs-operator">=</span> doc.getDocumentElement();<br>    doRegisterBeanDefinitions(root);<br>&#125;<br></code></pre></td></tr></table></figure><p>doRegisterBeanDefinitions:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRegisterBeanDefinitions</span><span class="hljs-params">(Element root)</span> &#123;<br>    <span class="hljs-type">BeanDefinitionParserDelegate</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.delegate;<br>    <span class="hljs-built_in">this</span>.delegate = createDelegate(getReaderContext(), root, parent);<br>    <span class="hljs-comment">//默认的命名空间即</span><br>    <span class="hljs-comment">//http://www.springframework.org/schema/beans</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.delegate.isDefaultNamespace(root)) &#123;<br>        <span class="hljs-comment">//检查profile属性</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">profileSpec</span> <span class="hljs-operator">=</span> root.getAttribute(PROFILE_ATTRIBUTE);<br>        <span class="hljs-keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;<br>            <span class="hljs-comment">//profile属性可以以,分割</span><br>            String[] specifiedProfiles = StringUtils.tokenizeToStringArray(<br>                    profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);<br>            <span class="hljs-keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    preProcessXml(root);<br>    parseBeanDefinitions(root, <span class="hljs-built_in">this</span>.delegate);<br>    postProcessXml(root);<br>    <span class="hljs-built_in">this</span>.delegate = parent;<br>&#125;<br></code></pre></td></tr></table></figure><p>delegate的作用在于处理beans标签的嵌套，其实Spring配置文件是可以写成这样的:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span>    <br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;base.SimpleBean&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;java.lang.Object&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>xml(schema)的命名空间其实类似于java的报名，命名空间采用URL，比如Spring的是这样:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span>    <br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><p>xmlns属性就是xml规范定义的用来设置命名空间的。这样设置了之后其实里面的bean元素全名就相当于<a href="http://www.springframework.org/schema/beans:bean%EF%BC%8C%E5%8F%AF%E4%BB%A5%E6%9C%89%E6%95%88%E7%9A%84%E9%98%B2%E6%AD%A2%E5%91%BD%E5%90%8D%E5%86%B2%E7%AA%81%E3%80%82%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E8%A7%84%E8%8C%83%E5%AE%9A%E4%B9%89%E7%9A%84org.w3c.dom.Node.getNamespaceURI%E6%96%B9%E6%B3%95%E8%8E%B7%E5%BE%97%E3%80%82">http://www.springframework.org/schema/beans:bean，可以有效的防止命名冲突。命名空间可以通过规范定义的org.w3c.dom.Node.getNamespaceURI方法获得。</a></p><p>注意一下profile的检查, AbstractEnvironment.acceptsProfiles:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acceptsProfiles</span><span class="hljs-params">(String... profiles)</span> &#123;<br>    Assert.notEmpty(profiles, <span class="hljs-string">&quot;Must specify at least one profile&quot;</span>);<br>    <span class="hljs-keyword">for</span> (String profile : profiles) &#123;<br>        <span class="hljs-keyword">if</span> (StringUtils.hasLength(profile) &amp;&amp; profile.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;!&#x27;</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!isProfileActive(profile.substring(<span class="hljs-number">1</span>))) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isProfileActive(profile)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>原理很简单，注意从源码可以看出，<strong>profile属性支持!取反</strong>。</p><p>preProcessXml方法是个空实现，供子类去覆盖，<strong>目的在于给子类一个把我们自定义的标签转为Spring标准标签的机会</strong>, 想的真周到。</p><p>DefaultBeanDefinitionDocumentReader.parseBeanDefinitions：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseBeanDefinitions</span><span class="hljs-params">(Element root, BeanDefinitionParserDelegate delegate)</span> &#123;<br>    <span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;<br>        <span class="hljs-type">NodeList</span> <span class="hljs-variable">nl</span> <span class="hljs-operator">=</span> root.getChildNodes();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> nl.item(i);<br>            <span class="hljs-keyword">if</span> (node <span class="hljs-keyword">instanceof</span> Element) &#123;<br>                <span class="hljs-type">Element</span> <span class="hljs-variable">ele</span> <span class="hljs-operator">=</span> (Element) node;<br>                <span class="hljs-keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;<br>                    parseDefaultElement(ele, delegate);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    delegate.parseCustomElement(ele);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        delegate.parseCustomElement(root);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见，对于非默认命名空间的元素交由delegate处理。</p><h4 id="默认命名空间解析"><a href="#默认命名空间解析" class="headerlink" title="默认命名空间解析"></a>默认命名空间解析</h4><p>即import, alias, bean, 嵌套的beans四种元素。parseDefaultElement:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseDefaultElement</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;<br>    <span class="hljs-comment">//&quot;import&quot;</span><br>    <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;<br>        importBeanDefinitionResource(ele);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;<br>        processAliasRegistration(ele);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;<br>        processBeanDefinition(ele, delegate);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;<br>        <span class="hljs-comment">// recurse</span><br>        doRegisterBeanDefinitions(ele);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="import"><a href="#import" class="headerlink" title="import"></a>import</h5><p>写法示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;CTIContext.xml&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;customerContext.xml&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>importBeanDefinitionResource套路和之前的配置文件加载完全一样，不过注意被import进来的文件是先于当前文件 被解析的。</p><h5 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h5><p>假如有一个bean名为componentA-dataSource，但是另一个组件想以componentB-dataSource的名字使用，就可以这样定义:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;componentA-dataSource&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;componentB-dataSource&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>processAliasRegistration核心源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processAliasRegistration</span><span class="hljs-params">(Element ele)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">alias</span> <span class="hljs-operator">=</span> ele.getAttribute(ALIAS_ATTRIBUTE);<br>    getReaderContext().getRegistry().registerAlias(name, alias);<br>    getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));<br>&#125;<br></code></pre></td></tr></table></figure><p>从前面的源码可以发现，registry其实就是DefaultListableBeanFactory，它实现了BeanDefinitionRegistry接口。registerAlias方法的实现在SimpleAliasRegistry:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerAlias</span><span class="hljs-params">(String name, String alias)</span> &#123;<br>    Assert.hasText(name, <span class="hljs-string">&quot;&#x27;name&#x27; must not be empty&quot;</span>);<br>    Assert.hasText(alias, <span class="hljs-string">&quot;&#x27;alias&#x27; must not be empty&quot;</span>);<br>    <span class="hljs-comment">//名字和别名一样</span><br>    <span class="hljs-keyword">if</span> (alias.equals(name)) &#123;<br>        <span class="hljs-comment">//ConcurrentHashMap</span><br>        <span class="hljs-built_in">this</span>.aliasMap.remove(alias);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">registeredName</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.aliasMap.get(alias);<br>        <span class="hljs-keyword">if</span> (registeredName != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (registeredName.equals(name)) &#123;<br>                <span class="hljs-comment">// An existing alias - no need to re-register</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!allowAliasOverriding()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span><br>                    (<span class="hljs-string">&quot;Cannot register alias &#x27;&quot;</span> + alias + <span class="hljs-string">&quot;&#x27; for name &#x27;&quot;</span> +<br>                    name + <span class="hljs-string">&quot;&#x27;: It is already registered for name &#x27;&quot;</span> + registeredName + <span class="hljs-string">&quot;&#x27;.&quot;</span>);<br>            &#125;<br>        &#125;<br>        checkForAliasCircle(name, alias);<br>        <span class="hljs-built_in">this</span>.aliasMap.put(alias, name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以别名关系的保存使用Map完成，key为别名，value为本来的名字。</p><h5 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h5><p>bean节点是Spring最最常见的节点了。</p><p>DefaultBeanDefinitionDocumentReader.processBeanDefinition:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processBeanDefinition</span><span class="hljs-params">(Element ele, BeanDefinitionParserDelegate delegate)</span> &#123;<br>    <span class="hljs-type">BeanDefinitionHolder</span> <span class="hljs-variable">bdHolder</span> <span class="hljs-operator">=</span> delegate.parseBeanDefinitionElement(ele);<br>    <span class="hljs-keyword">if</span> (bdHolder != <span class="hljs-literal">null</span>) &#123;<br>        bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// Register the final decorated instance.</span><br>            BeanDefinitionReaderUtils.registerBeanDefinition<br>                (bdHolder, getReaderContext().getRegistry());<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;<br>            getReaderContext().error(<span class="hljs-string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +<br>                    bdHolder.getBeanName() + <span class="hljs-string">&quot;&#x27;&quot;</span>, ele, ex);<br>        &#125;<br>        <span class="hljs-comment">// Send registration event.</span><br>        getReaderContext().fireComponentRegistered(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComponentDefinition</span>(bdHolder));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="id-amp-name处理"><a href="#id-amp-name处理" class="headerlink" title="id &amp; name处理"></a>id &amp; name处理</h6><p>最终调用BeanDefinitionParserDelegate.parseBeanDefinitionElement(Element ele, BeanDefinition containingBean)，源码较长，分部分说明。</p><p>首先获取到id和name属性，<strong>name属性支持配置多个，以逗号分隔，如果没有指定id，那么将以第一个name属性值代替。id必须是唯一的，name属性其实是alias的角色，可以和其它的bean重复，如果name也没有配置，那么其实什么也没做</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> ele.getAttribute(ID_ATTRIBUTE);<br><span class="hljs-type">String</span> <span class="hljs-variable">nameAttr</span> <span class="hljs-operator">=</span> ele.getAttribute(NAME_ATTRIBUTE);<br>List&lt;String&gt; aliases = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();<br><span class="hljs-keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;<br>    <span class="hljs-comment">//按,分隔</span><br>    String[] nameArr = StringUtils.tokenizeToStringArray<br>        (nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);<br>    aliases.addAll(Arrays.asList(nameArr));<br>&#125;<br><span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> id;<br><span class="hljs-keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;<br>    <span class="hljs-comment">//name的第一个值作为id</span><br>    beanName = aliases.remove(<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">//默认null</span><br><span class="hljs-keyword">if</span> (containingBean == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">//校验id是否已重复，如果重复直接抛异常</span><br>    <span class="hljs-comment">//校验是通过内部一个HashSet完成的，出现过的id都会保存进此Set</span><br>    checkNameUniqueness(beanName, aliases, ele);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="beanName生成"><a href="#beanName生成" class="headerlink" title="beanName生成"></a>beanName生成</h6><p>如果name和id属性都没有指定，那么Spring会自己生成一个, BeanDefinitionParserDelegate.parseBeanDefinitionElement:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">beanName = <span class="hljs-built_in">this</span>.readerContext.generateBeanName(beanDefinition);<br><span class="hljs-type">String</span> <span class="hljs-variable">beanClassName</span> <span class="hljs-operator">=</span> beanDefinition.getBeanClassName();<br>aliases.add(beanClassName);<br></code></pre></td></tr></table></figure><p>可见，Spring同时会把类名作为其别名。</p><p>最终调用的是BeanDefinitionReaderUtils.generateBeanName:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">generateBeanName</span><span class="hljs-params">(</span><br><span class="hljs-params">        BeanDefinition definition, BeanDefinitionRegistry registry, <span class="hljs-type">boolean</span> isInnerBean)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">generatedBeanName</span> <span class="hljs-operator">=</span> definition.getBeanClassName();<br>    <span class="hljs-keyword">if</span> (generatedBeanName == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (definition.getParentName() != <span class="hljs-literal">null</span>) &#123;<br>            generatedBeanName = definition.getParentName() + <span class="hljs-string">&quot;$child&quot;</span>;<br>             <span class="hljs-comment">//工厂方法产生的bean</span><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (definition.getFactoryBeanName() != <span class="hljs-literal">null</span>) &#123;<br>            generatedBeanName = definition.getFactoryBeanName() + <span class="hljs-string">&quot;$created&quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> generatedBeanName;<br>    <span class="hljs-keyword">if</span> (isInnerBean) &#123;<br>        <span class="hljs-comment">// Inner bean: generate identity hashcode suffix.</span><br>        id = generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + <br>            ObjectUtils.getIdentityHexString(definition);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Top-level bean: use plain class name.</span><br>        <span class="hljs-comment">// Increase counter until the id is unique.</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>         <span class="hljs-comment">//用类名#自增的数字命名</span><br>        <span class="hljs-keyword">while</span> (counter == -<span class="hljs-number">1</span> || registry.containsBeanDefinition(id)) &#123;<br>            counter++;<br>            id = generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + counter;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> id;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="bean解析"><a href="#bean解析" class="headerlink" title="bean解析"></a>bean解析</h6><p>还是分部分说明(parseBeanDefinitionElement)。</p><p>首先获取到bean的class属性和parent属性，配置了parent之后，当前bean会继承父bean的属性。之后根据class和parent创建BeanDefinition对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;<br>    className = ele.getAttribute(CLASS_ATTRIBUTE).trim();<br>&#125;<br><span class="hljs-type">String</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;<br>    parent = ele.getAttribute(PARENT_ATTRIBUTE);<br>&#125;<br><span class="hljs-type">AbstractBeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> createBeanDefinition(className, parent);<br></code></pre></td></tr></table></figure><p>BeanDefinition的创建在BeanDefinitionReaderUtils.createBeanDefinition:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AbstractBeanDefinition <span class="hljs-title function_">createBeanDefinition</span><span class="hljs-params">(</span><br><span class="hljs-params">        String parentName, String className, ClassLoader classLoader)</span> &#123;<br>    <span class="hljs-type">GenericBeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericBeanDefinition</span>();<br>    bd.setParentName(parentName);<br>    <span class="hljs-keyword">if</span> (className != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (classLoader != <span class="hljs-literal">null</span>) &#123;<br>            bd.setBeanClass(ClassUtils.forName(className, classLoader));<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            bd.setBeanClassName(className);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> bd;<br>&#125;<br></code></pre></td></tr></table></figure><p>之后是解析bean的其它属性，其实就是读取其配置，调用相应的setter方法保存在BeanDefinition中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);<br></code></pre></td></tr></table></figure><p>之后解析bean的decription子元素:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;b&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;one, two&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;base.SimpleBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>SimpleBean<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>就仅仅是个描述。</p><p>然后是meta子元素的解析，meta元素在xml配置文件里是这样的:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;b&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;one, two&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;base.SimpleBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;skywalker&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注释上说，这样可以将任意的元数据附到对应的bean definition上。解析过程源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parseMetaElements</span><span class="hljs-params">(Element ele, BeanMetadataAttributeAccessor attributeAccessor)</span> &#123;<br>    <span class="hljs-type">NodeList</span> <span class="hljs-variable">nl</span> <span class="hljs-operator">=</span> ele.getChildNodes();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nl.getLength(); i++) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> nl.item(i);<br>        <span class="hljs-keyword">if</span> (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, META_ELEMENT)) &#123;<br>            <span class="hljs-type">Element</span> <span class="hljs-variable">metaElement</span> <span class="hljs-operator">=</span> (Element) node;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> metaElement.getAttribute(KEY_ATTRIBUTE);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> metaElement.getAttribute(VALUE_ATTRIBUTE);<br>             <span class="hljs-comment">//就是一个key, value的载体，无他</span><br>            <span class="hljs-type">BeanMetadataAttribute</span> <span class="hljs-variable">attribute</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanMetadataAttribute</span>(key, value);<br>             <span class="hljs-comment">//sourceExtractor默认是NullSourceExtractor，返回的是空</span><br>            attribute.setSource(extractSource(metaElement));<br>            attributeAccessor.addMetadataAttribute(attribute);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AbstractBeanDefinition继承自BeanMetadataAttributeAccessor类，底层使用了一个LinkedHashMap保存metadata。这个metadata具体是做什么暂时还不知道。</p><p>lookup-method解析：</p><p>此标签的作用在于当一个bean的某个方法被设置为lookup-method后，<strong>每次调用此方法时，都会返回一个新的指定bean的对象</strong>。用法示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;apple&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cn.com.willchen.test.di.Apple&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--水果盘--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;fruitPlate&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;cn.com.willchen.test.di.FruitPlate&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">lookup-method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;getFruit&quot;</span> <span class="hljs-attr">bean</span>=<span class="hljs-string">&quot;apple&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>数据保存在Set中，对应的类是MethodOverrides。可以参考:</p><p><a href="http://www.cnblogs.com/ViviChan/p/4981619.html">Spring - lookup-method方式实现依赖注入</a></p><p>replace-mothod解析:</p><p>此标签用于替换bean里面的特定的方法实现，替换者必须实现Spring的MethodReplacer接口，有点像aop的意思。</p><p>配置文件示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;replacer&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;springroad.deomo.chap4.MethodReplace&quot;</span> /&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;testBean&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;springroad.deomo.chap4.LookupMethodBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">replaced-method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;test&quot;</span> <span class="hljs-attr">replacer</span>=<span class="hljs-string">&quot;replacer&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">arg-type</span> <span class="hljs-attr">match</span>=<span class="hljs-string">&quot;String&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">replaced-method</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span> <br></code></pre></td></tr></table></figure><p>arg-type的作用是指定替换方法的参数类型，因为接口的定义参数都是Object的。参考: <a href="http://blog.csdn.net/lee576/article/details/8725548">SPRING.NET 1.3.2 学习20–方法注入之替换方法注入</a></p><p>解析之后将数据放在ReplaceOverride对象中，里面有一个LinkedList<String>专门用于保存arg-type。</p><p>构造参数(constructor-arg)解析:</p><p>作用一目了然，使用示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;base.SimpleBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.String&quot;</span>&gt;</span>Cat<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>type一般不需要指定，除了泛型集合那种。除此之外，constructor-arg还支持name, index, ref等属性，可以具体的指定参数的位置等。构造参数解析后保存在BeanDefinition内部一个ConstructorArgumentValues对象中。如果设置了index属性，那么以Map&lt;Integer, ValueHolder&gt;的形式保存，反之，以List<ValueHolder>的形式保存。</p><p>property解析:</p><p>非常常用的标签，用以为bean的属性赋值，支持value和ref两种形式，示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;base.SimpleBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;skywalker&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>value和ref属性不能同时出现，如果是ref，那么将其值保存在不可变的RuntimeBeanReference对象中，其实现了BeanReference接口，此接口只有一个getBeanName方法。如果是value，那么将其值保存在TypedStringValue对象中。最终将对象保存在BeanDefinition内部一个MutablePropertyValues对象中(内部以ArrayList实现)。</p><p>qualifier解析:</p><p>配置示例:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;base.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;skywalker&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;12&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">qualifier</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.springframework.beans.factory.annotation.Qualifier&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;student&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;base.Student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;seaswalker&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;15&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">qualifier</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;student_2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">qualifier</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;base.SimpleBean&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>SimpleBean部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@Qualifier(&quot;student&quot;)</span><br><span class="hljs-keyword">private</span> Student student;<br></code></pre></td></tr></table></figure><p>此标签和@Qualifier, @Autowired两个注解一起使用才有作用。@Autowired注解采用按类型查找的方式进行注入，如果找到多个需要类型的bean便会报错，有了@Qualifier标签就可以再按照此注解指定的名称查找。两者结合相当于实现了按类型+名称注入。type属性可以不指定，因为默认就是那个。qualifier标签可以有attribute子元素，比如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">qualifier</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.springframework.beans.factory.annotation.Qualifier&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;student&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">attribute</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">qualifier</span>&gt;</span><br></code></pre></td></tr></table></figure><p>貌似是用来在qualifier也区分不开的时候使用。attribute键值对保存在BeanMetadataAttribute对象中。整个qualifier保存在AutowireCandidateQualifier对象中。</p><h6 id="Bean装饰"><a href="#Bean装饰" class="headerlink" title="Bean装饰"></a>Bean装饰</h6><p>这部分是针对其它schema的属性以及子节点，比如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;base.Student&quot;</span> <span class="hljs-attr">primary</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-override</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>没见过这种用法，留个坑。</p><h6 id="Bean注册"><a href="#Bean注册" class="headerlink" title="Bean注册"></a>Bean注册</h6><p>BeanDefinitionReaderUtils.registerBeanDefinition:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinition</span><span class="hljs-params">(</span><br><span class="hljs-params">    BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span> &#123;<br>    <span class="hljs-comment">// Register bean definition under primary name.</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> definitionHolder.getBeanName();<br>    registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());<br>    <span class="hljs-comment">// Register aliases for bean name, if any.</span><br>    String[] aliases = definitionHolder.getAliases();<br>    <span class="hljs-keyword">if</span> (aliases != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (String alias : aliases) &#123;<br>            registry.registerAlias(beanName, alias);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>registry其实就是DefaultListableBeanFactory对象，registerBeanDefinition方法主要就干了这么两件事:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span> &#123;<br>    <span class="hljs-built_in">this</span>.beanDefinitionMap.put(beanName, beanDefinition);<br>    <span class="hljs-built_in">this</span>.beanDefinitionNames.add(beanName);<br>&#125;<br></code></pre></td></tr></table></figure><p>一个是Map，另一个是List，一目了然。registerAlias方法的实现在其父类SimpleAliasRegistry，就是把键值对放在了一个ConcurrentHashMap里。</p><p>ComponentRegistered事件触发:</p><p>默认是个空实现，前面说过了。</p><h6 id="BeanDefiniton数据结构"><a href="#BeanDefiniton数据结构" class="headerlink" title="BeanDefiniton数据结构"></a>BeanDefiniton数据结构</h6><p>BeanDefiniton数据结构如下图:</p><p><img src="BeanDefinition.jpg" alt="BeanDefinition数据结构"></p><h5 id="beans"><a href="#beans" class="headerlink" title="beans"></a>beans</h5><p>beans元素的嵌套直接递归调用DefaultBeanDefinitionDocumentReader.parseBeanDefinitions。</p><h4 id="其它命名空间解析"><a href="#其它命名空间解析" class="headerlink" title="其它命名空间解析"></a>其它命名空间解析</h4><p>入口在DefaultBeanDefinitionDocumentReader.parseBeanDefinitions-&gt;BeanDefinitionParserDelegate.parseCustomElement(第二个参数为空):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> BeanDefinition <span class="hljs-title function_">parseCustomElement</span><span class="hljs-params">(Element ele, BeanDefinition containingBd)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">namespaceUri</span> <span class="hljs-operator">=</span> getNamespaceURI(ele);<br>    <span class="hljs-type">NamespaceHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);<br>    <span class="hljs-keyword">return</span> handler.parse(ele, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ParserContext</span>(<span class="hljs-built_in">this</span>.readerContext, <span class="hljs-built_in">this</span>, containingBd));<br>&#125;<br></code></pre></td></tr></table></figure><p>NamespaceHandlerResolver由XmlBeanDefinitionReader初始化，是一个DefaultNamespaceHandlerResolver对象，也是NamespaceHandlerResolver接口的唯一实现。</p><p>其resolve方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> NamespaceHandler <span class="hljs-title function_">resolve</span><span class="hljs-params">(String namespaceUri)</span> &#123;<br>    Map&lt;String, Object&gt; handlerMappings = getHandlerMappings();<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">handlerOrClassName</span> <span class="hljs-operator">=</span> handlerMappings.get(namespaceUri);<br>    <span class="hljs-keyword">if</span> (handlerOrClassName == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (handlerOrClassName <span class="hljs-keyword">instanceof</span> NamespaceHandler) &#123;<br>        <span class="hljs-keyword">return</span> (NamespaceHandler) handlerOrClassName;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> (String) handlerOrClassName;<br>        Class&lt;?&gt; handlerClass = ClassUtils.forName(className, <span class="hljs-built_in">this</span>.classLoader);<br>        <span class="hljs-type">NamespaceHandler</span> <span class="hljs-variable">namespaceHandler</span> <span class="hljs-operator">=</span> (NamespaceHandler) BeanUtils.instantiateClass(handlerClass);<br>        namespaceHandler.init();<br>        handlerMappings.put(namespaceUri, namespaceHandler);<br>        <span class="hljs-keyword">return</span> namespaceHandler;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>容易看出，Spring其实使用了一个Map了保存其映射关系，key就是命名空间的uri，value是<strong>NamespaceHandler对象或是Class完整名，如果发现是类名，那么用反射的方法进行初始化，如果是NamespaceHandler对象，那么直接返回</strong>。</p><p>NamespaceHandler映射关系来自于各个Spring jar包下的META-INF/spring.handlers文件，以spring-context包为例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler<br>http\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler<br>http\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler<br>http\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler<br>http\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler<br></code></pre></td></tr></table></figure><h5 id="NamespaceHandler继承体系"><a href="#NamespaceHandler继承体系" class="headerlink" title="NamespaceHandler继承体系"></a>NamespaceHandler继承体系</h5><p><img src="NamespaceHandler.jpg" alt="NamespaceHandler继承体系"></p><h5 id="init"><a href="#init" class="headerlink" title="init"></a>init</h5><p>resolve中调用了其init方法，此方法用以向NamespaceHandler对象注册BeanDefinitionParser对象。**此接口用以解析顶层(beans下)的非默认命名空间元素，比如<code>&lt;context:annotation-config /&gt;</code>**。</p><p>所以这样逻辑就很容易理解了: <strong>每种子标签的解析仍是策略模式的体现，init负责向父类NamespaceHandlerSupport注册不同的策略，由父类的NamespaceHandlerSupport.parse方法根据具体的子标签调用相应的策略完成解析的过程</strong>。</p><p>此部分较为重要，所以重新开始大纲。 </p><h5 id="BeanFactory数据结构"><a href="#BeanFactory数据结构" class="headerlink" title="BeanFactory数据结构"></a>BeanFactory数据结构</h5><p>BeanDefinition在BeanFactory中的主要数据结构如下图:</p><p><img src="Beanfactory_structure.jpg" alt="Beanfactory数据结构"></p><h3 id="prepareBeanFactory"><a href="#prepareBeanFactory" class="headerlink" title="prepareBeanFactory"></a>prepareBeanFactory</h3><p>此方法负责对BeanFactory进行一些特征的设置工作，”特征”包含这么几个方面:</p><h4 id="BeanExpressionResolver"><a href="#BeanExpressionResolver" class="headerlink" title="BeanExpressionResolver"></a>BeanExpressionResolver</h4><p>此接口只有一个实现: StandardBeanExpressionResolver。接口只含有一个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Object <span class="hljs-title function_">evaluate</span><span class="hljs-params">(String value, BeanExpressionContext evalContext)</span><br></code></pre></td></tr></table></figure><p>prepareBeanFactory将一个此对象放入BeanFactory:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">beanFactory.setBeanExpressionResolver(<span class="hljs-keyword">new</span>  <span class="hljs-title class_">StandardBeanExpressionResolver</span>(beanFactory.getBeanClassLoader()));<br></code></pre></td></tr></table></figure><p>StandardBeanExpressionResolver对象内部有一个关键的成员: SpelExpressionParser,其整个类图:</p><p><img src="images/ExpressionParser.jpg" alt="ExpressionParser继承体系"></p><p>这便是Spring3.0开始出现的Spel表达式的解释器。</p><h4 id="PropertyEditorRegistrar"><a href="#PropertyEditorRegistrar" class="headerlink" title="PropertyEditorRegistrar"></a>PropertyEditorRegistrar</h4><p>此接口用于向Spring注册java.beans.PropertyEditor，只有一个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">registerCustomEditors(PropertyEditorRegistry registry)<br></code></pre></td></tr></table></figure><p>实现也只有一个: ResourceEditorRegistrar。</p><p>在编写xml配置时，我们设置的值都是字符串形式，所以在使用时肯定需要转为我们需要的类型，PropertyEditor接口正是定义了这么个东西。</p><p>prepareBeanFactory:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">beanFactory.addPropertyEditorRegistrar(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceEditorRegistrar</span>(<span class="hljs-built_in">this</span>, getEnvironment()));<br></code></pre></td></tr></table></figure><p>BeanFactory也暴露了registerCustomEditors方法用以添加自定义的转换器，所以这个地方是组合模式的体现。</p><p>我们有两种方式可以添加自定义PropertyEditor:</p><ul><li><p>通过<code>context.getBeanFactory().registerCustomEditor</code></p></li><li><p>通过Spring配置文件:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.beans.factory.config.CustomEditorConfigurer&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;customEditors&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;base.Cat&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;base.CatEditor&quot;</span> /&gt;</span> <br>      <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>参考: <a href="http://blog.csdn.net/zhoudaxia/article/details/36247883">深入理解JavaBean(2)：属性编辑器PropertyEditor</a></p><h4 id="环境注入"><a href="#环境注入" class="headerlink" title="环境注入"></a>环境注入</h4><p>在Spring中我们自己的bean可以通过实现EnvironmentAware等一系列Aware接口获取到Spring内部的一些对象。prepareBeanFactory:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationContextAwareProcessor</span>(<span class="hljs-built_in">this</span>));<br></code></pre></td></tr></table></figure><p>ApplicationContextAwareProcessor核心的invokeAwareInterfaces方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeAwareInterfaces</span><span class="hljs-params">(Object bean)</span> &#123;<br>    <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Aware) &#123;<br>        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> EnvironmentAware) &#123;<br>            ((EnvironmentAware) bean).setEnvironment(<span class="hljs-built_in">this</span>.applicationContext.getEnvironment());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> EmbeddedValueResolverAware) &#123;<br>            ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="hljs-built_in">this</span>.embeddedValueResolver);<br>        &#125;<br>        <span class="hljs-comment">//....</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="依赖解析忽略"><a href="#依赖解析忽略" class="headerlink" title="依赖解析忽略"></a>依赖解析忽略</h4><p>此部分设置哪些接口在进行依赖注入的时候应该被忽略:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);<br>beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);<br>beanFactory.ignoreDependencyInterface(MessageSourceAware.class);<br>beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);<br>beanFactory.ignoreDependencyInterface(EnvironmentAware.class);<br></code></pre></td></tr></table></figure><h4 id="bean伪装"><a href="#bean伪装" class="headerlink" title="bean伪装"></a>bean伪装</h4><p>有些对象并不在BeanFactory中，但是我们依然想让它们可以被装配，这就需要伪装一下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);<br>beanFactory.registerResolvableDependency(ResourceLoader.class, <span class="hljs-built_in">this</span>);<br>beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, <span class="hljs-built_in">this</span>);<br>beanFactory.registerResolvableDependency(ApplicationContext.class, <span class="hljs-built_in">this</span>);<br></code></pre></td></tr></table></figure><p>伪装关系保存在一个Map&lt;Class&lt;?&gt;, Object&gt;里。</p><h4 id="LoadTimeWeaver"><a href="#LoadTimeWeaver" class="headerlink" title="LoadTimeWeaver"></a>LoadTimeWeaver</h4><p>如果配置了此bean，那么：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;<br>    beanFactory.addBeanPostProcessor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoadTimeWeaverAwareProcessor</span>(beanFactory));<br>    <span class="hljs-comment">// Set a temporary ClassLoader for type matching.</span><br>    beanFactory.setTempClassLoader(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ContextTypeMatchClassLoader</span>(beanFactory.getBeanClassLoader()));<br>&#125;<br></code></pre></td></tr></table></figure><p>这个东西具体是干什么的在后面context:load-time-weaver中说明。</p><h4 id="注册环境"><a href="#注册环境" class="headerlink" title="注册环境"></a>注册环境</h4><p>源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;<br>    beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());<br>&#125;<br><span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;<br>    beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());<br>&#125;<br><span class="hljs-keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;<br>    beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().<br>        getSystemEnvironment());<br>&#125;<br></code></pre></td></tr></table></figure><p>containsLocalBean特殊之处在于不会去父BeanFactory寻找。</p><h3 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory"></a>postProcessBeanFactory</h3><p>此方法允许子类在所有的bean尚未初始化之前注册BeanPostProcessor。空实现且没有子类覆盖。</p><h3 id="invokeBeanFactoryPostProcessors"><a href="#invokeBeanFactoryPostProcessors" class="headerlink" title="invokeBeanFactoryPostProcessors"></a>invokeBeanFactoryPostProcessors</h3><p>BeanFactoryPostProcessor接口允许我们在bean正是初始化之前改变其值。此接口只有一个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span>;<br></code></pre></td></tr></table></figure><p>有两种方式可以向Spring添加此对象:</p><ul><li><p>通过代码的方式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">context.addBeanFactoryPostProcessor<br></code></pre></td></tr></table></figure></li><li><p>通过xml配置的方式:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;base.SimpleBeanFactoryPostProcessor&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>注意此时尚未进行bean的初始化工作，初始化是在后面的finishBeanFactoryInitialization进行的，所以在BeanFactoryPostProcessor对象中获取bean会导致提前初始化。</p><p>此方法的关键源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeBeanFactoryPostProcessors</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;<br>    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory,<br>        getBeanFactoryPostProcessors());<br>&#125;<br></code></pre></td></tr></table></figure><p>getBeanFactoryPostProcessors获取的就是AbstractApplicationContext的成员beanFactoryPostProcessors(ArrayList)，但是很有意思，<strong>只有通过context.addBeanFactoryPostProcessor这种方式添加的才会出现在这个List里，所以对于xml配置方式，此List其实没有任何元素。玄机就在PostProcessorRegistrationDelegate里</strong>。</p><p>核心思想就是使用BeanFactory的getBeanNamesForType方法获取相应的BeanDefinition的name数组，之后逐一调用getBean方法获取到bean(初始化)，getBean方法后面再说。</p><p>注意此处有一个优先级的概念，如果你的BeanFactoryPostProcessor同时实现了Ordered或者是PriorityOrdered接口，那么会被首先执行。</p><h3 id="BeanPostProcessor注册"><a href="#BeanPostProcessor注册" class="headerlink" title="BeanPostProcessor注册"></a>BeanPostProcessor注册</h3><p>此部分实质上是在BeanDefinitions中寻找BeanPostProcessor，之后调用BeanFactory.addBeanPostProcessor方法保存在一个List中，注意添加时仍然有优先级的概念，优先级高的在前面。</p><h3 id="MessageSource"><a href="#MessageSource" class="headerlink" title="MessageSource"></a>MessageSource</h3><p>此接口用以支持Spring国际化。继承体系如下:</p><p><img src="MessageSource.jpg" alt="MessageSource继承体系"></p><p>AbstractApplicationContext的initMessageSource()方法就是在BeanFactory中查找MessageSource的bean，如果配置了此bean，那么调用getBean方法完成其初始化并将其保存在AbstractApplicationContext内部messageSource成员变量中，用以处理ApplicationContext的getMessage调用，因为从继承体系上来看，ApplicationContext是MessageSource的子类，此处是委托模式的体现。如果没有配置此bean，那么初始化一个DelegatingMessageSource对象，此类是一个空实现，同样用以处理getMessage调用请求。</p><p>参考: <a href="http://stamen.iteye.com/blog/1541732">学习Spring必学的Java基础知识(8)—-国际化信息</a></p><h3 id="事件驱动"><a href="#事件驱动" class="headerlink" title="事件驱动"></a>事件驱动</h3><p>此接口代表了Spring的事件驱动(监听器)模式。一个事件驱动包含三部分:</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>java的所有事件对象一般都是java.util.EventObject的子类，Spring的整个继承体系如下:</p><p><img src="EventObject.jpg" alt="EventObject继承体系"></p><h4 id="发布者"><a href="#发布者" class="headerlink" title="发布者"></a>发布者</h4><h5 id="ApplicationEventPublisher"><a href="#ApplicationEventPublisher" class="headerlink" title="ApplicationEventPublisher"></a>ApplicationEventPublisher</h5><p><img src="ApplicationEventPublisher.jpg" alt="ApplicationEventPublisher继承体系"></p><p>一目了然。</p><h5 id="ApplicationEventMulticaster"><a href="#ApplicationEventMulticaster" class="headerlink" title="ApplicationEventMulticaster"></a>ApplicationEventMulticaster</h5><p>ApplicationEventPublisher实际上正是将请求委托给ApplicationEventMulticaster来实现的。其继承体系:</p><p><img src="ApplicationEventMulticaster.jpg" alt="ApplicationEventMulticaster继承体系"></p><h4 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h4><p>所有的监听器是jdk EventListener的子类，这是一个mark接口。继承体系:</p><p><img src="EventListener.jpg" alt="EventListener继承体系"></p><p>可以看出SmartApplicationListener和GenericApplicationListener是高度相似的，都提供了事件类型检测和顺序机制，而后者是从Spring4.2加入的，Spring官方文档推荐使用后者代替前者。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>前面说过ApplicationEventPublisher是通过委托给ApplicationEventMulticaster实现的，所以refresh方法中完成的是对ApplicationEventMulticaster的初始化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Initialize event multicaster for this context.</span><br>initApplicationEventMulticaster();<br></code></pre></td></tr></table></figure><p>initApplicationEventMulticaster则首先在BeanFactory中寻找ApplicationEventMulticaster的bean，如果找到，那么调用getBean方法将其初始化，如果找不到那么使用SimpleApplicationEventMulticaster。</p><h4 id="事件发布"><a href="#事件发布" class="headerlink" title="事件发布"></a>事件发布</h4><p>AbstractApplicationContext.publishEvent核心代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">publishEvent</span><span class="hljs-params">(Object event, ResolvableType eventType)</span> &#123;<br>    getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);<br>&#125;<br></code></pre></td></tr></table></figure><p>SimpleApplicationEventMulticaster.multicastEvent:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">multicastEvent</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ApplicationEvent event, ResolvableType eventType)</span> &#123;<br>    <span class="hljs-type">ResolvableType</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> (eventType != <span class="hljs-literal">null</span> ? eventType : resolveDefaultEventType(event));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;<br>        <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> getTaskExecutor();<br>        <span class="hljs-keyword">if</span> (executor != <span class="hljs-literal">null</span>) &#123;<br>            executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    invokeListener(listener, event);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            invokeListener(listener, event);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="监听器获取"><a href="#监听器获取" class="headerlink" title="监听器获取"></a>监听器获取</h5><p>获取当然还是通过beanFactory的getBean来完成的，值得注意的是Spring在此处使用了缓存(ConcurrentHashMap)来加速查找的过程。</p><h5 id="同步-异步"><a href="#同步-异步" class="headerlink" title="同步/异步"></a>同步/异步</h5><p>可以看出，如果executor不为空，那么监听器的执行实际上是异步的。那么如何配置同步/异步呢?</p><h6 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">task:executor</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;multicasterExecutor&quot;</span> <span class="hljs-attr">pool-size</span>=<span class="hljs-string">&quot;3&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.context.event.SimpleApplicationEventMulticaster&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;taskExecutor&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;multicasterExecutor&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>task schema是Spring从3.0开始加入的，使我们可以不再依赖于Quartz实现定时任务，源码在org.springframework.core.task包下，使用需要引入schema：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">xmlns:task=&quot;http://www.springframework.org/schema/task&quot;<br>xsi:schemaLocation=&quot;http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-4.0.xsd&quot;<br></code></pre></td></tr></table></figure><p>可以参考: <a href="http://gong1208.iteye.com/blog/1773177">Spring定时任务的几种实现</a></p><h6 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h6><p>开启注解支持:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 开启@AspectJ AOP代理 --&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span> <span class="hljs-attr">proxy-target-class</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>  <br><span class="hljs-comment">&lt;!-- 任务调度器 --&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">task:scheduler</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;scheduler&quot;</span> <span class="hljs-attr">pool-size</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span>  <br><span class="hljs-comment">&lt;!-- 任务执行器 --&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">task:executor</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;executor&quot;</span> <span class="hljs-attr">pool-size</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span>  <br><span class="hljs-comment">&lt;!--开启注解调度支持 @Async @Scheduled--&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">task:annotation-driven</span> <span class="hljs-attr">executor</span>=<span class="hljs-string">&quot;executor&quot;</span> <span class="hljs-attr">scheduler</span>=<span class="hljs-string">&quot;scheduler&quot;</span> <span class="hljs-attr">proxy-target-class</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span>  <br></code></pre></td></tr></table></figure><p>在代码中使用示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailRegisterListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span>&lt;RegisterEvent&gt; &#123;  <br>    <span class="hljs-meta">@Async</span>  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(<span class="hljs-keyword">final</span> RegisterEvent event)</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;注册成功，发送确认邮件给：&quot;</span> + ((User)event.getSource()).getUsername());  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><p>参考: <a href="http://jinnianshilongnian.iteye.com/blog/1902886">详解Spring事件驱动模型</a></p><h3 id="onRefresh"><a href="#onRefresh" class="headerlink" title="onRefresh"></a>onRefresh</h3><p>这又是一个模版方法，允许子类在进行bean初始化之前进行一些定制操作。默认空实现。</p><h3 id="ApplicationListener注册"><a href="#ApplicationListener注册" class="headerlink" title="ApplicationListener注册"></a>ApplicationListener注册</h3><p>registerListeners方法干的，没什么好说的。</p><h3 id="singleton初始化"><a href="#singleton初始化" class="headerlink" title="singleton初始化"></a>singleton初始化</h3><p>finishBeanFactoryInitialization：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishBeanFactoryInitialization</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;<br>    <span class="hljs-keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;<br>            beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;<br>        beanFactory.setConversionService(<br>                beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;<br>        beanFactory.addEmbeddedValueResolver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringValueResolver</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> String <span class="hljs-title function_">resolveStringValue</span><span class="hljs-params">(String strVal)</span> &#123;<br>                <span class="hljs-keyword">return</span> getEnvironment().resolvePlaceholders(strVal);<br>            &#125;<br>        &#125;);<br>    &#125;<br>    String[] weaverAwareNames = beanFactory.getBeanNamesForType<br>        (LoadTimeWeaverAware.class, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;<br>        getBean(weaverAwareName);<br>    &#125;<br>    <span class="hljs-comment">// Allow for caching all bean definition metadata, not expecting further changes.</span><br>    beanFactory.freezeConfiguration();<br>    <span class="hljs-comment">// Instantiate all remaining (non-lazy-init) singletons.</span><br>    beanFactory.preInstantiateSingletons();<br>&#125;<br></code></pre></td></tr></table></figure><p>分部分说明。</p><h4 id="ConversionService"><a href="#ConversionService" class="headerlink" title="ConversionService"></a>ConversionService</h4><p>此接口用于类型之间的转换，在Spring里其实就是把配置文件中的String转为其它类型，从3.0开始出现，目的和jdk的PropertyEditor接口是一样的，参考ConfigurableBeanFactory.setConversionService注释:</p><blockquote><blockquote><p>Specify a Spring 3.0 ConversionService to use for converting<br>property values, as an alternative to JavaBeans PropertyEditors.<br>@since 3.0</p></blockquote></blockquote><h4 id="StringValueResolver"><a href="#StringValueResolver" class="headerlink" title="StringValueResolver"></a>StringValueResolver</h4><p>用于解析注解的值。接口只定义了一个方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String <span class="hljs-title function_">resolveStringValue</span><span class="hljs-params">(String strVal)</span>;<br></code></pre></td></tr></table></figure><h4 id="LoadTimeWeaverAware"><a href="#LoadTimeWeaverAware" class="headerlink" title="LoadTimeWeaverAware"></a>LoadTimeWeaverAware</h4><p>实现了此接口的bean可以得到LoadTimeWeaver，此处仅仅初始化。</p><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><p>DefaultListableBeanFactory.preInstantiateSingletons:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preInstantiateSingletons</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    List&lt;String&gt; beanNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;(<span class="hljs-built_in">this</span>.beanDefinitionNames);<br>    <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>        <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">bd</span> <span class="hljs-operator">=</span> getMergedLocalBeanDefinition(beanName);<br>        <span class="hljs-keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;<br>            <span class="hljs-keyword">if</span> (isFactoryBean(beanName)) &#123;<br>                <span class="hljs-keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX <br>                    + beanName);<br>                <span class="hljs-type">boolean</span> isEagerInit;<br>                <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span> &amp;&amp; factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean) &#123;<br>                    isEagerInit = AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Boolean&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                            <span class="hljs-keyword">return</span> ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();<br>                        &#125;<br>                    &#125;, getAccessControlContext());<br>                &#125;<br>                <span class="hljs-keyword">else</span> &#123;<br>                    isEagerInit = (factory <span class="hljs-keyword">instanceof</span> SmartFactoryBean &amp;&amp;<br>                            ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());<br>                &#125;<br>                <span class="hljs-keyword">if</span> (isEagerInit) &#123;<br>                    getBean(beanName);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                getBean(beanName);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Trigger post-initialization callback for all applicable beans...</span><br>    <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">singletonInstance</span> <span class="hljs-operator">=</span> getSingleton(beanName);<br>        <span class="hljs-keyword">if</span> (singletonInstance <span class="hljs-keyword">instanceof</span> SmartInitializingSingleton) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">SmartInitializingSingleton</span> <span class="hljs-variable">smartSingleton</span> <span class="hljs-operator">=</span> <br>                (SmartInitializingSingleton) singletonInstance;<br>            <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123;<br>                AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Object&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                        smartSingleton.afterSingletonsInstantiated();<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                    &#125;<br>                &#125;, getAccessControlContext());<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                smartSingleton.afterSingletonsInstantiated();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先进行Singleton的初始化，其中如果bean是FactoryBean类型(注意，只定义了factory-method属性的普通bean并不是FactoryBean)，并且还是SmartFactoryBean类型，那么需要判断是否需要eagerInit(isEagerInit是此接口定义的方法)。</p><h1 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h1><p>这里便是bean初始化的核心逻辑。源码比较复杂，分开说。以getBean(String name)为例。AbstractBeanFactory.getBean:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-keyword">return</span> doGetBean(name, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>第二个参数表示bean的Class类型，第三个表示创建bean需要的参数，最后一个表示不需要进行类型检查。</p><h2 id="beanName转化"><a href="#beanName转化" class="headerlink" title="beanName转化"></a>beanName转化</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> transformedBeanName(name);<br></code></pre></td></tr></table></figure><p>这里是将FactoryBean的前缀去掉以及将别名转为真实的名字。</p><h2 id="手动注册bean检测"><a href="#手动注册bean检测" class="headerlink" title="手动注册bean检测"></a>手动注册bean检测</h2><p>前面注册环境一节说过，Spring其实手动注册了一些单例bean。这一步就是检测是不是这些bean。如果是，那么再检测是不是工厂bean，如果是返回其工厂方法返回的实例，如果不是返回bean本身。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">sharedInstance</span> <span class="hljs-operator">=</span> getSingleton(beanName);<br><span class="hljs-keyword">if</span> (sharedInstance != <span class="hljs-literal">null</span> &amp;&amp; args == <span class="hljs-literal">null</span>) &#123;<br>    bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="检查父容器"><a href="#检查父容器" class="headerlink" title="检查父容器"></a>检查父容器</h2><p>如果父容器存在并且存在此bean定义，那么交由其父容器初始化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BeanFactory</span> <span class="hljs-variable">parentBeanFactory</span> <span class="hljs-operator">=</span> getParentBeanFactory();<br><span class="hljs-keyword">if</span> (parentBeanFactory != <span class="hljs-literal">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;<br>    <span class="hljs-comment">// Not found -&gt; check parent.</span><br>    <span class="hljs-comment">//此方法其实是做了前面beanName转化的逆操作，因为父容器同样会进行转化操作</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">nameToLookup</span> <span class="hljs-operator">=</span> originalBeanName(name);<br>    <span class="hljs-keyword">if</span> (args != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// Delegation to parent with explicit args.</span><br>        <span class="hljs-keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// No args -&gt; delegate to standard getBean method.</span><br>        <span class="hljs-keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="依赖初始化"><a href="#依赖初始化" class="headerlink" title="依赖初始化"></a>依赖初始化</h2><p>bean可以由depends-on属性配置依赖的bean。Spring会首先初始化依赖的bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] dependsOn = mbd.getDependsOn();<br><span class="hljs-keyword">if</span> (dependsOn != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">for</span> (String dependsOnBean : dependsOn) &#123;<br>         <span class="hljs-comment">//检测是否存在循环依赖</span><br>        <span class="hljs-keyword">if</span> (isDependent(beanName, dependsOnBean)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanCreationException</span>(mbd.getResourceDescription(), beanName,<br>            <span class="hljs-string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; and &#x27;&quot;</span> + dependsOnBean + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        &#125;<br>        registerDependentBean(dependsOnBean, beanName);<br>        getBean(dependsOnBean);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>registerDependentBean进行了依赖关系的注册，这么做的原因是Spring在即进行bean销毁的时候会首先销毁被依赖的bean。依赖关系的保存是通过一个ConcurrentHashMap&lt;String, Set<String>&gt;完成的，key是bean的真实名字。</p><h2 id="Singleton初始化"><a href="#Singleton初始化" class="headerlink" title="Singleton初始化"></a>Singleton初始化</h2><p>虽然这里大纲是Singleton初始化，但是getBean方法本身是包括所有scope的初始化，在这里一次说明了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>    sharedInstance = getSingleton(beanName, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectFactory</span>&lt;Object&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>            <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>        &#125;<br>    &#125;);<br>    bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="getSingleton方法"><a href="#getSingleton方法" class="headerlink" title="getSingleton方法"></a>getSingleton方法</h3><h4 id="是否存在"><a href="#是否存在" class="headerlink" title="是否存在"></a>是否存在</h4><p>首先会检测是否已经存在，如果存在，直接返回:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>.singletonObjects) &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">singletonObject</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.singletonObjects.get(beanName);<br>&#125;<br></code></pre></td></tr></table></figure><p>所有的单例bean都保存在这样的数据结构中: <code>ConcurrentHashMap&lt;String, Object&gt;</code>。</p><h4 id="bean创建"><a href="#bean创建" class="headerlink" title="bean创建"></a>bean创建</h4><p>源码位于AbstractAutowireCapableBeanFactory.createBean，主要分为几个部分:</p><h5 id="lookup-method检测"><a href="#lookup-method检测" class="headerlink" title="lookup-method检测"></a>lookup-method检测</h5><p>此部分用于检测lookup-method标签配置的方法是否存在:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">mbdToUse</span> <span class="hljs-operator">=</span> mbd;<br>mbdToUse.prepareMethodOverrides();<br></code></pre></td></tr></table></figure><p>prepareMethodOverrides:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareMethodOverrides</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeanDefinitionValidationException &#123;<br>    <span class="hljs-comment">// Check that lookup methods exists.</span><br>    <span class="hljs-type">MethodOverrides</span> <span class="hljs-variable">methodOverrides</span> <span class="hljs-operator">=</span> getMethodOverrides();<br>    <span class="hljs-keyword">if</span> (!methodOverrides.isEmpty()) &#123;<br>        Set&lt;MethodOverride&gt; overrides = methodOverrides.getOverrides();<br>        <span class="hljs-keyword">synchronized</span> (overrides) &#123;<br>            <span class="hljs-keyword">for</span> (MethodOverride mo : overrides) &#123;<br>                prepareMethodOverride(mo);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>prepareMethodOverride:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prepareMethodOverride</span><span class="hljs-params">(MethodOverride mo)</span>  &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> ClassUtils.getMethodCountForName(getBeanClass(), mo.getMethodName());<br>    <span class="hljs-keyword">if</span> (count == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanDefinitionValidationException</span>(<br>                <span class="hljs-string">&quot;Invalid method override: no method with name &#x27;&quot;</span> + mo.getMethodName() +<br>                <span class="hljs-string">&quot;&#x27; on class [&quot;</span> + getBeanClassName() + <span class="hljs-string">&quot;]&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (count == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// Mark override as not overloaded, to avoid the overhead of arg type checking.</span><br>        mo.setOverloaded(<span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="InstantiationAwareBeanPostProcessor触发"><a href="#InstantiationAwareBeanPostProcessor触发" class="headerlink" title="InstantiationAwareBeanPostProcessor触发"></a>InstantiationAwareBeanPostProcessor触发</h5><p>在这里触发的是其postProcessBeforeInitialization和postProcessAfterInstantiation方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> resolveBeforeInstantiation(beanName, mbdToUse);<br><span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br><span class="hljs-type">Object</span> <span class="hljs-variable">beanInstance</span> <span class="hljs-operator">=</span> doCreateBean(beanName, mbdToUse, args);<br><span class="hljs-keyword">return</span> beanInstance;<br></code></pre></td></tr></table></figure><p>继续:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">resolveBeforeInstantiation</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;<br>        <span class="hljs-comment">// Make sure bean class is actually resolved at this point.</span><br>        <span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<br>            Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);<br>            <span class="hljs-keyword">if</span> (targetType != <span class="hljs-literal">null</span>) &#123;<br>                bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);<br>                <span class="hljs-keyword">if</span> (bean != <span class="hljs-literal">null</span>) &#123;<br>                    bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);<br>                &#125;<br>            &#125;<br>        &#125;<br>        mbd.beforeInstantiationResolved = (bean != <span class="hljs-literal">null</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure><p>从这里可以看出，<strong>如果InstantiationAwareBeanPostProcessor返回的不是空，那么将不会继续执行剩下的Spring初始化流程，此接口用于初始化自定义的bean，主要是在Spring内部使用</strong>。</p><h5 id="doCreateBean"><a href="#doCreateBean" class="headerlink" title="doCreateBean"></a>doCreateBean</h5><p>同样分为几部分。</p><h6 id="创建-createBeanInstance"><a href="#创建-createBeanInstance" class="headerlink" title="创建(createBeanInstance)"></a>创建(createBeanInstance)</h6><p>关键代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">instanceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-literal">null</span>) &#123;<br>    instanceWrapper = createBeanInstance(beanName, mbd, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>createBeanInstance的创建过程又分为以下几种情况:</p><ul><li><p>工厂bean:</p><p>调用instantiateUsingFactoryMethod方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> BeanWrapper <span class="hljs-title function_">instantiateUsingFactoryMethod</span><span class="hljs-params">(</span><br><span class="hljs-params">  String beanName, RootBeanDefinition mbd, Object[] explicitArgs)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConstructorResolver</span>(<span class="hljs-built_in">this</span>).instantiateUsingFactoryMethod(beanName, mbd, explicitArgs);<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，此处的工厂bean指的是配置了factory-bean/factory-method属性的bean，不是实现了FacrotyBean接口的bean。如果没有配置factory-bean属性，那么factory-method指向的方法必须是静态的。此方法主要做了这么几件事:</p><ul><li><p>初始化一个BeanWrapperImpl对象。</p></li><li><p>根据设置的参数列表使用反射的方法寻找相应的方法对象。</p></li><li><p>InstantiationStrategy:</p><p>bean的初始化在此处又抽成了策略模式，类图:</p><p><img src="InstantiationStrategy.jpg" alt="InstantiationStrategy类图"></p><p>instantiateUsingFactoryMethod部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">beanInstance = <span class="hljs-built_in">this</span>.beanFactory.getInstantiationStrategy().instantiate(<br>    mbd, beanName, <span class="hljs-built_in">this</span>.beanFactory, factoryBean, factoryMethodToUse, argsToUse);<br></code></pre></td></tr></table></figure><p>getInstantiationStrategy返回的是CglibSubclassingInstantiationStrategy对象。此处instantiate实现也很简单，就是调用工厂方法的Method对象反射调用其invoke即可得到对象，SimpleInstantiationStrategy.</p><p>instantiate核心源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">instantiate</span><span class="hljs-params">(RootBeanDefinition bd, String beanName, BeanFactory owner,</span><br><span class="hljs-params">    Object factoryBean, <span class="hljs-keyword">final</span> Method factoryMethod, Object... args)</span> &#123;<br>    <span class="hljs-keyword">return</span> factoryMethod.invoke(factoryBean, args);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>构造器自动装配</p><p>createBeanInstance部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Need to determine the constructor...</span><br>Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);<br><span class="hljs-keyword">if</span> (ctors != <span class="hljs-literal">null</span> ||<br>  mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||<br>    <span class="hljs-comment">//配置了&lt;constructor-arg&gt;子元素</span><br>  mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;<br>  <span class="hljs-keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>determineConstructorsFromBeanPostProcessors源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Constructor&lt;?&gt;[] determineConstructorsFromBeanPostProcessors(Class&lt;?&gt; beanClass, String beanName) &#123;<br>  <span class="hljs-keyword">if</span> (beanClass != <span class="hljs-literal">null</span> &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<br>      <span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<br>          <span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;<br>              <span class="hljs-type">SmartInstantiationAwareBeanPostProcessor</span> <span class="hljs-variable">ibp</span> <span class="hljs-operator">=</span> <br>                  (SmartInstantiationAwareBeanPostProcessor) bp;<br>              Constructor&lt;?&gt;[] ctors = ibp.determineCandidateConstructors(beanClass, beanName);<br>              <span class="hljs-keyword">if</span> (ctors != <span class="hljs-literal">null</span>) &#123;<br>                  <span class="hljs-keyword">return</span> ctors;<br>              &#125;<br>          &#125;<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见是由SmartInstantiationAwareBeanPostProcessor决定的，默认是没有配置这种东西的。</p><p>之后就是判断bean的自动装配模式，可以通过如下方式配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;base.Student&quot;</span> <span class="hljs-attr">primary</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;default&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>autowire共有以下几种选项:</p><ul><li>no: 默认的，不进行自动装配。在这种情况下，只能通过ref方式引用其它bean。</li><li>byName: 根据bean里面属性的名字在BeanFactory中进行查找并装配。</li><li>byType: 按类型。</li><li>constructor: 以byType的方式查找bean的构造参数列表。</li><li>default: 由父bean决定。</li></ul><p>参考: <a href="http://www.cnblogs.com/ViviChan/p/4981539.html">Spring - bean的autowire属性(自动装配)</a></p><p>autowireConstructor调用的是ConstructorResolver.autowireConstructor，此方法主要做了两件事:</p><ul><li><p>得到合适的构造器对象。</p></li><li><p>根据构造器参数的类型去BeanFactory查找相应的bean:</p><p>入口方法在ConstructorResolver.resolveAutowiredArgument:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">resolveAutowiredArgument</span><span class="hljs-params">(</span><br><span class="hljs-params">        MethodParameter param, String beanName, Set&lt;String&gt; autowiredBeanNames, </span><br><span class="hljs-params">        TypeConverter typeConverter)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.beanFactory.resolveDependency(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">DependencyDescriptor</span>(param, <span class="hljs-literal">true</span>), beanName, <br>            autowiredBeanNames, typeConverter);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>最终调用的还是CglibSubclassingInstantiationStrategy.instantiate方法，关键源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">instantiate</span><span class="hljs-params">(RootBeanDefinition bd, String beanName, BeanFactory owner,</span><br><span class="hljs-params">      <span class="hljs-keyword">final</span> Constructor&lt;?&gt; ctor, Object... args)</span> &#123;<br>  <span class="hljs-keyword">if</span> (bd.getMethodOverrides().isEmpty()) &#123;<br>           <span class="hljs-comment">//反射调用</span><br>      <span class="hljs-keyword">return</span> BeanUtils.instantiateClass(ctor, args);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner, ctor, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，如果配置了lookup-method标签，<strong>得到的实际上是用Cglib生成的目标类的代理子类</strong>。</p><p>CglibSubclassingInstantiationStrategy.instantiateWithMethodInjection:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">instantiateWithMethodInjection</span><span class="hljs-params">(RootBeanDefinition bd, String beanName, BeanFactory owner,Constructor&lt;?&gt; ctor, Object... args)</span> &#123;<br>  <span class="hljs-comment">// Must generate CGLIB subclass...</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CglibSubclassCreator</span>(bd, owner).instantiate(ctor, args);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>默认构造器</p><p>一行代码，很简单:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// No special handling: simply use no-arg constructor.</span><br><span class="hljs-keyword">return</span> instantiateBean(beanName, mbd);<br></code></pre></td></tr></table></figure></li></ul><h6 id="MergedBeanDefinitionPostProcessor"><a href="#MergedBeanDefinitionPostProcessor" class="headerlink" title="MergedBeanDefinitionPostProcessor"></a>MergedBeanDefinitionPostProcessor</h6><p>触发源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (mbd.postProcessingLock) &#123;<br>    <span class="hljs-keyword">if</span> (!mbd.postProcessed) &#123;<br>        applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);<br>        mbd.postProcessed = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此接口也是Spring内部使用的，不管它了。</p><h6 id="属性解析"><a href="#属性解析" class="headerlink" title="属性解析"></a>属性解析</h6><p>入口方法: AbstractAutowireCapableBeanFactory.populateBean，它的作用是: 根据autowire类型进行autowire by name，by type 或者是直接进行设置，简略后的源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">populateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</span> &#123;<br>    <span class="hljs-comment">//所有&lt;property&gt;的值</span><br>    <span class="hljs-type">PropertyValues</span> <span class="hljs-variable">pvs</span> <span class="hljs-operator">=</span> mbd.getPropertyValues();<br><br>    <span class="hljs-keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||<br>            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;<br>        <span class="hljs-type">MutablePropertyValues</span> <span class="hljs-variable">newPvs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MutablePropertyValues</span>(pvs);<br><br>        <span class="hljs-comment">// Add property values based on autowire by name if applicable.</span><br>        <span class="hljs-keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;<br>            autowireByName(beanName, mbd, bw, newPvs);<br>        &#125;<br><br>        <span class="hljs-comment">// Add property values based on autowire by type if applicable.</span><br>        <span class="hljs-keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;<br>            autowireByType(beanName, mbd, bw, newPvs);<br>        &#125;<br><br>        pvs = newPvs;<br>    &#125;<br>    <span class="hljs-comment">//设值</span><br>    applyPropertyValues(beanName, mbd, bw, pvs);<br>&#125;<br></code></pre></td></tr></table></figure><p>autowireByName源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">autowireByName</span><span class="hljs-params">(</span><br><span class="hljs-params">        String beanName, AbstractBeanDefinition mbd, BeanWrapper bw, MutablePropertyValues pvs)</span> &#123;<br>    <span class="hljs-comment">//返回所有引用(ref=&quot;XXX&quot;)的bean名称</span><br>    String[] propertyNames = unsatisfiedNonSimpleProperties(mbd, bw);<br>    <span class="hljs-keyword">for</span> (String propertyName : propertyNames) &#123;<br>        <span class="hljs-keyword">if</span> (containsBean(propertyName)) &#123;<br>             <span class="hljs-comment">//从BeanFactory获取</span><br>            <span class="hljs-type">Object</span> <span class="hljs-variable">bean</span> <span class="hljs-operator">=</span> getBean(propertyName);<br>            pvs.add(propertyName, bean);<br>            registerDependentBean(propertyName, beanName);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>autowireByType也是同样的套路，所以可以得出结论: <strong>autowireByName和autowireByType方法只是先获取到引用的bean，真正的设值是在applyPropertyValues中进行的。</strong></p><h6 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h6><p>Spring判断一个属性可不可以被设置(存不存在)是通过java bean的内省操作来完成的，也就是说，属性可以被设置的条件是<strong>此属性拥有public的setter方法，并且注入时的属性名应该是setter的名字</strong>。</p><h6 id="初始化-2"><a href="#初始化-2" class="headerlink" title="初始化"></a>初始化</h6><p>此处的初始化指的是bean已经构造完成，执行诸如调用其init方法的操作。相关源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Initialize the bean instance.</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<br><span class="hljs-keyword">try</span> &#123;<br>    populateBean(beanName, mbd, instanceWrapper);<br>    <span class="hljs-keyword">if</span> (exposedObject != <span class="hljs-literal">null</span>) &#123;<br>        exposedObject = initializeBean(beanName, exposedObject, mbd);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>initializeBean:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">initializeBean</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> Object bean, RootBeanDefinition mbd)</span> &#123;<br>    <span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-literal">null</span>) &#123;<br>        AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Object&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                invokeAwareMethods(beanName, bean);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125;, getAccessControlContext());<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        invokeAwareMethods(beanName, bean);<br>    &#125;<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">wrappedBean</span> <span class="hljs-operator">=</span> bean;<br>    <span class="hljs-keyword">if</span> (mbd == <span class="hljs-literal">null</span> || !mbd.isSynthetic()) &#123;<br>        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);<br>    &#125;<br><br>    invokeInitMethods(beanName, wrappedBean, mbd);<br><br>    <span class="hljs-keyword">if</span> (mbd == <span class="hljs-literal">null</span> || !mbd.isSynthetic()) &#123;<br>        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);<br>    &#125;<br>    <span class="hljs-keyword">return</span> wrappedBean;<br>&#125;<br></code></pre></td></tr></table></figure><p>主要的操作步骤一目了然。</p><ul><li><p>Aware方法触发:</p><p>我们的bean有可能实现了一些XXXAware接口，此处就是负责调用它们:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeAwareMethods</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String beanName, <span class="hljs-keyword">final</span> Object bean)</span> &#123;<br>  <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> Aware) &#123;<br>      <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanNameAware) &#123;<br>          ((BeanNameAware) bean).setBeanName(beanName);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanClassLoaderAware) &#123;<br>          ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());<br>      &#125;<br>      <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> BeanFactoryAware) &#123;<br>          ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="hljs-built_in">this</span>);<br>      &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>BeanPostProcessor触发，没什么好说的</p></li><li><p>调用init方法:</p><p>在XML配置中，bean可以有一个init-method属性来指定初始化时调用的方法。从原理来说，其实就是一个反射调用。不过注意这里有一个InitializingBean的概念。</p><p>此接口只有一个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br></code></pre></td></tr></table></figure><p>如果我们的bean实现了此接口，那么此方法会首先被调用。此接口的意义在于: 当此bean的所有属性都被设置(注入)后，给bean一个利用现有属性重新组织或是检查属性的机会。感觉和init方法有些冲突，不过此接口在Spring被广泛使用。</p></li></ul><h3 id="getObjectForBeanInstance"><a href="#getObjectForBeanInstance" class="headerlink" title="getObjectForBeanInstance"></a>getObjectForBeanInstance</h3><p>位于AbstractBeanFactory，此方法的目的在于如果bean是FactoryBean，那么返回其工厂方法创建的bean，而不是自身。</p><h2 id="Prototype初始化"><a href="#Prototype初始化" class="headerlink" title="Prototype初始化"></a>Prototype初始化</h2><p>AbstractBeanFactory.doGetBean相关源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mbd.isPrototype()) &#123;<br>    <span class="hljs-comment">// It&#x27;s a prototype -&gt; create a new instance.</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">prototypeInstance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        beforePrototypeCreation(beanName);<br>        prototypeInstance = createBean(beanName, mbd, args);<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        afterPrototypeCreation(beanName);<br>    &#125;<br>    bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="beforePrototypeCreation"><a href="#beforePrototypeCreation" class="headerlink" title="beforePrototypeCreation"></a>beforePrototypeCreation</h3><p>此方法用于确保在同一时刻只能有一个此bean在初始化。</p><h3 id="createBean"><a href="#createBean" class="headerlink" title="createBean"></a>createBean</h3><p>和单例的是一样的，不在赘述。</p><h3 id="afterPrototypeCreation"><a href="#afterPrototypeCreation" class="headerlink" title="afterPrototypeCreation"></a>afterPrototypeCreation</h3><p>和beforePrototypeCreation对应的，你懂的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看出，初始化其实和单例是一样的，只不过单例多了一个是否已经存在的检查。</p><h2 id="其它Scope初始化"><a href="#其它Scope初始化" class="headerlink" title="其它Scope初始化"></a>其它Scope初始化</h2><p>其它就指的是request、session。此部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">scopeName</span> <span class="hljs-operator">=</span> mbd.getScope();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Scope</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.scopes.get(scopeName);<br>    <span class="hljs-keyword">if</span> (scope == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">scopedInstance</span> <span class="hljs-operator">=</span> scope.get(beanName, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectFactory</span>&lt;Object&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>            beforePrototypeCreation(beanName);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">return</span> createBean(beanName, mbd, args);<br>            &#125;<br>            <span class="hljs-keyword">finally</span> &#123;<br>                afterPrototypeCreation(beanName);<br>            &#125;<br>        &#125;<br>    &#125;);<br>    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);<br>&#125;<br></code></pre></td></tr></table></figure><p>scopes是一个LinkedHashMap&lt;String, Scope&gt;，可以调用 ConfigurableBeanFactory定义的registerScope方法注册其值。</p><p>Scope接口继承体系:</p><p><img src="Scope.jpg" alt="Scope继承体系"></p><p>根据socpe.get的注释，此方法如果找到了叫做beanName的bean，那么返回，如果没有，将调用ObjectFactory创建之。Scope的实现参考类图。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://github.com/seaswalker/spring-analysis/blob/master/note/Spring.md">spring</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>spring-analysis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解k8s容器网络</title>
    <link href="/2023/08/04/k8s/k8s%E4%B9%8B%E7%90%86%E8%A7%A3%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/"/>
    <url>/2023/08/04/k8s/k8s%E4%B9%8B%E7%90%86%E8%A7%A3%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="理解k8s容器网络"><a href="#理解k8s容器网络" class="headerlink" title="理解k8s容器网络"></a>理解k8s容器网络</h1><h2 id="docker实现容器通信原理"><a href="#docker实现容器通信原理" class="headerlink" title="docker实现容器通信原理"></a>docker实现容器通信原理</h2><ul><li>Docker 项目会默认在宿主机上创建一个名叫 docker0 的网桥，凡是连接在 docker0 网桥上的容器，就可以通过它来进行通信。把这些容器“连接”到 docker0 网桥上需要使用一种名叫Veth Pair的虚拟设备了。Veth Pair 常常被用作连接不同 Network Namespace 的“网线”。</li><li>Veth Pair 设备的特点是：它被创建出来后，总是以两张虚拟网卡（Veth Peer）的形式成对出现的。并且，从其中一个“网卡”发出的数据包，可以直接出现在与它对应的另一张“网卡”上，哪怕这两个“网卡”在不同的 Network Namespace 里。<h3 id="单主机容器通讯原理"><a href="#单主机容器通讯原理" class="headerlink" title="单主机容器通讯原理"></a>单主机容器通讯原理</h3><img src="img.png"></li></ul><p>如上图：同一宿主机上，容器之间都是连接到docker0这个网桥上的，docker0可以作为虚拟交换机（或路由器）使容器可以相互通信</p><h3 id="跨主机网络的实现"><a href="#跨主机网络的实现" class="headerlink" title="跨主机网络的实现"></a>跨主机网络的实现</h3><p>要理解容器『跨主通信』的原理，就一定要先从 Flannel 这个项目说起。目前，Flannel 支持三种后端实现，分别是：VXLAN、host-gw、UDP（弃用）</p><h4 id="UDP模式理解容器网络"><a href="#UDP模式理解容器网络" class="headerlink" title="UDP模式理解容器网络"></a>UDP模式理解容器网络</h4><p>两台宿主机。<br>宿主机 Node 1 上有一个容器 container-1，它的 IP 地址是 100.96.1.2，对应的 docker0 网桥的地址是：100.96.1.1/24。<br>宿主机 Node 2 上有一个容器 container-2，它的 IP 地址是 100.96.2.3，对应的 docker0 网桥的地址是：100.96.2.1/24。<br><img src="img_1.png"><br>container-1 访问 container-2：</p><ol><li>container-1 容器里的进程发起的 IP 包，其源地址就是 100.96.1.2，目的地址就是 100.96.2.3。由于目的地址 100.96.2.3 并不在 Node 1 的 docker0 网桥的网段里，所以这个 IP 包会被交给默认路由规则，通过容器的网关进入 docker0 网桥（如果是同一台宿主机上的容器间通信，走的是直连规则），从而出现在宿主机上。</li><li>这时候，这个 IP 包的下一个目的地，就取决于宿主机上的路由规则了。此时，Flannel 已经在宿主机上创建出了一系列的路由规则，以 Node 1 为例，如下所示：<br>在 Node 1 上<br>$ ip route<br>default via 10.168.0.1 dev eth0<br>100.96.0.0/16 dev flannel0  proto kernel  scope link  src 100.96.1.0<br>100.96.1.0/24 dev docker0  proto kernel  scope link  src 100.96.1.1<br>10.168.0.0/24 dev eth0  proto kernel  scope link  src 10.168.0.2</li><li>由于我们的 IP 包的目的地址是 100.96.2.3，它匹配不到本机 docker0 网桥对应的 100.96.1.0/24 网段，只能匹配到第1条、也就是 100.96.0.0/16 对应的这条路由规则，从而进入到一个叫作 flannel0 的设备中</li><li>flannel0 有个设备叫做TUN 设备（Tunnel 设备），TUN 设备是一种工作在三层（Network Layer）的虚拟网络设备。TUN 设备的功能非常简单，即：在操作系统内核和用户应用程序之间传递 IP 包。 当操作系统将一个 IP 包发送给 flannel0 设备之后，flannel0 就会把这个 IP 包，交给创建这个设备的应用程序，也就是 Flannel 进程。这是一个从内核态（Linux 操作系统）向用户态（Flannel 进程）的流动方向。<br><img src="img_2.png"><br>可以看到：</li></ol><p>第一次：用户态的容器进程发出的 IP 包经过 docker0 网桥进入内核态；</p><p>第二次：IP 包根据路由表进入 TUN（flannel0）设备，从而回到用户态的 flanneld 进程；</p><p>第三次：flanneld 进行 UDP 封包之后重新进入内核态，将 UDP 包通过宿主机的 eth0 发出去。</p><ol start="5"><li><p>反之，如果 Flannel 进程向 flannel0 设备发送了一个 IP 包，那么这个 IP 包就会出现在宿主机网络栈中，然后根据宿主机的路由表进行下一步处理。这是一个从用户态向内核态的流动方向。所以，当 IP 包从容器经过 docker0 出现在宿主机，然后又根据路由表进入 flannel0 设备后，宿主机上的 flanneld 进程（Flannel 项目在每个宿主机上的主进程），就会收到这个 IP 包。然后，flanneld 看到了这个 IP 包的目的地址，是 100.96.2.3，就把它发送给了 Node 2 宿主机。</p></li><li><p>确定IP地址对应的容器，是运行在 Node 2 上，因为由 Flannel 管理的容器网络里，一台宿主机上的所有容器，都属于该宿主机被分配的一个“子网” ，IP地址对应的容器，是运行在 Node 2 上的<br>子网与宿主机的对应关系，正是保存在 Etcd 当中，如下所示：<br>$ etcdctl ls /coreos.com/network/subnets<br>/coreos.com/network/subnets/100.96.1.0-24<br>/coreos.com/network/subnets/100.96.2.0-24<br>/coreos.com/network/subnets/100.96.3.0-24</p></li><li><p>这个请求得完成的原因：每台宿主机上的 flanneld，都监听着一个 8285 端口，所以 flanneld 只要把 UDP 包发往 Node 2 的 8285 端口即可。flanneld 会直接把这个 IP 包发送给它所管理的 TUN 设备，即 flannel0 设备。Linux 内核网络栈就会负责处理这个 IP 包，具体的处理方法，就是通过本机的路由表来寻找这个 IP 包的下一步流向。</p></li><li><p>NNode 2 上的路由表，跟 Node 1 非常类似，如下所示：<br>在 Node 2 上<br>$ ip route<br>default via 10.168.0.1 dev eth0<br>100.96.0.0/16 dev flannel0  proto kernel  scope link  src 100.96.2.0<br>100.96.2.0/24 dev docker0  proto kernel  scope link  src 100.96.2.1<br>10.168.0.0/24 dev eth0  proto kernel  scope link  src 10.168.0.3<br>这个 IP 包的目的地址是 100.96.2.3，它跟第2条、也就是 100.96.2.0/24 网段对应的路由规则匹配更加精确。所以，Linux 内核就会按照这条路由规则，把这个 IP 包转发给 docker0 网桥。</p></li><li><p>docker0 网桥的地址范围必须是 Flannel 为宿主机分配的子网。这个很容易实现，以 Node 1 为例，你只需要给它上面的 Docker Daemon 启动时配置如下所示的 bip 参数即可：<br>$ FLANNEL_SUBNET=100.96.1.1/24<br>$ dockerd –bip=$FLANNEL_SUBNET …</p></li><li><p>Flannel 进行 UDP 封装（Encapsulation）和解封装（Decapsulation）的过程，也都是在用户态完成的。在 Linux 操作系统中，上述这些上下文切换和用户态操作的代价其实是比较高的，这也正是造成 Flannel UDP 模式性能不好的主要原因。</p></li><li><p>Flannel UDP 模式提供的其实是一个三层的 Overlay 网络，即：它首先对发出端的 IP 包进行 UDP 封装，然后在接收端进行解封装拿到原始的 IP 包，进而把这个 IP 包转发给目标容器。这就好比，Flannel 在不同宿主机上的两个容器之间打通了一条“隧道”，使得这两个容器可以直接使用 IP 地址进行通信，而无需关心容器和宿主机的分布情况。</p></li></ol><p>所以说，我们在进行系统级编程的时候，有一个非常重要的优化原则，就是要减少用户态到内核态的切换次数，并且把核心的处理逻辑都放在内核态进行。这也是为什么，Flannel 后来支持的VXLAN 模式，逐渐成为了主流的容器网络方案的原因。</p><h4 id="VXLAN模式"><a href="#VXLAN模式" class="headerlink" title="VXLAN模式"></a>VXLAN模式</h4><ul><li>VXLAN，即 Virtual Extensible LAN（虚拟可扩展局域网），是 Linux 内核本身就支持的一种网络虚似化技术。所以说，VXLAN 可以完全在内核态实现上述封装和解封装的工作，通过“隧道”机制，构建出覆盖网络（Overlay Network）</li><li>需要在已有的宿主机网络上，再通过软件构建一个覆盖在已有宿主机网络之上的、可以把所有容器连通在一起的虚拟网络。所以，这种技术就被称为：Overlay Network（覆盖网络）。</li><li>网络插件flannel：网络插件真正要做的事情，把不同宿主机上的特殊设备连通，从而达到容器跨主机通信的目的。</li><li>VXLAN是Flannel默认和推荐的模式。当我们使用默认配置安装Flannel时，它会为每个节点分配一个24位子网，并在每个节点上创建两张虚机网卡： cni0 和 flannel.1 。 cni0 是一个网桥设备，类似于 docker0 ，节点上所有的Pod都通过veth pair的形式与 cni0 相连。 flannel.1 则是一个VXLAN类型的设备，充当VTEP的角色，实现对VXLAN报文的封包解包。<br>Flannel VXLAN 模式的工作原理:实现不同主机上容器之间的通讯<br><img src="img_3.png"></li></ul><p>图中每台宿主机上名叫 flannel.1 的设备，就是 VXLAN 所需的 VTEP 设备，它既有 IP 地址，也有 MAC 地址</p><p>流程描述：</p><ol><li>当 Node 2 启动并加入 Flannel 网络之后，在 Node 1（以及所有其他节点）上，flanneld 就会添加一条如下所示的路由规则：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ route -n<br>Kernel IP routing table<br>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br>10.1.16.0       10.1.16.0       255.255.255.0   UG    0      0        0 flannel.1<br>这条规则：<br>凡是发往10.1.16.0/24网段的IP包,都需要经过flannel.1设备发出,它最后被发往的网关地址是：10.1.16.0。<br></code></pre></td></tr></table></figure></li><li>flanneld 又是如何知道这个 IP 地址对应的容器，是运行在 Node2 上的呢？<br>Flannel项目里一个非常重要的概念：子网（Subnet）事实上，在由 Flannel 管理的容器网络里，一台宿主机上的所有容器，都属于该宿主机被分配的一个『子网』。在上面的例子中，Node1 的子网是 10.1.15.0/24，container-1 的 IP 地址是 10.1.15.2，Node2 的子网是 10.1.16.0/24，container-2 的IP地址是 10.1.16.3。Flannel VXLAN 模式的流程图中可以看到，10.1.16.0 正是 Node 2 上的 VTEP 设备（也就是 flannel.1 设备）的 IP 地址。</li><li>把 Node 1 和 Node 2 上的 flannel.1 设备分别称为“源 VTEP 设备”和“目的 VTEP 设备，这些 VTEP 设备之间，就需要想办法组成一个虚拟的二层网络，即：通过二层数据帧进行通信。源 VTEP 设备”收到“原始 IP 包”后，就要想办法把“原始 IP 包”加上一个目的 MAC 地址，封装成一个二层数据帧，然后发送给“目的 VTEP 设备”（当然，这么做还是因为这个 IP 包的目的地址不是本机）。要根据三层 IP 地址查询对应的二层 MAC 地址，这正是 ARP（Address Resolution Protocol ）表的功能。</li></ol><p>而这里要用到的 ARP 记录，也是 flanneld 进程在 Node 2 节点启动时，自动添加在 Node 1 上的。我们可以通过 ip 命令看到它，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在 Node 1 上</span><br>$ ip neigh show dev flannel.1<br>10.1.16.0 lladdr 5e:f8:4f:00:e3:37 PERMANENT<br></code></pre></td></tr></table></figure><p>每台节点启动时都会把VTEP设备对应的 ARP 记录，直接下放到其他每台宿主机上。<br>4.Linux 内核就可以开始二层封包工作了。这个二层帧的格式，如下所示：<br><img src="img_4.png"></p><p>上图Flannel VXLAN 模式的内部帧<br>可以看到，Linux 内核会把“目的 VTEP 设备”的 MAC 地址，填写在图中的 Inner Ethernet Header 字段，得到一个二层数据帧。<br>需要注意的是，上述封包过程只是加一个二层头，不会改变“原始 IP 包”的内容。所以图中的 Inner IP Header 字段，依然是 container-2 的 IP 地址，即 10.1.16.3。<br>5. 这些 VTEP 设备的 MAC 地址，对于宿主机本身没有什么意义，并不能在我们的宿主机二层网络里传输，Linux 内核还需要再把“内部数据帧”进一步封装成为宿主机网络里的一个普通的数据帧，好让它“载着”“内部数据帧”，通过宿主机的 eth0 网卡进行传输。<br>6. 为了实现这个“搭便车”的机制，Linux 内核会在“内部数据帧”前面，加上一个特殊的 VXLAN 头，用来表示这个“乘客”实际上是一个 VXLAN 要使用的数据帧。而这个 VXLAN 头里有一个重要的标志叫作VNI，它是 VTEP 设备识别某个数据帧是不是应该归自己处理的重要标识。而在 Flannel 中，VNI 的默认值是 1，这也是为何，宿主机上的 VTEP 设备都叫作 flannel.1 的原因，这里的“1”，其实就是 VNI 的值。<br>7. 然后，Linux 内核会把这个数据帧封装进一个 UDP 包里发出去。这个 UDP 包里面，其实是一个完整的二层数据帧，在宿主机看来，它会以为自己的 flannel.1 设备只是在向另外一台宿主机的 flannel.1 设备，发起了一次普通的 UDP 链接<br>8. 一个 flannel.1 设备只知道另一端的 flannel.1 设备的 MAC 地址，却不知道对应的宿主机地址是什么？<br>   这种场景下，flannel.1 设备实际上要扮演一个“网桥”的角色，在二层网络进行 UDP 包的转发。在 Linux 内核里面，“网桥”设备进行转发的依据，来自于FDB（Forwarding Database）的转发数据库。这个 flannel.1“网桥”对应的 FDB 信息，也是 flanneld 进程负责维护的。它的内容可以通过 bridge fdb 命令查看到，如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在 Node 1 上，使用“目的 VTEP 设备”的 MAC 地址进行查询</span><br>$ bridge fdb show flannel.1 | grep 5e:f8:4f:00:e3:37<br>5e:f8:4f:00:e3:37 dev flannel.1 dst 10.168.0.3 self permanent<br></code></pre></td></tr></table></figure><p>可以看到，在上面这条 FDB 记录里，指定了这样一条规则，即：<br>发往我们前面提到的“目的 VTEP 设备”（MAC 地址是 5e:f8:4f:00:e3:37）的二层数据帧，应该通过 flannel.1 设备，发往 IP 地址为 10.168.0.3 的主机。显然，这台主机正是 Node 2，UDP 包要发往的目的地就找到了。<br>9. 接下来的流程，就是一个正常的、宿主机网络上的封包工作。UDP 包是一个四层数据包，所以 Linux 内核会在它前面加上一个 IP 头，即原理图中的 Outer IP Header，组成一个 IP 包。并且，在这个 IP 头里，会填上前面通过 FDB 查询出来的目的主机的 IP 地址，即 Node 2 的 IP 地址 10.168.0.3。然后，Linux 内核再在这个 IP 包前面加上二层数据帧头，即原理图中的 Outer Ethernet Header，并把 Node 2 的 MAC 地址填进去。这个 MAC 地址本身，是 Node 1 的 ARP 表要学习的内容，无需 Flannel 维护。这时候，我们封装出来的“外部数据帧”的格式，如下所示：<br>   <img src="img_5.png"></p><p>上图Flannel VXLAN 模式的外部帧，这样，封包工作就宣告完成了。<br>接下来，Node 1 上的 flannel.1 设备就可以把这个数据帧从 Node 1 的 eth0 网卡发出去。显然，这个帧会经过宿主机网络来到 Node 2 的 eth0 网卡。<br>这时候，Node 2 的内核网络栈会发现这个数据帧里有 VXLAN Header，并且 VNI=1。所以 Linux 内核会对它进行拆包，拿到里面的内部数据帧，然后根据 VNI 的值，把它交给 Node 2 上的 flannel.1 设备。而 flannel.1 设备则会进一步拆包，取出“原始 IP 包”。接下来就到了单机容器网络的处理流程。最终，IP 包就进入到了 container-2 容器的 Network Namespace 里。</p><h2 id="Kubernetes网络模型与CNI网络插件"><a href="#Kubernetes网络模型与CNI网络插件" class="headerlink" title="Kubernetes网络模型与CNI网络插件"></a>Kubernetes网络模型与CNI网络插件</h2><p>Kubernetes 之所以要设置这样一个与 docker0 网桥功能几乎一样的 CNI 网桥，主要原因包括两个方面：</p><ol><li>Kubernetes 项目并没有使用 Docker 的网络模型（CNM），所以它并不希望、也不具备配置 docker0 网桥的能力；</li><li>这还与 Kubernetes 如何配置 Pod，也就是 Infra 容器的 Network Namespace 密切相关。</li></ol><p>Kubernetes 是通过一个叫作 CNI 的接口，维护了一个单独的网桥来代替 docker0。这个网桥的名字就叫作：CNI 网桥，它在宿主机上的设备名称默认是：cni0。<br>CNI 的设计思想，就是：Kubernetes 在启动 Infra 容器之后，就可以直接调用 CNI 网络插件，为这个 Infra 容器的 Network Namespace，配置符合预期的网络栈.<br>如下图所示：docker0替换成cni0<br><img src="img_6.png"><br>大致概括一下整个过程：</p><p>发送端：在Pod中发起 ping  ，ICMP 报文经过 cni0 网桥后交由 flannel.1 设备处理。 flannel.1 设备是一个VXLAN类型的设备，负责VXLAN封包解包。 因此，在发送端，flannel.1 将原始L2报文封装成VXLAN UDP报文，然后从 eth0 发送。<br>接收端：Node2收到UDP报文，发现是一个VXLAN类型报文，交由 flannel.1 进行解包。根据解包后得到的原始报文中的目的IP，将原始报文经由 cni0 网桥发送给Pod。<br>因为我们的 IP 包的目的 IP 地址是 10.244.1.3，所以它只能匹配到第二条规则，也就是 10.244.1.0 对应的这条路由规则。</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"># 在 Node <span class="hljs-number">1</span> 上<br>$ route -n<br>Kernel IP routing table<br>Destination     Gateway         Genmask         Flags Metric Ref    Use Iface<br>...<br><span class="hljs-number">10.244.0.0</span>      <span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>         <span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">0</span>   U     <span class="hljs-number">0</span>      <span class="hljs-number">0</span>        <span class="hljs-number">0</span> cni0<br><span class="hljs-number">10.244.1.0</span>      <span class="hljs-number">10</span>.<span class="hljs-number">244</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>      <span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">0</span>   UG    <span class="hljs-number">0</span>      <span class="hljs-number">0</span>        <span class="hljs-number">0</span> flannel.<span class="hljs-number">1</span><br><br><br></code></pre></td></tr></table></figure><p>理解所谓的“Kubernetes 网络模型”:</p><ul><li><p>所有容器都可以直接使用 IP 地址与其他容器通信，而无需使用 NAT。</p></li><li><p>所有宿主机都可以直接使用 IP 地址与所有容器通信，而无需使用 NAT。反之亦然。</p></li><li><p>容器自己“看到”的自己的 IP 地址，和别人（宿主机或者容器）看到的地址是完全一样的。</p><h2 id="Kubernetes三层网络方案"><a href="#Kubernetes三层网络方案" class="headerlink" title="Kubernetes三层网络方案"></a>Kubernetes三层网络方案</h2><p>典型例子，莫过于 Flannel 的 host-gw 模式和 Calico 项目了</p><h3 id="Flannel-的-host-gw-模式。"><a href="#Flannel-的-host-gw-模式。" class="headerlink" title="Flannel 的 host-gw 模式。"></a>Flannel 的 host-gw 模式。</h3><p><img src="img_7.png"></p></li><li><p>要求所有宿主机都在一个局域网内，跨局域网无法进行路由.</p></li><li><p>host-gw 模式的工作原理，其实就是将每个 Flannel 子网（Flannel Subnet，比如：10.244.1.0/24）的“下一跳”，设置成了该子网对应的宿主机的 IP 地址。这台“主机”（Host）会充当这条容器通信路径里的“网关”（Gateway）。这也正是“host-gw”的含义。</p></li><li><p>在host-gw模式下，由于不涉及VXLAN的封包解包，不再需要flannel.1虚机网卡。 flanneld 负责为各节点设置路由 ，将对应节点Pod子网的下一跳地址指向对应的节点的ip</p></li></ul><p>host-gw 模式能够正常工作的核心，就在于 IP 包在封装成帧发送出去的时候，会使用路由表里的“下一跳”来设置目的 MAC 地址。这样，它就会经过二层网络到达目的宿主机。所以说，Flannel host-gw 模式必须要求集群宿主机之间是二层连通的。</p><h2 id="三层和隧道的异同"><a href="#三层和隧道的异同" class="headerlink" title="三层和隧道的异同"></a>三层和隧道的异同</h2><p>相同之处是都实现了跨主机容器的三层互通，而且都是通过对目的 MAC 地址的操作来实现的；不同之处是三层通过配置下一条主机的路由规则来实现互通，隧道则是通过通过在 IP 包外再封装一层 MAC 包头来实现。<br>三层的优点：少了封包和解包的过程，性能肯定是更高的。<br>三层的缺点：需要自己想办法维护路由规则。<br>隧道的优点：简单，原因是大部分工作都是由 Linux 内核的模块实现了，应用层面工作量较少。 </p>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kubernetus权限管理akcess</title>
    <link href="/2023/08/04/k8s/kubernetus%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86akcess/"/>
    <url>/2023/08/04/k8s/kubernetus%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86akcess/</url>
    
    <content type="html"><![CDATA[<p>akcess是一个命令行实用程序，可用于与其他团队共享对 Kubernetes 集群的细粒度访问。<br>安装 wget <a href="https://github.com/viveksinghggits/akcess/releases/download/v0.0.4/akcess_0.0.4_Linux_x86_64.tar.gz">https://github.com/viveksinghggits/akcess/releases/download/v0.0.4/akcess_0.0.4_Linux_x86_64.tar.gz</a><br>解压配置<br>tar xf akcess_0.0.1_Linux_x86_64.tar.gz -C  /usr/local/bin<br>参数解释</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">允许访问从default命名空间获取 pod<br>akcess allow --verb list --resource pods<br><br>允许访问以查看命名空间<span class="hljs-built_in">test</span>中名称为nginx的pod 的日志<br>akcess allow --verb get --resource pods,pods/log -n <span class="hljs-built_in">test</span> --resource-name nginx<br><br>允许访问创建namespace:database中的pod及pod日志<br>akcess allow  --verb get,create --resource pods,pods/exec -n database<br><br>允许访问指定标签的的pod<br>akcess allow  --verb get --resource pods,pods/log -l component=database -n backend<br></code></pre></td></tr></table></figure><ul><li>将上述命令的输出重定向到一个文件，该文件可以在KUBECONFIGenv var 中设置。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">akcess allow --verb get --resource pods,pods/log -n <span class="hljs-built_in">test</span> &gt; logsconfig(生成config文件)<br><br>每当我们创建一个Kubernetes资源时，我们都会用一个keyallow.akcess.id和value对其进行注释，使其成为UUID <br>已经创建的资源集合或者akcess allow已经运行的次数可以通过运行算出<br><br>akcess list<br>- <span class="hljs-built_in">id</span>: ee022ab3-246f-4a6d-bd53-e04ae90cc1d9<br>  createdAt: 2022-03-06T12:03:42.171995731+01:00<br>  namespace: <span class="hljs-built_in">test</span><br>- <span class="hljs-built_in">id</span>: 818e4e6f-4be9-41a2-9f8b-de4247626d16<br>  createdAt: 2022-03-06T12:12:17.884823402+01:00<br>  namespace: default<br>要删除Kubernetes特定运行的资源，我们可以运行<br><br>» akcess delete --<span class="hljs-built_in">id</span> ee022ab3-246f-4a6d-bd53-e04ae90cc1d9<br></code></pre></td></tr></table></figure></li><li>参数补充：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><code class="hljs bash">resources:<br>      - <span class="hljs-string">&quot;configmaps&quot;</span><br>      - <span class="hljs-string">&quot;endpoints&quot;</span><br>      - <span class="hljs-string">&quot;persistentvolumeclaims&quot;</span><br>      - <span class="hljs-string">&quot;pods&quot;</span><br>      - <span class="hljs-string">&quot;pods/log&quot;</span><br>      - <span class="hljs-string">&quot;pods/portforward&quot;</span><br>      - <span class="hljs-string">&quot;podtemplates&quot;</span><br>      - <span class="hljs-string">&quot;replicationcontrollers&quot;</span><br>      - <span class="hljs-string">&quot;resourcequotas&quot;</span><br>      - <span class="hljs-string">&quot;secrets&quot;</span><br>      - <span class="hljs-string">&quot;services&quot;</span><br>      - <span class="hljs-string">&quot;events&quot;</span><br>      - <span class="hljs-string">&quot;daemonsets&quot;</span><br>      - <span class="hljs-string">&quot;deployments&quot;</span><br>      - <span class="hljs-string">&quot;replicasets&quot;</span><br>      - <span class="hljs-string">&quot;ingresses&quot;</span><br>      - <span class="hljs-string">&quot;networkpolicies&quot;</span><br>      - <span class="hljs-string">&quot;poddisruptionbudgets&quot;</span><br><br> verbs:   [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;list&quot;</span>, <span class="hljs-string">&quot;watch&quot;</span>, <span class="hljs-string">&quot;create&quot;</span>, <span class="hljs-string">&quot;update&quot;</span>, <span class="hljs-string">&quot;patch&quot;</span>, <span class="hljs-string">&quot;delete&quot;</span>]<br><br>以下三种：<br>---<br>apiVersion: rbac.authorization.k8s.io/v1<br>kind: ClusterRole<br>metadata:<br>  name: template-namespaced-resources___operation<br>rules:<br>  - apiGroups:<br>      - <span class="hljs-string">&quot;*&quot;</span><br>    resources:<br>      - <span class="hljs-string">&quot;*&quot;</span><br>    verbs:<br>      - <span class="hljs-string">&quot;*&quot;</span><br>---<br>apiVersion: rbac.authorization.k8s.io/v1<br>kind: ClusterRole<br>metadata:<br>  name: template-namespaced-resources___developer<br>rules:<br>  - apiGroups:<br>      - <span class="hljs-string">&quot;*&quot;</span><br>    resources:<br>      - <span class="hljs-string">&quot;configmaps&quot;</span><br>      - <span class="hljs-string">&quot;endpoints&quot;</span><br>      - <span class="hljs-string">&quot;persistentvolumeclaims&quot;</span><br>      - <span class="hljs-string">&quot;pods&quot;</span><br>      - <span class="hljs-string">&quot;pods/log&quot;</span><br>      - <span class="hljs-string">&quot;pods/portforward&quot;</span><br>      - <span class="hljs-string">&quot;podtemplates&quot;</span><br>      - <span class="hljs-string">&quot;replicationcontrollers&quot;</span><br>      - <span class="hljs-string">&quot;resourcequotas&quot;</span><br>      - <span class="hljs-string">&quot;services&quot;</span><br>      - <span class="hljs-string">&quot;events&quot;</span><br>      - <span class="hljs-string">&quot;daemonsets&quot;</span><br>      - <span class="hljs-string">&quot;deployments&quot;</span><br>      - <span class="hljs-string">&quot;replicasets&quot;</span><br>      - <span class="hljs-string">&quot;ingresses&quot;</span><br>      - <span class="hljs-string">&quot;networkpolicies&quot;</span><br>      - <span class="hljs-string">&quot;poddisruptionbudgets&quot;</span><br>    verbs:<br>      - <span class="hljs-string">&quot;*&quot;</span><br>---<br>apiVersion: rbac.authorization.k8s.io/v1<br>kind: ClusterRole<br>metadata:<br>  name: template-cluster-resources___read-only<br>rules:<br>  - apiGroups:<br>      - <span class="hljs-string">&quot;*&quot;</span><br>    resources:<br>      - <span class="hljs-string">&quot;componentstatuses&quot;</span><br>      - <span class="hljs-string">&quot;namespaces&quot;</span><br>      - <span class="hljs-string">&quot;nodes&quot;</span><br>      - <span class="hljs-string">&quot;persistentvolumes&quot;</span><br>      - <span class="hljs-string">&quot;mutatingwebhookconfigurations&quot;</span><br>      - <span class="hljs-string">&quot;validatingwebhookconfigurations&quot;</span><br>      - <span class="hljs-string">&quot;customresourcedefinitions&quot;</span><br>      - <span class="hljs-string">&quot;apiservices&quot;</span><br>      - <span class="hljs-string">&quot;tokenreviews&quot;</span><br>      - <span class="hljs-string">&quot;selfsubjectaccessreviews&quot;</span><br>      - <span class="hljs-string">&quot;selfsubjectrulesreviews&quot;</span><br>      - <span class="hljs-string">&quot;subjectaccessreviews&quot;</span><br>      - <span class="hljs-string">&quot;certificatesigningrequests&quot;</span><br>      - <span class="hljs-string">&quot;runtimeclasses&quot;</span><br>      - <span class="hljs-string">&quot;podsecuritypolicies&quot;</span><br>      - <span class="hljs-string">&quot;clusterrolebindings&quot;</span><br>      - <span class="hljs-string">&quot;clusterroles&quot;</span><br>      - <span class="hljs-string">&quot;priorityclasses&quot;</span><br>      - <span class="hljs-string">&quot;csidrivers&quot;</span><br>      - <span class="hljs-string">&quot;csinodes&quot;</span><br>      - <span class="hljs-string">&quot;storageclasses&quot;</span><br>      - <span class="hljs-string">&quot;volumeattachment&quot;</span><br>    verbs: [<span class="hljs-string">&quot;get&quot;</span>, <span class="hljs-string">&quot;list&quot;</span>, <span class="hljs-string">&quot;watch&quot;</span>, <span class="hljs-string">&quot;delete&quot;</span>]<br>---<br>apiVersion: rbac.authorization.k8s.io/v1<br>kind: ClusterRole<br>metadata:<br>  name: template-cluster-resources___admin<br>rules:<br>  - apiGroups:<br>      - <span class="hljs-string">&quot;*&quot;</span><br>    resources:<br>      - <span class="hljs-string">&quot;componentstatuses&quot;</span><br>      - <span class="hljs-string">&quot;namespaces&quot;</span><br>      - <span class="hljs-string">&quot;nodes&quot;</span><br>      - <span class="hljs-string">&quot;persistentvolumes&quot;</span><br>      - <span class="hljs-string">&quot;mutatingwebhookconfigurations&quot;</span><br>      - <span class="hljs-string">&quot;validatingwebhookconfigurations&quot;</span><br>      - <span class="hljs-string">&quot;customresourcedefinitions&quot;</span><br>      - <span class="hljs-string">&quot;apiservices&quot;</span><br>      - <span class="hljs-string">&quot;tokenreviews&quot;</span><br>      - <span class="hljs-string">&quot;selfsubjectaccessreviews&quot;</span><br>      - <span class="hljs-string">&quot;selfsubjectrulesreviews&quot;</span><br>      - <span class="hljs-string">&quot;subjectaccessreviews&quot;</span><br>      - <span class="hljs-string">&quot;certificatesigningrequests&quot;</span><br>      - <span class="hljs-string">&quot;runtimeclasses&quot;</span><br>      - <span class="hljs-string">&quot;podsecuritypolicies&quot;</span><br>      - <span class="hljs-string">&quot;clusterrolebindings&quot;</span><br>      - <span class="hljs-string">&quot;clusterroles&quot;</span><br>      - <span class="hljs-string">&quot;priorityclasses&quot;</span><br>      - <span class="hljs-string">&quot;csidrivers&quot;</span><br>      - <span class="hljs-string">&quot;csinodes&quot;</span><br>      - <span class="hljs-string">&quot;storageclasses&quot;</span><br>      - <span class="hljs-string">&quot;volumeattachment&quot;</span><br>    verbs: [<span class="hljs-string">&quot;*&quot;</span>]<br><br><br>apiVersion: rbac.authorization.k8s.io/v1<br>kind: ClusterRole<br>metadata:<br>  name: template-namespaced-resources___test<br>rules:<br>  - apiGroups:<br>      - <span class="hljs-string">&quot;*&quot;</span><br>    resources:<br>      - <span class="hljs-string">&quot;pods&quot;</span><br>      - <span class="hljs-string">&quot;pods/log&quot;</span><br>      - <span class="hljs-string">&quot;pods/portforward&quot;</span><br>      - <span class="hljs-string">&quot;podtemplates&quot;</span><br>      - <span class="hljs-string">&quot;deployments&quot;</span><br>    verbs:<br>      - <span class="hljs-string">&quot;*&quot;</span><br></code></pre></td></tr></table></figure><h1 id="用户分类"><a href="#用户分类" class="headerlink" title="用户分类"></a>用户分类</h1>K8s的用户分两种，一种是普通用户，一种是ServiceAccount（服务账户）。</li></ul><h2 id="普通用户"><a href="#普通用户" class="headerlink" title="普通用户"></a>普通用户</h2><p>普通用户是假定被外部或独立服务管理的。管理员分配私钥。平时常用的kubectl命令都是普通用户执行的。<br>如果是用户需求权限，则将Role与User(或Group)绑定(这需要创建User/Group)，是给用户使用的。</p><h2 id="ServiceAccount（服务账户）"><a href="#ServiceAccount（服务账户）" class="headerlink" title="ServiceAccount（服务账户）"></a>ServiceAccount（服务账户）</h2><p>ServiceAccount（服务帐户）是由Kubernetes API管理的用户。它们绑定到特定的命名空间，并由API服务器自动创建或通过API调用手动创建。服务帐户与存储为Secrets的一组证书相关联，这些凭据被挂载到pod中，以便集群进程与Kubernetes API通信。（登录dashboard时我们使用的就是ServiceAccount）<br>如果是程序需求权限，将Role与ServiceAccount指定(这需要创建ServiceAccount并且在deployment中指定ServiceAccount)，是给程序使用的。<br>相当于Role是一个类，用作权限申明，User/Group/ServiceAccount将成为类的实例。</p><p>工作流程图<br><img src="img.png"></p><h1 id="K8s角色-amp-角色绑定（以ServiceAccount展开讲解）"><a href="#K8s角色-amp-角色绑定（以ServiceAccount展开讲解）" class="headerlink" title="K8s角色&amp;角色绑定（以ServiceAccount展开讲解）"></a>K8s角色&amp;角色绑定（以ServiceAccount展开讲解）</h1><h2 id="授权介绍"><a href="#授权介绍" class="headerlink" title="授权介绍"></a>授权介绍</h2><p>在RABC API中，通过如下的步骤进行授权：</p><p>定义角色：在定义角色时会指定此角色对于资源的访问控制的规则。<br>绑定角色：将主体与角色进行绑定，对用户进行访问授权。<br>角色</p><p>Role：授权特定命名空间的访问权限<br>ClusterRole：授权所有命名空间的访问权限<br>角色绑定</p><p>RoleBinding：将角色绑定到主体（即subject）<br>ClusterRoleBinding：将集群角色绑定到主体<br>主体（subject）</p><p>User：用户<br>Group：用户组<br>ServiceAccount：服务账号<br><img src="img_1.png"></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://github.com/viveksinghggits/akcess">akcess</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>akcess</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring-mvc</title>
    <link href="/2023/08/02/spring/spring-mvc/"/>
    <url>/2023/08/02/spring/spring-mvc/</url>
    
    <content type="html"><![CDATA[<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>spring-mvc的核心便是DispatcherServlet，所以初始化也是围绕其展开的。类图:</p><p><img src="DispatcherServlet.jpg" alt="DispatcherServlet类图"></p><p>Servlet标准定义了init方法是其生命周期的初始化方法。</p><p>HttpServletBean.init:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException &#123;<br>    <span class="hljs-comment">// Set bean properties from init parameters.</span><br>    <span class="hljs-type">PropertyValues</span> <span class="hljs-variable">pvs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletConfigPropertyValues</span>(getServletConfig(), <span class="hljs-built_in">this</span>.requiredProperties);<br>    <span class="hljs-comment">//包装DispatcherServlet，准备放入容器</span><br>    <span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">bw</span> <span class="hljs-operator">=</span> PropertyAccessorFactory.forBeanPropertyAccess(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-comment">//用以加载spring-mvc配置文件</span><br>    <span class="hljs-type">ResourceLoader</span> <span class="hljs-variable">resourceLoader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletContextResourceLoader</span>(getServletContext());<br>    bw.registerCustomEditor(Resource.class, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceEditor</span>(resourceLoader, getEnvironment()));<br>    <span class="hljs-comment">//没有子类实现此方法</span><br>    initBeanWrapper(bw);<br>    bw.setPropertyValues(pvs, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// Let subclasses do whatever initialization they like.</span><br>    initServletBean();<br>&#125;<br></code></pre></td></tr></table></figure><p>主要逻辑一目了然。注意<strong>setPropertyValues方法会导致对DispatcherServlet相关setter方法的调用，所以当进行容器初始化时从init-param中读取的参数已被设置到DispatcherServlet的相关字段(Field)中</strong>。</p><h2 id="容器初始化"><a href="#容器初始化" class="headerlink" title="容器初始化"></a>容器初始化</h2><p>FrameworkServlet.initServletBean简略版源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initServletBean</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.webApplicationContext = initWebApplicationContext();<br>    <span class="hljs-comment">//空实现，且没有子类覆盖</span><br>    initFrameworkServlet()<br>&#125;<br></code></pre></td></tr></table></figure><p>FrameworkServlet.initWebApplicationContext:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title function_">initWebApplicationContext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//根容器查找</span><br>    <span class="hljs-type">WebApplicationContext</span> <span class="hljs-variable">rootContext</span> <span class="hljs-operator">=</span><br>            WebApplicationContextUtils.getWebApplicationContext(getServletContext());<br>    <span class="hljs-type">WebApplicationContext</span> <span class="hljs-variable">wac</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.webApplicationContext != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//有可能DispatcherServlet被作为Spring bean初始化，且webApplicationContext已被注入进来</span><br>        wac = <span class="hljs-built_in">this</span>.webApplicationContext;<br>        <span class="hljs-keyword">if</span> (wac <span class="hljs-keyword">instanceof</span> ConfigurableWebApplicationContext) &#123;<br>            <span class="hljs-type">ConfigurableWebApplicationContext</span> <span class="hljs-variable">cwac</span> <span class="hljs-operator">=</span> (ConfigurableWebApplicationContext) wac;<br>            <span class="hljs-keyword">if</span> (!cwac.isActive()) &#123;<br>                <span class="hljs-keyword">if</span> (cwac.getParent() == <span class="hljs-literal">null</span>) &#123;<br>                    cwac.setParent(rootContext);<br>                &#125;<br>                configureAndRefreshWebApplicationContext(cwac);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (wac == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//是否已经存在于ServletContext中</span><br>        wac = findWebApplicationContext();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (wac == <span class="hljs-literal">null</span>) &#123;<br>        wac = createWebApplicationContext(rootContext);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.refreshEventReceived) &#123;<br>        onRefresh(wac);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.publishContext) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">attrName</span> <span class="hljs-operator">=</span> getServletContextAttributeName();<br>        getServletContext().setAttribute(attrName, wac);<br>    &#125;<br>    <span class="hljs-keyword">return</span> wac;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面分部分展开。</p><h3 id="根容器查找"><a href="#根容器查找" class="headerlink" title="根容器查找"></a>根容器查找</h3><p>spring-mvc支持Spring容器与MVC容器共存，此时，Spring容器即根容器，mvc容器将根容器视为父容器。</p><p>Spring容器(根容器)以下列形式进行配置(web.xml):</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br></code></pre></td></tr></table></figure><p>根据Servlet规范，各组件的加载 顺序如下:</p><p>listener -&gt; filter -&gt; servlet</p><p>WebApplicationContextUtils.getWebApplicationContext:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE</span> <span class="hljs-operator">=</span> WebApplicationContext.class.getName() + <span class="hljs-string">&quot;.ROOT&quot;</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> WebApplicationContext <span class="hljs-title function_">getWebApplicationContext</span><span class="hljs-params">(ServletContext sc)</span> &#123;<br>    <span class="hljs-keyword">return</span> getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);<br>&#125;<br></code></pre></td></tr></table></figure><p>两参数方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> WebApplicationContext <span class="hljs-title function_">getWebApplicationContext</span><span class="hljs-params">(ServletContext sc, String attrName)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">attr</span> <span class="hljs-operator">=</span> sc.getAttribute(attrName);<br>    <span class="hljs-keyword">if</span> (attr == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (WebApplicationContext) attr;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以得出结论:</p><p><strong>如果Spring根容器存在，那么它被保存在ServletContext中，其key为<code>WebApplicationContext.class.getName() + &quot;.ROOT&quot;</code>。</strong></p><h3 id="容器创建"><a href="#容器创建" class="headerlink" title="容器创建"></a>容器创建</h3><p>FrameworkServlet.createWebApplicationContext:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title function_">createWebApplicationContext</span><span class="hljs-params">(ApplicationContext parent)</span> &#123;<br>    Class&lt;?&gt; contextClass = getContextClass();<br>    <span class="hljs-keyword">if</span> (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationContextException</span>();<br>    &#125;<br>    <span class="hljs-type">ConfigurableWebApplicationContext</span> <span class="hljs-variable">wac</span> <span class="hljs-operator">=</span><br>            (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);<br>    wac.setEnvironment(getEnvironment());<br>    wac.setParent(parent);<br>    wac.setConfigLocation(getContextConfigLocation());<br>    configureAndRefreshWebApplicationContext(wac);<br>    <span class="hljs-keyword">return</span> wac;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过对getContextClass方法的调用，Spring允许我们自定义容器的类型，即我们可以在web.xml中如下配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>SpringMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置文件位置 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-servlet.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 容器类型 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextClass<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>java.lang.Object<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br></code></pre></td></tr></table></figure><p>configureAndRefreshWebApplicationContext核心源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureAndRefreshWebApplicationContext</span><span class="hljs-params">(ConfigurableWebApplicationContext wac)</span> &#123;<br>    applyInitializers(wac);<br>    wac.refresh();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ApplicationContextInitializer"><a href="#ApplicationContextInitializer" class="headerlink" title="ApplicationContextInitializer"></a>ApplicationContextInitializer</h4><p>ApplicationContextInitializer允许我们在Spring(mvc)容器初始化之前干点坏事，可以通过init-param传入:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextInitializerClasses<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>坏事儿<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br></code></pre></td></tr></table></figure><p>applyInitializers方法正是要触发这些坏事儿。类图:</p><p><img src="ApplicationContextInitializer.jpg" alt="ApplicationContextInitializer类图"></p><h4 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h4><p>“配置”指的便是spring-servlet.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;controller&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 启用对静态资源使用默认servlet处理，非REST方式不需要 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br><span class="hljs-comment">&lt;!-- 配置视图 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.UrlBasedViewResolver&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- viewClass属性必不可少 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>而解析的入口便在于对refresh方法的调用，此方法位于AbstractApplicationContext，这一点在spring-core时已经见过了，下面我们重点关注不同于spring-core的地方。</p><p>对于spring-mvc来说，其容器默认为XmlWebApplicationContext，部分类图:</p><p><img src="XmlWebApplicationContext.jpg" alt="XmlWebApplicationContext类图"></p><p>XmlWebApplicationContext通过重写loadBeanDefinitions方法改变了bean加载行为，使其指向spring-servlet.xml。</p><p>spring-servlet.xml中不同于spring-core的地方便在于引入了mvc命名空间，正如spring-core中笔记中所说的那样，<strong>Spring用过jar包/META-INFO中的.handlers文件定义针对不同的命名空间所使用的解析器</strong>。</p><p>mvc命名空间的解析器为MvcNamespaceHandler，部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>    registerBeanDefinitionParser(<span class="hljs-string">&quot;annotation-driven&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationDrivenBeanDefinitionParser</span>());<br>    registerBeanDefinitionParser(<span class="hljs-string">&quot;default-servlet-handler&quot;</span>, <br>                                 <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultServletHandlerBeanDefinitionParser</span>());<br>    registerBeanDefinitionParser(<span class="hljs-string">&quot;interceptors&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IanterceptorsBeanDefinitionParser</span>());<br>    registerBeanDefinitionParser(<span class="hljs-string">&quot;view-resolvers&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ViewResolversBeanDefinitionParser</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p>老样子，按部分展开。</p><h5 id="注解驱动"><a href="#注解驱动" class="headerlink" title="注解驱动"></a>注解驱动</h5><p>其parse方法负责向Sprng容器注册一些必要的组件，整理如下图:</p><p><img src="mvc-annotation.png" alt="mvc-annotation"></p><h5 id="静态资源处理"><a href="#静态资源处理" class="headerlink" title="静态资源处理"></a>静态资源处理</h5><p>即:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>DefaultServletHandlerBeanDefinitionParser.parse负责向容器注册以下三个组件:</p><ul><li>DefaultServletHttpRequestHandler</li><li>SimpleUrlHandlerMapping</li><li>HttpRequestHandlerAdapter</li></ul><h5 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h5><p>InterceptorsBeanDefinitionParser.parse方法负责<strong>将每一项<code>mvc:interceptor</code>配置解析为一个MappedInterceptor bean并注册到容器中</strong>。</p><h5 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h5><p>有两种方式向Spring容器注册视图:</p><ul><li><p>以前采用较土的方式:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.UrlBasedViewResolver&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- viewClass属性必不可少 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>通过特定的标签:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-resolvers</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mvc:jsp</span> <span class="hljs-attr">view-class</span>=<span class="hljs-string">&quot;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:view-resolvers</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ul><p>从这里可以推测出: 拦截器同样支持第一种方式，Spring在查找时应该会查询某一接口的子类。</p><p>ViewResolversBeanDefinitionParser.parse方法的作用便是将每一个视图解析为ViewResolver并注册到容器。</p><h4 id="Scope-处理器注册"><a href="#Scope-处理器注册" class="headerlink" title="Scope/处理器注册"></a>Scope/处理器注册</h4><p>AbstractRefreshableWebApplicationContext.postProcessBeanFactory:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> &#123;<br>    beanFactory.addBeanPostProcessor(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletContextAwareProcessor</span>(<span class="hljs-built_in">this</span>.servletContext, <span class="hljs-built_in">this</span>.servletConfig));<br>    beanFactory.ignoreDependencyInterface(ServletContextAware.class);<br>    beanFactory.ignoreDependencyInterface(ServletConfigAware.class);<br>    WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, <span class="hljs-built_in">this</span>.servletContext);<br>    WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, <br>        <span class="hljs-built_in">this</span>.servletContext, <span class="hljs-built_in">this</span>.servletConfig);<br>&#125;<br></code></pre></td></tr></table></figure><p>ServletContextAwareProcessor用以向实现了ServletContextAware的bean注册ServletContext。</p><p>registerWebApplicationScopes用以注册”request”, “session”, “globalSession”, “application”四种scope，scope是个什么东西以及如何自定义，在spring-core中已经进行过说明了。</p><p>registerEnvironmentBeans用以将servletContext、servletConfig以及各种启动参数注册到Spring容器中。</p><h2 id="MVC初始化"><a href="#MVC初始化" class="headerlink" title="MVC初始化"></a>MVC初始化</h2><p>入口位于DispatcherServlet的initStrategies方法(经由onRefresh调用):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initStrategies</span><span class="hljs-params">(ApplicationContext context)</span> &#123;<br>    initMultipartResolver(context);<br>    initLocaleResolver(context);<br>    initThemeResolver(context);<br>    initHandlerMappings(context);<br>    initHandlerAdapters(context);<br>    initHandlerExceptionResolvers(context);<br>    initRequestToViewNameTranslator(context);<br>    initViewResolvers(context);<br>    initFlashMapManager(context);<br>&#125;<br></code></pre></td></tr></table></figure><p>显然，这里就是spring-mvc的核心了。</p><h3 id="文件上传支持"><a href="#文件上传支持" class="headerlink" title="文件上传支持"></a>文件上传支持</h3><p>initMultipartResolver核心源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initMultipartResolver</span><span class="hljs-params">(ApplicationContext context)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">this</span>.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver.class);<br>    &#125; <span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<br>        <span class="hljs-comment">// Default is no multipart resolver.</span><br>        <span class="hljs-built_in">this</span>.multipartResolver = <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>MultipartResolver用于开启Spring MVC文件上传功能，其类图:</p><p><img src="MultipartResolver.jpg" alt="MultipartResolver类图"></p><p>也就是说，如果我们要使用文件上传功能，须在容器中注册一个MultipartResolver bean。当然，默认是没有的。</p><h3 id="地区解析器"><a href="#地区解析器" class="headerlink" title="地区解析器"></a>地区解析器</h3><p>LocaleResolver接口定义了Spring MVC如何获取客户端(浏览器)的地区，initLocaleResolver方法在容器中寻找此bean，如果没有，注册AcceptHeaderLocaleResolver，即根据request的请求头<strong>Accept-Language</strong>获取地区。</p><p>spring-mvc采用了属性文件的方式配置默认策略(即bean)，此文件位于spring-mvc的jar包的org.springframework.web.servlet下。</p><h3 id="主题解析器"><a href="#主题解析器" class="headerlink" title="主题解析器"></a>主题解析器</h3><p>ThemeResolver接口配合Spring标签库使用可以通过动态决定使用的css以及图片的方式达到换肤的效果，其类图:</p><p><img src="ThemeResolver.jpg" alt="ThemeResolver类图"></p><p>如果容器中不存在叫做themeResolver的bean，initThemeResolver方法将向容器中注册FixedThemeResolver，此bean只能提供一套默认的主题，名为theme。</p><h3 id="HandlerMapping检查"><a href="#HandlerMapping检查" class="headerlink" title="HandlerMapping检查"></a>HandlerMapping检查</h3><p>initHandlerMappings方法用于确保容器中<strong>至少含有一个HandlerMapping对象</strong>。从前面配置解析-注解驱动一节中可以看出，注解驱动导致已经注册了两个此对象。</p><p>如果没有开启注解驱动，那么将会使用默认的HandlerMapping，相关源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.handlerMappings == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-built_in">this</span>.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);<br>    <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>        logger.debug(<span class="hljs-string">&quot;No HandlerMappings found in servlet &#x27;&quot;</span> + getServletName() + <span class="hljs-string">&quot;&#x27;: using default&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>前面提到了，默认的策略由DispatcherServlet.properties决定，<strong>目前是BeanNameUrlHandlerMapping和DefaultAnnotationHandlerMapping</strong>。</p><h3 id="HandlerAdapter检查"><a href="#HandlerAdapter检查" class="headerlink" title="HandlerAdapter检查"></a>HandlerAdapter检查</h3><p>套路和上面完全一样，默认使用HttpRequestHandlerAdapter、SimpleControllerHandlerAdapter和AnnotationMethodHandlerAdapter。</p><h3 id="HandlerExceptionResolver检查"><a href="#HandlerExceptionResolver检查" class="headerlink" title="HandlerExceptionResolver检查"></a>HandlerExceptionResolver检查</h3><p>套路和上面完全一样，默认使用AnnotationMethodHandlerExceptionResolver、ResponseStatusExceptionResolver、DefaultHandlerExceptionResolver。</p><h3 id="RequestToViewNameTranslator"><a href="#RequestToViewNameTranslator" class="headerlink" title="RequestToViewNameTranslator"></a>RequestToViewNameTranslator</h3><p>initRequestToViewNameTranslator方法回向容器中注册一个DefaultRequestToViewNameTranslator对象，此接口用以完成从HttpServletRequest到视图名的解析，其使用场景是<strong>给定的URL无法匹配任何控制器时</strong>。</p><p>DefaultRequestToViewNameTranslator的转换例子:</p><p><a href="http://localhost:8080/gamecast/display.html">http://localhost:8080/gamecast/display.html</a> -&gt; display(视图)</p><p>其类图:</p><p><img src="RequestToViewNameTranslator.jpg" alt="RequestToViewNameTranslator类图"></p><h3 id="ViewResolver检查"><a href="#ViewResolver检查" class="headerlink" title="ViewResolver检查"></a>ViewResolver检查</h3><p>熟悉的套路，默认使用InternalResourceViewResolver。</p><h3 id="FlashMapManager"><a href="#FlashMapManager" class="headerlink" title="FlashMapManager"></a>FlashMapManager</h3><p>initFlashMapManager方法会向容器注册SessionFlashMapManager对象，类图:</p><p><img src="FlashMapManager.jpg" alt="FlashMapManager类图"></p><p>此接口和FlashMap搭配使用，用于在<strong>请求重定向时保存/传递参数</strong>。</p><h2 id="HandlerMapping初始化"><a href="#HandlerMapping初始化" class="headerlink" title="HandlerMapping初始化"></a>HandlerMapping初始化</h2><p>此接口用以根据请求的URL寻找合适的处理器。从前面配置解析一节可以看出，我们的容器中有三个HandlerMapping实现，下面以RequestMappingHandlerMapping位代表进行说明。</p><h3 id="RequestMappingHandlerMapping"><a href="#RequestMappingHandlerMapping" class="headerlink" title="RequestMappingHandlerMapping"></a>RequestMappingHandlerMapping</h3><p>此实现根据@Controller和@RequestMapping注解完成解析。类图(忽略部分接口):</p><p><img src="RequestMappingHandlerMapping.jpg" alt="RequestMappingHandlerMapping类图"></p><p>初始化的入口位于AbstractHandlerMethodMapping的afterPropertiesSet方法和AbstractHandlerMapping的initApplicationContext方法，afterPropertiesSet调用了initHandlerMethods:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initHandlerMethods</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//获取容器中所有的bean</span><br>    String[] beanNames = (<span class="hljs-built_in">this</span>.detectHandlerMethodsInAncestorContexts ?<br>            BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class)             :getApplicationContext().getBeanNamesForType(Object.class));<br>    <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>        <span class="hljs-keyword">if</span> (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;<br>            Class&lt;?&gt; beanType = <span class="hljs-literal">null</span>;<br>            beanType = getApplicationContext().getType(beanName);<br>             <span class="hljs-comment">//isHandler方法的原理:</span><br>             <span class="hljs-comment">//判断类上有没有@Controller注解或者是@RequestMapping注解</span><br>            <span class="hljs-keyword">if</span> (beanType != <span class="hljs-literal">null</span> &amp;&amp; isHandler(beanType)) &#123;<br>                detectHandlerMethods(beanName);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//空实现</span><br>    handlerMethodsInitialized(getHandlerMethods());<br>&#125;<br></code></pre></td></tr></table></figure><p>detectHandlerMethods方法将反射遍历类中所有的public方法，如果方法上含有@RequestMapping注解，那么将方法上的路径与类上的基础路径(如果有)进行合并，之后将映射(匹配关系)注册到MappingRegistry中。</p><p>注意，<strong>类上的@RequestMapping注解只能作为基路径存在，也就是说，如果类里面没有任何的方法级@RequestMapping注解，那么类上的注解是没有意义的</strong>。这一点可以从实验和源码上得到证实。</p><p>下面我们关注一下映射关系是如何保存(注册)的。</p><p>内部类AbstractHandlerMethodMapping.MappingRegistry是映射的载体，类图:</p><p><img src="MappingRegistry.jpg" alt="MappingRegistry类图"></p><p>其register方法简略版源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(T mapping, Object handler, Method method)</span> &#123;<br>    <span class="hljs-comment">//包装bean和方法</span><br>    <span class="hljs-type">HandlerMethod</span> <span class="hljs-variable">handlerMethod</span> <span class="hljs-operator">=</span> createHandlerMethod(handler, method);<br>    <span class="hljs-built_in">this</span>.mappingLookup.put(mapping, handlerMethod);<br>    List&lt;String&gt; directUrls = getDirectUrls(mapping);<br>    <span class="hljs-keyword">for</span> (String url : directUrls) &#123;<br>        <span class="hljs-built_in">this</span>.urlLookup.add(url, mapping);<br>    &#125;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (getNamingStrategy() != <span class="hljs-literal">null</span>) &#123;<br>        name = getNamingStrategy().getName(handlerMethod, mapping);<br>        addMappingName(name, handlerMethod);<br>    &#125;<br>    <span class="hljs-type">CorsConfiguration</span> <span class="hljs-variable">corsConfig</span> <span class="hljs-operator">=</span> initCorsConfiguration(handler, method, mapping);<br>    <span class="hljs-keyword">if</span> (corsConfig != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-built_in">this</span>.corsLookup.put(handlerMethod, corsConfig);<br>    &#125;<br>    <span class="hljs-built_in">this</span>.registry.put(mapping, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MappingRegistration</span>&lt;T&gt;(mapping, handlerMethod, directUrls, name));<br>&#125;<br></code></pre></td></tr></table></figure><p>mapping其实是一个RequestMappingInfo对象，可以将其看做是**@RequestMapping注解各种属性的一个封装**。最终由RequestMappingInfo.createRequestMappingInfo方法创建，源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> RequestMappingInfo <span class="hljs-title function_">createRequestMappingInfo</span><span class="hljs-params">(</span><br><span class="hljs-params">        RequestMapping requestMapping, RequestCondition&lt;?&gt; customCondition)</span> &#123;<br>    <span class="hljs-keyword">return</span> RequestMappingInfo<br>            .paths(resolveEmbeddedValuesInPatterns(requestMapping.path()))<br>            .methods(requestMapping.method())<br>            .params(requestMapping.params())<br>            .headers(requestMapping.headers())<br>            .consumes(requestMapping.consumes())<br>            .produces(requestMapping.produces())<br>            .mappingName(requestMapping.name())<br>            .customCondition(customCondition)<br>            .options(<span class="hljs-built_in">this</span>.config)<br>            .build();<br>&#125;<br></code></pre></td></tr></table></figure><p>这就很明显了，具体每种属性什么意义可以参考@RequestMapping源码。</p><p>register方法中urlLookup其实就是将paths属性中的每个path都与处理器做映射。</p><p>getNamingStrategy方法得到的是一个HandlerMethodMappingNamingStrategy接口的实例，此接口用以根据HandlerMethod得到一个名字，类图:</p><p><img src="HandlerMethodMappingNamingStrategy.jpg" alt="HandlerMethodMappingNamingStrategy类图"></p><p>比如对于我们的控制器,SimpleController.echo方法，最终得到的名字将是SC#echo。</p><h4 id="跨域请求"><a href="#跨域请求" class="headerlink" title="跨域请求"></a>跨域请求</h4><p>spring-mvc自4.2开启加入了跨域请求Cors的支持，主要有两种配置方式:</p><ul><li><p>xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:cors</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:cors</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>@CrossOrigin注解。</p></li></ul><p>Cors的原理可以参考:</p><p><a href="http://www.cnblogs.com/dojo-lzz/p/4265637.html">探讨跨域请求资源的几种方式</a></p><p>而initCorsConfiguration方法的作用便是将@CrossOrigin注解的各种属性封装在CorsConfiguration中。</p><h4 id="拦截器初始化"><a href="#拦截器初始化" class="headerlink" title="拦截器初始化"></a>拦截器初始化</h4><p>AbstractHandlerMapping.initApplicationContext:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initApplicationContext</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    detectMappedInterceptors(<span class="hljs-built_in">this</span>.adaptedInterceptors);<br>&#125;<br></code></pre></td></tr></table></figure><p>作用就是从容器中获取所有MappedInterceptor bean并放到adaptedInterceptors中，前面提到过了，我们使用mvc:interceptor定义的拦截器其实就是MappedInterceptor对象。类图:</p><p><img src="MappedInterceptor.jpg" alt="MappedInterceptor类图"></p><h2 id="HandlerAdapter初始化"><a href="#HandlerAdapter初始化" class="headerlink" title="HandlerAdapter初始化"></a>HandlerAdapter初始化</h2><p>同样，我们以RequestMappingHandlerAdapter为例进行说明，类图:</p><p><img src="RequestMappingHandlerAdapter.jpg" alt="RequestMappingHandlerAdapter类图"></p><p>显然，入口在afterPropertiesSet方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// Do this first, it may add ResponseBody advice beans</span><br>    initControllerAdviceCache();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.argumentResolvers == <span class="hljs-literal">null</span>) &#123;<br>        List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers();<br>        <span class="hljs-built_in">this</span>.argumentResolvers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerMethodArgumentResolverComposite</span>()<br>            .addResolvers(resolvers);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.initBinderArgumentResolvers == <span class="hljs-literal">null</span>) &#123;<br>        List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers();<br>        <span class="hljs-built_in">this</span>.initBinderArgumentResolvers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerMethodArgumentResolverComposite</span>()<br>            .addResolvers(resolvers);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.returnValueHandlers == <span class="hljs-literal">null</span>) &#123;<br>        List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers();<br>        <span class="hljs-built_in">this</span>.returnValueHandlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HandlerMethodReturnValueHandlerComposite</span>()<br>            .addHandlers(handlers);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ControllerAdvice"><a href="#ControllerAdvice" class="headerlink" title="@ControllerAdvice"></a>@ControllerAdvice</h3><p>initControllerAdviceCache方法用以解析并存储标注了@ControllerAdvice的bean，这东西是干什么的参考：</p><p><a href="http://jinnianshilongnian.iteye.com/blog/1866350">Spring3.2新注解@ControllerAdvice</a></p><h3 id="参数解析器"><a href="#参数解析器" class="headerlink" title="参数解析器"></a>参数解析器</h3><p>HandlerMethodArgumentResolver即参数解析器，负责从request中解析、得到Controller方法所需的参数。afterPropertiesSet方法设置了一组默认的解析器。具体是哪些参考getDefaultArgumentResolvers方法。类图:</p><p><img src="HandlerMethodArgumentResolver.jpg" alt="HandlerMethodArgumentResolver类图"></p><h3 id="InitBinder支持"><a href="#InitBinder支持" class="headerlink" title="@InitBinder支持"></a>@InitBinder支持</h3><p>此注解定义的其实是自定义类型转换器。使用方法参考:</p><p><a href="http://blog.csdn.net/songzaiblog/article/details/49757253">springMVC @initBinder 使用</a></p><p>getDefaultInitBinderArgumentResolvers返回了一组默认使用的转换器，不过其实这里的转换器和上面的参数解析器其实是一个类型的，这里留个坑。</p><h3 id="返回结果解析器"><a href="#返回结果解析器" class="headerlink" title="返回结果解析器"></a>返回结果解析器</h3><p>HandlerMethodReturnValueHandler接口用以处理方法调用(Controller方法)的返回值，类图:</p><p><img src="HandlerMethodReturnValueHandler.jpg" alt="HandlerMethodReturnValueHandler类图"></p><p>getDefaultReturnValueHandlers方法便返回了一坨这东西。</p><h1 id="请求响应"><a href="#请求响应" class="headerlink" title="请求响应"></a>请求响应</h1><p>我们先来看一下入口在哪。众所周知，Servlet标准定义了所有请求先由service方法处理，如果是get或post方法，那么再交由doGet或是doPost方法处理。</p><p>FrameworkServlet覆盖了service方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">service</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;<br>    <span class="hljs-type">HttpMethod</span> <span class="hljs-variable">httpMethod</span> <span class="hljs-operator">=</span> HttpMethod.resolve(request.getMethod());<br>    <span class="hljs-keyword">if</span> (HttpMethod.PATCH == httpMethod || httpMethod == <span class="hljs-literal">null</span>) &#123;<br>        processRequest(request, response);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">super</span>.service(request, response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Spring要覆盖此方法的目的在于拦截PATCH请求，PATCH请求与PUT类似，不同在于PATCH是局部更新，而后者是全部更新。可以参考:</p><p><a href="https://segmentfault.com/q/1010000005685904">PATCH和PUT方法的区别？</a></p><p>FrameworkServlet同样也覆盖了doGet和doPost方法，两者只是调用processRequest方法。</p><h2 id="请求上下文"><a href="#请求上下文" class="headerlink" title="请求上下文"></a>请求上下文</h2><p>Spring MVC会在请求分发之前进行上下文的准备工作，含两部分:</p><ol><li>将地区(Locale)和请求属性以ThreadLocal的方法与当前线程进行关联，分别可以通过LocaleContextHolder和RequestContextHolder进行获取。</li><li>将WebApplicationContext、FlashMap等组件放入到Request属性中。</li></ol><h2 id="请求分发"><a href="#请求分发" class="headerlink" title="请求分发"></a>请求分发</h2><p>DispatcherServlet.doDispatch简略版源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doDispatch</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> &#123;<br>    <span class="hljs-type">HandlerExecutionChain</span> <span class="hljs-variable">mappedHandler</span> <span class="hljs-operator">=</span> getHandler(processedRequest);<br>    <span class="hljs-type">HandlerAdapter</span> <span class="hljs-variable">ha</span> <span class="hljs-operator">=</span> getHandlerAdapter(mappedHandler.getHandler());<br>    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());<br>    applyDefaultViewName(processedRequest, mv);<br>    mappedHandler.applyPostHandle(processedRequest, response, mv);<br>    processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="处理器查找"><a href="#处理器查找" class="headerlink" title="处理器查找"></a>处理器查找</h3><p>即为请求寻找合适的Controller的过程。DispatcherServlet.getHandler:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> HandlerExecutionChain <span class="hljs-title function_">getHandler</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>    <span class="hljs-keyword">for</span> (HandlerMapping hm : <span class="hljs-built_in">this</span>.handlerMappings) &#123;<br>        <span class="hljs-type">HandlerExecutionChain</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> hm.getHandler(request);<br>        <span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> handler;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从这里可以看出，寻找处理器实际上委托给HandlerMapping实现，寻找的过程便是遍历所有的HandlerMapping进行查找，<strong>一旦找到，那么不再继续进行遍历</strong>。也就是说HandlerMapping之间有优先级的概念，而根据AnnotationDrivenBeanDefinitionParser的注释，RequestMappingHandlerMapping其实有最高的优先级。</p><p>AbstractHandlerMapping.getHandler:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> HandlerExecutionChain <span class="hljs-title function_">getHandler</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> getHandlerInternal(request);<br>    <span class="hljs-type">HandlerExecutionChain</span> <span class="hljs-variable">executionChain</span> <span class="hljs-operator">=</span> getHandlerExecutionChain(handler, request);<br>    <span class="hljs-comment">//判断请求头中是否有ORIGIN字段</span><br>    <span class="hljs-keyword">if</span> (CorsUtils.isCorsRequest(request)) &#123;<br>        <span class="hljs-type">CorsConfiguration</span> <span class="hljs-variable">globalConfig</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.corsConfigSource.getCorsConfiguration(request);<br>        <span class="hljs-type">CorsConfiguration</span> <span class="hljs-variable">handlerConfig</span> <span class="hljs-operator">=</span> getCorsConfiguration(handler, request);<br>        <span class="hljs-type">CorsConfiguration</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> (globalConfig != <span class="hljs-literal">null</span> ? <br>            globalConfig.combine(handlerConfig) : handlerConfig);<br>        executionChain = getCorsHandlerExecutionChain(request, executionChain, config);<br>    &#125;<br>    <span class="hljs-keyword">return</span> executionChain;<br>&#125;<br></code></pre></td></tr></table></figure><p>getHandlerInternal方法便是根据url进行查找的过程，可以参见MVC初始化-HandlerMapping初始化一节。下面重点是执行链的生成。</p><p>getHandlerExecutionChain方法的原理就是从adaptedInterceptors中获得所有可以适配当前请求URL的MappedInterceptor并将其添加到HandlerExecutionChain的拦截器列表中。拦截器的顺序其实就是我们定义/注册的顺序。</p><p>从getCorsHandlerExecutionChain的源码中可以看出，对于跨域请求其实是向调用链插入了一个CorsInterceptor。</p><h3 id="适配器查找"><a href="#适配器查找" class="headerlink" title="适配器查找"></a>适配器查找</h3><p>DispatcherServlet.getHandlerAdapter:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> HandlerAdapter <span class="hljs-title function_">getHandlerAdapter</span><span class="hljs-params">(Object handler)</span> &#123;<br>    <span class="hljs-keyword">for</span> (HandlerAdapter ha : <span class="hljs-built_in">this</span>.handlerAdapters) &#123;<br>        <span class="hljs-keyword">if</span> (ha.supports(handler)) &#123;<br>            <span class="hljs-keyword">return</span> ha;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从前面配置解析-注解驱动可以看出，第一个适配器是RequestMappingHandlerAdapter，而其support方法直接返回true，这就导致了使用的适配器总是这一个。</p><h2 id="请求处理"><a href="#请求处理" class="headerlink" title="请求处理"></a>请求处理</h2><p>RequestMappingHandlerAdapter.handleInternal:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title function_">handleInternal</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">        HttpServletResponse response, HandlerMethod handlerMethod)</span>&#123;<br>    ModelAndView mav;<br>    <span class="hljs-comment">// Execute invokeHandlerMethod in synchronized block if required.</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.synchronizeOnSession) &#123;<br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">mutex</span> <span class="hljs-operator">=</span> WebUtils.getSessionMutex(session);<br>            <span class="hljs-keyword">synchronized</span> (mutex) &#123;<br>                mav = invokeHandlerMethod(request, response, handlerMethod);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// No HttpSession available -&gt; no mutex necessary</span><br>            mav = invokeHandlerMethod(request, response, handlerMethod);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// No synchronization on session demanded at all...</span><br>        mav = invokeHandlerMethod(request, response, handlerMethod);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123;<br>        <span class="hljs-keyword">if</span> (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123;<br>            applyCacheSeconds(response, <span class="hljs-built_in">this</span>.cacheSecondsForSessionAttributeHandlers);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            prepareResponse(response);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mav;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Session同步"><a href="#Session同步" class="headerlink" title="Session同步"></a>Session同步</h3><p>可以看出，如果开启了synchronizeOnSession，那么<strong>同一个session的请求将会串行执行</strong>，这一选项默认是关闭的，当然我们可以通过注入的方式进行改变。</p><h3 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h3><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>正如前面HandlerAdapter初始化-参数解析器一节提到的，HandlerAdapter内部含有一组解析器负责对各类型的参数进行解析。下面我们就常用的自定义参数和Model为例进行说明。</p><h4 id="自定义参数"><a href="#自定义参数" class="headerlink" title="自定义参数"></a>自定义参数</h4><p>解析由RequestParamMethodArgumentResolver完成。</p><p>supportsParameter方法决定了一个解析器可以解析的参数类型，该解析器支持@RequestParam标准的参数或是<strong>简单类型</strong>的参数，具体参见其注释。为什么此解析器可以同时解析@RequestParam注解和普通参数呢?玄机在于RequestMappingHandlerAdapter方法在初始化参数解析器时其实初始化了<strong>两个RequestMappingHandlerAdapter对象</strong>，getDefaultArgumentResolvers方法相关源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;HandlerMethodArgumentResolver&gt; <span class="hljs-title function_">getDefaultArgumentResolvers</span><span class="hljs-params">()</span> &#123;<br>    resolvers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestPartMethodArgumentResolver</span>(getMessageConverters(), <span class="hljs-built_in">this</span>.requestResponseBodyAdvice));<br>    <span class="hljs-comment">// Catch-all</span><br>    resolvers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestParamMethodArgumentResolver</span>(getBeanFactory(), <span class="hljs-literal">true</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>useDefaultResolution参数用于启动对常规类型参数的解析，这里的常规类型指的又是什么呢?</p><p>实际上由BeanUtils.isSimpleProperty方法决定:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSimpleProperty</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> &#123;<br>    Assert.notNull(clazz, <span class="hljs-string">&quot;Class must not be null&quot;</span>);<br>    <span class="hljs-keyword">return</span> isSimpleValueType(clazz) || (clazz.isArray() &amp;&amp; isSimpleValueType(clazz.getComponentType()));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSimpleValueType</span><span class="hljs-params">(Class&lt;?&gt; clazz)</span> &#123;<br>    <span class="hljs-keyword">return</span> (ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() ||<br>            CharSequence.class.isAssignableFrom(clazz) ||<br>            Number.class.isAssignableFrom(clazz) ||<br>            Date.class.isAssignableFrom(clazz) ||<br>            URI.class == clazz || URL.class == clazz ||<br>            Locale.class == clazz || Class.class == clazz);<br>&#125;<br></code></pre></td></tr></table></figure><p>忽略复杂的调用关系，最核心的实现位于resolveName方法，部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">resolveName</span><span class="hljs-params">(String name, MethodParameter parameter, NativeWebRequest request)</span> &#123;<br>    <span class="hljs-keyword">if</span> (arg == <span class="hljs-literal">null</span>) &#123;<br>        String[] paramValues = request.getParameterValues(name);<br>        <span class="hljs-keyword">if</span> (paramValues != <span class="hljs-literal">null</span>) &#123;<br>            arg = (paramValues.length == <span class="hljs-number">1</span> ? paramValues[<span class="hljs-number">0</span>] : paramValues);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arg;<br>&#125;<br></code></pre></td></tr></table></figure><p>name就是方法的参数名，可以看出，参数解析<strong>就是根据参数名去request查找对应属性的过程</strong>，在这里参数类型并没有起什么作用。</p><h6 id="参数名是从哪里来的"><a href="#参数名是从哪里来的" class="headerlink" title="参数名是从哪里来的"></a>参数名是从哪里来的</h6><p>方法名获取的入口位于RequestParamMethodArgumentResolver的resolveArgument方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title function_">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span><br><span class="hljs-params">    NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">NamedValueInfo</span> <span class="hljs-variable">namedValueInfo</span> <span class="hljs-operator">=</span> getNamedValueInfo(parameter);<br>&#125;<br></code></pre></td></tr></table></figure><p>getNamedValueInfo方法最终完成对MethodParameter的getParameterName方法的调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getParameterName</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ParameterNameDiscoverer</span> <span class="hljs-variable">discoverer</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.parameterNameDiscoverer;<br>    <span class="hljs-keyword">if</span> (discoverer != <span class="hljs-literal">null</span>) &#123;<br>        String[] parameterNames = (<span class="hljs-built_in">this</span>.method != <span class="hljs-literal">null</span> ?<br>                discoverer.getParameterNames(<span class="hljs-built_in">this</span>.method) : discoverer.getParameterNames(<span class="hljs-built_in">this</span>.constructor));<br>        <span class="hljs-keyword">if</span> (parameterNames != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.parameterName = parameterNames[<span class="hljs-built_in">this</span>.parameterIndex];<br>        &#125;<br>        <span class="hljs-built_in">this</span>.parameterNameDiscoverer = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.parameterName;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然，参数名的获取由接口ParameterNameDiscoverer完成:</p><p><img src="ParameterNameDiscoverer.jpg" alt="ParameterNameDiscoverer"></p><p>默认采用DefaultParameterNameDiscoverer，但此类其实相当于StandardReflectionParameterNameDiscoverer和LocalVariableTableParameterNameDiscoverer的组合，且前者先于后者进行解析。</p><p>StandardReflectionParameterNameDiscoverer.getParameterNames:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String[] getParameterNames(Method method) &#123;<br>    Parameter[] parameters = method.getParameters();<br>    String[] parameterNames = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[parameters.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; parameters.length; i++) &#123;<br>        <span class="hljs-type">Parameter</span> <span class="hljs-variable">param</span> <span class="hljs-operator">=</span> parameters[i];<br>        <span class="hljs-keyword">if</span> (!param.isNamePresent()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        parameterNames[i] = param.getName();<br>    &#125;<br>    <span class="hljs-keyword">return</span> parameterNames;<br>&#125;<br></code></pre></td></tr></table></figure><p>此类被注解UsesJava8标注，其原理就是利用的jdk8的-parameters编译参数，只有在加上此选项的情况下才能用反射的方法获得真实的参数名，所以一般情况下StandardReflectionParameterNameDiscoverer是无法成功获取参数名的。</p><p>LocalVariableTableParameterNameDiscoverer利用了ASM直接访问class文件中的本地变量表来得到变量名，下面是使用<code>javap -verbose</code>命令得到的本地变量表示例:</p><p><img src="local_variable_tables.PNG" alt="本地变量表"></p><p>但是默认情况下javac compiler是不生成本地变量表这种调试信息的，需要加<code>-g</code>参数才可以，那为什么在我们的测试Controller中却可以获得呢，玄机就在于idea的下列设置:</p><p><img src="idea_debug_info.PNG" alt="idea编译设置"></p><p>取消这项设置的勾选再次运行程序便出问题了:</p><p><img src="debug_info_error.PNG" alt="调试信息错误"></p><h4 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h4><p>解析由ModelMethodProcessor完成。</p><p>supportsParameter方法很简单:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> &#123;<br>    <span class="hljs-keyword">return</span> Model.class.isAssignableFrom(parameter.getParameterType());<br>&#125;<br></code></pre></td></tr></table></figure><p>很直白了。</p><p>resolveArgument：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">resolveArgument</span><span class="hljs-params">(MethodParameter parameter, ModelAndViewContainer mavContainer,</span><br><span class="hljs-params">    NativeWebRequest webRequest, WebDataBinderFactory binderFactory)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">return</span> mavContainer.getModel();<br>&#125;<br></code></pre></td></tr></table></figure><p>忽略各种调用关系，<strong>Model其实是一个BindingAwareModelMap对象，且每次请求(需要注入Model的前提下)都有一个新的该对象生成</strong>。类图:</p><p><img src="BindingAwareModelMap.jpg" alt="BindingAwareModelMap类图"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>我们可以通过实现HandlerMethodArgumentResolver接口并将其注册容器的方式实现自定义参数类型的解析。</li><li>为了防止出现参数名获取不到的问题，应优先使用@RequestParam注解直接声明需要的参数名称。</li></ul><h3 id="返回值解析"><a href="#返回值解析" class="headerlink" title="返回值解析"></a>返回值解析</h3><p>套路和上面是一样的，通常情况，我们返回的其实是view名，负责处理的是ViewNameMethodReturnValueHandler，</p><p>supportsReturnType方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">supportsReturnType</span><span class="hljs-params">(MethodParameter returnType)</span> &#123;<br>    Class&lt;?&gt; paramType = returnType.getParameterType();<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">void</span>.class == paramType || CharSequence.class.isAssignableFrom(paramType));<br>&#125;<br></code></pre></td></tr></table></figure><p>handleReturnValue:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleReturnValue</span><span class="hljs-params">(Object returnValue, MethodParameter returnType,</span><br><span class="hljs-params">        ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> &#123;<br>    <span class="hljs-keyword">if</span> (returnValue <span class="hljs-keyword">instanceof</span> CharSequence) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">viewName</span> <span class="hljs-operator">=</span> returnValue.toString();<br>        mavContainer.setViewName(viewName);<br>         <span class="hljs-comment">// 判断的依据: 是否以redirect:开头</span><br>        <span class="hljs-keyword">if</span> (isRedirectViewName(viewName)) &#123;<br>            mavContainer.setRedirectModelScenario(<span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见这里并没有进行实际的处理，只是解析得到了最终的视图名称。</p><h3 id="视图渲染"><a href="#视图渲染" class="headerlink" title="视图渲染"></a>视图渲染</h3><p>由DispatcherServlet的processDispatchResult方法完成，源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processDispatchResult</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response,</span><br><span class="hljs-params">        HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">errorView</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (exception != <span class="hljs-literal">null</span>) &#123;<br>         <span class="hljs-comment">//一般不会到这个分支</span><br>        <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> ModelAndViewDefiningException) &#123;<br>            mv = ((ModelAndViewDefiningException) exception).getModelAndView();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> (mappedHandler != <span class="hljs-literal">null</span> ? mappedHandler.getHandler() : <span class="hljs-literal">null</span>);<br>            mv = processHandlerException(request, response, handler, exception);<br>            errorView = (mv != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// Did the handler return a view to render?</span><br>    <span class="hljs-keyword">if</span> (mv != <span class="hljs-literal">null</span> &amp;&amp; !mv.wasCleared()) &#123;<br>        render(mv, request, response);<br>        <span class="hljs-keyword">if</span> (errorView) &#123;<br>            WebUtils.clearErrorRequestAttributes(request);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，处理<strong>根据是否抛出异常分为了两种情况</strong>。</p><p>如果抛出了异常，那么processHandlerException方法将会遍历所有的HandlerExceptionResolver实例，默认有哪些参考MVC初始化-HandlerExceptionResolver检查一节。默认的处理器用于改变响应状态码、调用标注了@ExceptionHandler的bean进行处理，如果没有@ExceptionHandler的bean或是不能处理此类异常，那么就会导致ModelAndView始终为null，最终Spring MVC将异常向上抛给Tomcat，然后Tomcat就会把堆栈打印出来。</p><p>如果我们想将其定向到指定的错误页面，可以这样配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultErrorView&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;error&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此处理器会返回一个非空的ModelAndView。</p><h4 id="ModelAndView"><a href="#ModelAndView" class="headerlink" title="ModelAndView"></a>ModelAndView</h4><p>回过头来看一下这到底是个什么东西。类图:</p><p><img src="ModelAndView.jpg" alt="ModelAndView类图"></p><p>很直白。</p><p>怎么生成的。RequestMappingHandlerAdapter.getModelAndView相关源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ModelMap</span> <span class="hljs-variable">model</span> <span class="hljs-operator">=</span> mavContainer.getModel();<br><span class="hljs-type">ModelAndView</span> <span class="hljs-variable">mav</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ModelAndView</span>(mavContainer.getViewName(), model, mavContainer.getStatus());<br></code></pre></td></tr></table></figure><h4 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h4><p>DispatcherServlet.render简略版源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">render</span><span class="hljs-params">(ModelAndView mv, HttpServletRequest request, HttpServletResponse response)</span> &#123;<br>    <span class="hljs-type">Locale</span> <span class="hljs-variable">locale</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.localeResolver.resolveLocale(request);<br>    response.setLocale(locale);<br>    View view;<br>    <span class="hljs-comment">//判断依据: 是否是String类型</span><br>    <span class="hljs-keyword">if</span> (mv.isReference()) &#123;<br>        <span class="hljs-comment">// We need to resolve the view name.</span><br>        view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// No need to lookup: the ModelAndView object contains the actual View object.</span><br>        view = mv.getView();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (mv.getStatus() != <span class="hljs-literal">null</span>) &#123;<br>        response.setStatus(mv.getStatus().value());<br>    &#125;<br>    view.render(mv.getModelInternal(), request, response);<br>&#125;<br></code></pre></td></tr></table></figure><p>resolveViewName方法将会遍历所有的ViewResolver bean，只要有一个解析的结果(View)不为空，即停止遍历。根据MVC初始化-ViewResolver检查一节和我们的配置文件可知，容器中有两个ViewResolver ，分别是: InternalResourceViewResolver和UrlBasedViewResolver。</p><h5 id="ViewResolver"><a href="#ViewResolver" class="headerlink" title="ViewResolver"></a>ViewResolver</h5><p>类图(忽略实现类):</p><p><img src="ViewResolver.jpg" alt="ViewResolver类图"></p><p>resolveViewName方法的源码不再贴出，其实只做了一件事: 用反射创建并初始化我们指定的View，根据我们的配置，就是JstlView。</p><h5 id="View"><a href="#View" class="headerlink" title="View"></a>View</h5><p>类图:</p><p><img src="JstlView.jpg" alt="JstlView类图"></p><p>渲染的核心逻辑位于InternalResourceView.renderMergedOutputModel，简略版源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">renderMergedOutputModel</span><span class="hljs-params">(</span><br><span class="hljs-params">        Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response)</span> &#123;<br>    <span class="hljs-comment">// 将Model中的属性设置的request中</span><br>    exposeModelAsRequestAttributes(model, request);<br>    <span class="hljs-comment">// 获取资源(jsp)路径</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">dispatcherPath</span> <span class="hljs-operator">=</span> prepareForRendering(request, response);<br>    <span class="hljs-comment">// Obtain a RequestDispatcher for the target resource (typically a JSP).</span><br>    <span class="hljs-type">RequestDispatcher</span> <span class="hljs-variable">rd</span> <span class="hljs-operator">=</span> getRequestDispatcher(request, dispatcherPath);<br>    <span class="hljs-comment">// If already included or response already committed, perform include, else forward.</span><br>    <span class="hljs-keyword">if</span> (useInclude(request, response)) &#123;<br>        response.setContentType(getContentType());<br>        rd.include(request, response);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Note: The forwarded resource is supposed to determine the content type itself.</span><br>        rd.forward(request, response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，对jsp来说，所谓的渲染其实就是<strong>将Model中的属性设置到Request，再利用原生Servlet RequestDispatcher API进行转发的过程</strong>。</p><h1 id="拾遗"><a href="#拾遗" class="headerlink" title="拾遗"></a>拾遗</h1><h2 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h2><p>通常我们可以在Controller或方法上标注@ResponseBody注解以表示需要将对象转为JSON并返回给前端，那么Spring MVC是如何自动完成这一过程的呢?</p><p>从前面初始化-容器初始化-容器创建-配置解析一节可以看出，Spring MVC采用org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser进行配置的解析，核心的parse方法中完成了对HttpMessageConverter的初始化。</p><h3 id="HttpMessageConverter"><a href="#HttpMessageConverter" class="headerlink" title="HttpMessageConverter"></a>HttpMessageConverter</h3><p>Spring的HttpMessageConverter接口负责HTTP请求-Java对象与Java对象-响应之间的转换。我们以Spring默认使用的Jackson转换器为例，类图:</p><p><img src="HttpMessageConverter.jpg" alt="HttpMessageConverter"></p><p>HttpMessageConverter实现的初始化由AnnotationDrivenBeanDefinitionParser的getMessageConverters方法完成，HttpMessageConverter的来源分为自定义和默认。</p><p>示例配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mvc:message-converters</span> <span class="hljs-attr">register-defaults</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;test.Converter&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:message-converters</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:annotation-driven</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><p>Spring允许我们通过XML配置文件的message-converters元素来进行自定义。</p><h4 id="默认"><a href="#默认" class="headerlink" title="默认"></a>默认</h4><p>当<strong>检测到没有配置message-converters元素或者register-defaults=”true”时Spring便会注册默认转换器</strong>。这其中便包括MappingJacksonHttpMessageConverter，相关源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (jacksonPresent) &#123;<br>    messageConverters.add(createConverterDefinition(<br>        org.springframework.http.converter.json.MappingJacksonHttpMessageConverter.class, source));<br>&#125;<br></code></pre></td></tr></table></figure><p>jacksonPresent声明:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">jacksonPresent</span> <span class="hljs-operator">=</span><br>    ClassUtils.isPresent(<span class="hljs-string">&quot;org.codehaus.jackson.map.ObjectMapper&quot;</span>, AnnotationDrivenBeanDefinitionParser.class.getClassLoader()) &amp;&amp;<br>    ClassUtils.isPresent(<span class="hljs-string">&quot;org.codehaus.jackson.JsonGenerator&quot;</span>, AnnotationDrivenBeanDefinitionParser.class.getClassLoader());<br></code></pre></td></tr></table></figure><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><p>入口位于ServletInvocableHandlerMethod的invokeAndHandle方法对于响应的处理:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-built_in">this</span>.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest);<br></code></pre></td></tr></table></figure><p>returnValueHandlers其实就是RequestMappingHandlerAdapter内部的returnValueHandlers，后者由RequestMappingHandlerAdapter的afterPropertiesSet方法初始化，关键在于:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">handlers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestResponseBodyMethodProcessor</span>(getMessageConverters(), <span class="hljs-built_in">this</span>.contentNegotiationManager));<br></code></pre></td></tr></table></figure><p>对象到JSON的转换正是由RequestResponseBodyMethodProcessor完成，ServletInvocableHandlerMethod通过supportsReturnType方法决定HandlerMethodReturnValueHandler是否可以处理当前返回类型或返回方法，RequestResponseBodyMethodProcessor的实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">supportsReturnType</span><span class="hljs-params">(MethodParameter returnType)</span> &#123;<br>    <span class="hljs-keyword">return</span> ((AnnotationUtils.findAnnotation(returnType.getContainingClass(), ResponseBody.class) != <span class="hljs-literal">null</span>) ||<br>        (returnType.getMethodAnnotation(ResponseBody.class) != <span class="hljs-literal">null</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>核心的handleReturnValue方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleReturnValue</span><span class="hljs-params">(Object returnValue, MethodParameter returnType,</span><br><span class="hljs-params">    ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> &#123;<br>    mavContainer.setRequestHandled(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">if</span> (returnValue != <span class="hljs-literal">null</span>) &#123;<br>        writeWithMessageConverters(returnValue, returnType, webRequest);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里其实是通过HttpMessageConverter的canRead或canWrite方法来判断给定的转换器是否合适，canWrite方法实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canWrite</span><span class="hljs-params">(Class&lt;?&gt; clazz, MediaType mediaType)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.objectMapper.canSerialize(clazz) &amp;&amp; canWrite(mediaType));<br>&#125;<br></code></pre></td></tr></table></figure><p>这里剩下的便是Jackson的事情了，注意MappingJacksonHttpMessageConverter中的objectMapper被所有的线程所共享，因为其是线程安全的，但是这样是否有性能问题?</p><h2 id="参数解析-amp-结果转换"><a href="#参数解析-amp-结果转换" class="headerlink" title="参数解析 &amp; 结果转换"></a>参数解析 &amp; 结果转换</h2><p>Spring MVC中参数到各种类型的转换由HandlerMethodArgumentResolver接口完成，而Controller返回值到真正的响应的转换由HandlerMethodReturnValueHandler接口完成。两者分别负责Spring MVC中数据的输入与输出，可用下图表示:</p><p><img src="mvc_input_output.PNG" alt="Spring MVC输入输出转换"></p><p>HandlerMethodArgumentResolver接口及其主要实现类如下图:</p><p><img src="HandlerMethodArgumentResolver_all.jpg" alt="HandlerMethodArgumentResolver"></p><p>HandlerMethodReturnValueHandler接口以及主要实现类如下:</p><p><img src="HandlerMethodReturnValueHandler_all.jpg" alt="HandlerMethodReturnValueHandler"></p><p>其实有很多类同时实现了两个接口，比如RequestResponseBodyMethodProcessor，这样的类一般以Processor结尾。</p><p>两种转换器的初始化由HandlerAdapter完成，这也很好的体现了HandlerAdapter接口的功能。以喜闻乐见的RequestMappingHandlerAdapter为例，其初始化的HandlerMethodReturnValueHandler列表如下:</p><ul><li>ModelAndViewMethodReturnValueHandler</li><li>ModelMethodProcessor</li><li>HttpEntityMethodProcessor</li><li>HttpHeadersReturnValueHandler</li><li>CallableMethodReturnValueHandler</li><li>DeferredResultMethodReturnValueHandler</li><li>AsyncTaskMethodReturnValueHandler</li><li>ListenableFutureReturnValueHandler</li><li>ModelAttributeMethodProcessor</li><li>RequestResponseBodyMethodProcessor</li><li>ViewNameMethodReturnValueHandler</li><li>MapMethodProcessor</li><li>ModelAndViewResolverMethodReturnValueHandler</li></ul><p>从中也可以推测出我们可以把哪些类型的值(对象)直接”丢给”Spring。</p><p>对于HandlerMethodArgumentResolver和HandlerMethodReturnValueHandler来说，HttpMessageConverter像是两者手中用来实现功能的武器。</p><h2 id="“纯”对象参数接收"><a href="#“纯”对象参数接收" class="headerlink" title="“纯”对象参数接收"></a>“纯”对象参数接收</h2><p>假设有如下这样的Controller:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/echoAgain&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">echo</span><span class="hljs-params">(SimpleModel simpleModel, Model model)</span> &#123;<br>    model.addAttribute(<span class="hljs-string">&quot;echo&quot;</span>, <span class="hljs-string">&quot;hello &quot;</span> + simpleModel.getName() + <span class="hljs-string">&quot;, your age is &quot;</span> + simpleModel.getAge() + <span class="hljs-string">&quot;.&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;echo&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过测试可以发现，SimpleModel参数既可以接收get请求，也可以接收post请求。那么在这种情况下请求参数是被哪个参数解析器解析的呢，debug发现: ServletModelAttributeMethodProcessor：</p><p><img src="ServletModelAttributeMethodProcessor.jpg" alt="ServletModelAttributeMethodProcessor"></p><p>核心的supportsParameter方法由父类ModelAttributeMethodProcessor实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">supportsParameter</span><span class="hljs-params">(MethodParameter parameter)</span> &#123;<br>    <span class="hljs-keyword">return</span> (parameter.hasParameterAnnotation(ModelAttribute.class) ||<br>        (<span class="hljs-built_in">this</span>.annotationNotRequired &amp;&amp; !BeanUtils.isSimpleProperty(parameter.getParameterType())));<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，这里支持带有ModelAttribute注解或者是非基本类型的参数解析，同时annotationNotRequired必须设为false，即ModelAttribute注解不必存在，这里是在ServletModelAttributeMethodProcessor的构造器中进行控制的，<br>RequestMappingHandlerAdapter.getDefaultArgumentResolvers部分源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">resolvers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletModelAttributeMethodProcessor</span>(<span class="hljs-literal">false</span>));<br></code></pre></td></tr></table></figure><p>此类的作用是对@ModelAttribute注解标注的参数进行解析，假设我们将Controller方法改写成:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/echoAgain&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">echo</span><span class="hljs-params">(<span class="hljs-meta">@ModelAttribute</span> SimpleModel simpleModel, Model model)</span> &#123;<br>    model.addAttribute(<span class="hljs-string">&quot;echo&quot;</span>, <span class="hljs-string">&quot;hello &quot;</span> + simpleModel.getName() + <span class="hljs-string">&quot;, your age is &quot;</span> + simpleModel.getAge() + <span class="hljs-string">&quot;.&quot;</span>);<br>    System.out.println(model.asMap().get(<span class="hljs-string">&quot;simpleModel&quot;</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;echo&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，Spring会首先反射生成一个SimpleModel对象，之后将从request中获取的参数尝试设置到SimpleModel对象中去，最后将此对象放置到Model中(本质上就是一个Map)，key就是simpleModel.下面我们来看一下具体的解析过程，整个过程可以分为<br>以下三部分:</p><h3 id="参数对象构造"><a href="#参数对象构造" class="headerlink" title="参数对象构造"></a>参数对象构造</h3><p>因为SimpleModel是一个对象类型，所以要想将参数注入到其中，第一步必然是先创建一个对象，创建的入口位于ModelAttributeMethodProcessor的resolveArgument方法，相关源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//name在这里便是simpleModel</span><br><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> ModelFactory.getNameForParameter(parameter);<br><span class="hljs-type">Object</span> <span class="hljs-variable">attribute</span> <span class="hljs-operator">=</span> (mavContainer.containsAttribute(name) ? mavContainer.getModel().get(name) :<br>                    createAttribute(name, parameter, binderFactory, webRequest));<span class="hljs-comment">//反射实例化</span><br></code></pre></td></tr></table></figure><p>ModelAndViewContainer是个什么东西呢，从名字就可以看出就，它是Spring MVC里两个重要概念Model和View的组合体，用来记录在请求响应过程中Model和View的变化，在这里可以简单理解为去Model中检查有没有叫simpleModel的属性已经存在。</p><h3 id="参数绑定"><a href="#参数绑定" class="headerlink" title="参数绑定"></a>参数绑定</h3><p>这里使用到了DataBinder接口，按照注释的说明，此接口用以<strong>向执行的对象中设置属性值</strong>，就是这么简单，其继承体系如下图:</p><p><img src="DataBinder.jpg" alt="DataBinder"></p><p>WebDataBinderFactory接口用以创建WebDataBinder对象，其继承体系如下图:</p><p><img src="WebDataBinderFactory.jpg" alt="WebDataBinderFactory"></p><p>默认使用的是ServletRequestDataBinderFactory，创建了一个ExtendedServletRequestDataBinder对象:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> ServletRequestDataBinder <span class="hljs-title function_">createBinderInstance</span><span class="hljs-params">(Object target, String objectName, NativeWebRequest request)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExtendedServletRequestDataBinder</span>(target, objectName);<br>&#125;<br></code></pre></td></tr></table></figure><p>参数绑定的入口位于ModelAttributeMethodProcessor.resolveArgument方法，相关源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!mavContainer.isBindingDisabled(name)) &#123;<br>    bindRequestParameters(binder, webRequest);<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来由ServletRequestDataBinder的bind方法完成，核心源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(ServletRequest request)</span> &#123;<br>    <span class="hljs-type">MutablePropertyValues</span> <span class="hljs-variable">mpvs</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletRequestParameterPropertyValues</span>(request);<br>    doBind(mpvs);<br>&#125;<br></code></pre></td></tr></table></figure><p>在ServletRequestParameterPropertyValues构造器中获取了Request中所有的属性对。doBind方法便是调用前面初始化的目标对象的setter方法进行参数设置的过程，不再展开。</p><h3 id="参数校验"><a href="#参数校验" class="headerlink" title="参数校验"></a>参数校验</h3><p>将我们的Controller方法改写为下面这种形式便可以启动Spring MVC的参数校验:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/echoAgain&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">echo</span><span class="hljs-params">(<span class="hljs-meta">@Validated</span> SimpleModel simpleModel, Model model)</span> &#123;<br>    model.addAttribute(<span class="hljs-string">&quot;echo&quot;</span>, <span class="hljs-string">&quot;hello &quot;</span> + simpleModel.getName() + <span class="hljs-string">&quot;, your age is &quot;</span> + simpleModel.getAge() + <span class="hljs-string">&quot;.&quot;</span>);<br>    System.out.println(model.asMap().get(<span class="hljs-string">&quot;simpleModel&quot;</span>));<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;echo&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里@Validated注解可以用@Valid(javax)替换，前者是Spring对java校验标准的扩充，增加了校验组的支持。<br>为什么参数校验要放到参数绑定后面进行说明呢，因为**@Validated和@valid注解不会影响Spring MVC参数解析的行为，被这两个注解标注的对象仍是由参数绑定一节提到的解析器进行解析。**</p><p>当参数校验绑定之后，Spring MVC会尝试对参数进行校验，如果我们设置了校验注解。ModelAttributeMethodProcessor.resolveArgument方法相关源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">validateIfApplicable(binder, parameter);<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validateIfApplicable</span><span class="hljs-params">(WebDataBinder binder, MethodParameter methodParam)</span> &#123;<br>    Annotation[] annotations = methodParam.getParameterAnnotations();<br>    <span class="hljs-keyword">for</span> (Annotation ann : annotations) &#123;<br>        <span class="hljs-type">Validated</span> <span class="hljs-variable">validatedAnn</span> <span class="hljs-operator">=</span> AnnotationUtils.getAnnotation(ann, Validated.class);<br>        <span class="hljs-keyword">if</span> (validatedAnn != <span class="hljs-literal">null</span> || ann.annotationType().getSimpleName().startsWith(<span class="hljs-string">&quot;Valid&quot;</span>)) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">hints</span> <span class="hljs-operator">=</span> (validatedAnn != <span class="hljs-literal">null</span> ? validatedAnn.value() : AnnotationUtils.getValue(ann));<br>            Object[] validationHints = (hints <span class="hljs-keyword">instanceof</span> Object[] ? (Object[]) hints : <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[] &#123;hints&#125;);<br>            binder.validate(validationHints);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>DataBinder.validate:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">validate</span><span class="hljs-params">(Object... validationHints)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Validator validator : getValidators()) &#123;<br>        <span class="hljs-keyword">if</span> (!ObjectUtils.isEmpty(validationHints) &amp;&amp; validator <span class="hljs-keyword">instanceof</span> SmartValidator) &#123;<br>            ((SmartValidator) validator).validate(getTarget(), getBindingResult(), validationHints);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (validator != <span class="hljs-literal">null</span>) &#123;<br>            validator.validate(getTarget(), getBindingResult());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可见，具体的校验交给了<code>org.springframework.validation.Validator</code>实现，类图:</p><p><img src="Validator.png" alt="Validator"></p><p>getValidators方法获取的实际上是DataBinder内部的validators字段:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Validator&gt; validators = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Validator&gt;();<br></code></pre></td></tr></table></figure><p>根据这里的校验器的来源可以分为以下两种情况。</p><h4 id="JSR校验"><a href="#JSR校验" class="headerlink" title="JSR校验"></a>JSR校验</h4><p>需要引入hibernate-validator到classpath中，回顾最前面配置解析部分，配置:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>会利用AnnotationDrivenBeanDefinitionParser进行相关的解析、初始化工作，正是在其parse方法完成了对JSR校验的支持。相关源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> BeanDefinition <span class="hljs-title function_">parse</span><span class="hljs-params">(Element element, ParserContext parserContext)</span> &#123;<br>    <span class="hljs-type">RuntimeBeanReference</span> <span class="hljs-variable">validator</span> <span class="hljs-operator">=</span> getValidator(element, source, parserContext);<br>&#125;<br><br><span class="hljs-keyword">private</span> RuntimeBeanReference <span class="hljs-title function_">getValidator</span><span class="hljs-params">(Element element, Object source, ParserContext parserContext)</span> &#123;<br>    <span class="hljs-comment">//mvc:annotation-driven配置支持validator属性</span><br>    <span class="hljs-keyword">if</span> (element.hasAttribute(<span class="hljs-string">&quot;validator&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeBeanReference</span>(element.getAttribute(<span class="hljs-string">&quot;validator&quot;</span>));<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (javaxValidationPresent) &#123;<br>        <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">validatorDef</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(<br>                <span class="hljs-string">&quot;org.springframework.validation.beanvalidation.OptionalValidatorFactoryBean&quot;</span>);<br>        validatorDef.setSource(source);<br>        validatorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">validatorName</span> <span class="hljs-operator">=</span> parserContext.getReaderContext().registerWithGeneratedName(validatorDef);<br>        parserContext.registerComponent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanComponentDefinition</span>(validatorDef, validatorName));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeBeanReference</span>(validatorName);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>javaxValidationPresent的定义:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">javaxValidationPresent</span> <span class="hljs-operator">=</span><br>    ClassUtils.isPresent(<span class="hljs-string">&quot;javax.validation.Validator&quot;</span>, AnnotationDrivenBeanDefinitionParser.class.getClassLoader());<br></code></pre></td></tr></table></figure><p> 实现了InitializingBean接口，所以afterPropertiesSet方法是其初始化的入口，具体的校验过程不再展开。<br> 除此之外还有一个有意思的问题，就是上面提到的校验器是如何进入到DataBinder中去的呢?答案是WebDataBinderFactory创建DataBinder对象时会利用WebBindingInitializer对DataBinder进行初始化，正是在这里<br> 将容器中存在的校验器设置到DataBinder中，至于WebBindingInitializer又是从哪里来的，不再探究了，否则这细节实在是太麻烦了，意义不大。</p><h4 id="自定义校验器"><a href="#自定义校验器" class="headerlink" title="自定义校验器"></a>自定义校验器</h4><p>我们可以实现Spring提供的Validator接口，然后在Controller里边这样设置我们要是用的校验器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@InitBinder</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initBinder</span><span class="hljs-params">(DataBinder dataBinder)</span> &#123;<br>    dataBinder.setValidator(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleModelValidator</span>());<br>    <span class="hljs-comment">//如果有多个可以使用addValidators方法</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们的Controller方法依然可以如此定义:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/echoAgain&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">echo</span><span class="hljs-params">(<span class="hljs-meta">@Validated</span> SimpleModel simpleModel, Model model)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;echo&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果有错误，会直接返回400.</p><h4 id="一个有意思的问题"><a href="#一个有意思的问题" class="headerlink" title="一个有意思的问题"></a>一个有意思的问题</h4><p>如果我们把Controller方法这样定义会怎样?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(value = &quot;/echoAgain&quot;, method = RequestMethod.POST)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">echo</span><span class="hljs-params">(<span class="hljs-meta">@Validated</span> <span class="hljs-meta">@RequestBody</span> SimpleModel simpleModel, Model model)</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>答案是@RequestBody注解先于@Validated注解起作用，这样既可以利用@RequestBody注解向Controller传递json串，同时又能够达到校验的目的。从源码的角度来说，这在很大程度上是一个顺序的问题:<br>RequestMappingHandlerAdapter.getDefaultArgumentResolvers相关源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">resolvers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletModelAttributeMethodProcessor</span>(<span class="hljs-literal">false</span>));<br>resolvers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RequestResponseBodyMethodProcessor</span>(getMessageConverters(), <span class="hljs-built_in">this</span>.requestResponseBodyAdvice));<br></code></pre></td></tr></table></figure><p>虽然ServletModelAttributeMethodProcessor位于RequestResponseBodyMethodProcessor之前，但构造器参数为false说明了此解析器必须要求参数被@ModelAttribute注解标注，其实在最后还有一个不需要注解的解析器被添加:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Catch-all</span><br>resolvers.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletModelAttributeMethodProcessor</span>(<span class="hljs-literal">true</span>));<br></code></pre></td></tr></table></figure><p>至此，真相大白。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://github.com/seaswalker/spring-analysis/blob/master/note/spring-mvc.md">spring-mvc</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>spring-analysis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>spring-mvc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring-boot</title>
    <link href="/2023/07/28/spring/spring-boot/"/>
    <url>/2023/07/28/spring/spring-boot/</url>
    
    <content type="html"><![CDATA[<h1 id="SpringApplication"><a href="#SpringApplication" class="headerlink" title="SpringApplication"></a>SpringApplication</h1><p>启动程序首先初始化了一个SpringApplication对象。来看一看在它的构造器里发生了什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">SpringApplication</span><span class="hljs-params">(ResourceLoader resourceLoader, Object... sources)</span> &#123;<br><span class="hljs-built_in">this</span>.resourceLoader = resourceLoader;<br>initialize(sources);<br>&#125;<br></code></pre></td></tr></table></figure><p>initialize方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(Object[] sources)</span> &#123;<br><span class="hljs-keyword">if</span> (sources != <span class="hljs-literal">null</span> &amp;&amp; sources.length &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">this</span>.sources.addAll(Arrays.asList(sources));<br>&#125;<br><span class="hljs-built_in">this</span>.webEnvironment = deduceWebEnvironment();<br>setInitializers((Collection) getSpringFactoriesInstances(<br>ApplicationContextInitializer.class));<br>setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));<br><span class="hljs-built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="web环境检测"><a href="#web环境检测" class="headerlink" title="web环境检测"></a>web环境检测</h2><p>deduceWebEnvironment方法用于检测当前是否是web工程环境，检测的标准也很简单，classpath中必须同时存在下面这两个类:</p><ul><li>javax.servlet.Servlet</li><li>org.springframework.web.context.ConfigurableWebApplicationContext</li></ul><h2 id="ApplicationContextInitializer"><a href="#ApplicationContextInitializer" class="headerlink" title="ApplicationContextInitializer"></a>ApplicationContextInitializer</h2><p>下一步便是检测应当使用哪些ApplicationContextInitializer，这货并不是spring-boot的专属，而是定义在context下，这东西是在喜闻乐见的refesh方法执行之前留给我们进行自定义初始化的钩子。典型的使用的场景是注册我们自己的属性来源、设置激活的profile。</p><p>在简单的web应用场景下(没有数据库/mybatis)，共最终引入了下列的类:</p><p><img src="ApplicationContextInitializer.png" alt="ApplicationContextInitializer"></p><p>来自于三个jar包:</p><ul><li>spring-boot</li><li>spring-boot-autoconfigure</li><li>spring-beans</li></ul><h2 id="ApplicationListener"><a href="#ApplicationListener" class="headerlink" title="ApplicationListener"></a>ApplicationListener</h2><p>这货是典型的观察者模式实现，类图:</p><p><img src="ApplicationListener.png" alt="ApplicationListener"></p><p>在简单的web应用场景下，系统共初始化了这些监听器:</p><p><img src="ApplicationListener_used.png" alt="ApplicationListener"></p><h2 id="SpringApplicationRunListener"><a href="#SpringApplicationRunListener" class="headerlink" title="SpringApplicationRunListener"></a>SpringApplicationRunListener</h2><p>就像它长得那样，就是用来监听SpringApplication的run方法的监听器。看看这货用到了哪些实现类:</p><p><img src="SpringApplicationRunListener.png" alt="SpringApplicationRunListener"></p><h1 id="run"><a href="#run" class="headerlink" title="run"></a>run</h1><p>从这一节开始，就进入了SpringApplication的run方法的势力范围。整个方法的流程总结如下图:</p><p><img src="spring_application_run.png" alt="SpringApplication.run"></p><h2 id="starting"><a href="#starting" class="headerlink" title="starting"></a>starting</h2><p>SpringApplicationRunListener其实起一个广播器的作用，将消息广播给ApplicationListener一节初始化的10个Listener中的某几个。</p><p>debug可以发现，对启动事件感兴趣的只有LoggingApplicationListener一个。</p><p> 当LoggingApplicationListener监听到启动事件时，所作的主要工作便是决定采用哪一个日志框架，其判断逻辑如下:</p><ul><li><p>如果系统变量<code>org.springframework.boot.logging.LoggingSystem</code>存在，那么由其决定。</p></li><li><p>依次检测classpath中这些类是否存在:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ch.qos.logback.core.Appender;<br>org.apache.logging.log4j.core.impl.Log4jContextFactory;<br>java.util.logging.LogManager;<br></code></pre></td></tr></table></figure></li></ul><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>相关源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ConfigurableEnvironment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> prepareEnvironment(listeners, applicationArguments);<br></code></pre></td></tr></table></figure><p>Spring里面的Environment到底是个什么东西，详细参考隔壁(Spring.md)Environment接口一节，总结来说，这货就是属性配置来源(比如系统变量)和profile的综合体。</p><h3 id="属性来源"><a href="#属性来源" class="headerlink" title="属性来源"></a>属性来源</h3><p>在web环境下共初始化了以下4个属性来源:</p><ul><li>System.getProperties()</li><li>System.getenv()</li><li>servlet-context-init-params</li><li>servlet-config-init-params</li></ul><p>有意思的问题：此时servlet-context-init-params和servlet-config-init-params实际上是一个占位符，无法从这两个来源获得任何真实的属性，等到refresh方法执行时才会被真实的来源替换。</p><h3 id="profile配置"><a href="#profile配置" class="headerlink" title="profile配置"></a>profile配置</h3><p>SpringApplication.configureProfiles方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureProfiles</span><span class="hljs-params">(ConfigurableEnvironment environment, String[] args)</span> &#123;<br>environment.getActiveProfiles(); <span class="hljs-comment">// ensure they are initialized</span><br><span class="hljs-comment">// But these ones should go first (last wins in a property key clash)</span><br>  <span class="hljs-comment">// 默认空</span><br>Set&lt;String&gt; profiles = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;String&gt;(<span class="hljs-built_in">this</span>.additionalProfiles);<br>profiles.addAll(Arrays.asList(environment.getActiveProfiles()));<br>environment.setActiveProfiles(profiles.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[profiles.size()]));<br>&#125;<br></code></pre></td></tr></table></figure><p>active profile取自上一节中的属性来源，key为<code>spring.profiles.active</code>.</p><h2 id="environmentPrepared"><a href="#environmentPrepared" class="headerlink" title="environmentPrepared"></a>environmentPrepared</h2><h3 id="配置文件加载"><a href="#配置文件加载" class="headerlink" title="配置文件加载"></a>配置文件加载</h3><p>监听器ConfigFileApplicationListener负责spring-boot配置文件的加载，ConfigFileApplicationListener默认会从以下的位置搜索配置文件:</p><ol><li>classpath下的application.properties或application.yml</li><li>file:./下的application.properties或application.yml</li><li>classpath:config目录下的application.properties或application.yml</li><li>file:./config目录下的application.properties或application.yml</li></ol><p>此监听器是如何加载的?源码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEnvironmentPreparedEvent</span><span class="hljs-params">(ApplicationEnvironmentPreparedEvent event)</span> &#123;<br>List&lt;EnvironmentPostProcessor&gt; postProcessors = loadPostProcessors();<br>postProcessors.add(<span class="hljs-built_in">this</span>);<br>AnnotationAwareOrderComparator.sort(postProcessors);<br><span class="hljs-keyword">for</span> (EnvironmentPostProcessor postProcessor : postProcessors) &#123;<br>postProcessor.postProcessEnvironment(event.getEnvironment(),<br>event.getSpringApplication());<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然核心的加载操作是通过EnvironmentPostProcessor接口实现的，此接口允许我们在context刷新之前自定义配置加载，并且Spring推荐此接口的实现类同时实现Ordered接口。类图:</p><p><img src="EnvironmentPostProcessor.png" alt="EnvironmentPostProcessor"></p><p>加上ConfigFileApplicationListener自己，spring-boot默认共初始化了三个加载器，其它两个是SpringApplicationJsonEnvironmentPostProcessor和CloudFoundryVcapEnvironmentPostProcessor，下面按照其优先级顺序进行说明。</p><h4 id="SpringApplicationJsonEnvironmentPostProcessor"><a href="#SpringApplicationJsonEnvironmentPostProcessor" class="headerlink" title="SpringApplicationJsonEnvironmentPostProcessor"></a>SpringApplicationJsonEnvironmentPostProcessor</h4><p>尝试读取spring.application.json或SPRING_APPLICATION_JSON系统指定的json配置文件，从这里加载的配置具有最高的优先级，当然，默认是没有的。</p><h4 id="CloudFoundryVcapEnvironmentPostProcessor"><a href="#CloudFoundryVcapEnvironmentPostProcessor" class="headerlink" title="CloudFoundryVcapEnvironmentPostProcessor"></a>CloudFoundryVcapEnvironmentPostProcessor</h4><p>从Cloud Foundry加载配置，这是什么东西问度娘。</p><h4 id="ConfigFileApplicationListener"><a href="#ConfigFileApplicationListener" class="headerlink" title="ConfigFileApplicationListener"></a>ConfigFileApplicationListener</h4><p>这里就是加载配置文件加载一节所说的配置文件的过程。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://github.com/seaswalker/spring-analysis/blob/master/note/spring-boot.md">spring-boot</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>spring-analysis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>spring-boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Argo CD 入门教程</title>
    <link href="/2023/07/26/k8s/Argo%20CD%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2023/07/26/k8s/Argo%20CD%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="Argo-CD-入门教程"><a href="#Argo-CD-入门教程" class="headerlink" title="Argo CD 入门教程"></a>Argo CD 入门教程</h2><p>Argo CD 是以 Kubernetes 作为基础设施，遵循声明式 GitOps 理念的持续交付（continuous delivery, CD）工具，支持多种配置管理工具，包括 ksonnet/jsonnet、kustomize 和 Helm 等。它的配置和使用非常简单，并且自带一个简单易用的可视化界面。</p><p>按照官方定义，Argo CD 被实现为一个 Kubernetes 控制器，它会持续监控正在运行的应用，并将当前的实际状态与 Git 仓库中声明的期望状态进行比较，如果实际状态不符合期望状态，就会更新应用的实际状态以匹配期望状态。</p><p>在正式开始解读和使用 Argo CD 之前，我们需要先搞清楚为什么需要 Argo CD？它能给我们带来什么价值？</p><h2 id="传统-CD-工作流"><a href="#传统-CD-工作流" class="headerlink" title="传统 CD 工作流"></a>传统 CD 工作流</h2><p>目前大多数 CI/CD 工具都使用基于 Push 的部署模式，例如 Jenkins、CircleCI 等。这种模式一般都会在 CI 流水线运行完成后执行一个命令（比如 kubectl）将应用部署到目标环境中。</p><p>这种 CD 模式的缺陷很明显：</p><ul><li>  需要安装配置额外工具（比如 kubectl）；</li><li>  需要 Kubernetes 对其进行授权；</li><li>  需要云平台授权；</li><li>  无法感知部署状态。也就无法感知期望状态与实际状态的偏差，需要借助额外的方案来保障一致性。</li></ul><p>下面以 Argo CD 为例，来看看遵循声明式 GitOps 理念的 CD 工具是怎么实现的。</p><h2 id="使用-Argo-CD-的-CD-工作流"><a href="#使用-Argo-CD-的-CD-工作流" class="headerlink" title="使用 Argo CD 的 CD 工作流"></a>使用 Argo CD 的 CD 工作流</h2><p>和传统 CI/CD 工具一样，CI 部分并没有什么区别，无非就是测试、构建镜像、推送镜像、修改部署清单等等。重点在于 CD 部分。</p><p>Argo CD 会被部署在 Kubernetes 集群中，使用的是基于 Pull 的部署模式，它会周期性地监控应用的实际状态，也会周期性地拉取 Git 仓库中的配置清单，并将实际状态与期望状态进行比较，如果实际状态不符合期望状态，就会更新应用的实际状态以匹配期望状态。</p><p>无论是通过 CI 流水线触发更新 K8s 编排文件，还是 DevOps 工程师直接修改 K8s 编排文件，Argo CD 都会自动拉取最新的配置并应用到 K8s 集群中。</p><p>最终会得到一个相互隔离的 CI 与 CD 流水线，CI 流水线通常由研发人员（或者 DevOps 团队）控制，CD 流水线通常由集群管理员（或者 DevOps 团队）控制。</p><h2 id="Argo-CD-的优势"><a href="#Argo-CD-的优势" class="headerlink" title="Argo CD 的优势"></a>Argo CD 的优势</h2><p>下面我们来看看 Argo CD 相较于传统 CD 工具有哪些比较明显的优势。</p><h3 id="Git-作为应用的唯一真实来源"><a href="#Git-作为应用的唯一真实来源" class="headerlink" title="Git 作为应用的唯一真实来源"></a>Git 作为应用的唯一真实来源</h3><p>所有 K8s 的声明式配置都保存在 Git 中，并把 Git 作为应用的唯一事实来源，我们不再需要手动更新应用（比如执行脚本，执行 kubectl apply 或者 helm install 命令），只需要通过统一的接口（Git）来更新应用。</p><p>此外，Argo CD 不仅会监控 Git 仓库中声明的期望状态，还会监控集群中应用的实际状态，并将两种状态进行对比，只要实际状态不符合期望状态，实际状态就会被修正与期望状态一致。所以即使有人修改了集群中应用的状态（比如修改了副本数量），Argo CD 还是会将其恢复到之前的状态。<strong>这就真正确保了 Git 仓库中的编排文件可以作为集群状态的唯一真实来源。</strong></p><p>当然，有时候我们需要快速更新应用并进行调试，通过 Git 来触发更新还是慢了点，这也不是没有办法，我们可以修改 Argo CD 的配置，使其不对手动修改的部分进行覆盖或者回退，而是直接发送告警，提醒管理员不要忘了将更新提交到 Git 仓库中。</p><h3 id="快速回滚"><a href="#快速回滚" class="headerlink" title="快速回滚"></a>快速回滚</h3><p>Argo CD 会定期拉取最新配置并应用到集群中，一旦最新的配置导致应用出现了故障（比如应用启动失败），我们可以通过 Git History 将应用状态快速恢复到上一个可用的状态。</p><p>如果你有多个 Kubernetes 集群使用同一个 Git 仓库，这个优势会更明显，因为你不需要分别在不同的集群中通过 <code>kubectl delete</code> 或者 <code>helm uninstall</code> 等手动方式进行回滚，只需要将 Git 仓库回滚到上一个可用的版本，Argo CD 便会自动同步。</p><h3 id="集群灾备"><a href="#集群灾备" class="headerlink" title="集群灾备"></a>集群灾备</h3><p>如果你在 青云北京3区中的 KubeSphere集群出现故障，且短期内不可恢复，可以直接创建一个新集群，然后将 Argo CD 连接到 Git 仓库，这个仓库包含了整个集群的所有配置声明。最终新集群的状态会与之前旧集群的状态一致，完全不需要人工干预。</p><h3 id="使用-Git-实现访问控制"><a href="#使用-Git-实现访问控制" class="headerlink" title="使用 Git 实现访问控制"></a>使用 Git 实现访问控制</h3><p>通常在生产环境中是不允许所有人访问 Kubernetes 集群的，如果直接在 Kubernetes 集群中控制访问权限，必须要使用复杂的 RBAC 规则。在 Git 仓库中控制权限就比较简单了，例如所有人（DevOps 团队，运维团队，研发团队，等等）都可以向仓库中提交 Pull Request，但只有高级工程师可以合并 Pull Request。</p><p>这样做的好处是，除了集群管理员和少数人员之外，其他人不再需要直接访问 Kubernetes 集群，只需访问 Git 仓库即可。对于程序而言也是如此，类似于 Jenkins 这样的 CI 工具也不再需要访问 Kubernetes 的权限，因为只有 Argo CD 才可以 apply 配置清单，而且 Argo CD 已经部署在 Kubernetes 集群中，必要的访问权限已经配置妥当，这样就不需要给集群外的任意人或工具提供访问的证书，可以提供更强大的安全保障。</p><h3 id="扩展-Kubernetes"><a href="#扩展-Kubernetes" class="headerlink" title="扩展 Kubernetes"></a>扩展 Kubernetes</h3><p>虽然 Argo CD 可以部署在 Kubernetes 集群中，享受 Kubernetes 带来的好处，但这不是 Argo CD 专属的呀！Jenkins 不是也可以部署在 Kubernetes 中吗？Argo CD 有啥特殊的吗？</p><p>那当然有了，没这金刚钻也不敢揽这瓷器活啊，Argo CD 巧妙地利用了 Kubernetes 集群中的很多功能来实现自己的目的，例如所有的资源都存储在 Etcd 集群中，利用 Kubernetes 的控制器来监控应用的实际状态并与期望状态进行对比，等等。</p><p>这样做最直观的好处就是<strong>可以实时感知应用的部署状态</strong>。例如，当你在 Git 仓库中更新配置清单中的镜像版本后，Argo CD 会将集群中的应用更新到最新版本，你可以在 Argo CD 的可视化界面中实时查看更新状态（比如 Pod 创建成功，应用成功运行并且处于健康状态，或者应用运行失败需要进行回滚操作）。</p><h2 id="Argo-CD-架构"><a href="#Argo-CD-架构" class="headerlink" title="Argo CD 架构"></a>Argo CD 架构</h2><p>从功能架构来看，Argo CD 主要有三个组件：API Server、Repository Server 和 Application Controller。从 GitOps 工作流的角度来看，总共分为 3 个阶段：检索、调谐和呈现。</p><h3 id="检索-–-Repository-Server"><a href="#检索-–-Repository-Server" class="headerlink" title="检索 – Repository Server"></a>检索 – Repository Server</h3><p>检索阶段会克隆应用声明式配置清单所在的 Git 仓库，并将其缓存到本地存储。包含 Kubernetes 原生的配置清单、Helm Chart 以及 Kustomize 配置清单。履行这些职责的组件就是 <strong>Repository Server</strong>。</p><h3 id="调谐-–-Application-Controller"><a href="#调谐-–-Application-Controller" class="headerlink" title="调谐 – Application Controller"></a>调谐 – Application Controller</h3><p>调谐（Reconcile）阶段是最复杂的，这个阶段会将 <strong>Repository Server</strong> 获得的配置清单与反映集群当前状态的实时配置清单进行对比，一旦检测到应用处于 <code>OutOfSync</code> 状态，<strong>Application Controller</strong> 就会采取修正措施，使集群的实际状态与期望状态保持一致。</p><h3 id="呈现-–-API-Server"><a href="#呈现-–-API-Server" class="headerlink" title="呈现 – API Server"></a>呈现 – API Server</h3><p>最后一个阶段是呈现阶段，由 Argo CD 的 <strong>API Server</strong> 负责，它本质上是一个 gRPC/REST Server，提供了一个无状态的可视化界面，用于展示调谐阶段的结果。同时还提供了以下这些功能：</p><ul><li>  应用管理和状态报告；</li><li>  调用与应用相关的操作（例如同步、回滚、以及用户自定义的操作）；</li><li>  Git 仓库与集群凭证管理（以 Kubernetes Secret 的形式存储）；</li><li>  为外部身份验证组件提供身份验证和授权委托；</li><li>  RBAC 增强；</li><li>  Git Webhook 事件的监听器/转发器。</li></ul><h2 id="部署-Argo-CD"><a href="#部署-Argo-CD" class="headerlink" title="部署 Argo CD"></a>部署 Argo CD</h2><p>Argo CD 有两种不同的部署模式：</p><h3 id="多租户"><a href="#多租户" class="headerlink" title="多租户"></a>多租户</h3><p>Argo CD 最常用的部署模式是多租户，一般如果组织内部包含多个应用研发团队，就会采用这种部署模式。用户可以使用可视化界面或者 argocd CLI 来访问 Argo CD。argocd CLI 必须先通过 <code>argocd login &lt;server-host&gt;</code> 来获取 Argo CD 的访问授权。</p><pre><code class="hljs">$ argocd login SERVER [flags]## Login to Argo CD using a username and password$ argocd login cd.argoproj.io## Login to Argo CD using SSO$ argocd login cd.argoproj.io --sso## Configure direct access using Kubernetes API server$ argocd login cd.argoproj.io --core</code></pre><p>多租户模式提供了两种不同的配置清单：</p><h4 id="非高可用"><a href="#非高可用" class="headerlink" title="非高可用"></a>非高可用</h4><p>推荐用于测试和演示环境，不推荐在生产环境下使用。有两种部署清单可供选择：</p><ul><li>  <a href="https://github.com/argoproj/argo-cd/blob/master/manifests/install.yaml">install.yaml</a> - 标准的 Argo CD 部署清单，拥有集群管理员权限。可以使用 Argo CD 在其运行的集群内部署应用程序，也可以通过接入外部集群的凭证将应用部署到外部集群中。</li><li>  <a href="https://github.com/argoproj/argo-cd/blob/master/manifests/namespace-install.yaml">namespace-install.yaml</a> - 这个部署清单只需要 namespace 级别的权限。如果你不需要在 Argo CD 运行的集群中部署应用，只需通过接入外部集群的凭证将应用部署到外部集群中，推荐使用此部署清单。还有一种花式玩法，你可以为每个团队分别部署单独的 Argo CD 实例，但是每个 Argo CD 实例都可以使用特殊的凭证（例如 <code>argocd cluster add &lt;CONTEXT&gt; --in-cluster --namespace &lt;YOUR NAMESPACE&gt;</code>）将应用部署到同一个集群中（即 <code>kubernetes.svc.default</code>，也就是内部集群）。</li></ul><blockquote><p>⚠️注意：namespace-install.yaml 配置清单中并不包含 Argo CD 的 CRD，需要自己提前单独部署：<code>kubectl apply -k https://github.com/argoproj/argo-cd/manifests/crds\?ref\=stable</code>。</p></blockquote><h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><p>与非高可用部署清单包含的组件相同，但增强了高可用能力和弹性能力，推荐在生产环境中使用。</p><ul><li>  <a href="https://github.com/argoproj/argo-cd/blob/master/manifests/ha/install.yaml">ha/install.yaml</a> - 与上文提到的 install.yaml 的内容相同，但配置了相关组件的多个副本。</li><li>  <a href="https://github.com/argoproj/argo-cd/blob/master/manifests/ha/namespace-install.yaml">ha/namespace-install.yaml</a> - 与上文提到的 namespace-install.yaml 相同，但配置了相关组件的多个副本。</li></ul><h3 id="Core"><a href="#Core" class="headerlink" title="Core"></a>Core</h3><p>Core 模式也就是最精简的部署模式，不包含 API Server 和可视化界面，只部署了每个组件的轻量级（非高可用）版本。</p><p>用户需要 Kubernetes 访问权限来管理 Argo CD，因此必须使用下面的命令来配置 argocd CLI：</p><pre><code class="hljs">$ kubectl config set-context --current --namespace=argocd # change current kube context to argocd namespace$ argocd login --core</code></pre><p>也可以使用命令 <code>argocd admin dashboard</code> 手动启用可视化界面。</p><p>具体的配置清单位于 Git 仓库中的 <a href="https://github.com/argoproj/argo-cd/blob/master/manifests/core-install.yaml">core-install.yaml</a>。</p><hr><p>除了直接通过原生的配置清单进行部署，Argo CD 还支持额外的配置清单管理工具。</p><h3 id="Kustomize"><a href="#Kustomize" class="headerlink" title="Kustomize"></a>Kustomize</h3><p>Argo CD 配置清单也可以使用 Kustomize 来部署，建议通过远程的 URL 来调用配置清单，使用 patch 来配置自定义选项。</p><pre><code class="hljs">apiVersion: kustomize.config.k8s.io/v1beta1kind: Kustomizationnamespace: argocdresources:- https://raw.githubusercontent.com/argoproj/argo-cd/v2.0.4/manifests/ha/install.yaml</code></pre><h3 id="Helm"><a href="#Helm" class="headerlink" title="Helm"></a>Helm</h3><p>Argo CD 的 Helm Chart 目前由社区维护，地址： <a href="https://github.com/argoproj/argo-helm/tree/master/charts/argo-cd">https://github.com/argoproj/argo-helm/tree/master/charts/argo-cd</a>。</p><hr><p>下面演示一下部署过程。如果没有现成的 Kubernetes 环境，可以通过 <a href="https://kubesphere.cloud/console/resource/">KubeSphere Cloud 托管集群服务</a>快速创建一个，免费体验时间为 2 小时，到期后集群会自动删除，可不限次重建。</p><p>创建 Kubernetes 集群的过程很简单，首先注册登录 <a href="https://kubesphere.cloud/">https://kubesphere.cloud</a> 控制台，然后点击 <strong>托管集群服务</strong> 打开 <strong>新建 Kubernetes 集群</strong> 页面，填写集群名称，选择运行环境，点击 <strong>新建</strong> 菜单即可创建集群。</p><p>几秒钟之后便会创建完毕，并显示集群基本信息。下载 kubeconfig，便可使用 kubectl 来访问集群。</p><p>接下来开始部署 Argo CD：</p><pre><code class="hljs">$ kubectl create namespace argocd$ kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml</code></pre><p>查看部署结果：</p><pre><code class="hljs">$ kubectl -n argocd get podargocd-applicationset-controller-69879c47c-pcbkg   1/1     Running   0          26margocd-notifications-controller-6b4b74d8d8-s7mrz   1/1     Running   0          26margocd-redis-65596bf87-2hzcv                       1/1     Running   0          26margocd-dex-server-78c9764884-6lcww                 1/1     Running   0          26margocd-repo-server-657d46f8b-87rzq                 1/1     Running   0          26margocd-application-controller-0                    1/1     Running   0          26margocd-server-6b48df79dd-b7bkw                     1/1     Running   0          26m</code></pre><h2 id="访问-Argo-CD"><a href="#访问-Argo-CD" class="headerlink" title="访问 Argo CD"></a>访问 Argo CD</h2><p>部署完成后，可以通过 Service <code>argocd-server</code> 来访问可视化界面。</p><pre><code class="hljs">$ kubectl -n argocd get svc                                                             NAME                                      TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                      AGEargocd-applicationset-controller          ClusterIP   10.105.250.212   &lt;none&gt;        7000/TCP,8080/TCP            5m10sargocd-dex-server                         ClusterIP   10.108.88.97     &lt;none&gt;        5556/TCP,5557/TCP,5558/TCP   5m10sargocd-metrics                            ClusterIP   10.103.11.245    &lt;none&gt;        8082/TCP                     5m10sargocd-notifications-controller-metrics   ClusterIP   10.98.136.200    &lt;none&gt;        9001/TCP                     5m9sargocd-redis                              ClusterIP   10.110.151.108   &lt;none&gt;        6379/TCP                     5m9sargocd-repo-server                        ClusterIP   10.109.131.197   &lt;none&gt;        8081/TCP,8084/TCP            5m9sargocd-server                             ClusterIP   10.98.23.255     &lt;none&gt;        80/TCP,443/TCP               5m9sargocd-server-metrics                     ClusterIP   10.103.184.121   &lt;none&gt;        8083/TCP                     5m8s</code></pre><p>如果你的客户端可以直连 Service IP，那就直接可以通过 argocd-server 的 Cluster IP 来访问。或者可以直接通过本地端口转发来访问：</p><pre><code class="hljs">$ kubectl port-forward svc/argocd-server -n argocd 8080:443Forwarding from 127.0.0.1:8080 -&gt; 8080Forwarding from [::1]:8080 -&gt; 8080</code></pre><p>初始密码以明文形式存储在 Secret <code>argocd-initial-admin-secret</code> 中，可以通过以下命令获取：</p><pre><code class="hljs">$ kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=&quot;&#123;.data.password&#125;&quot; | base64 -d; echo</code></pre><p>也可以通过以下命令来修改登录密码：</p><pre><code class="hljs">$ argocd account update-password --account admin --current-password xxxx --new-password xxxx</code></pre><p>登录后的界面：</p><h2 id="Argo-CD-核心概念"><a href="#Argo-CD-核心概念" class="headerlink" title="Argo CD 核心概念"></a>Argo CD 核心概念</h2><p>在正式开始使用 Argo CD 之前，需要先了解两个基本概念。</p><h3 id="Argo-CD-Application"><a href="#Argo-CD-Application" class="headerlink" title="Argo CD Application"></a>Argo CD Application</h3><p>Argo CD 中的 Application 定义了 Kubernetes 资源的<strong>来源</strong>（Source）和<strong>目标</strong>（Destination）。来源指的是 Git 仓库中 Kubernetes 资源配置清单所在的位置，而目标是指资源在 Kubernetes 集群中的部署位置。</p><p>来源可以是原生的 Kubernetes 配置清单，也可以是 Helm Chart 或者 Kustomize 部署清单。</p><p>目标指定了 Kubernetes 集群中 API Server 的 URL 和相关的 namespace，这样 Argo CD 就知道将应用部署到哪个集群的哪个 namespace 中。</p><p>简而言之，<strong>Application 的职责就是将目标 Kubernetes 集群中的 namespace 与 Git 仓库中声明的期望状态连接起来</strong>。</p><p>Application 的配置清单示例：</p><p>如果有多个团队，每个团队都要维护大量的应用，就需要用到 Argo CD 的另一个概念：<strong>项目</strong>（Project）。</p><h3 id="Argo-CD-Project"><a href="#Argo-CD-Project" class="headerlink" title="Argo CD Project"></a>Argo CD Project</h3><p>Argo CD 中的项目（Project）可以用来对 Application 进行分组，不同的团队使用不同的项目，这样就实现了多租户环境。项目还支持更细粒度的访问权限控制：</p><ul><li>  限制部署内容（受信任的 Git 仓库）；</li><li>  限制目标部署环境（目标集群和 namespace）；</li><li>  限制部署的资源类型（例如 RBAC、CRD、DaemonSets、NetworkPolicy 等）；</li><li>  定义项目角色，为 Application 提供 RBAC（例如 OIDC group 或者 JWT 令牌绑定）。</li></ul><h2 id="Demo-演示"><a href="#Demo-演示" class="headerlink" title="Demo 演示"></a>Demo 演示</h2><p>最后通过一个简单的示例来展示 Argo CD 的工作流程。</p><h3 id="准备-Git-仓库"><a href="#准备-Git-仓库" class="headerlink" title="准备 Git 仓库"></a>准备 Git 仓库</h3><p>在 GitHub 上创建一个项目，取名为 <a href="https://github.com/yangchuansheng/argocd-lab">argocd-lab</a>，为了方便实验将仓库设置为公共仓库。在仓库中新建 dev 目录，在目录中创建两个 YAML 配置清单，分别是 <code>deployment.yaml</code> 和 <code>service.yaml</code>。</p><p>配置清单内容如下：</p><pre><code class="hljs"># deployment.yamlapiVersion: apps/v1kind: Deploymentmetadata:  name: myappspec:  selector:    matchLabels:      app: myapp  replicas: 2  template:    metadata:      labels:        app: myapp    spec:      containers:      - name: myapp        image: nginx:latest        ports:        - containerPort: 80        # service.yamlapiVersion: v1kind: Servicemetadata:  name: myapp-servicespec:  selector:    app: myapp  ports:  - port: 80    protocol: TCP    targetPort: 80</code></pre><p>接下来在仓库根目录中创建一个 Application 的配置清单：</p><pre><code class="hljs"># application.yamlapiVersion: argoproj.io/v1alpha1kind: Applicationmetadata:  name: myapp-argo-application  namespace: argocdspec:  project: default  source:    repoURL: https://github.com/yangchuansheng/argocd-lab.git    targetRevision: HEAD    path: dev  destination:     server: https://kubernetes.default.svc    namespace: myapp  syncPolicy:    syncOptions:    - CreateNamespace=true    automated:      selfHeal: true      prune: true</code></pre><p>参数解释：</p><ul><li><strong>syncPolicy</strong> : 指定自动同步策略和频率，不配置时需要手动触发同步。</li><li><strong>syncOptions</strong> : 定义同步方式。<ul><li>  <strong>CreateNamespace=true</strong> : 如果不存在这个 namespace，就会自动创建它。</li></ul></li><li><strong>automated</strong> : 检测到实际状态与期望状态不一致时，采取的同步措施。<ul><li>  <strong>selfHeal</strong> : 当集群世纪状态不符合期望状态时，自动同步。</li><li>  <strong>prune</strong> : 自动同步时，删除 Git 中不存在的资源。</li></ul></li></ul><p>Argo CD 默认情况下<strong>每 3 分钟</strong>会检测 Git 仓库一次，用于判断应用实际状态是否和 Git 中声明的期望状态一致，如果不一致，状态就转换为 <code>OutOfSync</code>。默认情况下并不会触发更新，除非通过 <code>syncPolicy</code> 配置了自动同步。</p><p>如果嫌周期性同步太慢了，也可以通过设置 Webhook 来使 Git 仓库更新时立即触发同步。具体的使用方式会放到后续的教程中，本文不再赘述。</p><h3 id="创建-Application"><a href="#创建-Application" class="headerlink" title="创建 Application"></a>创建 Application</h3><p>现在万事具备，只需要通过 application.yaml 创建 Application 即可。</p><pre><code class="hljs">$ kubectl apply -f application.yamlapplication.argoproj.io/myapp-argo-application created</code></pre><p>在 Argo CD 可视化界面中可以看到应用已经创建成功了。</p><p>点进去可以看到应用的同步详情和各个资源的健康状况。</p><p><strong>如果你更新了 deployment.yaml 中的镜像，Argo CD 会自动检测到 Git 仓库中的更新，并且将集群中 Deployment 的镜像更新为 Git 仓库中最新设置的镜像版本。</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了 Argo CD 的优势、架构和工作原理，并通过一个简单的示例对其功能进行演示，比如修改 Git 仓库内容后，可以自动触发更新。还可以通过 Event Source 和 Trigger 实现更多自动化部署的需求。</p><h2 id="Refenences"><a href="#Refenences" class="headerlink" title="Refenences"></a>Refenences</h2><ul><li><a href="https://icloudnative.io/posts/getting-started-with-argocd">Argo CD 入门教程</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>GitOps</tag>
      
      <tag>devops</tag>
      
      <tag>Argo CD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为kubernetes-dashboard创建token,方便页面访问</title>
    <link href="/2023/07/25/k8s/%E4%B8%BAkubernetes-dashboard%E5%88%9B%E5%BB%BAtoken,%E6%96%B9%E4%BE%BF%E9%A1%B5%E9%9D%A2%E8%AE%BF%E9%97%AE/"/>
    <url>/2023/07/25/k8s/%E4%B8%BAkubernetes-dashboard%E5%88%9B%E5%BB%BAtoken,%E6%96%B9%E4%BE%BF%E9%A1%B5%E9%9D%A2%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<p>在公网可以使用命令操作k8s后,然后安装kubernetes-dashboard发现,执行 <code>kubectl proxy</code> 可以打开 <a href="http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/">http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/</a>,</p><p>但是没有权限访问,需要创建token访问.</p><h2 id="Creating-a-Service-Account"><a href="#Creating-a-Service-Account" class="headerlink" title="Creating a Service Account"></a>Creating a Service Account</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">admin-user</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kubernetes-dashboard</span><br><br></code></pre></td></tr></table></figure><h2 id="Creating-a-ClusterRoleBinding"><a href="#Creating-a-ClusterRoleBinding" class="headerlink" title="Creating a ClusterRoleBinding"></a>Creating a ClusterRoleBinding</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><br><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">rbac.authorization.k8s.io/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRoleBinding</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">admin-user</span><br><span class="hljs-attr">roleRef:</span><br>  <span class="hljs-attr">apiGroup:</span> <span class="hljs-string">rbac.authorization.k8s.io</span><br>  <span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterRole</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">cluster-admin</span><br><span class="hljs-attr">subjects:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">kind:</span> <span class="hljs-string">ServiceAccount</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">admin-user</span><br>    <span class="hljs-attr">namespace:</span> <span class="hljs-string">kubernetes-dashboard</span><br><br></code></pre></td></tr></table></figure><h2 id="Getting-a-Bearer-Token-for-ServiceAccount"><a href="#Getting-a-Bearer-Token-for-ServiceAccount" class="headerlink" title="Getting a Bearer Token for ServiceAccount"></a>Getting a Bearer Token for ServiceAccount</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl -n kubernetes-dashboard create token admin-user<br></code></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://github.com/kubernetes/dashboard/blob/master/docs/user/access-control/creating-sample-user.md">creating-sample-user</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>kubernetes-dashboard</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>将k3s部署的api server地址对外暴露访问</title>
    <link href="/2023/07/24/k8s/%E5%B0%86k3s%E9%83%A8%E7%BD%B2%E7%9A%84api%20server%E5%9C%B0%E5%9D%80%E5%AF%B9%E5%A4%96%E6%9A%B4%E9%9C%B2%E8%AE%BF%E9%97%AE/"/>
    <url>/2023/07/24/k8s/%E5%B0%86k3s%E9%83%A8%E7%BD%B2%E7%9A%84api%20server%E5%9C%B0%E5%9D%80%E5%AF%B9%E5%A4%96%E6%9A%B4%E9%9C%B2%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<p>按照官网的推荐部署后,内网正常使用kubectl操作没问题,心想将<code>api server</code>地址使用frp对外暴露后,将可以在公司远程操作家里的k3s服务.</p><p>但是使用后发现报SANs认证异常,报错如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">➜  kubectl.exe get ns<br>Unable to connect to the server: x509: certificate is valid for 10.43.0.1, 127.0.0.1, 192.168.5.104, ::1, not 82.157.70.xx<br><br></code></pre></td></tr></table></figure><p>经过排除,验证发现只能重新安装部署k3s,只需在部署脚本添加<code>--tls-san</code>参数即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">完整脚本</span><br>curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_EXEC=&quot;--tls-san x.x.x.x&quot; INSTALL_K3S_MIRROR=cn sh -<br><br></code></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://docs.k3s.io/zh/quick-start">快速入门指南</a></li><li><a href="https://github.com/k3s-io/k3s/issues/1381">Remote kubectl x509: certificate is valid for 127.0.0.1 #1381</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k3s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript let与var的区别</title>
    <link href="/2023/07/20/typeScript/TypeScript%20let%E4%B8%8Evar%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2023/07/20/typeScript/TypeScript%20let%E4%B8%8Evar%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="1、作用域不同"><a href="#1、作用域不同" class="headerlink" title="1、作用域不同"></a>1、作用域不同</h2><p>用var声明的变量，只有函数作用域和全局作用域，没有块级作用域。而let可以实现块级作用域，只能在代码块<code>&#123;&#125;</code>内有效，在<code>&#123;&#125;</code>之外不能访问，如下代码所示：</p><pre><code class="hljs">&#123;  let a = 0;  var b = 1;&#125; console.log(a)  // ReferenceError: a is not definedconsole.log(b)  // 1</code></pre><h3 id="补充：循环作用域"><a href="#补充：循环作用域" class="headerlink" title="补充：循环作用域"></a>补充：循环作用域</h3><p>在for循环中，不仅循环体<code>&#123;&#125;</code>会生成块级作用域，循环条件<code>()</code>也会生成块级作用域，循环条件<code>()</code>的块级作用域是循环体<code>&#123;&#125;</code>块级作用域的父级作用域，所以let可以跨越<code>()</code>和<code>&#123;&#125;</code>作用域。如下所示：</p><pre><code class="hljs">for (let i = 0; i &lt; 10 ; i++) &#123;    setTimeout(function() &#123;console.log(i); &#125;, 100 * i);&#125;</code></pre><h2 id="2、let没有变量提升"><a href="#2、let没有变量提升" class="headerlink" title="2、let没有变量提升"></a>2、let没有变量提升</h2><p>在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为：暂时性死区，英文为：temporal dead zone，简称 TDZ。</p><pre><code class="hljs">//报错console.log(a)let a=10</code></pre><h2 id="3、let变量不能重复声明"><a href="#3、let变量不能重复声明" class="headerlink" title="3、let变量不能重复声明"></a>3、let变量不能重复声明</h2><p>使用var，多次声明同一个变量，不会报错，只会得到一个变量，如下代码所示：</p><pre><code class="hljs">var a=1;var a=2;</code></pre><p>上述例子中，所有的a的声明实际上都引用了一个相同的a。在多人开发一个项目时，容易出现问题。比如都定义了一个变量a，但各自用途不同，后面定义的a会把前面定义的覆盖掉。而let就相对严格，无法多次声明同一个变量，一个变量只能声明一次，并且无法在 let 语句前去访问该变量：</p><pre><code class="hljs">let a=1;let a=2; //错误</code></pre><h2 id="4、for循环中的let与var"><a href="#4、for循环中的let与var" class="headerlink" title="4、for循环中的let与var"></a>4、for循环中的let与var</h2><pre><code class="hljs">for (var i = 0; i &lt; 3; i++) &#123;    setTimeout(function ()&#123;console.log(&quot;i:&quot; + i);&#125;);&#125;</code></pre><p>上述代码打印出来i都是3，这个结果令人感觉奇怪。其实并不奇怪，原因如下所示：</p><p>（1）var是全局变量，并且可以允许重复定义，所以在<code>for (var i = 0; i &lt; 3; i++)</code>语句中，i重复定义了3次，最终的值以最后一次定义为准。<br>（2）JavaScript是单线程，<code>setTimeout()</code>会等for执行完之后才开始计时，此时i的值为3，最终打印出3</p><pre><code class="hljs">for (let j = 0; j &lt; 3; j++) &#123;    setTimeout(function ()&#123;console.log(&quot;j:&quot; + j);&#125;);&#125;</code></pre><p>上述代码打印出来i是0、1、2，原因分析如下：</p><p>（1）变量j是用let声明的，当前的j只在本轮循环中有效，每次循环的j其实都是一个新的变量。<br>（2）在for循环中，不仅循环体<code>&#123;&#125;</code>会生成块级作用域，循环条件<code>()</code>也会生成块级作用域，循环条件<code>()</code>的块级作用域是循环体<code>&#123;&#125;</code>块级作用域的父级作用域，所以let可以跨越<code>()</code>和<code>&#123;&#125;</code>作用域。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="http://www.mybatis.cn/typescript/1826.html">TypeScript let与var的区别</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello 算法</title>
    <link href="/2023/07/19/book/Hello%20%E7%AE%97%E6%B3%95/Hello%20%E7%AE%97%E6%B3%95/"/>
    <url>/2023/07/19/book/Hello%20%E7%AE%97%E6%B3%95/Hello%20%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<iframe height=850  width=100% src="https://www.hello-algo.com/" allowfullscreen></iframe><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.hello-algo.com/">Hello 算法</a></li><li><a href="https://github.com/krahets/hello-algo">Hello 算法 code</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>algorithms</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>trojan使用记录</title>
    <link href="/2023/07/10/other/trojan/"/>
    <url>/2023/07/10/other/trojan/</url>
    
    <content type="html"><![CDATA[<p>centos 安装 trojan</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">yum update -y  #CentOS<br>yum install -y curl  #CentOS<br>source &lt;(curl -sL https://git.io/trojan-install)<br></code></pre></td></tr></table></figure><p>centos 卸载 trojan</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source &lt;(curl -sL https://git.io/trojan-install) --remove<br></code></pre></td></tr></table></figure><p>安装后按提示选择域名证书和数据库即可</p><p>域名申请推荐godaddy,国内只要域名指向国内服务器都需要备案</p><p>申请域名后推荐转入dnspod进行域名管理,方便一键使用脚本申请ssl(后续整理如何进行一键ssl申请)</p><p>安装完毕后强烈开启bbr-plus魔改版加速,否则速度慢<br>    wget -N –no-check-certificate “<a href="https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot;">https://raw.githubusercontent.com/chiakge/Linux-NetSpeed/master/tcp.sh&quot;</a> &amp;&amp; chmod +x tcp.sh &amp;&amp; ./tcp.sh</p><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>trojan安装后默认监听443端口,由于443端口还想为其他服务提供,可进行修改端口,并取消ssl</p><p>issues 链接(<a href="https://github.com/Jrohy/trojan/issues/583">https://github.com/Jrohy/trojan/issues/583</a>)</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">修改 <span class="hljs-regexp">/etc/</span>systemd<span class="hljs-regexp">/system/</span>trojan-web.service 配置文件, 在<span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>trojan web 后面加入 -p <span class="hljs-number">4443</span> 使trojan-web使用<span class="hljs-number">4443</span>端口并关闭ssl功能，然后运行:<br><br>systemctl daemon-reload<br>systemctl restart trojan-web<br></code></pre></td></tr></table></figure><p>注意以上只是trojan-web端口进行了修改,trojan服务的端口可进行管理面板自行修改,否则也是占用443端口</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://github.com/Jrohy/trojan">trojan</a></li><li><a href="https://github.com/al-one/certbot-auth-dnspod">一键设置ssl</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>trojan</tag>
      
      <tag>ssl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSH login without password</title>
    <link href="/2023/07/10/SSH%20login%20without%20%20password/"/>
    <url>/2023/07/10/SSH%20login%20without%20%20password/</url>
    
    <content type="html"><![CDATA[<h2 id="Your-aim"><a href="#Your-aim" class="headerlink" title="Your aim"></a>Your aim</h2><p>You want to use Linux and OpenSSH to automate your tasks. Therefore you need an <strong>automatic</strong> login from host A / user a to Host B / user b. You don’t want to enter any passwords, because you want to call ssh from a within a shell script.</p><h2 id="How-to-do-it"><a href="#How-to-do-it" class="headerlink" title="How to do it"></a>How to do it</h2><p>First log in on A as user a and generate a pair of authentication keys. Do not enter a passphrase:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">a@A:~&gt; ssh-keygen -t rsa<br>Generating public/private rsa key pair.<br>Enter file in which to save the key (/home/a/.ssh/id_rsa): <br>Created directory &#x27;/home/a/.ssh&#x27;.<br>Enter passphrase (empty for no passphrase): <br>Enter same passphrase again: <br>Your identification has been saved in /home/a/.ssh/id_rsa.<br>Your public key has been saved in /home/a/.ssh/id_rsa.pub.<br>The key fingerprint is:<br>3e:4f:05:79:3a:9f:96:7c:3b:ad:e9:58:37:bc:37:e4 a@A<br></code></pre></td></tr></table></figure><p>Now use ssh to create a directory ~/.ssh as user b on B. (The directory may already exist, which is fine):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">a@A:~&gt; ssh b@B mkdir -p .ssh<br>b@B&#x27;s password: <br></code></pre></td></tr></table></figure><p>Finally append a’s new public key to :.ssh/authorized_keys and enter b’s password one last time:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">a@A:~&gt; cat .ssh/id_rsa.pub | ssh b@B &#x27;cat &gt;&gt; .ssh/authorized_keys&#x27;<br>b@B&#x27;s password: <br></code></pre></td></tr></table></figure><p>From now on you can log into B as b from A as a without password:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">a@A:~&gt; ssh b@B <br></code></pre></td></tr></table></figure><p><strong>A note</strong> from one of our readers: Depending on your version of SSH you might also have to do the following changes:</p><ul><li>  Put the public key in .ssh/authorized_keys2</li><li>  Change the permissions of .ssh to 700</li><li>  Change the permissions of .ssh/authorized_keys2 to 640</li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="http://linuxproblem.org/art_9.html">SSH login without password</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记录cm311-la刷机</title>
    <link href="/2023/07/09/other/cm311/"/>
    <url>/2023/07/09/other/cm311/</url>
    
    <content type="html"><![CDATA[<p><img src="img.png" alt="img.png"><br>注意点:</p><ul><li>1.推荐淘宝购买免拆神器,省去手动短接问题</li><li>2.卖家刷好的机器,可能无法安装armbianx系统,使用下面的连接重新刷机后即可安装armbian系统</li><li>3.推荐将armbian安装至闪存中,否则会出现开机sshd服务无法启动问题,并且闪存体验更好</li></ul><h1 id="安装Ubuntu桌面-可选"><a href="#安装Ubuntu桌面-可选" class="headerlink" title="安装Ubuntu桌面[可选]"></a>安装Ubuntu桌面[可选]</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">armbian-software<br><br>选择 201 安装<br></code></pre></td></tr></table></figure><h1 id="使用该机顶盒远程连接window系统"><a href="#使用该机顶盒远程连接window系统" class="headerlink" title="使用该机顶盒远程连接window系统"></a>使用该机顶盒远程连接window系统</h1><p> 安装remmina软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install remmina remmina-plugin-vnc<br>sudo apt install remmina remmina-plugin-rdp<br></code></pre></td></tr></table></figure><h1 id="安装xrdp-远程连接ubuntu"><a href="#安装xrdp-远程连接ubuntu" class="headerlink" title="安装xrdp 远程连接ubuntu"></a>安装xrdp 远程连接ubuntu</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install xrdp xorgxrdp<br>sudo systemctl enable xrdp<br>sudo reboot<br><br></code></pre></td></tr></table></figure><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点:"></a>注意点:</h2><p> 默认直接安装xrdp,会因为ipv6问题无法使用远程连接,上面应该是额外安装xorgxrdp 才可以使用<br>    参考下面链接</p><h1 id="安装frp并实现开机启动"><a href="#安装frp并实现开机启动" class="headerlink" title="安装frp并实现开机启动"></a>安装frp并实现开机启动</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/systemd/system/frpc.service<br><br></code></pre></td></tr></table></figure><p>内容为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>[Unit]<br>Description=frpc daemon<br>After=syslog.target  network.target<br>Wants=network.target<br><br>[Service]<br>Type=simple<br>ExecStart=/usr/sbin/frp/frpc -c /etc/frp/frpc.ini<br>Restart= always<br>RestartSec=1min<br>ExecStop=/usr/bin/killall frpc<br><br><br>[Install]<br>WantedBy=multi-user.target<br><br></code></pre></td></tr></table></figure><p>如果无法生效删除服务重新安装即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl disable frpc.service <br>systemctl enable frpc.service <br><br></code></pre></td></tr></table></figure><h1 id="安装openresty"><a href="#安装openresty" class="headerlink" title="安装openresty"></a>安装openresty</h1><p>参考下面链接</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://github.com/ophub/amlogic-s9xxx-armbian">amlogic-s9xxx-armbian</a></li><li><a href="https://www.emuelec.cn/460.html">Emuelec 4.6-正式版-s905x2x3X4-s922-57.5g-4整合包</a></li><li><a href="https://openresty.org/cn/linux-packages.html#ubuntu">armbian系统安装openresty,建议使用ubuntu Jammy 版本</a></li><li><a href="https://www.youtube.com/watch?v=PQGODwWkQGs">魔百盒cm311刷armbian系统，做家庭服务器静音又省电</a></li><li><a href="https://forum.armbian.com/topic/13740-how-to-enable-rdp-xrdp-with-armbian-so-you-can-login-from-a-windows-pc/"> How to enable RDP (xrdp) with Armbian so you can login from a Windows PC</a></li><li><a href="https://github.com/neutrinolabs/xrdp/issues/1855">xrdp_wm_log_msg: Error connecting to sesman: 127.0.0.1 port: 3350</a></li><li><a href="https://www.vmvps.com/how-to-solve-the-error-caused-by-usr-bin-mandb.html">关于/usr/bin/mandb报错的解决方案</a></li><li><a href="https://askubuntu.com/questions/637432/sudo-comes-up-with-an-error-cannot-run-anything-as-root">Sudo comes up with an error, cannot run anything as root</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cm311</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【jrebel and xrebel问题记录】激活时出现LS client not configued</title>
    <link href="/2023/07/09/other/jrebel/"/>
    <url>/2023/07/09/other/jrebel/</url>
    
    <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>笔者在重装另一台电脑的时候又遇到了这个安装jrebel and xrebel进行激活的问题 但是我在网上找了很多的办法（其实都是相同的办法，只是在尝试别人不同的用于激活的服务器）<br>我找到的网上其他人分享出来的几个服务器地址：<br><a href="https://jrebel.qekang.com/%7BGUID%7D">https://jrebel.qekang.com/{GUID}</a><br><a href="http://jrebel-license.jiweichengzhu.com/%7BGUID%7D">http://jrebel-license.jiweichengzhu.com/{GUID}</a></p><p>(你可以直接去掉后面的{GUID}直接访问这两个地址，能访问就说明这两个地址还在工作，还没有挂掉，且直接访问的话，有相应的使用说明，一开始我还以为是这两个服务器挂了导致激活不成功的，后面发现这两个地址能访问)</p><p>然后再配合这个地址（<a href="https://www.guidgen.com/">https://www.guidgen.com/</a>）生成的guid，和上面的服务器地址拼接起来(替换上面链接里的{GUID})，将拼接起来的内容放入那个激活界面然后任意输入一个邮箱地址就可用于激活</p><p>但是点击激活都是下面这样：<br><img src="img.png" alt="img.png"></p><h1 id="所使用的环境和版本"><a href="#所使用的环境和版本" class="headerlink" title="所使用的环境和版本"></a>所使用的环境和版本</h1><p>本次使用的是idea2022.3.1 （我升级到最新版的idea了）<br>然后通过这个idea下载到的Jrebel and Xrebel的版本也是最新版的2022.4.2</p><h1 id="解决过程"><a href="#解决过程" class="headerlink" title="解决过程"></a>解决过程</h1><p>一开始我是怀疑这个用于激活的地址挂掉了的，但后面发现这两个地址都能够正常访问，说明就不是激活地址的问题，后面在<a href="https://jrebel.qekang.com/">https://jrebel.qekang.com/</a>的激活介绍里面看到了激活失败的可能的问题原因：  </p><p><img src="img_1.png" alt="img_1.png"><br>刚好发现我就属于他描述的其中一种情况，然后我卸载了当前的2022.4.2版本的jrebel，删除了c盘用户下面的.jrebel文件，然后去官网下载了2022.4.1版本的jrebel解压到idea安装目录里面的pulgins的文件夹里，再重启idea后进行激活，发现激活成功</p><p>还是感谢那两位大佬共享出来的服务器！是我浅薄无知了，我一开始还怀疑网上共享出来的所有 的用于激活的链接都挂了呢</p><h2 id="手动下载jrebel"><a href="#手动下载jrebel" class="headerlink" title="手动下载jrebel"></a>手动下载jrebel</h2><p>1、先在idea中卸载之前安装的jrebel，保证idea中没有安装jrebel，然后关闭idea，在c盘的用户目录下去删除相关的.jrebel文件，如果你卸载了jrebel的话应该只会有几个文件在你的用户目录下，比如我的用户目录是这个“C:\Users\18296”</p><p>2、官网去找到过去版本的jrebel，地址：<a href="https://plugins.jetbrains.com/plugin/4441-jrebel-and-xrebel/versions">https://plugins.jetbrains.com/plugin/4441-jrebel-and-xrebel/versions</a>  </p><p><img src="img_2.png" alt="img_2.png"><br>下载一个过去版本的jrebel，下载下来是一个压缩包，解压到你的一个地方先保存下来</p><p>3、然后将解压出来的这个压缩包放到你的idea的安装目录的pulgin的目录里，比如我的安装目录的插件文件夹是这个：D:\qc_code\IntelliJ IDEA 2022.3.1\plugins</p><p>4、如果你的idea还是打开状态的话，建议重启一下idea，然后在你的idea的file–&gt;settings打开后就会看到Jrebel and Xrebel，找到它之后再按照网上提供的方法（也就是文章一开始的问题描述的那样，将对应的链接放入激活界面的方式进行激活）进行激活</p><p>5、激活成功后<br>最后建议把这个改为离线工作模式<br><img src="img_3.png" alt="img_3.png"></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://blog.csdn.net/chirp_CQ/article/details/128483587">【jrebel and xrebel问题记录】激活时出现LS client not configued</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>tools</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jrebel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven Wrapper</title>
    <link href="/2023/06/12/maven/Maven%20Wrapper/"/>
    <url>/2023/06/12/maven/Maven%20Wrapper/</url>
    
    <content type="html"><![CDATA[<p>Maven Wrapper 是一个用于构建 Maven 项目的工具，它可以帮助开发者自动化地下载和安装 Maven，以及管理 Maven 的版本和依赖项。Maven Wrapper 主要包含两个文件：maven-wrapper.jar 和 maven-wrapper.properties。</p><p>使用 Maven Wrapper 需要两个步骤：</p><ol><li><p>在项目根目录下放置 maven-wrapper.jar 和 maven-wrapper.properties 文件。</p></li><li><p>在命令行中使用 ./mvnw 或 mvnw.cmd 替代 mvn 命令，例如：</p></li></ol><pre><code class="hljs">./mvnw clean package</code></pre><p>或者：</p><pre><code class="hljs">mvnw.cmd clean package</code></pre><p>Maven Wrapper 会自动下载和安装与项目匹配的 Maven 版本，并使用该版本构建项目。使用 Maven Wrapper 的好处是可以避免在不同环境中安装不同版本的 Maven，以及避免在多个项目中使用不同版本的 Maven 导致冲突。</p><p>注意：在使用 Maven Wrapper 时，需要保证项目根目录下的 maven-wrapper.properties 文件与项目中使用的 Maven 版本匹配，否则可能会出现构建错误。</p>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>H3C NX30Pro 刷 openwrt 教程</title>
    <link href="/2023/06/12/other/H3C%20NX30Pro%20%E5%88%B7%20openwrt%20%E6%95%99%E7%A8%8B/"/>
    <url>/2023/06/12/other/H3C%20NX30Pro%20%E5%88%B7%20openwrt%20%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ff5ec665d-ba08-4091-bdb9-dd721106d127%2FSnipaste_2023-06-04_19-08-05.png?table=block&id=18281d71-3fc8-484b-9748-b90a69be3414&cache=v2" alt="notion image"></p><p>H3C NX30 Pro 就是目前百元路由器中性价比最高的（除了运营商定制机），京东618促销价格在159元左右，非常推荐。H3C NX30 Pro 和 360 T7、小米 WR30U 的硬件配置完全一样，用的都是百元路由器神U MT7981B，arm A53 双核 1.3Ghz，256M 的内存，也都是内置功放 Wi-Fi 信号没差，都是 200 元内最好。H3C NX30 Pro 主要优势是非运营商定制限制少，购买和保修都方便，目前刷机也是最方便的。</p><ul><li>  主要参考了<a href="https://www.right.com.cn/forum/thread-8291820-1-1.html">恩山 237 的帖子</a>，也用的他的固件。</li></ul><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ul><li><p>  H3C NX30 Pro 路由器</p></li><li><p>  有网口的 Windows 电脑（主要用 telnet、ssh，别的系统也行）</p></li><li><p>  <a href="https://share.qust.me/%E8%B7%AF%E7%94%B1%E5%99%A8/NX30Pro">下载需要的文件</a>（包含了 termius、winscp、和固件）</p></li></ul><h3 id="开启-SSH"><a href="#开启-SSH" class="headerlink" title="开启 SSH"></a>开启 SSH</h3><p>这一步请确保路由器能正常联网。NX30 Pro 默认开启了 telnet，默认的地址是 192.168.124.1，用户名是 H3C（全大写），密码就你设置的路由器后台密码，端口是 99。</p><p>打开 termius 选择 New Host 添加，Address 填写 192.168.124.1，取消勾选 SSH，勾选 Telnet，Port 端口填写上 99。</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F82fada35-f101-41ce-ba46-31dc43c86a2a%2FSnipaste_2023-06-04_17-30-30.png?table=block&id=e93fd997-b518-4f65-a880-cb8df1fd25e1&cache=v2" alt="notion image"></p><p>然后输入用户名和密码，输入密码不会显示，回车即可连上 Telnet。</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ffd8ddf35-e495-4f1d-99d6-143c90497aef%2FSnipaste_2023-06-04_17-29-52.png?table=block&id=3215fea7-49d1-493b-aaf4-9940db903ca4&cache=v2" alt="notion image"></p><p>然后复制下面的代码到终端里执行即可开启 SSH：</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Ffa297ff8-df2e-468c-9a2a-42aba811b7e6%2FSnipaste_2023-06-04_17-43-21.png?table=block&id=f240e432-97b6-49e5-a50a-51f0fbb5e7c2&cache=v2" alt="notion image"></p><h3 id="备份系统"><a href="#备份系统" class="headerlink" title="备份系统"></a>备份系统</h3><p>在终端里执行这命令，将系统备份到 tmp 路径下，备份的过程比较慢，需要 1-2 分钟。</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F0d538e33-3405-44a1-8f1a-2b68fe240dbb%2FSnipaste_2023-06-04_17-54-24.png?table=block&id=df382e67-f785-4a00-8e1f-e072279092d0&cache=v2" alt="notion image"></p><p>然后打开 WinSCP，文件协议选择 SCP，主机名 192.168.124.1，端口号 22，用户名 H3C，然后登录输入密码就能连上。</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd4256e7e-32af-4f8e-90f4-a2041815ba11%2FSnipaste_2023-06-04_17-59-16.png?table=block&id=df35f2c9-e745-4d65-92e7-cd44841a5740&cache=v2" alt="notion image"></p><p>登录后，将右侧 NX30Pro tmp 路径下的 backup.img 文件拖到右边电脑上保存，刷回官方固件需要用到。</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F2c1686e6-571b-4b4b-bf1d-c4194590c66d%2FSnipaste_2023-06-04_18-00-40.png?table=block&id=a2f25544-1e26-4e83-9234-b4da6ec89275&cache=v2" alt="notion image"></p><h3 id="刷写-uboot"><a href="#刷写-uboot" class="headerlink" title="刷写 uboot"></a>刷写 uboot</h3><p>将下载好的 uboot.bin 文件从左边电脑拖进右侧路由器 tmp 路径下。<br>然后执行命令，如图所示完成了写入 uboot。（请确保MD5 校验结果和图中相同，再敲回车执行，否则会变砖）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /tmp<br><span class="hljs-built_in">md5sum</span> uboot.bin<br>mtd write /tmp/uboot.bin FIP<br></code></pre></td></tr></table></figure><h3 id="刷写-openwrt"><a href="#刷写-openwrt" class="headerlink" title="刷写 openwrt"></a>刷写 openwrt</h3><p>路由器断电后，先按住背后 Reset 恢复按钮不放，再插电，等待 10s 左右松开背后 Reset，路由器就进入了 uboot，电脑用网线连接路由器 LAN1，并设置好静态 IP：IP地址填 192.168.1.2，子网掩码 255.255.255.0，网关 192.168.1.1，DNS 192.168.1.1。</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F99850372-fe52-4822-be76-5c3965577fe1%2FSnipaste_2023-06-04_18-52-10.png?table=block&id=6eda3d57-afec-4ed8-a398-c8e18393d840&cache=v2" alt="notion image"></p><p>现在浏览器打开 192.168.1.1 就能打开 uboot 后台。</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fd346bcca-fa78-4a4c-be4e-a5cd85e24bcd%2FSnipaste_2023-06-04_18-54-38.png?table=block&id=f51780be-0c2a-4b58-a800-642a9512836a&cache=v2" alt="notion image"></p><p>选择下载好的 NX30pro 的固件，upload 上传后，update 更新，写入即可。</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F342bfdb9-0608-45ad-aab6-d5e079cdafb9%2FSnipaste_2023-06-04_18-56-37.png?table=block&id=d94d2567-b017-473c-ac0e-8f8d8b65584b&cache=v2" alt="notion image"></p><p>更新完成后系统会重启进入 openwrt 的系统，默认的 WiFi 是 MTK 开头没有密码，后台地址 192.168.6.1，用户名 root，密码 password。</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2F96baccb6-f4dc-4369-b66e-fa8b589ed0f7%2FSnipaste_2023-06-04_18-58-15.png?table=block&id=71e89277-96fa-434e-bc3f-25c2d53b0f42&cache=v2" alt="notion image"></p><h3 id="刷回官方"><a href="#刷回官方" class="headerlink" title="刷回官方"></a>刷回官方</h3><p>刷回官方非常简单，进入 uboot 后选择之前备份的 backup.img 文件更新即可，系统就会重启进入官方的系统。</p><p><img src="https://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc1182f7b-e233-4edb-ba08-79016c96fb88%2FSnipaste_2023-06-04_18-59-03.png?table=block&id=d9b123d7-ad01-4468-96ed-9a058c064870&cache=v2" alt="notion image"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>H3C NX30 Pro 和之前推荐的两款 MT7981B 的路由配置没区别，非运营商定制，和最方便的刷机就是最大的优势，两百元价格内 MT7981B 的路由器有着最优秀的 WiFi 信号，还算不错的 CPU 性能，但我认为最重要的是能刷机并且有好的社区支持。</p><p>注意点:</p><ul><li>直接运行脚本,即可,中间会出现error无视即可</li><li>使用脚本下载文件时出现timeout超时现象时,可以直接将文件拷贝进去</li><li>拷贝文件使用winscp工具,或者直接使用scp命令即可</li><li>刷大分区固件和过度固件后,刷回官方可能会挂</li></ul><h3 id="问题"><a href="#问题" class="headerlink" title="问题:"></a>问题:</h3><ul><li>刷机成功后,再使用备份的镜像进行恢复,可以正常使用,但是更新h3c系统后,无法正常启动,以联系jd售后维修</li></ul><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://blog.qust.me/nx30pro">H3C NX30Pro 刷 openwrt 教程</a></li><li><a href="https://www.youtube.com/watch?v=0-liA6zihQQ&t=167s">NX30Pro完美刷机 | 刷入openwrt系统能顶软路由？</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>H3C NX30Pro</tag>
      
      <tag>openwrt</tag>
      
      <tag>路由器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux（Centos7）查看配置防火墙状态firewall、iptable</title>
    <link href="/2023/05/19/linux/linux%EF%BC%88Centos7%EF%BC%89%E6%9F%A5%E7%9C%8B%E9%85%8D%E7%BD%AE%E9%98%B2%E7%81%AB%E5%A2%99%E7%8A%B6%E6%80%81firewall%E3%80%81iptable/"/>
    <url>/2023/05/19/linux/linux%EF%BC%88Centos7%EF%BC%89%E6%9F%A5%E7%9C%8B%E9%85%8D%E7%BD%AE%E9%98%B2%E7%81%AB%E5%A2%99%E7%8A%B6%E6%80%81firewall%E3%80%81iptable/</url>
    
    <content type="html"><![CDATA[<blockquote><p>CentOS7 的防火墙配置跟以前版本有很大区别，CentOS7这个版本的防火墙默认使用的是firewall，与之前的版本Centos 6.x使用iptables不一样</p></blockquote><h2 id="一、iptables防火墙"><a href="#一、iptables防火墙" class="headerlink" title="一、iptables防火墙"></a>一、iptables防火墙</h2><h3 id="1、基本操作"><a href="#1、基本操作" class="headerlink" title="1、基本操作"></a>1、基本操作</h3><pre><code class="hljs"># 查看防火墙状态service iptables status# 停止防火墙service iptables stop# 启动防火墙service iptables start# 重启防火墙service iptables restart# 永久关闭防火墙chkconfig iptables off# 永久关闭后重启chkconfig iptables on</code></pre><h3 id="2、开启80端口"><a href="#2、开启80端口" class="headerlink" title="2、开启80端口"></a>2、开启80端口</h3><pre><code class="hljs">vim /etc/sysconfig/iptables# 加入如下代码-A INPUT -m state --state NEW -m tcp -p tcp --dport 80 -j ACCEPT保存退出后重启防火墙service iptables restart</code></pre><h2 id="二、firewall防火墙"><a href="#二、firewall防火墙" class="headerlink" title="二、firewall防火墙"></a>二、firewall防火墙</h2><h3 id="1、查看firewall服务状态"><a href="#1、查看firewall服务状态" class="headerlink" title="1、查看firewall服务状态"></a>1、查看firewall服务状态</h3><pre><code class="hljs">systemctl status firewalld#出现Active: active (running)切高亮显示则表示是启动状态。#出现 Active: inactive (dead)灰色表示停止，看单词也行。</code></pre><h3 id="2、查看firewall的状态"><a href="#2、查看firewall的状态" class="headerlink" title="2、查看firewall的状态"></a>2、查看firewall的状态</h3><pre><code class="hljs">firewall-cmd --state</code></pre><h3 id="3、开启、重启、关闭、firewalld-service服务"><a href="#3、开启、重启、关闭、firewalld-service服务" class="headerlink" title="3、开启、重启、关闭、firewalld.service服务"></a>3、开启、重启、关闭、firewalld.service服务</h3><pre><code class="hljs"># 开启service firewalld start# 重启service firewalld restart# 关闭service firewalld stop</code></pre><h3 id="4、查看防火墙规则"><a href="#4、查看防火墙规则" class="headerlink" title="4、查看防火墙规则"></a>4、查看防火墙规则</h3><pre><code class="hljs">firewall-cmd --list-all</code></pre><h3 id="5、查询、开放、关闭端口"><a href="#5、查询、开放、关闭端口" class="headerlink" title="5、查询、开放、关闭端口"></a>5、查询、开放、关闭端口</h3><pre><code class="hljs"># 查询端口是否开放firewall-cmd --query-port=8080/tcp# 开放80端口firewall-cmd --permanent --add-port=80/tcp# 移除端口firewall-cmd --permanent --remove-port=8080/tcp#重启防火墙(修改配置后要重启防火墙)firewall-cmd --reload</code></pre><h3 id="6、参数解释"><a href="#6、参数解释" class="headerlink" title="6、参数解释"></a>6、参数解释</h3><pre><code class="hljs">1、firwall-cmd：是Linux提供的操作firewall的一个工具；2、--permanent：表示设置为持久；3、--add-port：标识添加的端口；</code></pre><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="http://www.05bd.com/1025.html">linux（Centos7）查看配置防火墙状态firewall、iptable</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>firewall</tag>
      
      <tag>iptable</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 ... 运算符进行解包</title>
    <link href="/2023/05/18/js/%E4%BD%BF%E7%94%A8%20...%20%E8%BF%90%E7%AE%97%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%A7%A3%E5%8C%85/"/>
    <url>/2023/05/18/js/%E4%BD%BF%E7%94%A8%20...%20%E8%BF%90%E7%AE%97%E7%AC%A6%E8%BF%9B%E8%A1%8C%E8%A7%A3%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>在JavaScript中，使用 <code>...</code> 运算符可以将一个可迭代对象（如数组或字符串）解包为单独的元素。以下是一些使用 <code>...</code> 运算符解包的示例：</p><ol><li>解包数组：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(...arr); <span class="hljs-comment">// Output: 1 2 3</span><br></code></pre></td></tr></table></figure><ol start="2"><li>解包字符串：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">&#x27;Hello&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(...str); <span class="hljs-comment">// Output: H e l l o</span><br></code></pre></td></tr></table></figure><ol start="3"><li>将两个数组合并：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br><span class="hljs-keyword">const</span> combined = [...arr1, ...arr2];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(combined); <span class="hljs-comment">// Output: [1, 2, 3, 4, 5, 6]</span><br></code></pre></td></tr></table></figure><ol start="4"><li>将一个数组插入到另一个数组的中间：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>];<br><span class="hljs-keyword">const</span> result = [...arr1.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), ...arr2, ...arr1.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// Output: [1, 4, 5, 6, 2, 3]</span><br></code></pre></td></tr></table></figure><p>在这个示例中，我们使用 <code>slice</code> 方法从 <code>arr1</code> 中提取第一个元素，并将其与 <code>arr2</code> 和余下的 <code>arr1</code> 元素合并。最终结果是一个新的数组 <code>[1, 4, 5, 6, 2, 3]</code>。</p><p>希望这些示例能帮助您理解如何使用 <code>...</code> 运算符解包数据。</p>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gerrit</title>
    <link href="/2023/05/05/gerrit/gerrit/"/>
    <url>/2023/05/05/gerrit/gerrit/</url>
    
    <content type="html"><![CDATA[<p>Gerrit是一个基于代码审查的代码管理工具，每次提交代码都需要进行代码审查（Code Review）。这是Gerrit的核心功能之一，它可以确保代码质量和可维护性，并促进团队协作和知识共享。</p><p>在Gerrit中，每个提交都需要经过至少一个审阅者的审查才能被合并到主干分支中。审阅者可以是项目管理员、开发团队成员或其他有权限的人员。审阅者会对代码进行评估和反馈，包括代码风格、逻辑、安全性等方面的问题。开发人员需要根据审阅者的反馈进行修改和改进，直到代码达到审阅者的要求为止。</p><p>因此，每次提交都需要进行代码审查，这是Gerrit的基本原则之一。这种做法可以确保代码质量和可维护性，并促进团队协作和知识共享。</p><h2 id="使用api接口提交代码至gerrit"><a href="#使用api接口提交代码至gerrit" class="headerlink" title="使用api接口提交代码至gerrit"></a>使用api接口提交代码至gerrit</h2><p>要使用API接口提交代码至Gerrit，需要进行以下步骤：</p><ol><li><p>获取Gerrit的API访问权限：在Gerrit中，需要先获取API访问权限才能使用API接口提交代码。可以通过在Gerrit的Web界面中生成API访问令牌来获取API访问权限。</p></li><li><p>使用API接口提交代码：可以使用Gerrit的REST API接口来提交代码。具体步骤如下：</p><ul><li>构建提交信息：需要构建一个JSON格式的提交信息，包括提交的代码、提交信息、分支等信息。</li><li>使用HTTP POST请求提交代码：使用HTTP POST请求提交代码，将提交信息作为请求体发送到Gerrit的API接口中。</li><li>获取提交结果：根据API接口返回的结果，判断提交是否成功。</li></ul></li></ol><p>下面是一个使用curl命令提交代码至Gerrit的示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl -X POST -H <span class="hljs-string">&quot;Content-Type: application/json&quot;</span> -d @commit.json https://gerrit.example.com/a/changes/?o=ALL_REVISIONS<br></code></pre></td></tr></table></figure><p>其中，commit.json是一个JSON格式的提交信息文件，包括提交的代码、提交信息、分支等信息。提交信息的格式可以参考Gerrit的API文档。</p><p>需要注意的是，使用API接口提交代码需要具备一定的技术能力和安全意识，建议在熟悉API接口和Gerrit的使用规则后再进行操作。</p><h2 id="使用docekr部署gerrit"><a href="#使用docekr部署gerrit" class="headerlink" title="使用docekr部署gerrit"></a>使用docekr部署gerrit</h2><pre><code class="hljs">docker run -ti -p 8080:8080 -p 29418:29418 gerritcodereview/gerrit</code></pre><h2 id="Gerrit-Code-Review-Tool-Integration-for-the-IntelliJ-Platform"><a href="#Gerrit-Code-Review-Tool-Integration-for-the-IntelliJ-Platform" class="headerlink" title="Gerrit Code Review Tool Integration for the IntelliJ Platform"></a>Gerrit Code Review Tool Integration for the IntelliJ Platform</h2><p>   <a href="https://github.com/uwolfer/gerrit-intellij-plugin">https://github.com/uwolfer/gerrit-intellij-plugin</a></p><h2 id="gerrit设置部分用户组成员提交指定分支代码无需审核"><a href="#gerrit设置部分用户组成员提交指定分支代码无需审核" class="headerlink" title="gerrit设置部分用户组成员提交指定分支代码无需审核"></a>gerrit设置部分用户组成员提交指定分支代码无需审核</h2><p>要在Gerrit中设置部分用户组成员提交指定分支代码无需审核，您可以按照以下步骤进行操作：</p><ol><li><p>创建一个新的用户组：在Gerrit中创建一个新的用户组，例如<code>branch-admins</code>。</p></li><li><p>将用户添加到用户组中：将您想要允许提交指定分支代码的用户添加到<code>branch-admins</code>用户组中。</p></li><li><p>创建一个新的分支权限：在Gerrit中创建一个新的分支权限，例如<code>branch-admins-push</code>。</p></li><li><p>将用户组添加到分支权限中：将<code>branch-admins</code>用户组添加到<code>branch-admins-push</code>分支权限中。</p></li><li><p>将分支权限添加到分支访问控制列表中：将<code>branch-admins-push</code>分支权限添加到您想要允许提交代码的分支的访问控制列表中。</p></li></ol><p>例如，如果您想要允许<code>branch-admins</code>用户组成员提交<code>master</code>分支的代码无需审核，可以按照以下步骤进行操作：</p><ol><li><p>在Gerrit中创建一个新的用户组<code>branch-admins</code>，并将需要允许提交代码的用户添加到该用户组中。</p></li><li><p>在Gerrit中创建一个新的分支权限<code>branch-admins-push</code>，并将<code>branch-admins</code>用户组添加到该分支权限中。</p></li><li><p>在Gerrit中打开<code>master</code>分支的访问控制列表，并将<code>branch-admins-push</code>分支权限添加到该列表中。</p></li><li><p>保存更改并重启Gerrit服务。</p></li></ol><p>现在，<code>branch-admins</code>用户组成员就可以提交<code>master</code>分支的代码无需审核。请注意，这种设置可能会降低代码质量和安全性，因此应该谨慎使用。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://hub.docker.com/r/gerritcodereview/gerrit">gerritcodereview/gerrit</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Gerrit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TableLogic</title>
    <link href="/2023/05/05/mybatisplus/TableLogic/"/>
    <url>/2023/05/05/mybatisplus/TableLogic/</url>
    
    <content type="html"><![CDATA[<p>在 MyBatis Plus 中，@TableLogic 注解用于实现数据库数据逻辑删除。注意，该注解只对自动注入的 sql 起效：  </p><h3 id="插入（insert）"><a href="#插入（insert）" class="headerlink" title="插入（insert）"></a>插入（insert）</h3><p>不作限制</p><h3 id="查找（select）"><a href="#查找（select）" class="headerlink" title="查找（select）"></a>查找（select）</h3><p>@TableLogic 注解将会在 select 语句的 where 条件添加条件，过滤掉已删除数据，且使用 wrapper.entity 生成的 where 条件会忽略该字段。例如：</p><pre><code class="hljs">SELECT  user_id,name,sex,age,deleted  FROM  user  WHERE  user_id=1  AND  deleted=&#39;0&#39;</code></pre><h3 id="更新（update）"><a href="#更新（update）" class="headerlink" title="更新（update）"></a>更新（update）</h3><p>@TableLogic 注解将会在 update 语句的 where 条件后追加条件，防止更新到已删除数据，且使用 wrapper.entity 生成的 where条件会忽略该字段。例如：</p><pre><code class="hljs">UPDATE  user  SET  deleted=&#39;1&#39;  WHERE  user_id=1  AND  deleted=&#39;0&#39;</code></pre><h3 id="删除（delete）"><a href="#删除（delete）" class="headerlink" title="删除（delete）"></a>删除（delete）</h3><p>@TableLogic 注解会将 delete 语句转变为 update 语句，例如：</p><pre><code class="hljs">update  user  set  deleted=1  where  id  =  1  and  deleted=0</code></pre><p><strong>@TableLogic 字段类型支持说明：</strong></p><ul><li>支持所有数据类型（推荐使用 Integer、Boolean、LocalDateTime）</li><li>如果数据库字段使用 datetime，逻辑未删除值和已删除值支持配置为字符串 null，另一个值支持配置为函数来获取值如now()</li></ul><blockquote><p>附录：</p><p>（1）逻辑删除是为了方便数据恢复和保护数据本身价值等等的一种方案，但实际就是删除。</p><p>（2）如果你需要频繁查出来看就不应使用逻辑删除，而是以一个状态去表示。</p></blockquote><h2 id="TableLogic-属性"><a href="#TableLogic-属性" class="headerlink" title="@TableLogic 属性"></a>@TableLogic 属性</h2><p>该注解提供了两个属性，分别如下：  </p><h3 id="value"><a href="#value" class="headerlink" title="value"></a>value</h3><p>用来指定逻辑未删除值，默认为空字符串。</p><h3 id="delval"><a href="#delval" class="headerlink" title="delval"></a>delval</h3><p>用来指定逻辑删除值，默认为空字符串。</p><p>当然，你也可以不在 @TableLogic 注解中指定 value 和 delval 属性的值。使用全局逻辑删除配置信息，配置如下：</p><pre><code class="hljs">#  application.ymlmybatis-plus:  global-config:    db-config:      #  全局逻辑删除的实体字段名  (since  3.3.0,  配置后可以忽略  @TableLogic  中的配置)      logic-delete-field:  flag      #  逻辑已删除值(默认为  1)      logic-delete-value:  1      #  逻辑未删除值(默认为  0)      logic-not-delete-value:  0</code></pre><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>我们在 user 数据表中添加一个 deleted 字段。如果该字段值为1，表示记录被删除。如果该字段值为0，表示记录未被删除。详细步骤如下：</p><p>（1）向 user 数据表添加 deleted 字段，sql 如下：</p><p>–  添加一个  deleted  字段，实现逻辑删除<br>    ALTER  TABLE  <code>user</code><br>    ADD  COLUMN  <code>deleted</code>    varchar(1)  NULL  DEFAULT  0  COMMENT  ‘是否删除（1-删除；0-未删除）’;</p><p>（2）创建 user 表的实体类 AnnotationUser7Bean，代码如下：</p><pre><code class="hljs">package  com.hxstrive.mybatis_plus.model;import  com.baomidou.mybatisplus.annotation.*;@TableName(value  =  &quot;user&quot;)public  class  AnnotationUser7Bean  &#123;   @TableId(value  =  &quot;user_id&quot;,  type  =  IdType.AUTO)   private  int  userId;   @TableField(&quot;name&quot;)   private  String  name;   @TableField(&quot;sex&quot;)   private  String  sex;   @TableField(&quot;age&quot;)   private  Integer  age;   @TableLogic(value  =  &quot;0&quot;,  delval  =  &quot;1&quot;)   private  String  deleted;   //  忽略  getter  和  setter  方法   @Override   public  String  toString()  &#123;      return  &quot;UserBean&#123;&quot;  +            &quot;userId=&quot;  +  userId  +            &quot;,  name=&#39;&quot;  +  name  +  &#39;&#39;&#39;  +            &quot;,  sex=&#39;&quot;  +  sex  +  &#39;&#39;&#39;  +            &quot;,  age=&quot;  +  age  +            &quot;,  deleted=&quot;  +  deleted  +            &#39;&#125;&#39;;   &#125;&#125;</code></pre><p>上面代码中，使用 @TableLogic 注解将 deleted 成员变量指定为逻辑删除字段。如下：</p><pre><code class="hljs">@TableLogic(value  =  &quot;0&quot;,  delval  =  &quot;1&quot;)private  String  deleted;</code></pre><p>（3）客户端代码，先查询用户ID为1的用户是否存在。如果存在，则删除该用户信息。然后，查询用户ID小于10的用户信息，代码如下：</p><pre><code class="hljs">package  com.hxstrive.mybatis_plus.simple_mapper.annotation;import  com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;import  com.hxstrive.mybatis_plus.mapper.AnnotationUser7Mapper;import  com.hxstrive.mybatis_plus.model.AnnotationUser7Bean;import  org.junit.jupiter.api.Test;import  org.junit.runner.RunWith;import  org.springframework.beans.factory.annotation.Autowired;import  org.springframework.boot.test.context.SpringBootTest;import  org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestclass  AnnotationDemo7  &#123;    @Autowired    private  AnnotationUser7Mapper  userMapper;    @Test    void  contextLoads()  throws  Exception  &#123;        //  删除用户ID为1的用户信息        AnnotationUser7Bean  oldUserBean  =  userMapper.selectById(1);        if(null  !=  oldUserBean)  &#123;            userMapper.deleteById(oldUserBean.getUserId());        &#125;        //  查询用户信息        QueryWrapper&lt;AnnotationUser7Bean&gt;  wrapper  =  new  QueryWrapper&lt;&gt;();        wrapper.lt(&quot;user_id&quot;,  10);        for(AnnotationUser7Bean  item  :  userMapper.selectList(wrapper))  &#123;            System.out.println(item);        &#125;    &#125;&#125;</code></pre><p>执行上面代码，将顺序执行如下 SQL 语句：</p><p>a、根据用户ID查询用户信息，sql 如下：</p><pre><code class="hljs">Preparing:  SELECT  user_id,name,sex,age,deleted  FROM  user  WHERE  user_id=?  AND  deleted=&#39;0&#39;Parameters:  1(Integer)</code></pre><p>b、根据用户ID删除用户信息，sql 如下：</p><pre><code class="hljs">Preparing:  UPDATE  user  SET  deleted=&#39;1&#39;  WHERE  user_id=?  AND  deleted=&#39;0&#39;Parameters:  1(Integer)</code></pre><p>上面 sql 是一个更新语句，这是因为我们使用了逻辑删除，而不是物理删除。</p><p>c、查询用户ID小于10的用户信息，sql 如下：</p><pre><code class="hljs">Preparing:  SELECT  user_id,name,sex,age,deleted  FROM  user  WHERE  deleted=&#39;0&#39;  AND  (user_id  &lt;  ?)Parameters:  10(Integer)</code></pre><p>细心的读者，会发现上面每条 sql 的 where 语句都添加了 “deleted=’0’” 条件。这是因为 “deleted=’0’” 条件将过滤所有已删除的数据。</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://www.hxstrive.com/subject/mybatis_plus/309.htm">@TableLogic</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mybatisplus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>clash的Docker部署</title>
    <link href="/2023/04/28/clash%E7%9A%84Docker%E9%83%A8%E7%BD%B2/"/>
    <url>/2023/04/28/clash%E7%9A%84Docker%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>Clash for docker， 一个运行在docker上的代理客户端</p><p><img src="https://user-images.githubusercontent.com/1166872/47954055-97e6cb80-dfc0-11e8-991f-230fd40481e5.png"></p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="1-下载对应-docker-镜像"><a href="#1-下载对应-docker-镜像" class="headerlink" title="1.下载对应 docker 镜像"></a>1.下载对应 docker 镜像</h3><pre><code class="hljs">docker pull dreamacro/clash-premium:latest</code></pre><h3 id="2-配置-config-yaml-文件"><a href="#2-配置-config-yaml-文件" class="headerlink" title="2.配置 config.yaml 文件"></a>2.配置 config.yaml 文件</h3><p>其实直接把 <code>clash for windows</code> 的配置文件取出来就行，另外把配置文件中 <code>external-controller</code> 的值改为 <code>0.0.0.0:9090</code></p><h3 id="3-运行-docker"><a href="#3-运行-docker" class="headerlink" title="3.运行 docker"></a>3.运行 docker</h3><pre><code class="hljs">docker run -d --name=clash -v &quot;$PWD/config.yaml:/root/.config/clash/config.yaml&quot; -p &quot;7890:7890&quot; -p &quot;9090:9090&quot; --restart=unless-stopped dreamacro/clash-premium  </code></pre><h3 id="4-静态控制网页"><a href="#4-静态控制网页" class="headerlink" title="4.静态控制网页"></a>4.静态控制网页</h3><p>打开网址 <a href="http://yacd.haishan.me/">http://yacd.haishan.me/</a> 输入目标地址的ip和端口 <code>http://127.0.0.1:9090</code></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://xiakong24.github.io/posts/d16dfd6d/">clash 的 Docker 部署</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>clash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx服务部署 Vue 项目后刷新页面,出现 404 问题</title>
    <link href="/2023/04/28/vue/Nginx%20%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%20Vue%20%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2,%E5%87%BA%E7%8E%B0%20404%20%E9%97%AE%E9%A2%98/"/>
    <url>/2023/04/28/vue/Nginx%20%E6%9C%8D%E5%8A%A1%E9%83%A8%E7%BD%B2%20Vue%20%E9%A1%B9%E7%9B%AE%E5%90%8E%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2,%E5%87%BA%E7%8E%B0%20404%20%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>1.vue-cli 3.x<br>2.Nginx</p><p>项目之前vue-router使用默认‘hash’模式，在本地与部署线上环境后都没有问题，因为要去掉URL中的 ‘#’ 号，故使用‘history’路由模式，故再次部署线上环境后，首页能正常访问，菜单内点击切换也没有问题，但当你刷新页面后，则出现 404 Not Found，故在此记录一下解决办法</p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>刷新页面时访问的资源在服务端找不到，因为此时vue-router设置路由地址被当作url地址，此时的地址路径肯定不是真实存在的，所以出现404现象。</p><p><img src="https://cdn.learnku.com/uploads/images/201909/25/42064/CZeXEhfdeV.png!large" alt="Nginx服务部署Vue项目后刷新页面,出现404问题"></p><p>之所以出现上面的现象，是因为在nginx配置的根目录/www/wwwroot/ssoShuang/dist下面压根没有’Menu/index’这个真实资源存在，这些访问资源都是在js里渲染的。<br>服务端nginx的一开始配置如下（假设域名为：testwx.wangshibo.com）：</p><pre><code class="hljs">server&#123;    listen 80;    server_name testwx.wangshibo.com;    index index.php index.html index.htm default.php default.htm default.html;    root /www/wwwroot/ssoShuang/dist;&#125;</code></pre><p>如上出现404的原因是由于在这个域名根目录/www/wwwroot/ssoShuang/dist下面压根就没有’Menu/index’这个真实目录存在。</p><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>在服务端nginx配置里添加vue-route的跳转设置（这里首页是index.html，如果是index.php就在下面对应位置替换），正确配置如下：</p><pre><code class="hljs">server&#123;    listen 80;    server_name testwx.wangshibo.com;    index index.php index.html index.htm default.php default.htm default.html;    root /www/wwwroot/ssoShuang/dist;    #vue-router配置    location / &#123;        try_files $uri $uri/ @router;        index index.html;    &#125;    location @router &#123;        rewrite ^.*$ /index.html last;    &#125;&#125;</code></pre><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://learnku.com/articles/34440">Nginx 服务部署 Vue 项目后刷新页面,出现 404 问题</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用python-dotenv解决代码与敏感信息的分离</title>
    <link href="/2023/04/14/python/%E7%94%A8python-dotenv%E8%A7%A3%E5%86%B3%E4%BB%A3%E7%A0%81%E4%B8%8E%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E7%9A%84%E5%88%86%E7%A6%BB/"/>
    <url>/2023/04/14/python/%E7%94%A8python-dotenv%E8%A7%A3%E5%86%B3%E4%BB%A3%E7%A0%81%E4%B8%8E%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E7%9A%84%E5%88%86%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<p>“12-Factor” 是构建SaaS服务的一种方法论，这套理论适用于任意语言和后端服务（数据库、消息队列、缓存等）开发的应用程序。</p><p>其中有一条很重要的原则是关于配置的， 12-Factor 要求代码和配置严格分离。</p><p>为什么要这么做?</p><p>如果你的代码放在Github等外部网络，哪一天要是代码不小心泄露了，你的各种密码，密钥，等配置全都暴露于公网中，这是一件非常可怕的事。</p><p>判断一个应用是否正确的将配置与代码分离开了，一个简单方法是你的代码是否可以立刻开源，而不用担心有任何敏感信息暴露。</p><p>将应用的配置存储于环境变量中是一种常规做法，例如在命令行中加入：</p><pre><code class="hljs">export PASSWORD=123456</code></pre><p>windows</p><pre><code class="hljs">set PASSWORD=123456</code></pre><p>业务代码中，通过环境变量来加载。</p><pre><code class="hljs">import osenv = os.environ.get(&quot;PASSWORD&quot;)print(env)</code></pre><p>这样做就不会将敏感信息暴露于业务代码中了，同时也可以最大程度让开发人员接触正式环境的敏感信息。</p><p>不过，问题来了，将敏感信息设置成环境变量，如果这样的信息非常多，挨个设置也太麻烦了。</p><p>你一定希望可以将这些敏感信息单独放在一个文件中，始终与代码分开管理</p><p>例如，我们在一个flask项目中，敏感信息我们专门放在一个叫.flaskenv 的文件中</p><p>.flaskenv 文件</p><pre><code class="hljs">FLASK_DEBUG=1FLASK_ENV=localAAA=1234</code></pre><p>可是这些配置如何加载到环境变量中去？</p><h3 id="python-dotenv"><a href="#python-dotenv" class="headerlink" title="python-dotenv"></a>python-dotenv</h3><p>python-dotenv 就是专门干这事的，他能将配置文件的配置信息自动加入到环境变量。</p><p>安装 python-dotenv</p><pre><code class="hljs">pip install python-dotenv</code></pre><p>加载配置文件</p><pre><code class="hljs">from dotenv import load_dotenv# 加载文件load_dotenv(&quot;.flaskenv&quot;)import osflask_env = os.environ.get(&quot;FLASK_ENV&quot;)print(flask_env) # local</code></pre><p>加载文件后，就可以通过os.environ从环境变量中读取内容。</p><h3 id="flask配置最佳实践"><a href="#flask配置最佳实践" class="headerlink" title="flask配置最佳实践"></a>flask配置最佳实践</h3><p>在flask中，python-dotenv 可以无缝接入项目中，只要你的项目中存在 .env 或者 .flaskenv 文件，他就会提示你是否安装 python-dotenv</p><pre><code class="hljs">$ flask run * Tip: There are .env files present. Do &quot;pip install python-dotenv&quot; to use them.</code></pre><p>安装完后python-dotenv后，就会自动加载里面的配置文件到环境变量中。</p><pre><code class="hljs"># config.pyclass LocalConfig(BaseConfig):    ENV = &quot;development&quot;    FLASK_DEBUG = 1    # 通过变量环境来加载数据库配置    SQLALCHEMY_DATABASE_URI = os.getenv(&quot;SQLALCHEMY_DATABASE_URI&quot;)# app.pydef create_app():    app = Flask(__name__)    app.config.from_object(LocalConfig)# view.pydef hello():    # 加载环境变量    os.environ.get(&quot;AAA&quot;)</code></pre><p>你不需要自己去加载配置文件，因为flask-cli 帮你做了这个事，但是生产环境我们通常会基于gunicorn来部署我们的应用，这时候就没法自动加载了。你需要在生成app实例前显式加载配置文件。</p><pre><code class="hljs">#run.pyfrom app import create_appfrom dotenv import load_dotenvload_dotenv(&#39;.flaskenv&#39;) app = create_app()</code></pre><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://foofish.net/python-dotenv.html">用python-dotenv解决代码与敏感信息的分离</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MapStruct使用指南</title>
    <link href="/2023/03/31/java/MapStruct%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2023/03/31/java/MapStruct%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="MapStruct使用指南"><a href="#MapStruct使用指南" class="headerlink" title="MapStruct使用指南"></a>MapStruct使用指南</h1><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>随着微服务和分布式应用程序迅速占领开发领域，数据完整性和安全性比以往任何时候都更加重要。在这些松散耦合的系统之间，安全的通信渠道和有限的数据传输是最重要的。大多数时候，终端用户或服务不需要访问模型中的全部数据，而只需要访问某些特定的部分。</p><p>数据传输对象(Data Transfer Objects, DTO)经常被用于这些应用中。DTO只是持有另一个对象中被请求的信息的对象。通常情况下，这些信息是有限的一部分。例如，在持久化层定义的实体和发往客户端的DTO之间经常会出现相互之间的转换。由于DTO是原始对象的反映，因此这些类之间的映射器在转换过程中扮演着关键角色。</p><p>这就是MapStruct解决的问题：手动创建bean映射器非常耗时。 但是该库可以自动生成Bean映射器类。</p><p>在本文中，我们将深入研究<a href="https://link.juejin.cn/?target=https://mapstruct.org/" title="https://mapstruct.org/">MapStruct</a>。</p><h2 id="MapStruct"><a href="#MapStruct" class="headerlink" title="MapStruct"></a>MapStruct</h2><p>MapStruct是一个开源的基于Java的代码生成器，用于创建实现Java Bean之间转换的扩展映射器。使用MapStruct，我们只需要创建接口，而该库会通过注解在编译过程中自动创建具体的映射实现，大大减少了通常需要手工编写的样板代码的数量。</p><h3 id="MapStruct-依赖"><a href="#MapStruct-依赖" class="headerlink" title="MapStruct 依赖"></a>MapStruct 依赖</h3><p>如果你使用Maven的话，可以通过引入依赖安装MapStruct：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mapstruct<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mapstruct<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;org.mapstruct.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这个依赖项会导入MapStruct的核心注释。由于MapStruct在编译时工作，并且会集成到像Maven和Gradle这样的构建工具上，我们还必须在&lt;build中/&gt;标签中添加一个插件<code>maven-compiler-plugin</code>，并在其配置中添加<code>annotationProcessorPaths</code>，该插件会在构建时生成对应的代码。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">annotationProcessorPaths</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">path</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mapstruct<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mapstruct-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;org.mapstruct.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">path</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">annotationProcessorPaths</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>如果你使用Gradle的话，安装MapStruct会更简单：</p><pre><code class="hljs">plugins &#123;    id &#39;net.ltgt.apt&#39; version &#39;0.20&#39;&#125;apply plugin: &#39;net.ltgt.apt-idea&#39;apply plugin: &#39;net.ltgt.apt-eclipse&#39;dependencies &#123;    compile &quot;org.mapstruct:mapstruct:$&#123;mapstructVersion&#125;&quot;    annotationProcessor &quot;org.mapstruct:mapstruct-processor:$&#123;mapstructVersion&#125;&quot;&#125;</code></pre><p><code>net.ltgt.apt</code>插件会负责处理注释。你可以根据你使用的IDE启用插件<code>apt-idea</code>或<code>apt-eclipse</code>插件。</p><p><a href="https://link.juejin.cn/?target=https://search.maven.org/classic/%23search%257Cga%257C1%257Cg%253A%2522org.mapstruct%2522%2520AND%2520a%253A%2522mapstruct%2522" title="https://search.maven.org/classic/#search%7Cga%7C1%7Cg%3A%22org.mapstruct%22%20AND%20a%3A%22mapstruct%22">MapStruct</a>及其<a href="https://link.juejin.cn/?target=https://search.maven.org/classic/%23search%257Cga%257C1%257Cg%253A%2522org.mapstruct%2522%2520AND%2520a%253A%2522mapstruct-processor%2522" title="https://search.maven.org/classic/#search%7Cga%7C1%7Cg%3A%22org.mapstruct%22%20AND%20a%3A%22mapstruct-processor%22">处理器</a>的最新稳定版本都可以从<a href="https://link.juejin.cn/?target=https://search.maven.org/search?q=g:org.mapstruct" title="https://search.maven.org/search?q=g:org.mapstruct">Maven中央仓库</a>中获得。</p><h1 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h1><h2 id="基本映射"><a href="#基本映射" class="headerlink" title="基本映射"></a>基本映射</h2><p>我们先从一些基本的映射开始。我们会创建一个Doctor对象和一个DoctorDto。为了方便起见，它们的属性字段都使用相同的名称：</p><pre><code class="hljs">public class Doctor &#123;    private int id;    private String name;    // getters and setters or builder&#125;public class DoctorDto &#123;    private int id;    private String name;    // getters and setters or builder&#125;</code></pre><p>现在，为了在这两者之间进行映射，我们要创建一个<code>DoctorMapper</code>接口。对该接口使用<code>@Mapper</code>注解，MapStruct就会知道这是两个类之间的映射器。</p><pre><code class="hljs">@Mapperpublic interface DoctorMapper &#123;    DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.class);    DoctorDto toDto(Doctor doctor);&#125;</code></pre><p>这段代码中创建了一个<code>DoctorMapper</code>类型的实例<code>INSTANCE</code>，在生成对应的实现代码后，这就是我们调用的“入口”。</p><p>我们在接口中定义了<code>toDto()</code>方法，该方法接收一个<code>Doctor</code>实例为参数，并返回一个<code>DoctorDto</code>实例。这足以让MapStruct知道我们想把一个<code>Doctor</code>实例映射到一个<code>DoctorDto</code>实例。</p><p>当我们构建/编译应用程序时，MapStruct注解处理器插件会识别出DoctorMapper接口并为其生成一个实现类。</p><pre><code class="hljs">public class DoctorMapperImpl implements DoctorMapper &#123;    @Override    public DoctorDto toDto(Doctor doctor) &#123;        if ( doctor == null ) &#123;            return null;        &#125;        DoctorDtoBuilder doctorDto = DoctorDto.builder();        doctorDto.id(doctor.getId());        doctorDto.name(doctor.getName());        return doctorDto.build();    &#125;&#125;</code></pre><p><code>DoctorMapperImpl</code>类中包含一个<code>toDto()</code>方法，将我们的<code>Doctor</code>属性值映射到<code>DoctorDto</code>的属性字段中。如果要将<code>Doctor</code>实例映射到一个<code>DoctorDto</code>实例，可以这样写：</p><pre><code class="hljs">DoctorDto doctorDto = DoctorMapper.INSTANCE.toDto(doctor);</code></pre><p><strong>注意</strong>：你可能也注意到了上面实现代码中的<code>DoctorDtoBuilder</code>。因为builder代码往往比较长，为了简洁起见，这里省略了builder模式的实现代码。如果你的类中包含Builder，MapStruct会尝试使用它来创建实例；如果没有的话，MapStruct将通过<code>new</code>关键字进行实例化。</p><h2 id="不同字段间映射"><a href="#不同字段间映射" class="headerlink" title="不同字段间映射"></a>不同字段间映射</h2><p>通常，模型和DTO的字段名不会完全相同。由于团队成员各自指定命名，以及针对不同的调用服务，开发者对返回信息的打包方式选择不同，名称可能会有轻微的变化。</p><p>MapStruct通过<code>@Mapping</code>注解对这类情况提供了支持。</p><h3 id="不同属性名称"><a href="#不同属性名称" class="headerlink" title="不同属性名称"></a>不同属性名称</h3><p>我们先更新<code>Doctor</code>类，添加一个属性<code>specialty</code>：</p><pre><code class="hljs">public class Doctor &#123;    private int id;    private String name;    private String specialty;    // getters and setters or builder&#125;</code></pre><p>在<code>DoctorDto</code>类中添加一个<code>specialization</code>属性：</p><pre><code class="hljs">public class DoctorDto &#123;    private int id;    private String name;    private String specialization;    // getters and setters or builder&#125;</code></pre><p>现在，我们需要让 <code>DoctorMapper</code> 知道这里的不一致。我们可以使用 <code>@Mapping</code> 注解，并设置其内部的 <code>source</code> 和 <code>target</code> 标记分别指向不一致的两个字段。</p><pre><code class="hljs">@Mapperpublic interface DoctorMapper &#123;    DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.class);    @Mapping(source = &quot;doctor.specialty&quot;, target = &quot;specialization&quot;)    DoctorDto toDto(Doctor doctor);&#125;</code></pre><p>这个注解代码的含义是：<code>Doctor</code>中的<code>specialty</code>字段对应于<code>DoctorDto</code>类的 <code>specialization</code> 。</p><p>编译之后，会生成如下实现代码：</p><pre><code class="hljs">public class DoctorMapperImpl implements DoctorMapper &#123;@Override    public DoctorDto toDto(Doctor doctor) &#123;        if (doctor == null) &#123;            return null;        &#125;        DoctorDtoBuilder doctorDto = DoctorDto.builder();        doctorDto.specialization(doctor.getSpecialty());        doctorDto.id(doctor.getId());        doctorDto.name(doctor.getName());        return doctorDto.build();    &#125;&#125;</code></pre><h3 id="多个源类"><a href="#多个源类" class="headerlink" title="多个源类"></a>多个源类</h3><p>有时，单个类不足以构建DTO，我们可能希望将多个类中的值聚合为一个DTO，供终端用户使用。这也可以通过在<code>@Mapping</code>注解中设置适当的标志来完成。</p><p>我们先新建另一个对象 <code>Education</code>:</p><pre><code class="hljs">public class Education &#123;    private String degreeName;    private String institute;    private Integer yearOfPassing;    // getters and setters or builder&#125;</code></pre><p>然后向 <code>DoctorDto</code>中添加一个新的字段：</p><pre><code class="hljs">public class DoctorDto &#123;    private int id;    private String name;    private String degree;    private String specialization;    // getters and setters or builder&#125;</code></pre><p>接下来，将 <code>DoctorMapper</code> 接口更新为如下代码：</p><pre><code class="hljs">@Mapperpublic interface DoctorMapper &#123;    DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.class);    @Mapping(source = &quot;doctor.specialty&quot;, target = &quot;specialization&quot;)    @Mapping(source = &quot;education.degreeName&quot;, target = &quot;degree&quot;)    DoctorDto toDto(Doctor doctor, Education education);&#125;</code></pre><p>我们添加了另一个<code>@Mapping</code>注解，并将其<code>source</code>设置为<code>Education</code>类的<code>degreeName</code>，将<code>target</code>设置为<code>DoctorDto</code>类的<code>degree</code>字段。</p><p>如果 <code>Education</code> 类和 <code>Doctor</code> 类包含同名的字段，我们必须让映射器知道使用哪一个，否则它会抛出一个异常。举例来说，如果两个模型都包含一个<code>id</code>字段，我们就要选择将哪个类中的<code>id</code>映射到DTO属性中。</p><h2 id="子对象映射"><a href="#子对象映射" class="headerlink" title="子对象映射"></a>子对象映射</h2><p>多数情况下，POJO中不会_只_包含基本数据类型，其中往往会包含其它类。比如说，一个<code>Doctor</code>类中会有多个患者类：</p><pre><code class="hljs">public class Patient &#123;    private int id;    private String name;    // getters and setters or builder&#125;</code></pre><p>在Doctor中添加一个患者列表<code>List</code>：</p><pre><code class="hljs">public class Doctor &#123;    private int id;    private String name;    private String specialty;    private List&lt;Patient&gt; patientList;    // getters and setters or builder&#125;</code></pre><p>因为<code>Patient</code>需要转换，为其创建一个对应的DTO：</p><pre><code class="hljs">public class PatientDto &#123;    private int id;    private String name;    // getters and setters or builder&#125;</code></pre><p>最后，在 <code>DoctorDto</code> 中新增一个存储 <code>PatientDto</code>的列表：</p><pre><code class="hljs">public class DoctorDto &#123;    private int id;    private String name;    private String degree;    private String specialization;    private List&lt;PatientDto&gt; patientDtoList;    // getters and setters or builder&#125;</code></pre><p>在修改 <code>DoctorMapper</code>之前，我们先创建一个支持 <code>Patient</code> 和 <code>PatientDto</code> 转换的映射器接口：</p><pre><code class="hljs">@Mapperpublic interface PatientMapper &#123;    PatientMapper INSTANCE = Mappers.getMapper(PatientMapper.class);    PatientDto toDto(Patient patient);&#125;</code></pre><p>这是一个基本映射器，只会处理几个基本数据类型。</p><p>然后，我们再来修改 <code>DoctorMapper</code> 处理一下患者列表：</p><pre><code class="hljs">@Mapper(uses = &#123;PatientMapper.class&#125;)public interface DoctorMapper &#123;    DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.class);    @Mapping(source = &quot;doctor.patientList&quot;, target = &quot;patientDtoList&quot;)    @Mapping(source = &quot;doctor.specialty&quot;, target = &quot;specialization&quot;)    DoctorDto toDto(Doctor doctor);&#125;</code></pre><p>因为我们要处理另一个需要映射的类，所以这里设置了<code>@Mapper</code>注解的<code>uses</code>标志，这样现在的 <code>@Mapper</code> 就可以使用另一个 <code>@Mapper</code>映射器。我们这里只加了一个，但你想在这里添加多少class/mapper都可以。</p><p>我们已经添加了<code>uses</code>标志，所以在为<code>DoctorMapper</code>接口生成映射器实现时，MapStruct 也会把 <code>Patient</code> 模型转换成 <code>PatientDto</code> ——因为我们已经为这个任务注册了 <code>PatientMapper</code>。</p><p>编译查看最新想实现代码：</p><pre><code class="hljs">public class DoctorMapperImpl implements DoctorMapper &#123;    private final PatientMapper patientMapper = Mappers.getMapper( PatientMapper.class );    @Override    public DoctorDto toDto(Doctor doctor) &#123;        if ( doctor == null ) &#123;            return null;        &#125;        DoctorDtoBuilder doctorDto = DoctorDto.builder();        doctorDto.patientDtoList( patientListToPatientDtoList(doctor.getPatientList()));        doctorDto.specialization( doctor.getSpecialty() );        doctorDto.id( doctor.getId() );        doctorDto.name( doctor.getName() );        return doctorDto.build();    &#125;        protected List&lt;PatientDto&gt; patientListToPatientDtoList(List&lt;Patient&gt; list) &#123;        if ( list == null ) &#123;            return null;        &#125;        List&lt;PatientDto&gt; list1 = new ArrayList&lt;PatientDto&gt;( list.size() );        for ( Patient patient : list ) &#123;            list1.add( patientMapper.toDto( patient ) );        &#125;        return list1;    &#125;&#125;</code></pre><p>显然，除了<code>toDto()</code>映射方法外，最终实现中还添加了一个新的映射方法—— <code>patientListToPatientDtoList()</code>。这个方法是在没有显式定义的情况下添加的，只是因为我们把<code>PatientMapper</code>添加到了<code>DoctorMapper</code>中。</p><p>该方法会遍历一个<code>Patient</code>列表，将每个元素转换为<code>PatientDto</code>，并将转换后的对象添加到<code>DoctorDto</code>对象内中的列表中。</p><h2 id="更新现有实例"><a href="#更新现有实例" class="headerlink" title="更新现有实例"></a>更新现有实例</h2><p>有时，我们希望用DTO的最新值更新一个模型中的属性，对目标对象(我们的例子中是<code>DoctorDto</code>)使用<code>@MappingTarget</code>注解，就可以更新现有的实例.</p><pre><code class="hljs">@Mapper(uses = &#123;PatientMapper.class&#125;)public interface DoctorMapper &#123;    DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.class);    @Mapping(source = &quot;doctorDto.patientDtoList&quot;, target = &quot;patientList&quot;)    @Mapping(source = &quot;doctorDto.specialization&quot;, target = &quot;specialty&quot;)    void updateModel(DoctorDto doctorDto, @MappingTarget Doctor doctor);&#125;</code></pre><p>重新生成实现代码，就可以得到<code>updateModel()</code>方法：</p><pre><code class="hljs">public class DoctorMapperImpl implements DoctorMapper &#123;    @Override    public void updateModel(DoctorDto doctorDto, Doctor doctor) &#123;        if (doctorDto == null) &#123;            return;        &#125;        if (doctor.getPatientList() != null) &#123;            List&lt;Patient&gt; list = patientDtoListToPatientList(doctorDto.getPatientDtoList());            if (list != null) &#123;                doctor.getPatientList().clear();                doctor.getPatientList().addAll(list);            &#125;            else &#123;                doctor.setPatientList(null);            &#125;        &#125;        else &#123;            List&lt;Patient&gt; list = patientDtoListToPatientList(doctorDto.getPatientDtoList());            if (list != null) &#123;                doctor.setPatientList(list);            &#125;        &#125;        doctor.setSpecialty(doctorDto.getSpecialization());        doctor.setId(doctorDto.getId());        doctor.setName(doctorDto.getName());    &#125;&#125;</code></pre><p>值得注意的是，由于患者列表是该模型中的子实体，因此患者列表也会进行更新。</p><h1 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h1><h2 id="数据类型映射"><a href="#数据类型映射" class="headerlink" title="数据类型映射"></a>数据类型映射</h2><p>MapStruct支持<code>source</code>和<code>target</code>属性之间的数据类型转换。它还提供了基本类型及其相应的包装类之间的自动转换。</p><p>自动类型转换适用于：</p><ul><li>  基本类型及其对应的包装类之间。比如， <code>int</code> 和 <code>Integer</code>， <code>float</code> 和 <code>Float</code>， <code>long</code> 和 <code>Long</code>，<code>boolean</code> 和 <code>Boolean</code> 等。</li><li>  任意基本类型与任意包装类之间。如 <code>int</code> 和 <code>long</code>， <code>byte</code> 和 <code>Integer</code> 等。</li><li>  所有基本类型及包装类与<code>String</code>之间。如 <code>boolean</code> 和 <code>String</code>， <code>Integer</code> 和 <code>String</code>， <code>float</code> 和 <code>String</code> 等。</li><li>  枚举和<code>String</code>之间。</li><li>  Java大数类型(<code>java.math.BigInteger</code>， <code>java.math.BigDecimal</code>) 和Java基本类型(包括其包装类)与<code>String</code>之间。</li><li>  其它情况详见<a href="https://link.juejin.cn/?target=https://mapstruct.org/documentation/stable/reference/html/%23implicit-type-conversions" title="https://mapstruct.org/documentation/stable/reference/html/#implicit-type-conversions">MapStruct官方文档</a>。</li></ul><p>因此，在生成映射器代码的过程中，如果源字段和目标字段之间属于上述任何一种情况，则MapStrcut会自行处理类型转换。</p><p>我们修改 <code>PatientDto</code> ，新增一个 <code>dateofBirth</code>字段：</p><pre><code class="hljs">public class PatientDto &#123;    private int id;    private String name;    private LocalDate dateOfBirth;    // getters and setters or builder&#125;</code></pre><p>另一方面，加入 <code>Patient</code> 对象中有一个<code>String</code> 类型的 <code>dateOfBirth</code> ：</p><pre><code class="hljs">public class Patient &#123;    private int id;    private String name;    private String dateOfBirth;    // getters and setters or builder&#125;</code></pre><p>在两者之间创建一个映射器：</p><pre><code class="hljs">@Mapperpublic interface PatientMapper &#123;    @Mapping(source = &quot;dateOfBirth&quot;, target = &quot;dateOfBirth&quot;, dateFormat = &quot;dd/MMM/yyyy&quot;)    Patient toModel(PatientDto patientDto);&#125;</code></pre><p>当对日期进行转换时，我们也可以使用 <code>dateFormat</code> 设置格式声明。生成的实现代码形式大致如下：</p><pre><code class="hljs">public class PatientMapperImpl implements PatientMapper &#123;    @Override    public Patient toModel(PatientDto patientDto) &#123;        if (patientDto == null) &#123;            return null;        &#125;        PatientBuilder patient = Patient.builder();        if (patientDto.getDateOfBirth() != null) &#123;            patient.dateOfBirth(DateTimeFormatter.ofPattern(&quot;dd/MMM/yyyy&quot;)                                .format(patientDto.getDateOfBirth()));        &#125;        patient.id(patientDto.getId());        patient.name(patientDto.getName());        return patient.build();    &#125;&#125;</code></pre><p>可以看到，这里使用了 <code>dateFormat</code> 声明的日期格式。如果我们没有声明格式的话，MapStruct会使用 <code>LocalDate</code>的默认格式，大致如下：</p><pre><code class="hljs">if (patientDto.getDateOfBirth() != null) &#123;    patient.dateOfBirth(DateTimeFormatter.ISO_LOCAL_DATE                        .format(patientDto.getDateOfBirth()));&#125;</code></pre><h3 id="数字格式转换"><a href="#数字格式转换" class="headerlink" title="数字格式转换"></a>数字格式转换</h3><p>上面的例子中可以看到，在进行日期转换的时候，可以通过<code>dateFormat</code>标志指定日期的格式。</p><p>除此之外，对于数字的转换，也可以使用<code>numberFormat</code>指定显示格式：</p><pre><code class="hljs">   // 数字格式转换示例   @Mapping(source = &quot;price&quot;, target = &quot;price&quot;, numberFormat = &quot;$#.00&quot;)</code></pre><h2 id="枚举映射"><a href="#枚举映射" class="headerlink" title="枚举映射"></a>枚举映射</h2><p>枚举映射的工作方式与字段映射相同。MapStruct会对具有相同名称的枚举进行映射，这一点没有问题。但是，对于具有不同名称的枚举项，我们需要使用<code>@ValueMapping</code>注解。同样，这与普通类型的<code>@Mapping</code>注解也相似。</p><p>我们先创建两个枚举。第一个是 <code>PaymentType</code>:</p><pre><code class="hljs">public enum PaymentType &#123;    CASH,    CHEQUE,    CARD_VISA,    CARD_MASTER,    CARD_CREDIT&#125;</code></pre><p>比如说，这是一个应用内可用的支付方式，现在我们要根据这些选项创建一个更一般、有限的识图：</p><pre><code class="hljs">public enum PaymentTypeView &#123;    CASH,    CHEQUE,    CARD&#125;</code></pre><p>现在，我们创建这两个<code>enum</code>之间的映射器接口：</p><pre><code class="hljs">@Mapperpublic interface PaymentTypeMapper &#123;    PaymentTypeMapper INSTANCE = Mappers.getMapper(PaymentTypeMapper.class);    @ValueMappings(&#123;            @ValueMapping(source = &quot;CARD_VISA&quot;, target = &quot;CARD&quot;),            @ValueMapping(source = &quot;CARD_MASTER&quot;, target = &quot;CARD&quot;),            @ValueMapping(source = &quot;CARD_CREDIT&quot;, target = &quot;CARD&quot;)    &#125;)    PaymentTypeView paymentTypeToPaymentTypeView(PaymentType paymentType);&#125;</code></pre><p>这个例子中，我们设置了一般性的<code>CARD</code>值，和更具体的 <code>CARD_VISA</code>, <code>CARD_MASTER</code> 和 <code>CARD_CREDIT</code> 。两个枚举间的枚举项数量不匹配—— <code>PaymentType</code> 有5个值，而 <code>PaymentTypeView</code> 只有3个。</p><p>为了在这些枚举项之间建立桥梁，我们可以使用<code>@ValueMappings</code>注解，该注解中可以包含多个<code>@ValueMapping</code>注解。这里，我们将<code>source</code>设置为三个具体枚举项之一，并将<code>target</code>设置为<code>CARD</code>。</p><p>MapStruct自然会处理这些情况：</p><pre><code class="hljs">public class PaymentTypeMapperImpl implements PaymentTypeMapper &#123;    @Override    public PaymentTypeView paymentTypeToPaymentTypeView(PaymentType paymentType) &#123;        if (paymentType == null) &#123;            return null;        &#125;        PaymentTypeView paymentTypeView;        switch (paymentType) &#123;            case CARD_VISA: paymentTypeView = PaymentTypeView.CARD;            break;            case CARD_MASTER: paymentTypeView = PaymentTypeView.CARD;            break;            case CARD_CREDIT: paymentTypeView = PaymentTypeView.CARD;            break;            case CASH: paymentTypeView = PaymentTypeView.CASH;            break;            case CHEQUE: paymentTypeView = PaymentTypeView.CHEQUE;            break;            default: throw new IllegalArgumentException( &quot;Unexpected enum constant: &quot; + paymentType );        &#125;        return paymentTypeView;    &#125;&#125;</code></pre><p><code>CASH</code>和<code>CHEQUE</code>默认转换为对应值，特殊的 <code>CARD</code> 值通过<code>switch</code>循环处理。</p><p>但是，如果你要将很多值转换为一个更一般的值，这种方式就有些不切实际了。其实我们不必手动分配每一个值，只需要让MapStruct将所有剩余的可用枚举项（在目标枚举中找不到相同名称的枚举项），直接转换为对应的另一个枚举项。</p><p>可以通过 <code>MappingConstants</code>实现这一点：</p><pre><code class="hljs">@ValueMapping(source = MappingConstants.ANY_REMAINING, target = &quot;CARD&quot;)PaymentTypeView paymentTypeToPaymentTypeView(PaymentType paymentType);</code></pre><p>在这个例子中，完成默认映射之后，所有剩余（未匹配）的枚举项都会映射为<code>CARD</code>：</p><pre><code class="hljs">@Overridepublic PaymentTypeView paymentTypeToPaymentTypeView(PaymentType paymentType) &#123;    if ( paymentType == null ) &#123;        return null;    &#125;    PaymentTypeView paymentTypeView;    switch ( paymentType ) &#123;        case CASH: paymentTypeView = PaymentTypeView.CASH;        break;        case CHEQUE: paymentTypeView = PaymentTypeView.CHEQUE;        break;        default: paymentTypeView = PaymentTypeView.CARD;    &#125;    return paymentTypeView;&#125;</code></pre><p>还有一种选择是使用<code>ANY UNMAPPED</code>：</p><pre><code class="hljs">@ValueMapping(source = MappingConstants.ANY_UNMAPPED, target = &quot;CARD&quot;)PaymentTypeView paymentTypeToPaymentTypeView(PaymentType paymentType);</code></pre><p>采用这种方式时，MapStruct不会像前面那样先处理默认映射，再将剩余的枚举项映射到<code>target</code>值。而是，直接将_所有_未通过<code>@ValueMapping</code>注解做显式映射的值都转换为<code>target</code>值。</p><h2 id="集合映射"><a href="#集合映射" class="headerlink" title="集合映射"></a>集合映射</h2><p>简单来说，使用MapStruct处理集合映射的方式与处理简单类型相同。</p><p>我们创建一个简单的接口或抽象类并声明映射方法。 MapStruct将根据我们的声明自动生成映射代码。 通常，生成的代码会遍历源集合，将每个元素转换为目标类型，并将每个转换后元素添加到目标集合中。</p><h3 id="List映射"><a href="#List映射" class="headerlink" title="List映射"></a>List映射</h3><p>我们先定义一个新的映射方法：</p><pre><code class="hljs">@Mapperpublic interface DoctorMapper &#123;    List&lt;DoctorDto&gt; map(List&lt;Doctor&gt; doctor);&#125;</code></pre><p>生成的代码大致如下：</p><pre><code class="hljs">public class DoctorMapperImpl implements DoctorMapper &#123;    @Override    public List&lt;DoctorDto&gt; map(List&lt;Doctor&gt; doctor) &#123;        if ( doctor == null ) &#123;            return null;        &#125;        List&lt;DoctorDto&gt; list = new ArrayList&lt;DoctorDto&gt;( doctor.size() );        for ( Doctor doctor1 : doctor ) &#123;            list.add( doctorToDoctorDto( doctor1 ) );        &#125;        return list;    &#125;    protected DoctorDto doctorToDoctorDto(Doctor doctor) &#123;        if ( doctor == null ) &#123;            return null;        &#125;        DoctorDto doctorDto = new DoctorDto();        doctorDto.setId( doctor.getId() );        doctorDto.setName( doctor.getName() );        doctorDto.setSpecialization( doctor.getSpecialization() );        return doctorDto;    &#125;&#125;</code></pre><p>可以看到，MapStruct为我们自动生成了从<code>Doctor</code>到<code>DoctorDto</code>的映射方法。</p><p>但是需要注意，如果我们在DTO中新增一个字段<code>fullName</code>，生成代码时会出现错误：</p><pre><code class="hljs">警告: Unmapped target property: &quot;fullName&quot;.</code></pre><p>基本上，这意味着MapStruct在当前情况下无法为我们自动生成映射方法。因此，我们需要手动定义<code>Doctor</code>和<code>DoctorDto</code>之间的映射方法。具体参考之前的小节。</p><h3 id="Set和Map映射"><a href="#Set和Map映射" class="headerlink" title="Set和Map映射"></a>Set和Map映射</h3><p>Set与Map型数据的处理方式与List相似。按照以下方式修改<code>DoctorMapper</code>：</p><pre><code class="hljs">@Mapperpublic interface DoctorMapper &#123;    Set&lt;DoctorDto&gt; setConvert(Set&lt;Doctor&gt; doctor);    Map&lt;String, DoctorDto&gt; mapConvert(Map&lt;String, Doctor&gt; doctor);&#125;</code></pre><p>生成的最终实现代码如下：</p><pre><code class="hljs">public class DoctorMapperImpl implements DoctorMapper &#123;    @Override    public Set&lt;DoctorDto&gt; setConvert(Set&lt;Doctor&gt; doctor) &#123;        if ( doctor == null ) &#123;            return null;        &#125;        Set&lt;DoctorDto&gt; set = new HashSet&lt;DoctorDto&gt;( Math.max( (int) ( doctor.size() / .75f ) + 1, 16 ) );        for ( Doctor doctor1 : doctor ) &#123;            set.add( doctorToDoctorDto( doctor1 ) );        &#125;        return set;    &#125;    @Override    public Map&lt;String, DoctorDto&gt; mapConvert(Map&lt;String, Doctor&gt; doctor) &#123;        if ( doctor == null ) &#123;            return null;        &#125;        Map&lt;String, DoctorDto&gt; map = new HashMap&lt;String, DoctorDto&gt;( Math.max( (int) ( doctor.size() / .75f ) + 1, 16 ) );        for ( java.util.Map.Entry&lt;String, Doctor&gt; entry : doctor.entrySet() ) &#123;            String key = entry.getKey();            DoctorDto value = doctorToDoctorDto( entry.getValue() );            map.put( key, value );        &#125;        return map;    &#125;    protected DoctorDto doctorToDoctorDto(Doctor doctor) &#123;        if ( doctor == null ) &#123;            return null;        &#125;        DoctorDto doctorDto = new DoctorDto();        doctorDto.setId( doctor.getId() );        doctorDto.setName( doctor.getName() );        doctorDto.setSpecialization( doctor.getSpecialization() );        return doctorDto;    &#125;&#125;</code></pre><p>与List映射类似，MapStruct自动生成了<code>Doctor</code>转换为<code>DoctorDto</code>的映射方法。</p><h3 id="集合映射策略"><a href="#集合映射策略" class="headerlink" title="集合映射策略"></a>集合映射策略</h3><p>很多场景中，我们需要对具有父子关系的数据类型进行转换。通常来说，会有一个数据类型（父），其字段是另一个数据类型（子）的集合。</p><p>对于这种情况，MapStruct提供了一种方法来选择如何将子类型设置或添加到父类型中。具体来说，就是<code>@Mapper</code> 注解中的<code>collectionMappingStrategy</code>属性，该属性可以取值为<code>ACCESSOR_ONLY</code>， <code>SETTER_PREFERRED</code>， <code>ADDER_PREFERRED</code> 或<code>TARGET_IMMUTABLE</code>。</p><p>这些值分别表示不同的为子类型集合赋值的方式。默认值是<code>ACCESSOR_ONLY</code>，这意味着只能使用访问器来设置子集合。</p><p>当父类型中的_Collection_字段<code>setter</code>方法不可用，但我们有一个子类型<code>add</code>方法时，这个选项就派上用场了；另一种有用的情况是父类型中的_Collection_字段是不可变的。</p><p>我们新建一个类：</p><pre><code class="hljs">public class Hospital &#123;    private List&lt;Doctor&gt; doctors;    // getters and setters or builder&#125;</code></pre><p>同时定义一个映射目标DTO类，同时定义子类型集合字段的getter、setter和adder：</p><pre><code class="hljs">public class HospitalDto &#123;    private List&lt;DoctorDto&gt; doctors;        // 子类型集合字段getter    public List&lt;DoctorDto&gt; getDoctors() &#123;        return doctors;    &#125;        // 子类型集合字段setter    public void setDoctors(List&lt;DoctorDto&gt; doctors) &#123;        this.doctors = doctors;    &#125;        // 子类型数据adder    public void addDoctor(DoctorDto doctorDTO) &#123;        if (doctors == null) &#123;            doctors = new ArrayList&lt;&gt;();        &#125;        doctors.add(doctorDTO);    &#125;&#125;</code></pre><p>创建对应的映射器：</p><pre><code class="hljs">@Mapper(uses = DoctorMapper.class)public interface HospitalMapper &#123;    HospitalMapper INSTANCE = Mappers.getMapper(HospitalMapper.class);    HospitalDto toDto(Hospital hospital);&#125;</code></pre><p>生成的最终实现代码为：</p><pre><code class="hljs">public class HospitalMapperImpl implements HospitalMapper &#123;    @Override    public HospitalDto toDto(Hospital hospital) &#123;        if ( hospital == null ) &#123;            return null;        &#125;        HospitalDto hospitalDto = new HospitalDto();        hospitalDto.setDoctors( doctorListToDoctorDtoList( hospital.getDoctors() ) );        return hospitalDto;    &#125;&#125;</code></pre><p>可以看到，在默认情况下采用的策略是<code>ACCESSOR_ONLY</code>，使用setter方法<code>setDoctors()</code>向<code>HospitalDto</code>对象中写入列表数据。</p><p>相对的，如果使用 <code>ADDER_PREFERRED</code> 作为映射策略：</p><pre><code class="hljs">@Mapper(collectionMappingStrategy = CollectionMappingStrategy.ADDER_PREFERRED,        uses = DoctorMapper.class)public interface HospitalMapper &#123;    HospitalMapper INSTANCE = Mappers.getMapper(HospitalMapper.class);    HospitalDto toDto(Hospital hospital);&#125;</code></pre><p>此时，会使用adder方法逐个将转换后的子类型DTO对象加入父类型的集合字段中。</p><pre><code class="hljs">public class CompanyMapperAdderPreferredImpl implements CompanyMapperAdderPreferred &#123;    private final EmployeeMapper employeeMapper = Mappers.getMapper( EmployeeMapper.class );    @Override    public CompanyDTO map(Company company) &#123;        if ( company == null ) &#123;            return null;        &#125;        CompanyDTO companyDTO = new CompanyDTO();        if ( company.getEmployees() != null ) &#123;            for ( Employee employee : company.getEmployees() ) &#123;                companyDTO.addEmployee( employeeMapper.map( employee ) );            &#125;        &#125;        return companyDTO;    &#125;&#125;</code></pre><p>如果目标DTO中既没有<code>setter</code>方法也没有<code>adder</code>方法，会先通过<code>getter</code>方法获取子类型集合，再调用集合的对应接口添加子类型对象。</p><p>可以在<a href="https://link.juejin.cn/?target=https://mapstruct.org/documentation/stable/reference/html/%23collection-mapping-strategies" title="https://mapstruct.org/documentation/stable/reference/html/#collection-mapping-strategies">参考文档</a>中看到不同类型的DTO定义（是否包含setter方法或adder方法），采用不同的映射策略时，所使用的添加子类型到集合中的方式。</p><h3 id="目标集合实现类型"><a href="#目标集合实现类型" class="headerlink" title="目标集合实现类型"></a>目标集合实现类型</h3><p>MapStruct支持将集合接口作为映射方法的目标类型。</p><p>在这种情况下，在生成的代码中会使用一些集合接口默认实现。 例如，上面的示例中，<code>List</code>的默认实现是<code>ArrayList</code>。</p><p>常见接口及其对应的默认实现如下：</p><p>Interface type</p><p>Implementation type</p><p><code>Collection</code></p><p><code>ArrayList</code></p><p><code>List</code></p><p><code>ArrayList</code></p><p><code>Map</code></p><p><code>HashMap</code></p><p><code>SortedMap</code></p><p><code>TreeMap</code></p><p><code>ConcurrentMap</code></p><p><code>ConcurrentHashMap</code></p><p>你可以在<a href="https://link.juejin.cn/?target=https://mapstruct.org/documentation/stable/reference/html/%23implementation-types-for-collection-mappings" title="https://mapstruct.org/documentation/stable/reference/html/#implementation-types-for-collection-mappings">参考文档</a>中找到MapStruct支持的所有接口列表，以及每个接口对应的默认实现类型。</p><h1 id="进阶操作"><a href="#进阶操作" class="headerlink" title="进阶操作"></a>进阶操作</h1><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>到目前为止，我们一直在通过<code>getMapper()</code>方法访问生成的映射器：</p><pre><code class="hljs">DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.class);</code></pre><p>但是，如果你使用的是Spring，只需要简单修改映射器配置，就可以像常规依赖项一样注入映射器。</p><p>修改 <code>DoctorMapper</code> 以支持Spring框架：</p><pre><code class="hljs">@Mapper(componentModel = &quot;spring&quot;)public interface DoctorMapper &#123;&#125;</code></pre><p>在<code>@Mapper</code>注解中添加<code>（componentModel = &quot;spring&quot;）</code>，是为了告诉MapStruct，在生成映射器实现类时，我们希望它能支持通过Spring的依赖注入来创建。现在，就不需要在接口中添加 <code>INSTANCE</code> 字段了。</p><p>这次生成的 <code>DoctorMapperImpl</code> 会带有 <code>@Component</code> 注解：</p><pre><code class="hljs">@Componentpublic class DoctorMapperImpl implements DoctorMapper &#123;&#125;</code></pre><p>只要被标记为<code>@Component</code>，Spring就可以把它作为一个bean来处理，你就可以在其它类（如控制器）中通过<code>@Autowire</code>注解来使用它：</p><pre><code class="hljs">@Controllerpublic class DoctorController() &#123;    @Autowired    private DoctorMapper doctorMapper;&#125;</code></pre><p>如果你不使用Spring, MapStruct也支持<a href="https://link.juejin.cn/?target=https://docs.oracle.com/javaee/6/tutorial/doc/giwhl.html" title="https://docs.oracle.com/javaee/6/tutorial/doc/giwhl.html">Java CDI</a>：</p><pre><code class="hljs">@Mapper(componentModel = &quot;cdi&quot;)public interface DoctorMapper &#123;&#125;</code></pre><h2 id="添加默认值"><a href="#添加默认值" class="headerlink" title="添加默认值"></a>添加默认值</h2><p><code>@Mapping</code> 注解有两个很实用的标志就是常量 <code>constant</code> 和默认值 <code>defaultValue</code> 。无论<code>source</code>如何取值，都将始终使用常量值； 如果<code>source</code>取值为<code>null</code>，则会使用默认值。</p><p>修改一下 <code>DoctorMapper</code> ，添加一个 <code>constant</code> 和一个 <code>defaultValue</code> ：</p><pre><code class="hljs">@Mapper(uses = &#123;PatientMapper.class&#125;, componentModel = &quot;spring&quot;)public interface DoctorMapper &#123;    @Mapping(target = &quot;id&quot;, constant = &quot;-1&quot;)    @Mapping(source = &quot;doctor.patientList&quot;, target = &quot;patientDtoList&quot;)    @Mapping(source = &quot;doctor.specialty&quot;, target = &quot;specialization&quot;, defaultValue = &quot;Information Not Available&quot;)    DoctorDto toDto(Doctor doctor);&#125;</code></pre><p>如果<code>specialty</code>不可用，我们会替换为<code>&quot;Information Not Available&quot;</code>字符串，此外，我们将<code>id</code>硬编码为<code>-1</code>。</p><p>生成代码如下：</p><pre><code class="hljs">@Componentpublic class DoctorMapperImpl implements DoctorMapper &#123;    @Autowired    private PatientMapper patientMapper;        @Override    public DoctorDto toDto(Doctor doctor) &#123;        if (doctor == null) &#123;            return null;        &#125;        DoctorDto doctorDto = new DoctorDto();        if (doctor.getSpecialty() != null) &#123;            doctorDto.setSpecialization(doctor.getSpecialty());        &#125;        else &#123;            doctorDto.setSpecialization(&quot;Information Not Available&quot;);        &#125;        doctorDto.setPatientDtoList(patientListToPatientDtoList(doctor.getPatientList()));        doctorDto.setName(doctor.getName());        doctorDto.setId(-1);        return doctorDto;    &#125;&#125;</code></pre><p>可以看到，如果 <code>doctor.getSpecialty()</code> 返回值为<code>null</code>，则将<code>specialization</code>设置为我们的默认信息。无论任何情况，都会对 <code>id</code>赋值，因为这是一个<code>constant</code>。</p><h2 id="添加表达式"><a href="#添加表达式" class="headerlink" title="添加表达式"></a>添加表达式</h2><p>MapStruct甚至允许在<code>@Mapping</code>注解中输入Java表达式。你可以设置 <code>defaultExpression</code> （ <code>source</code> 取值为 <code>null</code>时生效），或者一个<code>expression</code>（类似常量，永久生效）。</p><p>在 <code>Doctor</code> 和 <code>DoctorDto</code>两个类中都加了两个新属性，一个是 <code>String</code> 类型的 <code>externalId</code> ，另一个是<code>LocalDateTime</code>类型的 <code>appointment</code> ，两个类大致如下：</p><pre><code class="hljs">public class Doctor &#123;    private int id;    private String name;    private String externalId;    private String specialty;    private LocalDateTime availability;    private List&lt;Patient&gt; patientList;    // getters and setters or builder&#125;public class DoctorDto &#123;    private int id;    private String name;    private String externalId;    private String specialization;    private LocalDateTime availability;    private List&lt;PatientDto&gt; patientDtoList;    // getters and setters or builder&#125;</code></pre><p>修改 <code>DoctorMapper</code>：</p><pre><code class="hljs">@Mapper(uses = &#123;PatientMapper.class&#125;, componentModel = &quot;spring&quot;, imports = &#123;LocalDateTime.class, UUID.class&#125;)public interface DoctorMapper &#123;    @Mapping(target = &quot;externalId&quot;, expression = &quot;java(UUID.randomUUID().toString())&quot;)    @Mapping(source = &quot;doctor.availability&quot;, target = &quot;availability&quot;, defaultExpression = &quot;java(LocalDateTime.now())&quot;)    @Mapping(source = &quot;doctor.patientList&quot;, target = &quot;patientDtoList&quot;)    @Mapping(source = &quot;doctor.specialty&quot;, target = &quot;specialization&quot;)    DoctorDto toDtoWithExpression(Doctor doctor);&#125;</code></pre><p>可以看到，这里将 <code>externalId</code>的值设置为 <code>java(UUID.randomUUID().toString())</code> ，如果源对象中没有 <code>availability</code> 属性，则会把目标对象中的 <code>availability</code> 设置为一个新的 <code>LocalDateTime</code>对象。</p><p>由于表达式只是字符串，我们必须在表达式中指定使用的类。但是这里的表达式并不是最终执行的代码，只是一个字母的文本值。因此，我们要在 <code>@Mapper</code> 中添加 <code>imports = &#123;LocalDateTime.class, UUID.class&#125;</code> 。</p><h2 id="添加自定义方法"><a href="#添加自定义方法" class="headerlink" title="添加自定义方法"></a>添加自定义方法</h2><p>到目前为止，我们一直使用的策略是添加一个“占位符”方法，并期望MapStruct能为我们实现它。其实我们还可以向接口中添加自定义的<code>default</code>方法，也可以通过<code>default</code>方法直接实现一个映射。然后我们可以通过实例直接调用该方法，没有任何问题。</p><p>为此，我们创建一个 <code>DoctorPatientSummary</code>类，其中包含一个 <code>Doctor</code> 及其 <code>Patient</code>列表的汇总信息：</p><pre><code class="hljs">public class DoctorPatientSummary &#123;    private int doctorId;    private int patientCount;    private String doctorName;    private String specialization;    private String institute;    private List&lt;Integer&gt; patientIds;    // getters and setters or builder&#125;</code></pre><p>接下来，我们在 <code>DoctorMapper</code>中添加一个<code>default</code>方法，该方法会将 <code>Doctor</code> 和 <code>Education</code> 对象转换为一个 <code>DoctorPatientSummary</code>:</p><pre><code class="hljs">@Mapperpublic interface DoctorMapper &#123;    default DoctorPatientSummary toDoctorPatientSummary(Doctor doctor, Education education) &#123;        return DoctorPatientSummary.builder()                .doctorId(doctor.getId())                .doctorName(doctor.getName())                .patientCount(doctor.getPatientList().size())                                .patientIds(doctor.getPatientList()                        .stream()                      .map(Patient::getId)                        .collect(Collectors.toList()))                    .institute(education.getInstitute())                .specialization(education.getDegreeName())                .build();    &#125;&#125;</code></pre><p>这里使用了Builder模式创建<code>DoctorPatientSummary</code>对象。</p><p>在MapStruct生成映射器实现类之后，你就可以使用这个实现方法，就像访问任何其它映射器方法一样：</p><pre><code class="hljs">DoctorPatientSummary summary = doctorMapper.toDoctorPatientSummary(dotor, education);</code></pre><h2 id="创建自定义映射器"><a href="#创建自定义映射器" class="headerlink" title="创建自定义映射器"></a>创建自定义映射器</h2><p>前面我们一直是通过接口来设计映射器功能，其实我们也可以通过一个带 <code>@Mapper</code> 的 <code>abstract</code> 类来实现一个映射器。MapStruct也会为这个类创建一个实现，类似于创建一个接口实现。</p><p>我们重写一下前面的示例，这一次，我们将它修改为一个抽象类：</p><pre><code class="hljs">@Mapperpublic abstract class DoctorCustomMapper &#123;    public DoctorPatientSummary toDoctorPatientSummary(Doctor doctor, Education education) &#123;        return DoctorPatientSummary.builder()                .doctorId(doctor.getId())                .doctorName(doctor.getName())                .patientCount(doctor.getPatientList().size())                .patientIds(doctor.getPatientList()                        .stream()                        .map(Patient::getId)                        .collect(Collectors.toList()))                .institute(education.getInstitute())                .specialization(education.getDegreeName())                .build();    &#125;&#125;</code></pre><p>你可以用同样的方式使用这个映射器。由于限制较少，使用抽象类可以在创建自定义实现时给我们更多的控制和选择。另一个好处是可以添加<code>@BeforeMapping</code>和<code>@AfterMapping</code>方法。</p><h3 id="BeforeMapping-和-AfterMapping"><a href="#BeforeMapping-和-AfterMapping" class="headerlink" title="@BeforeMapping 和 @AfterMapping"></a>@BeforeMapping 和 @AfterMapping</h3><p>为了进一步控制和定制化，我们可以定义 <code>@BeforeMapping</code> 和 <code>@AfterMapping</code>方法。显然，这两个方法是在每次映射之前和之后执行的。也就是说，在最终的实现代码中，会在两个对象真正映射之前和之后添加并执行这两个方法。</p><p>可以在 <code>DoctorCustomMapper</code>中添加两个方法：</p><pre><code class="hljs">@Mapper(uses = &#123;PatientMapper.class&#125;, componentModel = &quot;spring&quot;)public abstract class DoctorCustomMapper &#123;    @BeforeMapping    protected void validate(Doctor doctor) &#123;        if(doctor.getPatientList() == null)&#123;            doctor.setPatientList(new ArrayList&lt;&gt;());        &#125;    &#125;    @AfterMapping    protected void updateResult(@MappingTarget DoctorDto doctorDto) &#123;        doctorDto.setName(doctorDto.getName().toUpperCase());        doctorDto.setDegree(doctorDto.getDegree().toUpperCase());        doctorDto.setSpecialization(doctorDto.getSpecialization().toUpperCase());    &#125;    @Mapping(source = &quot;doctor.patientList&quot;, target = &quot;patientDtoList&quot;)    @Mapping(source = &quot;doctor.specialty&quot;, target = &quot;specialization&quot;)    public abstract DoctorDto toDoctorDto(Doctor doctor);&#125;</code></pre><p>基于该抽象类生成一个映射器实现类：</p><pre><code class="hljs">@Componentpublic class DoctorCustomMapperImpl extends DoctorCustomMapper &#123;        @Autowired    private PatientMapper patientMapper;        @Override    public DoctorDto toDoctorDto(Doctor doctor) &#123;        validate(doctor);        if (doctor == null) &#123;            return null;        &#125;        DoctorDto doctorDto = new DoctorDto();        doctorDto.setPatientDtoList(patientListToPatientDtoList(doctor            .getPatientList()));        doctorDto.setSpecialization(doctor.getSpecialty());        doctorDto.setId(doctor.getId());        doctorDto.setName(doctor.getName());        updateResult(doctorDto);        return doctorDto;    &#125;&#125;</code></pre><p>可以看到， <code>validate()</code> 方法会在 <code>DoctorDto</code> 对象实例化之前执行，而<code>updateResult()</code>方法会在映射结束之后执行。</p><h2 id="映射异常处理"><a href="#映射异常处理" class="headerlink" title="映射异常处理"></a>映射异常处理</h2><p>异常处理是不可避免的，应用程序随时会产生异常状态。MapStruct提供了对异常处理的支持，可以简化开发者的工作。</p><p>考虑这样一个场景，我们想在 <code>Doctor</code> 映射为<code>DoctorDto</code>之前校验一下 <code>Doctor</code> 的数据。我们新建一个独立的 <code>Validator</code> 类进行校验：</p><pre><code class="hljs">public class Validator &#123;    public int validateId(int id) throws ValidationException &#123;        if(id == -1)&#123;            throw new ValidationException(&quot;Invalid value in ID&quot;);        &#125;        return id;    &#125;&#125;</code></pre><p>我们修改一下 <code>DoctorMapper</code> 以使用 <code>Validator</code> 类，无需指定实现。跟之前一样， 在<code>@Mapper</code>使用的类列表中添加该类。我们还需要做的就是告诉MapStruct我们的 <code>toDto()</code> 会抛出 <code>throws ValidationException</code>：</p><pre><code class="hljs">@Mapper(uses = &#123;PatientMapper.class, Validator.class&#125;, componentModel = &quot;spring&quot;)public interface DoctorMapper &#123;    @Mapping(source = &quot;doctor.patientList&quot;, target = &quot;patientDtoList&quot;)    @Mapping(source = &quot;doctor.specialty&quot;, target = &quot;specialization&quot;)    DoctorDto toDto(Doctor doctor) throws ValidationException;&#125;</code></pre><p>最终生成的映射器代码如下：</p><pre><code class="hljs">@Componentpublic class DoctorMapperImpl implements DoctorMapper &#123;    @Autowired    private PatientMapper patientMapper;    @Autowired    private Validator validator;    @Override    public DoctorDto toDto(Doctor doctor) throws ValidationException &#123;        if (doctor == null) &#123;            return null;        &#125;        DoctorDto doctorDto = new DoctorDto();        doctorDto.setPatientDtoList(patientListToPatientDtoList(doctor            .getPatientList()));        doctorDto.setSpecialization(doctor.getSpecialty());        doctorDto.setId(validator.validateId(doctor.getId()));        doctorDto.setName(doctor.getName());        doctorDto.setExternalId(doctor.getExternalId());        doctorDto.setAvailability(doctor.getAvailability());        return doctorDto;    &#125;&#125;</code></pre><p>MapStruct自动将<code>doctorDto</code>的<code>id</code>设置为<code>Validator</code>实例的方法返回值。它还在该方法签名中添加了一个throws子句。</p><p>注意，如果映射前后的一对属性的类型与<code>Validator</code>中的方法出入参类型一致，那该字段映射时就会调用<code>Validator</code>中的方法，所以该方式请谨慎使用。</p><h2 id="映射配置"><a href="#映射配置" class="headerlink" title="映射配置"></a>映射配置</h2><p>MapStruct为编写映射器方法提供了一些非常有用的配置。多数情况下，如果我们已经定义了两个类型之间的映射方法，当我们要添加相同类型之间的另一个映射方法时，我们往往会直接复制已有方法的映射配置。</p><p>其实我们不必手动复制这些注解，只需要简单的配置就可以创建一个相同/相似的映射方法。</p><h3 id="继承配置"><a href="#继承配置" class="headerlink" title="继承配置"></a>继承配置</h3><p>我们回顾一下“<a href="#%E6%9B%B4%E6%96%B0%E7%8E%B0%E6%9C%89%E5%AE%9E%E4%BE%8B" title="#%E6%9B%B4%E6%96%B0%E7%8E%B0%E6%9C%89%E5%AE%9E%E4%BE%8B">更新现有实例</a>”，在该场景中，我们创建了一个映射器，根据DoctorDto对象的属性更新现有的Doctor对象的属性值：</p><pre><code class="hljs">@Mapper(uses = &#123;PatientMapper.class&#125;)public interface DoctorMapper &#123;    DoctorMapper INSTANCE = Mappers.getMapper(DoctorMapper.class);    @Mapping(source = &quot;doctorDto.patientDtoList&quot;, target = &quot;patientList&quot;)    @Mapping(source = &quot;doctorDto.specialization&quot;, target = &quot;specialty&quot;)    void updateModel(DoctorDto doctorDto, @MappingTarget Doctor doctor);&#125;</code></pre><p>假设我们还有另一个映射器，将 <code>DoctorDto</code>转换为 <code>Doctor</code> ：</p><pre><code class="hljs">@Mapper(uses = &#123;PatientMapper.class, Validator.class&#125;)public interface DoctorMapper &#123;    @Mapping(source = &quot;doctorDto.patientDtoList&quot;, target = &quot;patientList&quot;)    @Mapping(source = &quot;doctorDto.specialization&quot;, target = &quot;specialty&quot;)    Doctor toModel(DoctorDto doctorDto);&#125;</code></pre><p>这两个映射方法使用了相同的注解配置， <code>source</code>和 <code>target</code>都是相同的。其实我们可以使用<code>@InheritConfiguration</code>注释，从而避免这两个映射器方法的重复配置。</p><p>如果对一个方法添加 <code>@InheritConfiguration</code> 注解，MapStruct会检索其它的已配置方法，寻找可用于当前方法的注解配置。一般来说，这个注解都用于<code>mapping</code>方法后面的<code>update</code>方法，如下所示：</p><pre><code class="hljs">@Mapper(uses = &#123;PatientMapper.class, Validator.class&#125;, componentModel = &quot;spring&quot;)public interface DoctorMapper &#123;    @Mapping(source = &quot;doctorDto.specialization&quot;, target = &quot;specialty&quot;)    @Mapping(source = &quot;doctorDto.patientDtoList&quot;, target = &quot;patientList&quot;)    Doctor toModel(DoctorDto doctorDto);    @InheritConfiguration    void updateModel(DoctorDto doctorDto, @MappingTarget Doctor doctor);&#125;</code></pre><h3 id="继承逆向配置"><a href="#继承逆向配置" class="headerlink" title="继承逆向配置"></a>继承逆向配置</h3><p>还有另外一个类似的场景，就是编写映射函数将_<strong>Model</strong>_ 转为 _<strong>DTO</strong>_，以及将 <em><strong>DTO</strong></em> 转为 _<strong>Model</strong>_。如下面的代码所示，我们必须在两个函数上添加相同的注释。</p><pre><code class="hljs">@Mapper(componentModel = &quot;spring&quot;)public interface PatientMapper &#123;    @Mapping(source = &quot;dateOfBirth&quot;, target = &quot;dateOfBirth&quot;, dateFormat = &quot;dd/MMM/yyyy&quot;)    Patient toModel(PatientDto patientDto);    @Mapping(source = &quot;dateOfBirth&quot;, target = &quot;dateOfBirth&quot;, dateFormat = &quot;dd/MMM/yyyy&quot;)    PatientDto toDto(Patient patient);&#125;</code></pre><p>两个方法的配置不会是完全相同的，实际上，它们应该是相反的。将_<strong>Model</strong>_ 转为 _<strong>DTO</strong>_，以及将 <em><strong>DTO</strong></em> 转为 _<strong>Model</strong>_——映射前后的字段相同，但是源属性字段与目标属性字段是相反的。</p><p>我们可以在第二个方法上使用<code>@InheritInverseConfiguration</code>注解，避免写两遍映射配置：</p><pre><code class="hljs">@Mapper(componentModel = &quot;spring&quot;)public interface PatientMapper &#123;    @Mapping(source = &quot;dateOfBirth&quot;, target = &quot;dateOfBirth&quot;, dateFormat = &quot;dd/MMM/yyyy&quot;)    Patient toModel(PatientDto patientDto);    @InheritInverseConfiguration    PatientDto toDto(Patient patient);&#125;</code></pre><p>这两个Mapper生成的代码是相同的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>在本文中，我们探讨了MapStruct——一个用于创建映射器类的库。从基本映射到自定义方法和自定义映射器，此外， 我们还介绍了MapStruct提供的一些高级操作选项，包括依赖注入，数据类型映射、枚举映射和表达式使用。</p><p>MapStruct提供了一个功能强大的集成插件，可减少开发人员编写模板代码的工作量，使创建映射器的过程变得简单快捷。</p><p>如果要探索更多、更详细的使用方式，可以参考MapStruct官方提供的<a href="https://link.juejin.cn/?target=https://mapstruct.org/documentation/stable/reference/html/" title="https://mapstruct.org/documentation/stable/reference/html/">参考指南</a>。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://juejin.cn/post/6956190395319451679">MapStruct使用指南</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>MapStruct</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解决xmrig挖矿木马问题</title>
    <link href="/2023/03/29/linux/%E8%A7%A3%E5%86%B3xmrig%E6%8C%96%E7%9F%BF%E6%9C%A8%E9%A9%AC%E5%AF%BC%E8%87%B4%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8cpu%E5%8D%A0%E6%BB%A1%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/03/29/linux/%E8%A7%A3%E5%86%B3xmrig%E6%8C%96%E7%9F%BF%E6%9C%A8%E9%A9%AC%E5%AF%BC%E8%87%B4%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8cpu%E5%8D%A0%E6%BB%A1%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h2 id="删除定时任务"><a href="#删除定时任务" class="headerlink" title="删除定时任务"></a>删除定时任务</h2><pre><code class="hljs">/etc/crontab</code></pre><h2 id="列出系统服务命令"><a href="#列出系统服务命令" class="headerlink" title="列出系统服务命令"></a>列出系统服务命令</h2><pre><code class="hljs"> systemctl list-unit-files</code></pre><h2 id="关闭服务并删除服务"><a href="#关闭服务并删除服务" class="headerlink" title="关闭服务并删除服务"></a>关闭服务并删除服务</h2><pre><code class="hljs">systemctl disable xmrig.servicerm -rf /etc/systemd/system/xmrig.service</code></pre><h2 id="删除-root-ssh-authorized-keys-文件中的未知密钥"><a href="#删除-root-ssh-authorized-keys-文件中的未知密钥" class="headerlink" title="删除 /root/.ssh/authorized_keys 文件中的未知密钥"></a>删除 /root/.ssh/authorized_keys 文件中的未知密钥</h2><h2 id="修改-etc-ssh-sshd-config中最后几行添加的文件-同时修改sshd端口为自定义端口"><a href="#修改-etc-ssh-sshd-config中最后几行添加的文件-同时修改sshd端口为自定义端口" class="headerlink" title="修改 /etc/ssh/sshd_config中最后几行添加的文件,同时修改sshd端口为自定义端口"></a>修改 /etc/ssh/sshd_config中最后几行添加的文件,同时修改sshd端口为自定义端口</h2><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ul><li>出现即使root用户也无法修改的权限是,使用 lsattr authorized_keys 查看是否出现 ia</li><li>使用 chattr -ia  /etc/crontab 解锁文件即可修改</li><li>建立了解lsattr 和chattr命令</li></ul><h2 id="可选"><a href="#可选" class="headerlink" title="可选"></a>可选</h2><h3 id="使用-防火墙关闭-所有端口的对外访问-放开sshd的端口"><a href="#使用-防火墙关闭-所有端口的对外访问-放开sshd的端口" class="headerlink" title="使用 防火墙关闭 所有端口的对外访问,放开sshd的端口"></a>使用 防火墙关闭 所有端口的对外访问,放开sshd的端口</h3><h3 id="开启firewall-cmd防火墙"><a href="#开启firewall-cmd防火墙" class="headerlink" title="开启firewall-cmd防火墙"></a>开启firewall-cmd防火墙</h3><h4 id="firewalld相关命令"><a href="#firewalld相关命令" class="headerlink" title="firewalld相关命令"></a>firewalld相关命令</h4><pre><code class="hljs">启动 systemctl start firewalld关闭 systemctl stop firewalld查看状态 systemctl status firewalld查看状态 firewall-cmd --state开机启用 systemctl enable firewalld开机禁用 systemctl disable firewalldfirewall-cmd --statesystemctl start  firewalld.service开启firewall防火墙后,默认所有端口都会关闭,放开sshd端口firewall-cmd --add-port=22222/tcp --permanent</code></pre>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux command</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>centos install openresty</title>
    <link href="/2023/03/29/linux/centos%20install%20openresty/"/>
    <url>/2023/03/29/linux/centos%20install%20openresty/</url>
    
    <content type="html"><![CDATA[<h1 id="centos-install-openresty"><a href="#centos-install-openresty" class="headerlink" title="centos install openresty"></a>centos install openresty</h1><h2 id="安装前准备："><a href="#安装前准备：" class="headerlink" title="安装前准备："></a>安装前准备：</h2><p>你必须将这些库 perl 5.6.1+，libpare, libssl 安装到您的电脑里。对于linux来说，需要确认使用ldconfig命令，让其在你的系统环境路径中能找到它们。</p><p>centos 建议使用yum安装以下的开发库：</p><pre><code class="hljs">yum install pcre-devel openssl-devel gcc curl</code></pre><h2 id="构建OpenResty："><a href="#构建OpenResty：" class="headerlink" title="构建OpenResty："></a>构建OpenResty：</h2><p>在centos 系统中添加openresty仓库，便于未来安装和更新软件包（通过yum check-update 命令）。运行下面的命令就可以添加我们的仓库。（对于Centos 8 以上版本，应将下面的yum都替换成dnf）：</p><pre><code class="hljs">wget https://openresty.org/package/centos/openresty.reposudo mv openresty.repo /etc/yum.repos.d/sudo yum check-update</code></pre><p>然后就可以像下面这样安装软件包，比如openresty:</p><pre><code class="hljs">sudo yum install -y openresty</code></pre><p>如果你想安装命令行工具 resty，那么可以像下面这样安装 openresty-resty包：</p><pre><code class="hljs">sudo yum install -y openresty-resty</code></pre><p>命令行工具 opm 在 openresty-opm包里，而restydoc 工具在 openresty-doc包里头。</p><h2 id="直接运行-bin-openresty就可以启动OpenResty"><a href="#直接运行-bin-openresty就可以启动OpenResty" class="headerlink" title="直接运行/bin/openresty就可以启动OpenResty"></a>直接运行/bin/openresty就可以启动OpenResty</h2><pre><code class="hljs">/usr/local/openresty/bin/openrestyopenresty</code></pre><h2 id="停止openresty"><a href="#停止openresty" class="headerlink" title="停止openresty"></a>停止openresty</h2><pre><code class="hljs">/usr/local/openresty/bin/openresty -s stopopenresty -s stop</code></pre>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>openresty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>极简项目管理:第三章 技巧</title>
    <link href="/2023/03/28/%E6%9E%81%E7%AE%80%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/ch3tips/"/>
    <url>/2023/03/28/%E6%9E%81%E7%AE%80%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/ch3tips/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-技巧和工具"><a href="#第三章-技巧和工具" class="headerlink" title="第三章 技巧和工具"></a>第三章 技巧和工具</h1><p>本节是一些日常工作中可以尝试的小技巧，不局限于小团队管理，平时工作生活的时候都可以尝试。</p><h2 id="跳出当前工作来看问题"><a href="#跳出当前工作来看问题" class="headerlink" title="跳出当前工作来看问题"></a>跳出当前工作来看问题</h2><p>即使明确地要求你从五十年的视角看待当下，当项目忙起来之后还是可能会忘记。眼前的利益和目标会被过度地看重。当很在意一个事情的时候，谁都可能钻进小巷子出不来。</p><p>小技巧是能够设置一个闹钟，每周提醒你一次。或者寻找一个项目之外的朋友，定期地提醒你。寻找一个能够给你在团队管理和技术上指导的人会很有帮助。</p><h2 id="每天都有面对面接触"><a href="#每天都有面对面接触" class="headerlink" title="每天都有面对面接触"></a>每天都有面对面接触</h2><p>Scrum管理是一个好东西，可以尝试。我只是用其中最基础的部分，每天十点或者下午四点半有一次小组集体站会。同时，每周作为一个冲刺周期（标准是两周个Sprint，我的项目一周一次更合适，根据你自己的情况来）。</p><p>XP和Scrum随着发展越来越重量级，一开始最好不要引入那些附加的管理方法。避免方法学崇拜。</p><h2 id="用GTD管理自己的工作"><a href="#用GTD管理自己的工作" class="headerlink" title="用GTD管理自己的工作"></a>用GTD管理自己的工作</h2><p>GTD（Get Things Done）这个概念很合适做一些事务性的工作。GTD方法的核心思想很简洁，值得尝试一下。</p><p>比较简单的方法是先从下载一个邮件客户端开始。</p><h2 id="使用邮件客户端"><a href="#使用邮件客户端" class="headerlink" title="使用邮件客户端"></a>使用邮件客户端</h2><p>使用一个邮件客户端，而不是直接使用网页版邮件系统。</p><p>推荐使用thunderbird作为邮件客户端，最大的好处是所有的邮件账户设置是跨平台的，可以通过复制和拷贝用户profile文件夹在多个系统或新系统中快速配置起来。</p><h2 id="使用IMAP而非POP3"><a href="#使用IMAP而非POP3" class="headerlink" title="使用IMAP而非POP3"></a>使用IMAP而非POP3</h2><p>使用IMAP方式收取，这样可以让你保持所有的客户端都看到同样的内容。</p><p>使用GTD方式管理自己的邮件，在邮箱里按照GTD的方式创建几个文件夹，将邮件作为任务管理的一种方式。</p><h2 id="使用最简单的todolist和日程提醒跟踪工具"><a href="#使用最简单的todolist和日程提醒跟踪工具" class="headerlink" title="使用最简单的todolist和日程提醒跟踪工具"></a>使用最简单的todolist和日程提醒跟踪工具</h2><p>事情刚开始多的时候，开始需要使用todolist来记录自己的待办事项，使用工具管理自己的会议等。</p><p>作为技术人员出身很容易就跑偏，开始钻研起来什么工具或者软件好用。todolist的应用至少有上百个，手机上的todo类软件更是一大把。我每隔一段时间就会沉迷于在各种效率软件的对比中。最后的结论就是最有效率的工具还是最简单的，避免分心。</p><p>我使用过的最有效的工具是一张A4纸，在纸上逐条写下今天或者未来一两天需要的事情。当一天结束，把没有完成的事情，重新拿一张A4纸，抄上。</p><p>日程提醒的最重要的点跟todolist一样：不管多小，随手记下来。</p><p>日程提醒使用你的手机上自带的工具就可以。成千上百的app，功能你多半用不上。重要的是随手需要提醒的事情记录下来。手机可以保证你能听得到提醒——事实上可能是最不容易漏掉提醒的工具。</p><h2 id="及时给你的组员反馈"><a href="#及时给你的组员反馈" class="headerlink" title="及时给你的组员反馈"></a>及时给你的组员反馈</h2><p>不管是对领导、客户、还是自己的组员，反馈都很重要。如果组员参与撰写了报告，报告结果之后需要你及时给组员说明报告的反响或者改进意见。</p><p>对下的反馈经常被忽略，我经常看到一个管理者突然把同事/下属们召集起来，要求一起完成一项工作。当工作完成，汇总给他（她）之后，管理者就消失了。而同事/下属如果没有得到自己工作成果的反馈和评价，会潜移默化的失去热情。</p><h2 id="主动找你的上司获取反馈"><a href="#主动找你的上司获取反馈" class="headerlink" title="主动找你的上司获取反馈"></a>主动找你的上司获取反馈</h2><p>如果你处在产出的提供方而不是汇总收集方，你可能就是那个逐渐失去工作热情的同事。主动去问，并将反馈传递给对你负责的同事。</p><p>注意这可能让你的上司不高兴。因为你的上司可能意识到他（她）自己在这点上做得不足。那就问得温柔一点 :)</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上是我日常使用的一些技巧。如果你在日常工作中有更多的技巧可以分享，欢迎<a href="https://github.com/lazyparser/minimalist-team-leader">提交PR</a>。</p>]]></content>
    
    
    <categories>
      
      <category>book</category>
      
      <category>极简项目管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>极简项目管理:第二章 领导</title>
    <link href="/2023/03/28/%E6%9E%81%E7%AE%80%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/ch2leading/"/>
    <url>/2023/03/28/%E6%9E%81%E7%AE%80%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/ch2leading/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-领导团队"><a href="#第二章-领导团队" class="headerlink" title="第二章 领导团队"></a>第二章 领导团队</h1><p>你所在的环境大概分两种：大公司和小公司。大公司像是IBM和百度阿里腾讯，技术员工有之职业等级，每年都有考核升级的机会，升级之后薪水和职责都会有改变。小公司没有这个划分，在研究机构和大学的课题组、创业公司等，想要获得晋升的途径有限。如果你在的公司足够小、足够扁平，或者你所在的项目足够短暂，那么员工的晋升途径就是升管理（你）或者跳槽（你的组员）。</p><p>本章描述我在小公司环境使用的管理方法，简洁粗暴，在你的小团队里面建立一套职业晋升方式。这套理论的核心概念只有两个思维模式、一个分类法，分别是“五十年后思维模式”、“面向简历思维模式”、“挑战、巩固、苦力活分类法”。</p><h2 id="五十年后思维模式"><a href="#五十年后思维模式" class="headerlink" title="五十年后思维模式"></a>五十年后思维模式</h2><p>在思维模式上的第一个转变就是将眼前的工作和项目管理，放在未来五十年的时间框架里考虑。</p><p>五十年内，你的员工会离开你的项目组，离开你的公司，有更好的发展。你的组员跟你共事的时间只有三个月或两年的时间，这段时间是他（她）职业生涯中的一个台阶。面对组员的时候可以问自己，十年之后这个组员会如何评价你在她（他）职业发展中起到的作用，是正面促进的作用，还是浪费时间更多一些？</p><p>五十年中，团队会解散、重建、壮大、调整。你和组员的领导关系只是你跟他（她）这五十年间关系的短暂形态。相遇过的人很有可能再重逢，如果提前知道以后你的组员可能在一个新的公司跟你成为同事、下属、抑或上级，再审视当下的日常决定，可能会有一些微小的改变。</p><p>五十年后大家都死了。我不是开玩笑啦（好吧，有一点）。当你因为项目工作的分歧变得言语激烈，甚至开始有攻击性言论的时候，想一想五十年后。</p><h2 id="面向简历思维模式"><a href="#面向简历思维模式" class="headerlink" title="面向简历思维模式"></a>面向简历思维模式</h2><p>“面向简历编程”是IT界的一句玩笑话，你可能看过也笑过。这个戏谑的说法有一点贬义的成分，我觉得隐含了“面向简历编程就不是为公司干活，是对公司有害的自私行为”的意思。这种对立的思维是错误的。好的组织（公司、研究机构、创业团体），能够给成员提供的不应该只有钱。放在五十年后思维模式里面看，在工作的同时，个人是需要有提升和发展的。这种需要体现在简历上，并不冲突。</p><p>一个经典的说法是西班牙模式和英国模式。西班牙模式觉得世界财富是固定的零和游戏，所以采用掠夺手段；英国模式觉得财富是不断增长的，大家通过交换都能赚钱，所以采取工业革命和贸易。我不知道我的类比是否正确，你能够理解我想表达的意思就好(^_^)。在西班牙模式下，组织从成员那里付费获取成果，成员有薪水之外的收益表示组织榨取的程度不够；英国模式中同样的组织从成员那里付费获得成果，不同的是认可成员自身能力的提升是双赢的结果。</p><p>那么落实到你和你的小团队身上呢？难道直接拿出来组员的简历跟他讨论当前这个项目结束之后简历怎么更新完善？</p><p>对。确实我是这么做的。</p><p>我在中科院下属一个科研机构工作的时候，需要招聘实习生。我们是事业单位，在北京，没什么钱，实习工资很少。跟我们竞争优秀实习生的公司很多，百度、阿里、腾讯能够提供的实习生工资比我们高很多，而且名气也比我们的大很多。如何吸引周边北大、清华、北航、北理工这样学校的优秀学生？在招募和培养一段时间实习生之后我发现了我们的优势所在。我见过很多的实习生，非常优秀，进入知名的大公司之后做的工作却多数是我们后面说到的“苦力活”。在实习期结束之后简历上不管怎么修饰，最后能够体现的就是“我的能力足够优秀，BAT录用了我做实习生”。在这点上我能够提供给实习生的就要多很多了。我所处的环境是国有科研机构，绝大部分工作都是开源的，实习生可以在简历中直接引用他们的工作成果；同时我们重度依赖实习生去跟踪和复现最新的研究论文的实现和结果，这样我们能够提供给实习生的挑战，很充实。进一步的，我们将实习生的研究报告、系统代码实现等都放在GitHub上。在实习结束之后，我会帮助实习生完善简历。这对于实习生在实习期结束之后的校招有着非常大的帮助。</p><p>正式员工或者合同工并没有实习生那样明确的离职时间点，这让你不能照搬用于实习生的方法。我的方式是在1on1（一对一谈话）的时候，直接询问我的队友的职业发展预期，以及优先看重的是什么。可以按照半年、一年、两年这样的时间节点进行讨论：“半年之后你希望能力经验上有什么收获？”，“一年之后你希望自己发展成什么样子？”，类似这样。当你的队友跟你敞开心扉，你们就可以开始寻找三个目标中共同的部分：组织建立这个团队的目标，作为组长的你的个人的目标，你面前的这位队友的目标。下一小节的思维模式告诉你在明确目标之后如何实现或体现你们的共识。</p><p>要做到这点，首先需要你的坦诚，坦诚地看待自己的目标和组织、队员目标的差异，坦诚地跟队友表达你希望帮助他（她）成功；其次需要谨记这是建立在信任和私密性的基础上的，面对面坐下来聊这个事情，使用即时通讯或者电话交流可能会增加对方被录音、截屏的担心，信任伴随着守密的责任；最后跟对方明确哪些是你的权责范围可以帮助的，哪些超过了你的权责能力，大包大揽的空头支票瞬间就会让你失掉信任，让对方觉得你只是想要套点话然后去告密。</p><h2 id="挑战、巩固、苦力活分类法"><a href="#挑战、巩固、苦力活分类法" class="headerlink" title="挑战、巩固、苦力活分类法"></a>挑战、巩固、苦力活分类法</h2><p>当你跟你的队友明确了目标之后，接下来团队要做的工作就可以按照“挑战、巩固、苦力活”三类进行简单的划分了。划分完全按照队友的目标和主观感受为标准，你要做的主要是引导队友进行划分，告诉你分类结果。</p><p><strong>挑战类</strong>的工作是指对于组员而言有两个特征。第一个是没有接触过的技术领域、第一次接触的工作内容、或是之前尚未成功过的工作。第二个特征是组员感兴趣，并且愿意去做。这类工作自然地可以更新到组员的简历中。理想的工作是在组员的舒适区之外，通过努力能够达到，又不至于难到明显无法实现（这里盲目乐观设计不现实目标的更可能是组员，而组长的你需要察觉并调整到合理范围）【TODO插入一张图解释】。</p><p>注意到这里对你的技术能力有一个潜在的假设。这种假设在<code>第一章 准备工作</code>中有提到。</p><p>对应的，<strong>苦力活</strong>对于组员而言满足两个特征中的任何一个：第一，组员没有兴趣；第二，组员已经非常熟练。这是完全主观的评价。即使现在人工智能非常火，很多人都想做，但是如果你的组员只喜欢做操作系统内核驱动开发，那么对于他而言你分配给他深度学习方面的开发工作就是苦力活，即使你自己觉得对他会很有帮助。员工已经非常熟练的工作不能够给员工的简历更加新的亮点，也不能够给他的个人技能提供进一步的提高。这类苦力活有一个好处可能是被你忽视的：这是在舒适区的工作，做起来心神舒畅，效率超高，能够获得安全感、幸福感和少量的成就感。舒适区里的苦力活就像是垫肚子的米饭一样，多少需要吃一点。</p><p><strong>巩固类</strong>的工作就是在组员愿意的前提下，既不是完全熟练也不是完全陌生的工作。这类工作对于组员而言是最甜蜜的工作：有足够的信心完成，又觉得能够获得技能提升和简历更新。</p><p>对于你而言，在分配给组员任务的时候，需要将这三类工作搭配着来是最好的。其中对于组员而言，自己不喜欢的苦力活是最应该避免的，别的工作分配好之后你都不需要操太多心。理想的情况是每个人都做着自己喜欢做的挑战、巩固和苦力活套餐。下一小节告诉你如何（尽量）做到让每个组员都高兴。</p><h2 id="任务分配的团体动力学"><a href="#任务分配的团体动力学" class="headerlink" title="任务分配的团体动力学"></a>任务分配的团体动力学</h2><p>秘诀就是注意到每个人的技能和喜好都是不一样的。在一个技术小方向上，一项工作任务对于老王可能是苦力活，对于小张就是挑战。那么你要做的就很明确了：在收集了大家的目标和反馈的基础上，在组内做分配即可。同时，注意这种“苦力变挑战”的关系隐含着建立一条组内1on1互助关系的可能性。</p><p>肯定有大家都不愿意做的事情。这个时候就因人和任务而异了。简单说没啥好办法，确保做苦力活的人不会不爽到发飙就行。</p><p>首先是可以尝试改变一下观点，尽可能地将这种苦力活儿转成有挑战的事情。如果你有权限，可以考虑招募新人或者实习生来做（前提是满足面向简历的模式）。如果临时性的工作，小工作你就自己做了。如果你一个人吃不下，那就尽量大家都均匀地吃一点。吃这个东西的时候，不患寡而患不均的情绪会比较多。你需要逐个安抚，开会群抚可能会起到反作用。</p><h2 id="一些管理的细节"><a href="#一些管理的细节" class="headerlink" title="一些管理的细节"></a>一些管理的细节</h2><p>找机会团队一起吃饭。有的组织提供吃饭的经费，这样的公司更能留住人。国家科研机构这样的没办法报销，你可能需要自己掏钱创造吃饭的机会。简单工作餐或者平民消费餐厅就非常好了。相信我，这个钱你花的值。团队有时候也会AA或者有人跳出来请客。团队不大的时候，这些都是OK的。喝下午茶也挺好，开会的时候吃零食和小点心也同样好。</p><p>一对一的讨论和你自己的技术判断要比周报之类的准确很多。</p><p>如果你无法踢出去搭顺风车的组员，那么在任务上进行明确的区分。尽你所能将干活的人和不干活的人隔离开，并且让干活的队友知道你的目的。</p><h2 id="超越基层管理"><a href="#超越基层管理" class="headerlink" title="超越基层管理"></a>超越基层管理</h2><p>有关基层软件项目管理的方法已经阐述清楚了。千真万确。</p><p>那么以后呢？可能你会有大的团队和项目需要负责，也可能会继续在管理的层级上向上走。也可能这次项目管理只是你职业生涯中的一次小插曲，项目结束之后你回到研究者或者技术专家的位置，不再从事管理的工作。不管是哪一种，我相信这本小册子都会改变你看待团队管理的角度，或许也会改变你看待未来的态度。</p><p>我对于更高级别的管理经验不足，不足以给出指导。但是有一条经验我很确定普遍适用：不要相信周报里写的东西。</p>]]></content>
    
    
    <categories>
      
      <category>book</category>
      
      <category>极简项目管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>极简项目管理:第一章 准备</title>
    <link href="/2023/03/28/%E6%9E%81%E7%AE%80%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/ch1prepare/"/>
    <url>/2023/03/28/%E6%9E%81%E7%AE%80%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/ch1prepare/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-准备和评估"><a href="#第一章-准备和评估" class="headerlink" title="第一章 准备和评估"></a>第一章 准备和评估</h1><p>所有的管理首先是预期（Expectation）的管理。首先是你自己的预期，然后是你的上级和你的组员的。本章帮助你评估和调整自己的预期。</p><p>在开始带领团队之前，你最好能够对本章中提到的问题进行一下自问自答。这些问题如果思考不充分可能会让你在后续的团队管理中内心痛苦，在真实的自己、理想的自己和别人要求的你之间来回拉扯。</p><h2 id="起因：为什么你会开始带团队？"><a href="#起因：为什么你会开始带团队？" class="headerlink" title="起因：为什么你会开始带团队？"></a>起因：为什么你会开始带团队？</h2><p>最常见的情况是你作为打工族在公司任职，你是技术岗位，工作了一段时间，上头提拔你做组长。这种情况下，要做的事情和你职责都是比较明确的。公司内部的组长也不少，大家的职责不会差别太大。</p><p>如果你是在研究机构或者学校念书，高年级了，导师有工程项目让你和几个低年级的人跟你一起做，你是实际上的项目小组长，上面的直接老板是你的导师。这也是目前非常普遍的一种组合，如果你念过研究生，可能不会陌生。这种组长的目标就是项目按时交付。很可能你自己或者低年级学生也需要基于项目写论文，这是后续项目工作中需要考虑的。</p><p>如果你是自己创业，或者做外包，处在建立团队的初期，那么你的目标就是让你的想法尽快实现，技术团队尽可能高效有冲劲，同时需要花大力气保证团队的稳定性。</p><p>这几种不同的情况，你手里的权利和责任范围是不同的。这会在后面的人事和薪资决定权上得到体现。</p><h2 id="结构：你的组员是否为你工作"><a href="#结构：你的组员是否为你工作" class="headerlink" title="结构：你的组员是否为你工作"></a>结构：你的组员是否为你工作</h2><p>这里是第一个非常重要的区分。你作为小团队的负责人会有一个直接的上级，部门经理、课题组导师、或者创业合伙人。而你的组员为你工作还是为你们共同的上级工作，性质不同。如果你的组员是为你工作的，那么你需要在工作中考虑得更多，包括团队成员的职业发展、绩效评价、个人关系等，相对而言团队也会更加紧密；相反如果明确组员跟你一样为更高管理层工作，那么你的职责更多的是起到一个协调和汇总。</p><p>这点区分之所以重要，是因为 <strong>组员、你、上层领导都可能会混淆权利和责任的匹配关系</strong>。如果组员想的是为你工作而你觉得组员是为了公司，那么你可能无法察觉和理解组员对你的失望和挫败感从何而来；反之如果你把组员当兄弟，但是其他人都觉得你只是一个协调的角色，那么你会强行给组员施加太多的情感压力，也会渴望组员热情回应你——结果往往会让你失望。</p><p>如果上级领导只是赋予你协调性的权力，但是又希望你承担起完全的责任——这发生的很普遍，不管是公司还是学校——那么你需要警惕并严肃对待：一定要尽可能早的跟你的上级沟通，<strong>不要做跟你的权限能力不匹配的承诺</strong>。例如后面会提到的，如果你不能够决定谁加入你的团队，给卖力的员工更多的激励，把浑水摸鱼的人踢出去，那么你实际上不应该让领导觉得你要为团队的成功或失败承担主要责任。</p><p>本节希望你牢记在心的最重要一句话是，组员是否为你工作是 <strong>你和每一个组员</strong> 之间的单独约定。你的每个组员都是不一样的，有的人为公司大老板工作，有的人 <strong>选择为你工作</strong> 。这可以看成你个人魅力的一部分体现。我见过很多成功的团队，团队负责人几乎都有这样的魅力体现出来。（有这种魅力，团队成功概率更高。）</p><h2 id="你是否愿意看到直接领导因为你而成功"><a href="#你是否愿意看到直接领导因为你而成功" class="headerlink" title="你是否愿意看到直接领导因为你而成功"></a>你是否愿意看到直接领导因为你而成功</h2><p>可能你的第一反应是吐槽老板，但是评价老板靠谱与否有另一套标准 :-)</p><p>简单说就是你跟你的直接老板是否都觉得你是在为他（她）工作，是否匹配。第二点是他（她）<strong>有没有担当</strong>，即是否能够在你的事情搞砸的时候站出来承担责任收拾残局，而不是把你拎出来放在他（她）的老板面前挡锅。你的直系老板的技术能力、管理判断力等，对你而言都是次要考虑的因素。我过去几年观察到的经验是下属很容易在老板的技术能力上吐槽，这就完全搞错了重点。恰恰相反的，下属应该在擅长的技术领域比直接老板强，并在团队中充分发挥这一点。</p><p>一个可以参考的评价标准是打开脑洞，想象一下当你领导的这个团队（项目）大获成功，你的直接上司得到嘉奖和升迁，你是否为他开心。开心就好。如果你觉得他（她）的成功是因为占了你的便宜，那么要多想想了。</p><h2 id="你是否有权把搭顺风车的组员踢出去"><a href="#你是否有权把搭顺风车的组员踢出去" class="headerlink" title="你是否有权把搭顺风车的组员踢出去"></a>你是否有权把搭顺风车的组员踢出去</h2><p><strong>基层管理就是让好员工干活爽。</strong> 推论是你需要甄别出让好员工不爽的因素并及时处理。我个人经验看到的最大的不爽因素是搭顺风车。</p><p>避免搭顺风车有两个步骤：及时发现，及时处理。基层管理人员在发现搭顺风车这件事情上有着绝对优势，只要把你的小团队聚集起来，闭上眼睛深吸一口气，你就能感觉到你的团队成员自发的把搭顺风车的人指认了出来。及时发现这一步的重点是：跟所有团队成员都有非正式的面对面接触（1on1），完全不要参考周报里写了什么（这也是为什么越往高层越难发现滥竽充数的原因）。</p><p>发现之后的处理，取决于你的风格、能力，以及团队成员的态度。做好撕破脸的预案，虽然我希望你不会用到。最为猛烈的方式是踢出团队，当必须要做的时候，不要犹豫。你可能多半没有办法直接调整组员（还记得前面说的权力范围么）但是你一定有办法跟你的直接老板进行协调，获得支持和协助。如果你没有办法踢出搭顺风车的人，继续往下看，后面的章节会有更加详细的操作建议。</p><p><strong>重点是目标是让好员工爽，怼搭车的人是手段不是目的。</strong></p><p>第二个重点是搭顺风车跟技术能力无关。如果你读过《人件》或许你会对“超级催化剂”有印象。团队中有一类角色很珍贵且罕见，他（她）的存在能够让团队整体的产出和凝聚力爆棚。而他（她）自己的周报和产出看起来很像是能力不足者的表现。如果你不听团队成员的意见，贸然把超级催化剂踢出去，那是你能力不足的表现。</p><h2 id="你是否有权影响队友的薪水"><a href="#你是否有权影响队友的薪水" class="headerlink" title="你是否有权影响队友的薪水"></a>你是否有权影响队友的薪水</h2><p>作为创业团队负责人或者课题组项目的博士生，你或许有这个权限调整单个组员的薪酬。而在公司，你可能连组员每个月拿多少钱都无法知晓。一般情况下，每个月或者季度你需要给你的团队成员打一次绩效。这是比较大的权力。</p><p>理论上，调整员工绩效的权力让你能够直接激励好的队友，惩罚偷懒的组员。<strong>理论上没错，使用要非常谨慎</strong>。薪资和绩效都是非常敏感的内容，当你没有把握的时候不要轻易去变动，尤其是你刚刚开始带领团队的时候，你多半是不知道一个人的绩效变化可能带来的连锁反应。</p><p>重点是不要扣绩效，不管你是否想赶这个人走。对于搭顺风车的人，踢出去而不是扣绩效。除非一致认可表现突出，否则也不要涨绩效。你的观察可能不够全面，你的衡量标准可能存在偏差。当你不确定的时候，组员认可的现状是最安全的。</p><h2 id="你一个人技术上能搞定么"><a href="#你一个人技术上能搞定么" class="headerlink" title="你一个人技术上能搞定么"></a>你一个人技术上能搞定么</h2><p>如果你刚看过《一分钟管理人》这样的一些经典管理学作品，可能会觉得自己已经掌握了管理的基本技巧：提前规划、及时表扬和批评，以人为本，情感关怀，有担当，如此种种。道理没错，我担心你并没有关注到其中的一个隐藏的假设。</p><p><strong>大部分管理方法学的书，假设你能够立刻替代你的任何组员</strong>。如果组员突然倒下或者离职了，你能够挽起袖子就接着做完。你的业务技术能力不会比任何一个组员差。组员大部分时候也这么认为，以至于一个程序员往往会因为看到上司的代码的粗陋和错误之处而开始看不起自己的上司。</p><p>这个假设大部分情况下是不成立的。我也不觉得这是你能否领导团队的前提。可惜的是，很多人并没有意识到自己被这个隐含的前提条件给束缚了，也没有深究自己的上司或自己的下属的某些要求和预期，是单纯以这个为前提作出的。误解一步步加深，鄙视的情绪悄悄生长和蔓延，你的领导力被慢慢地削弱。更可惜的是如果身为组长想要表现出自己做不到的技术能力，那么下场一般会比较可悲。《程序开发心理学》中详细记录了这样的悲情小故事。</p><p>重点是坦诚，跟团队成员的观念匹配。当你感觉到组员对你的预期时，明确地提出来并讨论，明确地表明自己能力的边界，明确地承认组员的技术优势并依赖于她（他）。</p><p>第二个重点是保持学习。我几乎每周都会有新的技术需要去了解，快速地进入一个新的技术细分领域并掌握基本的概念并没有那么难。留出足够的时间让自己保持学习能力，跟上团队成员以及大环境的变化节奏。</p><h2 id="需要阅读的书"><a href="#需要阅读的书" class="headerlink" title="需要阅读的书"></a>需要阅读的书</h2><p>《人月神话》、《人件》、《程序开发心理学》三本。如果时间来不及看完三本，看《人月神话》。但是我相信你肯定有时间看完。</p><p>这三本书让你对于软件项目管理有一个贴近现实的思维框架。其它项目管理类的书，更多的是希望把人当作无差别的机器人对待，对于基层管理而言，用处很小。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在正式开始带领全队之前，管理预期是最重要的事情。明确地讨论自己的权利和责任，做到匹配。放轻松，你只是一个最底层的小组长，坦诚地用真实的自己来跟别人打交道就够了。</p>]]></content>
    
    
    <categories>
      
      <category>book</category>
      
      <category>极简项目管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>极简项目管理:本书简介</title>
    <link href="/2023/03/28/%E6%9E%81%E7%AE%80%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/README/"/>
    <url>/2023/03/28/%E6%9E%81%E7%AE%80%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/README/</url>
    
    <content type="html"><![CDATA[<h1 id="极简项目管理"><a href="#极简项目管理" class="headerlink" title="极简项目管理"></a>极简项目管理</h1><p>如果你即将要开始变成一个小团队的负责人，那么这本书或许能够帮助到你。</p><p>可能你刚毕业不久，参加工作一年左右，得到了上司的认可开始带两三个新员工；可能你是高年级博士生，有几个硕士生围绕着你做项目；也可能你正在创业，需要组建一个小型技术团队来帮助你完成梦想。我们都能感到自己肩上的责任，领导的信任；但是团队管理这个事情好像并没有什么好说的：你拿到任务，分下去，过一段时间，收成果。这谁不会呢？</p><p>如果你在阅读完这本小册子之后，在日常的团队管理中能够有帮助，对于我而言是莫大的鼓励。如果有问题或勘误，欢迎与我联系讨论，我的邮箱是 <code>lazyparser[at]gmail.com</code> 。</p><p>这本小册子采用CC-BY-SA-NC方式发布，任何人都可以下载、打印、阅读传播。商业使用请联系我授权。本书的源代码是Markdown格式，托管在GitHub[1]上，可以根据自己需要转换成PDF、epub、azw、txt等多种格式。</p><p>[1] <a href="https://github.com/lazyparser/minimalist-team-leader">https://github.com/lazyparser/minimalist-team-leader</a></p>]]></content>
    
    
    <categories>
      
      <category>book</category>
      
      <category>极简项目管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>极简项目管理:前言</title>
    <link href="/2023/03/28/%E6%9E%81%E7%AE%80%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/preface/"/>
    <url>/2023/03/28/%E6%9E%81%E7%AE%80%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/preface/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>即使是最基层的管理也是很难的。毕竟，<strong>管理是面向人的，而人要比计算机复杂得多</strong>。这本小册子介绍了我在过去几年的项目管理中遇到的各种坑，以及在坑底仰望星空时感悟到的一些大道理。有些细节在你开始履行团队负责人职责的第一天就预示了团队是否能够成功。</p><p>书店里有关项目管理的书已经非常多了，团队管理的经典著作看一年可能都看不完，为什么还要写这本小册子呢？我读过不少知名的团队管理经典著作，在我自己的团队管理过程中也尝试实践过一些。我个人最大的感受是现有的管理方法和技术，对于一个基层管理的新人而言都太宏大了，就像是让刚学会走路的孩子去跑百米跨栏一样，重量级差太多。这本小册子记录了我在基层团队管理的实践中，觉得最重要和实用的一些操作。最大的特点是理论非常的轻量级，只有两条核心概念，连“理论”都算不上；非常简短，在上下班的地铁里就能够一口气读完。</p>]]></content>
    
    
    <categories>
      
      <category>book</category>
      
      <category>极简项目管理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>book</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>002--你不知道的基本数据类型和包装类+面试题</title>
    <link href="/2023/03/24/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/002--%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB+%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/03/24/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/002--%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8C%85%E8%A3%85%E7%B1%BB+%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="你不知道的基本数据类型和包装类-面试题"><a href="#你不知道的基本数据类型和包装类-面试题" class="headerlink" title="你不知道的基本数据类型和包装类 + 面试题"></a>你不知道的基本数据类型和包装类 + 面试题</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>Java 基本数据按类型可以分为四大类：布尔型、整数型、浮点型、字符型，这四大类包含 8 种基本数据类型。</p><ul><li>布尔型：boolean</li><li>整数型：byte、short、int、long</li><li>浮点型：float、double</li><li>字符型：char</li></ul><p>8 种基本类型取值如下：</p><table><thead><tr><th>数据类型</th><th>代表含义</th><th>默认值</th><th>取值</th><th>包装类</th></tr></thead><tbody><tr><td>boolean</td><td>布尔型</td><td>false</td><td>0(false) 到 1(true)</td><td>Boolean</td></tr><tr><td>byte</td><td>字节型</td><td>(byte)0</td><td>﹣128 到 127</td><td>Byte</td></tr><tr><td>char</td><td>字符型</td><td>‘\u0000’(空)</td><td>‘\u0000’ 到 ‘\uFFFF’</td><td>Character</td></tr><tr><td>short</td><td>短整数型</td><td>(short)0</td><td>-2^15 到 2^15</td><td>Short</td></tr><tr><td>int</td><td>整数型</td><td>0</td><td>﹣2^31 到 2^31﹣1</td><td>Integer</td></tr><tr><td>long</td><td>长整数型</td><td>0L</td><td>﹣2^63 到 2^63﹣1</td><td>Long</td></tr><tr><td>float</td><td>单浮点型</td><td>0.0f</td><td>1.4e-45 到 3.4e+38</td><td>Float</td></tr><tr><td>double</td><td>双浮点型</td><td>0.0d</td><td>4.9e-324 到 1.798e+308</td><td>Double</td></tr></tbody></table><p>除 char 的包装类 Character 和 int 的包装类 Integer之外，其他基本数据类型的包装类只需要首字母大写即可。包装类的作用和特点，本文下半部分详细讲解。</p><p>我们可以在代码中，查看某种类型的取值范围，代码如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) <br>    // Byte 取值：<span class="hljs-number">-128</span> ~ <span class="hljs-number">127</span><br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(String.format(&quot;Byte 取值：%d ~ %d&quot;, Byte.MIN_VALUE, Byte.MAX_VALUE));<br>    // <span class="hljs-type">Int</span> 取值：<span class="hljs-number">-2147483648</span> ~ <span class="hljs-number">2147483647</span><br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(String.format(&quot;Int 取值：%d ~ %d&quot;, <span class="hljs-type">Integer</span>.MIN_VALUE, <span class="hljs-type">Integer</span>.MAX_VALUE));<br><br></code></pre></td></tr></table></figure><h3 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h3><p>我们知道 8 种基本数据类型都有其对应的包装类，因为 Java的设计思想是万物皆对象，有很多时候我们需要以对象的形式操作某项功能，比如说获取哈希值（hashCode）或获取类（getClass）等。</p><p>那包装类特性有哪些？</p><p><strong>1. 功能丰富</strong></p><p>包装类本质上是一个对象，对象就包含有属性和方法，比如 hashCode、getClass 、max、min 等。</p><p><strong>2. 可定义泛型类型参数</strong></p><p>包装类可以定义泛型，而基本类型不行。</p><p>比如使用 Integer 定义泛型，代码：</p><pre><code class="hljs">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code></pre><p>如果使用 int 定义就会报错，代码：</p><pre><code class="hljs">List&lt;int&gt; list = new ArrayList&lt;&gt;();  // 编译器代码报错</code></pre><p><strong>3. 序列化</strong></p><p>因为包装类都实现了 Serializable 接口，所以包装类天然支持序列化和反序列化。比如 Integer 的类图如下：</p><p><img src="https://images.gitbook.cn/cb8c6a80-baa8-11e9-8bd3-43e1fddff917" alt="Integer 类图"></p><p><strong>4. 类型转换</strong></p><p>包装类提供了类型转换的方法，可以很方便的实现类型之间的转换，比如 Integer 类型转换代码：</p><pre><code class="hljs">String age = &quot;18&quot;;int ageInt = Integer.parseInt(age) + 2;// 输出结果：20System.out.println(ageInt);</code></pre><p><strong>5. 高频区间的数据缓存</strong></p><p>此特性为包装类很重要的用途之一，用于高频区间的数据缓存，以 Integer 为例来说，在数值区间为 -128~127<br>时，会直接复用已有对象，在这区间之外的数字才会在堆上产生。</p><p>我们使用 == 对 Integer 进行验证，代码如下：</p><pre><code class="hljs">public static void main(String[] args)         // Integer 高频区缓存范围 -128~127        Integer num1 = 127;        Integer num2 = 127;        // Integer 取值 127 == 结果为 true（值127 num1==num2 =&gt; true）        System.out.println(&quot;值127 num1==num2 =&gt; &quot; + (num1 == num2));        Integer num3 = 128;        Integer num4 = 128;        // Integer 取值 128 == 结果为 false（值128 num3==num4 =&gt; false）        System.out.println(&quot;值128 num3==num4 =&gt; &quot; + (num3 == num4));    </code></pre><p>从上面的代码很明显可以看出，Integer 为 127 时复用了已有对象，当值为 128 时，重新在堆上生成了新对象。</p><p>为什么会产生高频区域数据缓存？我们查看源码就能发现“线索”，源码版本 JDK8，源码如下：</p><pre><code class="hljs">public static Integer valueOf(int i)   if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)    return IntegerCache.cache[i + (-IntegerCache.low)];  return new Integer(i);</code></pre><p>由此可见，高频区域的数值会直接使用已有对象，非高频区域的数值会重新 new 一个新的对象。</p><p>各包装类高频区域的取值范围：</p><ul><li>Boolean：使用静态 final 定义，就会返回静态值</li><li>Byte：缓存区 -128~127</li><li>Short：缓存区 -128~127</li><li>Character：缓存区 0~127</li><li>Long：缓存区 -128~127</li><li>Integer：缓存区 -128~127</li></ul><h3 id="包装类的注意事项"><a href="#包装类的注意事项" class="headerlink" title="包装类的注意事项"></a>包装类的注意事项</h3><ul><li><p>int 的默认值是 0，而 Integer 的默认值是 null。</p></li><li><p>推荐所有包装类对象之间的值比较使用 <code>equals()</code> 方法，因为包装类的非高频区数据会在堆上产生，而高频区又会复用已有对象，这样会导致同样的代码，因为取值的不同，而产生两种截然不同的结果。代码示例：</p></li></ul> <figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) <br>    // <span class="hljs-type">Integer</span> 高频区缓存范围 <span class="hljs-number">-128</span>~<span class="hljs-number">127</span><br>    <span class="hljs-type">Integer</span> num1 = <span class="hljs-number">127</span>;<br>    <span class="hljs-type">Integer</span> num2 = <span class="hljs-number">127</span>;<br>    // <span class="hljs-type">Integer</span> 取值 <span class="hljs-number">127</span> == 结果为 <span class="hljs-keyword">true</span>（值<span class="hljs-number">127</span> num1==num2 =&gt; <span class="hljs-keyword">true</span>）<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;值127 num1==num2 =&gt; &quot; + (num1 == num2));<br>    <span class="hljs-type">Integer</span> num3 = <span class="hljs-number">128</span>;<br>    <span class="hljs-type">Integer</span> num4 = <span class="hljs-number">128</span>;<br>    // <span class="hljs-type">Integer</span> 取值 <span class="hljs-number">128</span> == 结果为 <span class="hljs-keyword">false</span>（值<span class="hljs-number">128</span> num3==num4 =&gt; <span class="hljs-keyword">false</span>）<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;值128 num3==num4 =&gt; &quot; + (num3 == num4));<br>    // <span class="hljs-type">Integer</span> 取值 <span class="hljs-number">128</span> equals 结果为 <span class="hljs-keyword">true</span>（值<span class="hljs-number">128</span> num3.equals(num4) =&gt; <span class="hljs-keyword">true</span>）<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;值128 num3.equals(num4) =&gt; &quot; + num3.equals(num4));<br><br></code></pre></td></tr></table></figure><ul><li><p>Float 和 Double 不会有缓存，其他包装类都有缓存。</p></li><li><p>Integer 是唯一一个可以修改缓存范围的包装类，在 VM optons 加入参数：</p></li></ul><blockquote><p>-XX:AutoBoxCacheMax=666 即修改缓存最大值为 <code>666</code> 。</p></blockquote><p>示例代码如下：</p><pre><code class="hljs">public static void main(String[] args)     Integer num1 = -128;    Integer num2 = -128;    System.out.println(&quot;值为-128 =&gt; &quot; + (num1 == num2));    Integer num3 = 666;    Integer num4 = 666;    System.out.println(&quot;值为666 =&gt; &quot; + (num3 == num4));    Integer num5 = 667;    Integer num6 = 667;    System.out.println(&quot;值为667 =&gt; &quot; + (num5 == num6));</code></pre><p>执行结果如下：</p><pre><code class="hljs">值为-128 =&gt; true值为666 =&gt; true值为667 =&gt; false</code></pre><p>由此可见将 Integer 最大缓存修改为 666 之后，667 不会被缓存，而 -128~666 之间的数都被缓存了。</p><h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="1-以下-Integer-代码输出的结果是？"><a href="#1-以下-Integer-代码输出的结果是？" class="headerlink" title="1. 以下 Integer 代码输出的结果是？"></a>1. 以下 Integer 代码输出的结果是？</h4><pre><code class="hljs">Integer age = 10;Integer age2 = 10;Integer age3 = 133;Integer age4 = 133;System.out.println((age == age2) + &quot;,&quot; + (age3 == age4));</code></pre><p>答：<code>true,false</code></p><h4 id="2-以下-Double-代码输出的结果是？"><a href="#2-以下-Double-代码输出的结果是？" class="headerlink" title="2. 以下 Double 代码输出的结果是？"></a>2. 以下 Double 代码输出的结果是？</h4><pre><code class="hljs">Double num = 10d;Double num2 = 10d;Double num3 = 133d;Double num4 = 133d;System.out.println((num == num2) + &quot;,&quot; + (num3 == num4));</code></pre><p>答：<code>false,false</code></p><h4 id="3-以下程序输出结果是？"><a href="#3-以下程序输出结果是？" class="headerlink" title="3. 以下程序输出结果是？"></a>3. 以下程序输出结果是？</h4><pre><code class="hljs">int i = 100;Integer j = new Integer(100);System.out.println(i == j);System.out.println(j.equals(i));</code></pre><p>A：true,true<br>B：true,false<br>C：false,true<br>D：false,false  </p><p>答：A</p><p>题目分析：有人认为这和 Integer 高速缓存有关系，但你发现把值改为 10000 结果也是 <code>true,true</code>，这是因为 Integer 和 int<br>比较时，会自动拆箱为 int 相当于两个 int 比较，值一定是 <code>true,true</code>。</p><h4 id="4-以下程序执行的结果是？"><a href="#4-以下程序执行的结果是？" class="headerlink" title="4. 以下程序执行的结果是？"></a>4. 以下程序执行的结果是？</h4><pre><code class="hljs">final int iMax = Integer.MAX_VALUE;System.out.println(iMax + 1);</code></pre><p>A：2147483648<br>B：-2147483648<br>C：程序报错<br>D：以上都不是</p><p>答：B</p><p>题目解析：这是因为整数在内存中使用的是补码的形式表示，最高位是符号位 0 表示正数，1 表示负数，当执行 +1 时，最高位就变成了 1，结果就成了-2147483648。</p><h4 id="5-以下程序执行的结果是？"><a href="#5-以下程序执行的结果是？" class="headerlink" title="5. 以下程序执行的结果是？"></a>5. 以下程序执行的结果是？</h4><pre><code class="hljs">Set&lt;Short&gt; set = new HashSet&lt;&gt;();for (short i = 0; i &lt; 5; i++)     set.add(i);    set.remove(i - 1);System.out.println(set.size());</code></pre><p>A：1<br>B：0<br>C：5<br>D：以上都不是  </p><p>答：5</p><p>题目解析：Short 类型 -1 之后转换成了 Int 类型，remove() 的时候在集合中找不到 Int<br>类型的数据，所以就没有删除任何元素，执行的结果就是 5。</p><h4 id="6-short-s-2-s-s-1-会报错吗？short-s-2-s-1-会报错吗？"><a href="#6-short-s-2-s-s-1-会报错吗？short-s-2-s-1-会报错吗？" class="headerlink" title="6. short s=2;s=s+1; 会报错吗？short s=2;s+=1; 会报错吗？"></a>6. <code>short s=2;s=s+1;</code> 会报错吗？<code>short s=2;s+=1;</code> 会报错吗？</h4><p>答：s=s+1 会报错，s+=1 不会报错，因为 s=s+1 会导致 short 类型升级为 int 类型，所以会报错，而 s+=1 还是原来的 short<br>类型，所以不会报错。</p><h4 id="7-float-f-3-4-会报错吗？为什么？"><a href="#7-float-f-3-4-会报错吗？为什么？" class="headerlink" title="7. float f=3.4; 会报错吗？为什么？"></a>7. <code>float f=3.4;</code> 会报错吗？为什么？</h4><p>答：会报错，因为值 3.4 是 double 类型，float 类型级别小于 double 类型，所以会报错。如下图所示：</p><p><img src="https://images.gitbook.cn/1cab8440-baaa-11e9-8bd3-43e1fddff917" alt="报错示例图"></p><h4 id="8-为什么需要包装类？"><a href="#8-为什么需要包装类？" class="headerlink" title="8. 为什么需要包装类？"></a>8. 为什么需要包装类？</h4><p>答：需要包装类的原因有两个。</p><p>① Java 的设计思想是万物既对象，包装类体现了面向对象的设计理念；<br>② 包装类包含了很多属性和方法，比基本数据类型功能多，比如提供的获取哈希值（hashCode）或获取类（getClass）的方法等。</p><h4 id="9-基本类-int-和包装类-Integer，在-128-127-之间都会复用已有的缓存对象，这种说法正确吗？"><a href="#9-基本类-int-和包装类-Integer，在-128-127-之间都会复用已有的缓存对象，这种说法正确吗？" class="headerlink" title="9. 基本类 int 和包装类 Integer，在 -128~127 之间都会复用已有的缓存对象，这种说法正确吗？"></a>9. 基本类 int 和包装类 Integer，在 -128~127 之间都会复用已有的缓存对象，这种说法正确吗？</h4><p>答：不正确，只有包装类高频区域数据才有缓存。</p><h4 id="10-包装类-Double-和-Integer-一样都有高频区域数据缓存，这种说法正确吗？"><a href="#10-包装类-Double-和-Integer-一样都有高频区域数据缓存，这种说法正确吗？" class="headerlink" title="10. 包装类 Double 和 Integer 一样都有高频区域数据缓存，这种说法正确吗？"></a>10. 包装类 Double 和 Integer 一样都有高频区域数据缓存，这种说法正确吗？</h4><p>答：不正确，基本数据类型的包装类只有 Double 和 Float 没有高频区域的缓存。</p><h4 id="11-包装类的值比较要使用什么方法？"><a href="#11-包装类的值比较要使用什么方法？" class="headerlink" title="11. 包装类的值比较要使用什么方法？"></a>11. 包装类的值比较要使用什么方法？</h4><p>答：包装类因为有高频区域数据缓存，所以推荐使用 equals() 方法进行值比较。</p><h4 id="12-包装类有哪些功能？"><a href="#12-包装类有哪些功能？" class="headerlink" title="12. 包装类有哪些功能？"></a>12. 包装类有哪些功能？</h4><p>答：包装类提供的功能有以下几个。</p><ul><li>功能丰富：包装类包含了有 hashCode、getClass 、max、min 等方法；</li><li>可定义泛型类型参数：例如 <code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code> ;</li><li>序列化：包装类实现了 Serializable 接口，所以包装类天然支持序列化和反序列化；</li><li>类型转换：包装类提供了方便的类型转换方法，比如 Integer 的 parseInt() 方法；</li><li>高频区域数据缓存：高频区域可使用已有的缓存对象。</li></ul><p>详见正文“包装类型”部分内容。</p><h4 id="13-泛型可以为基本类型吗？为什么？"><a href="#13-泛型可以为基本类型吗？为什么？" class="headerlink" title="13. 泛型可以为基本类型吗？为什么？"></a>13. 泛型可以为基本类型吗？为什么？</h4><p>答：泛型不能使用基本数据类型。泛型在 JVM（Java虚拟机）编译的时候会类型檫除，比如代码 <code>List&lt;Integer&gt; list</code> 在 JVM<br>编译的时候会转换为 <code>List list</code> ，因为泛型是在 JDK 5 时提供的，而 JVM<br>的类型檫除是为了兼容以前代码的一个折中方案，类型檫除之后就变成了 Object，而 Object<br>不能存储基本数据类型，但可以使用基本数据类型对应的包装类，所以像 <code>List&lt;int&gt; list</code> 这样的代码是不被允许的，编译器阶段会检查报错，而<br><code>List&lt;Integer&gt; list</code> 是被允许的。</p><h4 id="14-选择包装类还是基本类的原则有哪些？"><a href="#14-选择包装类还是基本类的原则有哪些？" class="headerlink" title="14. 选择包装类还是基本类的原则有哪些？"></a>14. 选择包装类还是基本类的原则有哪些？</h4><p>答：我们知道正确的使用包装类，可以提供程序的执行效率，可以使用已有的缓存，一般情况下选择基本数据类型还是包装类原则有以下几个。</p><p>① 所有 POJO 类属性必须使用包装类；<br>② RPC 方法返回值和参数必须使用包装类；<br>③ 所有局部变量推荐使用基本数据类型。</p><h4 id="15-基本数据类型在-JVM-中一定存储在栈中吗？为什么？"><a href="#15-基本数据类型在-JVM-中一定存储在栈中吗？为什么？" class="headerlink" title="15. 基本数据类型在 JVM 中一定存储在栈中吗？为什么？"></a>15. 基本数据类型在 JVM 中一定存储在栈中吗？为什么？</h4><p>答：基本数据类型不一定存储在栈中，因为基本类型的存储位置取决于声明的作用域，来看具体的解释。</p><ul><li>当基本数据类型为局部变量的时候，比如在方法中声明的变量，则存放在方法栈中的，当方法结束系统会释放方法栈，在该方法中的变量也会随着栈的销毁而结束，这也是局部变量只能在方法中使用的原因；</li><li>当基本数据类型为全局变量的时候，比如类中的声明的变量，则存储在堆上，因为全局变量不会随着某个方法的执行结束而销毁。</li></ul><h4 id="16-以下程序执行的结果是？"><a href="#16-以下程序执行的结果是？" class="headerlink" title="16. 以下程序执行的结果是？"></a>16. 以下程序执行的结果是？</h4><pre><code class="hljs">Integer i1 = new Integer(10);Integer i2 = new Integer(10);Integer i3 = Integer.valueOf(10);Integer i4 = Integer.valueOf(10);System.out.println(i1 == i2);System.out.println(i2 == i3);System.out.println(i3 == i4);</code></pre><p>A：false,false,false<br>B：false,false,true<br>C：false,true,true<br>D：true,false,false</p><p>答：B</p><p>题目解析：new Integer(10) 每次都会创建一个新对象，Integer.valueOf(10) 则会使用缓存池中的对象。</p><h4 id="17-3-0-1-0-3-返回值是多少？"><a href="#17-3-0-1-0-3-返回值是多少？" class="headerlink" title="17. 3*0.1==0.3 返回值是多少？"></a>17. 3*0.1==0.3 返回值是多少？</h4><p>答：返回值为：false。</p><p>题目解析：因为有些浮点数不能完全精确的表示出来，如下代码：</p><blockquote><p>System.out.println(3 * 0.1);</p></blockquote><p>返回的结果是：0.30000000000000004。</p>]]></content>
    
    
    <categories>
      
      <category>Java面试全解析核心知识点与典型面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>000--如何轻松获得Offer</title>
    <link href="/2023/03/24/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/000--%E5%A6%82%E4%BD%95%E8%BD%BB%E6%9D%BE%E8%8E%B7%E5%BE%97Offer/"/>
    <url>/2023/03/24/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/000--%E5%A6%82%E4%BD%95%E8%BD%BB%E6%9D%BE%E8%8E%B7%E5%BE%97Offer/</url>
    
    <content type="html"><![CDATA[<h2 id="如何轻松获得-Offer"><a href="#如何轻松获得-Offer" class="headerlink" title="如何轻松获得 Offer"></a>如何轻松获得 Offer</h2><p>你好，我是xx，某上市公司技术研发经理，前奇虎 360 员工，有着 10余年的编程工作经验，目前主要负责新员工技术面试和构建企业技术架构的相关事宜。随着面试过的人数增加，我发现面试者们暴露出了技术方面的很多问题，为了让更多面试者少走一些弯路，也为了让企业能招到合适的技术人才，于是就诞生了这个专栏。</p><p>为了写好这个专栏内容，我先后拜访了一二十家互联网公司，与不同的面试官和面试者进行面对面探讨，深入了解了企业对于面试者的要求和常见的 Java面试题型。之后我花了大半年的时间，结合自己 4 年多作为面试官的经历，把这些内容整理成文，用大约 10 万字的内容对 Java 的核心知识点和常见的 500多道面试题，做了详细的介绍，也就是本专栏中你所看到的全部内容，希望对你能有所帮助。</p><h3 id="为什么要学这个专栏内容？"><a href="#为什么要学这个专栏内容？" class="headerlink" title="为什么要学这个专栏内容？"></a>为什么要学这个专栏内容？</h3><p><strong>「因为它能为你赢得面试的主动权，让你获得更多的 Offer。」</strong></p><p>从业十多年，我从面试者变成面试官，在 Java 面试上积累了比较丰富的经验。</p><p>其实，很多面试者在搜集面试资料的时候都踩过一些“坑”，你是不是也遇到过：</p><ul><li>免费搜索的面试题，内容 <strong>不全面</strong> ，这就算了，有时候答案都 <strong>不准确</strong> </li><li>很多培训机构提供的面试宝典内容虽然不少，但 <strong>深度不够</strong> ，且面试题 <strong>过于老旧</strong> 脱离了企业实际需要</li><li>还有很多付费的面试题存在滥竽充数，提供了很多没有价值的面试题， <strong>钱花了，干货没学到</strong> </li><li>市面上大部分面试题只讲了基础概念， <strong>没有提供题目解析和示例代码</strong> ，不利于读者真正的掌握背后的原理，只能死记硬背，且容易忘记。</li></ul><p>为了规避这些“坑”，我跑了很多家互联网公司，来确认 Java 面试中实际考察的高频知识点和常见题型。可是有了第一手素材后，我要如何让大家真正从我的讲解中学到干货、用到实处呢？</p><p>经过反复验证，我才设计了如下的内容讲述模式。</p><p><strong>第一，500+ 面试题详解。</strong></p><p>如果你是还没走入职场的新人，我会为你提供完整的 Java 技术栈讲解，以及 最新、最全、最实用 的 500 多道 Java 面试题详解。</p><p><strong>第二，10万字 Java 核心知识点梳理。</strong></p><p>本专栏的每一篇内容，都采用的是「核心知识点 + N 道相关面试题」的模式，让你不单能应付面试，还能学到更多的 Java 核心知识。</p><p><strong>第三，技术、面试搭配平衡，不但让你学到心里，还助你展示出来。</strong></p><p>面对目前技术市场的相对冷淡和一个职位多个应聘者竞争的现状，面试者们只有掌握更多 Java 核心技能和面试理论知识，才能在众多面试者中脱颖而出。</p><p>本专栏每篇文章大致分为两个部分： <strong>Java 核心点介绍 + 相关面试题详解</strong><br>，这两部分内容相辅相成，前面的核心知识点介绍让后面的面试题更容易理解，后面的面试题加深了读者对于 Java 核心点的掌握。如此一来，让你所学及所用，不仅能够应付面试，更能学习到更多有价值的 Java 技术点，让你在面试中和工作中都能展示的更加出色。</p><h3 id="专栏大纲"><a href="#专栏大纲" class="headerlink" title="专栏大纲"></a>专栏大纲</h3><p>本专栏分为七大部分，共计 37 讲，约 10 万字。</p><h4 id="第一部分：Java-基础强化"><a href="#第一部分：Java-基础强化" class="headerlink" title="第一部分：Java 基础强化"></a>第一部分：Java 基础强化</h4><p>这部分包含 7 篇文章，我会从 Java 最基础的内容讲起。有最常见的 String 面试题从表象到原理的深入讲解还有 Java 8 中新特性的介绍，比如时间和日期模块，让你使用更简洁和优化的方式写出更完美的代码还有我们日常用的很多包装类不为人知的有趣现象和知识盲点介绍还有数组以及算法的介绍，虽然基础但容易被面试者忽略和容易出错的问题……</p><h4 id="第二部分：各种类和克隆"><a href="#第二部分：各种类和克隆" class="headerlink" title="第二部分：各种类和克隆"></a>第二部分：各种类和克隆</h4><p>这部分包含 4 篇文章，除了会深入讲解 Java 中的各种类和接口的相关内容，还会深入讲解浅克隆和深克隆的各种实现方式，以及配合各种图片让你更形象地理解深/浅克隆的本质。</p><h4 id="第三部分：数据结构和队列"><a href="#第三部分：数据结构和队列" class="headerlink" title="第三部分：数据结构和队列"></a>第三部分：数据结构和队列</h4><p>这部分包含 4 篇文章，对面试中必考的集合，除了相关的面试题讲解，更要理清各种集合之间的关系，创建集合之间的联系，这样才能对集合的整体理解做到心中有数。我使用了归纳法和各种关系图，帮你理清思路，打通你的“任督二脉”。其中还有队列的内容，可能开发者经常会听到，但实际的工作中使用的较少，本部分内容也会带你玩转这些数据结构，让你在面试中能够应对自如。</p><h4 id="第四部分：反射和动态代理"><a href="#第四部分：反射和动态代理" class="headerlink" title="第四部分：反射和动态代理"></a>第四部分：反射和动态代理</h4><p>这部分会帮你理清反射和动态代理的关系，并提供很多实际使用的场景，让你更好地使用到反射和动态代理，当然这部分也会为你提供各种形式反射和动态代理的实现方式，让你可以随心所欲的使用它们。这部分内容还提供了 IO 的相关知识，并提供详细的示例和原理分析，也会试着编写一个简单 Socket 服务器。</p><h4 id="第五部分：多线程编程"><a href="#第五部分：多线程编程" class="headerlink" title="第五部分：多线程编程"></a>第五部分：多线程编程</h4><p>这部分包含 7 篇文章，讲述了包含 Java 8 在内的 8 种线程池，以及线程池的正确使用姿势，还有死锁代码的编写和死锁的解决方案。本部分还会介绍 Java 中的各种锁，以及它们的区别和使用场景，还会介绍 CAS 和著名的 ABA 问题的解决方案，还有多线程中的各种高频面试题。</p><h4 id="第六部分：Java-热门框架和分布式消息队列"><a href="#第六部分：Java-热门框架和分布式消息队列" class="headerlink" title="第六部分：Java 热门框架和分布式消息队列"></a>第六部分：Java 热门框架和分布式消息队列</h4><p>这部分包含 6 篇文章，从 Spring 到最近比较热门的微服务框架 SpringBoot，还有国内常用的 Mybatis 和 Java 技术栈中其他常用的框架，比如 Dubbo 和 Zookeeper，还有分布式消息队列 RabbitMQ 和 Kafka 的介绍和面试题汇总。</p><h4 id="第七部分：Java-高手进阶"><a href="#第七部分：Java-高手进阶" class="headerlink" title="第七部分：Java 高手进阶"></a>第七部分：Java 高手进阶</h4><p>本部分内容包含 6 篇文章，可谓 Java 技术栈最实用的面试补充“大礼包”，有设计模式的面试题汇总还有 DBA 级别的 MySQL 和 Redis 面试题汇总还有成为高手必懂的 JVM 和算法的面试题汇总最后回到本专栏的主题内容，提供了 Java 最容易出错的面试题汇总作为收束篇目，助你稳健地拿到想要的 Offer。</p><p>以下是这个专栏的知识树：</p><p><img src="https://images.gitbook.cn/Fi8hRjU7MamV76mQsmGgPZLcmrqg" alt="avatar"></p><h3 id="专栏寄语"><a href="#专栏寄语" class="headerlink" title="专栏寄语"></a>专栏寄语</h3><p>希望通过本专栏的学习，你不但能拿到 Offer、取得更好的工作，还能建立一个完整的 Java 知识体系，让你学到的所有内容都能转化为实际的生产力，帮你在工作中取得不凡的成绩。并且希望明白原理后的你，能把这些记忆一直存储在自己大脑中，这样它将会成为你一辈子的财富。</p><p>我坚信：持续学习才是最有价值的投资，让我们一起行动起来，一起来做这件最有价值的事情。</p><p>最后，预祝每一位学习本专栏的朋友，都能找到一份自己理想中的工作。</p>]]></content>
    
    
    <categories>
      
      <category>Java面试全解析核心知识点与典型面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RedisSerializer接口的作用及其使用示例</title>
    <link href="/2023/02/22/redis/RedisSerializer%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/"/>
    <url>/2023/02/22/redis/RedisSerializer%E6%8E%A5%E5%8F%A3%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%85%B6%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<p>RedisSerializer 接口是 Redis 客户端用来序列化和反序列化数据的接口。RedisSerializer 接口的实现类可以将 Java 对象转换为字节数组，以便在 Redis 中进行存储，也可以将字节数组转换回 Java 对象。</p><p>RedisSerializer 接口有两个方法需要实现：</p><ul><li><code>serialize(Object object)</code>：将 Java 对象序列化成字节数组。</li><li><code>deserialize(byte[] bytes)</code>：将字节数组反序列化为 Java 对象。<br>以下是一个示例，展示如何使用 RedisSerializer 接口来序列化和反序列化一个 Java 对象：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <span class="hljs-comment">// getters and setters</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonSerializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RedisSerializer</span>&lt;Person&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] serialize(Person person) <span class="hljs-keyword">throws</span> SerializationException &#123;<br>        <span class="hljs-keyword">if</span> (person == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> mapper.writeValueAsBytes(person);<br>        &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SerializationException</span>(<span class="hljs-string">&quot;Error serializing object to JSON&quot;</span>, e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Person <span class="hljs-title function_">deserialize</span><span class="hljs-params">(<span class="hljs-type">byte</span>[] bytes)</span> <span class="hljs-keyword">throws</span> SerializationException &#123;<br>        <span class="hljs-keyword">if</span> (bytes == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">mapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> mapper.readValue(bytes, Person.class);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SerializationException</span>(<span class="hljs-string">&quot;Error deserializing object from JSON&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个 <code>Person</code> 类和一个实现了 <code>RedisSerializer&lt;Person&gt;</code> 接口的 <code>PersonSerializer</code> 类。在 <code>PersonSerializer</code> 类中，我们使用了 Jackson 库中的 <code>ObjectMapper</code> 来将 <code>Person</code> 对象转换为 JSON 字节数组并反之。当我们将 <code>Person</code> 对象存储到 Redis 中时，我们可以使用 <code>PersonSerializer</code> 将其序列化为字节数组，并使用 Redis 客户端将其存储到 Redis 中。当我们从 Redis 中获取 <code>Person</code> 对象时，我们可以使用 <code>PersonSerializer</code> 将其从字节数组反序列化为 <code>Person</code> 对象。</p>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Class类详解</title>
    <link href="/2023/02/20/java/Class%E7%B1%BB%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/02/20/java/Class%E7%B1%BB%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="Class类简介"><a href="#Class类简介" class="headerlink" title="Class类简介"></a>Class类简介</h2><p>在 <code>java</code> 世界里，一切皆对象。从某种意义上来说，<code>java</code> 有两种对象：实例对象和 <code>Class</code> 对象。每个类的运行时的<strong>类型信息</strong>就是用 <code>Class</code> 对象表示的，它包含了与类有关的信息，实例对象就是通过 <code>Class</code> 对象来创建的。<code>Java</code> 使用 <code>Class</code> 对象执行其 <code>RTTI</code> (运行时类型识别，Run-Time Type Identification)，多态就是基于 <code>RTTI</code> 实现的。</p><p>每一个类都有一个 <code>Class</code> 对象，每当编译一个新类就产生一个 <code>Class</code> 对象，基本类型 (boolean, byte, char, short, int, long, float, double)有 <code>Class</code> 对象，就连关键字 <code>void</code> 也有 <code>Class</code> 对象（void.class）。<code>Class</code> 对象对应着 <code>java.lang.Class</code> 类，如果说类是对象的抽象和集合，那么 <code>Class</code> 类就是对类的抽象和集合。</p><p><code>Class</code> 类只有一个私有的构造方法，不能通过 <code>new</code> 关键字来创建，而是在类加载的时候由 <code>Java</code> 虚拟机以及类加载器来自动构造的。</p><p><strong>所有的类都是在对其第一次使用时，动态加载到 <code>JVM</code> 中的（懒加载）。当程序创建第一个对类的静态成员的引用时，就会加载这个类。使用 <code>new</code> 创建类对象的时候也会被当作对类的静态成员的引用。因此 <code>java</code> 程序在它开始运行之前并非被完全加载，其各个类都是在必需时才加载的。</strong></p><p>在类加载阶段，类加载器首先检查这个类的 <code>Class</code> 对象是否已经被加载。如果尚未加载，默认的类加载器就会根据类的全限定名查找 <code>.class</code>文件。在这个类的字节码被加载时，它们会接受验证，以确保其没有被破坏，并且不包含不良 <code>java</code> 代码。一旦某个类的 <code>Class</code> 对象被载入内存，我们就可以它来创建这个类的所有对象。</p><h2 id="获取-Class-对象的方式"><a href="#获取-Class-对象的方式" class="headerlink" title="获取 Class 对象的方式"></a>获取 Class 对象的方式</h2><p>有三种获得 <code>Class</code> 对象的方式：</p><ol><li> <code>Class.forName</code>(“类的全限定名”)</li><li> 实例对象 <code>.getClass()</code></li><li> 类名 <code>.class</code> (类字面常量)</li></ol><p>第一种方式示例代码如下：</p><pre><code class="hljs">public class Dog &#123;    static &#123;        System.out.println(&quot;Loading Dog&quot;);    &#125;&#125;public class Cat &#123;    static &#123;        System.out.println(&quot;Loading Cat&quot;);    &#125;&#125;public class GetClassSimple &#123;    public static void main(String[] args) &#123;        Dog dog = new Dog();        try &#123;            Class&lt;?&gt; cat = Class.forName(&quot;fanda.zeng.reflect.Cat&quot;);               Class&lt;?&gt; dog2 = Class.forName(&quot;fanda.zeng.reflect.Dog&quot;);         &#125; catch (ClassNotFoundException e) &#123;            System.out.println(&quot;can not find class&quot;);            e.printStackTrace();        &#125;    &#125;&#125;</code></pre><p>输出：</p><pre><code class="hljs">Loading DogLoading Cat</code></pre><p>上述的 <code>static&#123;&#125;</code> 代码块只会在第一次加载类的时候被调用，由输出结果得知，<code>new</code> 对象和调用<code>Class.forName</code> 时会判断类是否已经加载，没有加载则会调用类加载器来加载类，已经加载过了，不会重复加载。<code>Class.forName</code> 的好处就在于，不需要为了获得 <code>Class</code> 引用而持有该类型的对象，只要通过全限定名就可以返回该类型的一个 <code>Class</code> 引用。</p><p>第二种方式示例代码如下：</p><pre><code class="hljs">Dog dog = new Dog();Class&lt;?&gt; clazz = dog.getClass();</code></pre><p>输出：</p><pre><code class="hljs">Loading Dog</code></pre><p>如果你已经有了该类型的对象，那么我们就可以通过调用 <code>getClass()</code> 方法来获取 <code>Class</code> 引用了，这个方法属于根类 <code>Object</code> 的一部分，它返回的是表示该对象的实际类型的 <code>Class</code> 引用。因为 <code>new</code> 操作已经把类加载到内存了，所有 <code>getClass</code> 方法不会再去执行类加载了，而是直接从 <code>java</code> 堆中返回该类型的 <code>Class</code> 引用。</p><p>第三种方式示例代码如下：</p><pre><code class="hljs">Class c1 = Integer.class;Class c2 = int.class;Class c3 = Integer.TYPE;Class dog = Dog.class;Class cat = Cat.class;System.out.println(c1);System.out.println(c2);System.out.println(c3);</code></pre><p>输出：</p><pre><code class="hljs">class java.lang.Integerintint</code></pre><p>这种方式在编译时就会受到检查(因此不需要置于try语句块中)，不仅可以应用于普通的类，也可以应用于接口、数组及基本数据类型。上述 c2 等价于 c3 ，因为在包装类中有个一个字段 <code>TYPE</code> ，<code>TYPE</code> 字段是一个引用，指向对应的基本数据类型的 <code>Class</code> 对象，因此不只 <code>Integer</code> 包装类，其他 7 种包装类以及 <code>Void</code> 类型都有对应的 <code>TYPE</code> 字段。</p><p>注意：上述代码没有打印 <code>Dog</code> 和 <code>Cat</code> 静态代码块的内存，因为用 <code>.class</code> 来创建 <code>Class</code> 对象的引用时，不会自动地初始化该 <code>Class</code> 对象，类加载被延迟到了对静态方法或者非常数静态域首次引用时才执行。示例代码如下：</p><pre><code class="hljs">public class Dog &#123;    static final String DOG_CONSTANT = &quot;DOG_CONSTANT&quot;;    static String staticValue = &quot;dog_staticValue&quot;;    static &#123;        System.out.println(&quot;Loading Dog&quot;);    &#125;&#125;Class dog = Dog.class;System.out.println(&quot;===== 常量 =====&quot;);System.out.println(Dog.DOG_CONSTANT);System.out.println(&quot;===== 静态成员 =====&quot;);System.out.println(Dog.staticValue);</code></pre><p>输出：</p><pre><code class="hljs">===== 常量 =====DOG_CONSTANT===== 静态成员 =====Loading Dogdog_staticValue</code></pre><p>由输出结果可知，当引用 <code>staticValue</code> 时，类被加载到内存并执行了静态代码块的内容。因为被 <code>static final</code> 修饰的属性在编译期就把结果放入常量池了，所以引用的时候并不需要类真正地被加载。但是，如果只是将一个域设置为 <code>static</code> 或 <code>final</code> 的，还不足以确保这种行为，此时引用会强制加载并初始化类。</p><h2 id="Class-对象的唯一性"><a href="#Class-对象的唯一性" class="headerlink" title="Class 对象的唯一性"></a>Class 对象的唯一性</h2><p>每个通过关键字 <code>class</code> 标识的类，在内存中有且只有一个与之对应的 <code>Class</code> 对象来描述其类型信息，不论通过哪种方式获得该类的 <code>Class</code> 对象，它们返回的都是指向同一个 <code>java</code> 堆地址上的 <code>Class</code> 引用，<code>jvm</code> 不会创建两个相同类型的 <code>Class</code>。也就是说，无论创建多少个实例对象，其依据的都是同一个 <code>Class</code> 对象。<code>java</code> 虚拟机中使用<strong>双亲委派模型</strong>来组织类加载器之间的关系，来保证 <code>Class</code> 对象的唯一性。验证代码如下：</p><pre><code class="hljs">Class dog = Dog.class;Class dog2 = Class.forName(&quot;fanda.zeng.reflect.Dog&quot;);Class dog3 = new Dog().getClass();Class dog4 = new Dog().getClass() ;if (dog == dog2 &amp;&amp; dog2 == dog3 &amp;&amp; dog3 == dog4) &#123;    System.out.println(true);&#125; else &#123;    System.out.println(false);&#125; </code></pre><p>输出结果为 <code>true</code> ，表示都是同一个堆上的 <code>Class</code> 引用。</p><h2 id="Class-类的方法"><a href="#Class-类的方法" class="headerlink" title="Class 类的方法"></a>Class 类的方法</h2><p>先说明一下，构造方法都是获取本类的(一定不包括父类)，只是公共和其他修饰符的区别。以下其他带有 <code>Declared</code> 的方法，都表示<strong>只能获取本类的属性</strong>(不包括父类的)，不过可以获取所有修饰符修饰的属性(<strong>公有，保护，默认，私有</strong>)。不带有 <code>Declared</code> 的方法，可以<strong>获取本类及父类</strong>的所有的属性，不过只能获取 <strong>公有</strong> 修饰符的 。</p><h3 id="获取构造函数"><a href="#获取构造函数" class="headerlink" title="获取构造函数"></a>获取构造函数</h3><pre><code class="hljs">//返回 Constructor 对象数组Constructor&lt;?&gt;[] getDeclaredConstructors()Constructor&lt;?&gt;[] getConstructors()       // 返回指定参数的 Constructor 对象Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)     Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes) </code></pre><h3 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h3><pre><code class="hljs">// 返回 Field 对象数组Field[] getFields() Field[] getDeclaredFields() // 返回指定的 Field 对象 Field getField(String name) Field getDeclaredField(String name) </code></pre><h3 id="获取成员方法"><a href="#获取成员方法" class="headerlink" title="获取成员方法"></a>获取成员方法</h3><pre><code class="hljs">// 返回 Method 对象数组 Method[] getMethods() Method[] getDeclaredMethods() / 返回指定的 Method 对象 Method getMethod(String name, Class&lt;?&gt;... parameterTypes) Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) </code></pre><h3 id="获取注解方法"><a href="#获取注解方法" class="headerlink" title="获取注解方法"></a>获取注解方法</h3><pre><code class="hljs">// 返回指定 Annotation 对象public &lt;A extends Annotation&gt; A getDeclaredAnnotation(Class&lt;A&gt; annotationClass) &#123;public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) &#123;// 返回 Annotation 对象数组Annotation[] getDeclaredAnnotations()public Annotation[] getAnnotations ()</code></pre><h3 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h3><pre><code class="hljs">// 创建此 Class 对象所表示的类的一个新实例T newInstance() </code></pre><h3 id="返回字符串-String-的方法"><a href="#返回字符串-String-的方法" class="headerlink" title="返回字符串(String)的方法"></a>返回字符串(String)的方法</h3><pre><code class="hljs">// 返回底层类的规范化名称 String getCanonicalName() // 返回全限定名(全限定名：包名.类名)String getName() // 返回源代码中给出的底层类的简称String getSimpleName() </code></pre><h3 id="返回-boolean-的方法"><a href="#返回-boolean-的方法" class="headerlink" title="返回 boolean 的方法"></a>返回 boolean 的方法</h3><pre><code class="hljs">// 判断是不是局部类，也就是方法里面的类 boolean isLocalClass()     // 判断是不是成员内部类，也就是一个类里面定义的类boolean isMemberClass()    // 判断当前类是不是匿名类，匿名类一般用于实例化接口boolean isAnonymousClass() // 如果指定类型的注释存在于此元素上isAnnotationPresent (Class&lt;? extends Annotation&gt; annotationClass)// 判断当前Class对象是否是注释类型boolean isAnnotation() ;// 判断该类是否是枚举类boolean isEnum() // 判断指定的 Object 是否 Class 的实例boolean isInstance(Object obj) // 判断指定的 Class 对象是否表示一个接口类型boolean isInterface() // 判断指定的 Class 对象是否表示一个基本类型boolean isPrimitive() </code></pre><h3 id="获取-Class-的修饰符"><a href="#获取-Class-的修饰符" class="headerlink" title="获取 Class 的修饰符"></a>获取 Class 的修饰符</h3><pre><code class="hljs">//返回此类或接口以整数编码的 Java 语言修饰符。public int getModifiers()；</code></pre><p>我们可以使用 <code>Class.getModifiers()</code> 获得调用类的修饰符的二进制值，然后使<br>用 <code>Modifier.toString(int modifiers)</code> 将获取到的二进制值转换为字符串。</p><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><pre><code class="hljs">// 动物类public class Animal &#123;    private int mAnimalPrivate;    protected int mAnimalProtected;    public int mAnimalpublic;    public Animal() &#123;    &#125;    public Animal(int mAnimalPrivate) &#123;        this.mAnimalPrivate = mAnimalPrivate;    &#125;    public Animal(int mAnimalPrivate, int mAnimalProtected) &#123;        this.mAnimalPrivate = mAnimalPrivate;        this.mAnimalProtected = mAnimalProtected;    &#125;    public Animal(int mAnimalPrivate, int mAnimalProtected, int mAnimalpublic) &#123;        this.mAnimalPrivate = mAnimalPrivate;        this.mAnimalProtected = mAnimalProtected;        this.mAnimalpublic = mAnimalpublic;    &#125;    public void animalPublic() &#123;        System.out.println(&quot;Method : animalPublic&quot;);    &#125;    private void animalPrivate() &#123;        System.out.println(&quot;Method : animalPrivate&quot;);    &#125;    protected void animalProtected() &#123;        System.out.println(&quot;Method : animalProtected&quot;);    &#125;&#125;// 猫类，继承动物类public class Cat extends Animal &#123;    static &#123;        System.out.println(&quot;Loading Cat&quot;);    &#125;    private int mCatPrivate;    protected int mCatProtected;    public int mCatpublic;    public Cat() &#123;    &#125;    public Cat(int mCatPrivate) &#123;        this.mCatPrivate = mCatPrivate;    &#125;    private Cat(int mCatPrivate, int mCatProtected) &#123;        this.mCatPrivate = mCatPrivate;        this.mCatProtected = mCatProtected;    &#125;    public void catPublic() &#123;        System.out.println(&quot;Method : catPublic&quot;);    &#125;    private void catPrivate() &#123;        System.out.println(&quot;Method : catPrivate&quot;);    &#125;    protected void catProtected() &#123;        System.out.println(&quot;Method : catProtected&quot;);    &#125;    @Override    public String toString() &#123;        return &quot;mCatPrivate = &quot; + mCatPrivate + &quot;-----------&quot; + &quot;mCatProtected = &quot; + mCatProtected + &quot;-----------&quot; + &quot;mCatpublic = &quot; + mCatpublic;    &#125;&#125;</code></pre><p>获取构造函数示例：</p><pre><code class="hljs">  public static void main(String[] args) throws Exception &#123;    Class clazz = Cat.class;    System.out.println(&quot;获取本类所有 public 构造方法&quot;);    for (Constructor constructor : clazz.getConstructors()) &#123;        System.out.println(constructor.toString());    &#125;    System.out.println();    System.out.println(&quot;获取本类所有构造方法&quot;);    for (Constructor declaredConstructor : clazz.getDeclaredConstructors()) &#123;        System.out.println(declaredConstructor.toString());    &#125;    System.out.println();    System.out.println(&quot;这里获取指定的带有两个参数的私有构造方法&quot;);    Constructor privateConstructor = clazz.getDeclaredConstructor(int.class, int.class);    System.out.println(privateConstructor.toString());    //  改变访问权限    privateConstructor.setAccessible(true);    Cat cat = (Cat) privateConstructor.newInstance(1, 2);    System.out.println(cat.toString());    System.out.println();    System.out.println(&quot;这里获取指定的带有一个参数的公有构造方法&quot;);    Constructor publicConstructor = clazz.getConstructor(int.class);    System.out.println(publicConstructor.toString());    Cat cat2 = (Cat) publicConstructor.newInstance(100);    System.out.println(cat2.toString());&#125;</code></pre><p>输出：</p><pre><code class="hljs">获取本类所有 public 构造方法public fanda.zeng.reflect.Cat(int)public fanda.zeng.reflect.Cat()获取本类所有构造方法private fanda.zeng.reflect.Cat(int,int)public fanda.zeng.reflect.Cat(int)public fanda.zeng.reflect.Cat()这里获取指定的带有两个参数的私有构造方法private fanda.zeng.reflect.Cat(int,int)Loading CatmCatPrivate = 1-----------mCatProtected = 2-----------mCatpublic = 0这里获取指定的带有一个参数的公有构造方法public fanda.zeng.reflect.Cat(int)mCatPrivate = 100-----------mCatProtected = 0-----------mCatpublic = 0</code></pre><p>获取成员变量示例：</p><pre><code class="hljs">public static void main(String[] args) throws Exception &#123;    Class clazz = Cat.class;    System.out.println(&quot;获取所有 public 成员变量&quot;);    for (Field field : clazz.getFields()) &#123;        System.out.println(field.toString());    &#125;    System.out.println();    System.out.println(&quot;获取本类所有成员变量&quot;);    for (Field field : clazz.getDeclaredFields()) &#123;        System.out.println(field.toString());    &#125;    System.out.println();    System.out.println(&quot;这里获取指定名字的成员变量&quot;);    Field mCatPrivateField = clazz.getDeclaredField(&quot;mCatPrivate&quot;);    System.out.println(mCatPrivateField.toString());    //  改变访问权限    mCatPrivateField.setAccessible(true);    Cat cat = new Cat();    mCatPrivateField.set(cat, 100);    System.out.println(cat.toString());&#125;</code></pre><p>输出：</p><pre><code class="hljs">获取所有 public 成员变量public int fanda.zeng.reflect.Cat.mCatpublicpublic int fanda.zeng.reflect.Animal.mAnimalpublic获取本类所有成员变量private int fanda.zeng.reflect.Cat.mCatPrivateprotected int fanda.zeng.reflect.Cat.mCatProtectedpublic int fanda.zeng.reflect.Cat.mCatpublic这里获取指定名字的成员变量private int fanda.zeng.reflect.Cat.mCatPrivateLoading CatmCatPrivate = 100-----------mCatProtected = 0-----------mCatpublic = 0</code></pre><p>获取成员方法示例：</p><pre><code class="hljs">public static void main(String[] args) throws Exception &#123;    Class clazz = Cat.class;    System.out.println(&quot;获取所有 public 成员方法&quot;);    for (Method method : clazz.getMethods()) &#123;        System.out.println(method.toString());    &#125;    System.out.println();    System.out.println(&quot;获取本类所有成员方法&quot;);    for (Method method : clazz.getDeclaredMethods()) &#123;        System.out.println(method.toString());    &#125;    System.out.println();    System.out.println(&quot;这里获取指定名字的成员方法&quot;);    Method catPrivateMethod = clazz.getDeclaredMethod(&quot;catPrivate&quot;);    System.out.println(catPrivateMethod.toString());    //  改变访问权限    catPrivateMethod.setAccessible(true);    Cat cat = new Cat();    catPrivateMethod.invoke(cat);&#125;</code></pre><p>输出：</p><pre><code class="hljs">获取所有 public 成员方法public java.lang.String fanda.zeng.reflect.Cat.toString()public void fanda.zeng.reflect.Cat.catPublic()public void fanda.zeng.reflect.Animal.animalPublic()public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedExceptionpublic final void java.lang.Object.wait() throws java.lang.InterruptedExceptionpublic final native void java.lang.Object.wait(long) throws java.lang.InterruptedExceptionpublic boolean java.lang.Object.equals(java.lang.Object)public native int java.lang.Object.hashCode()public final native java.lang.Class java.lang.Object.getClass()public final native void java.lang.Object.notify()public final native void java.lang.Object.notifyAll()获取本类所有成员方法public java.lang.String fanda.zeng.reflect.Cat.toString()public void fanda.zeng.reflect.Cat.catPublic()protected void fanda.zeng.reflect.Cat.catProtected()private void fanda.zeng.reflect.Cat.catPrivate()这里获取指定名字的成员方法private void fanda.zeng.reflect.Cat.catPrivate()Loading CatMethod : catPrivate</code></pre><p>上述获取所有公共方法时，包括本类及所有的父类的公共方法都会查找出来。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://fandazeng.github.io/2019/06/12/java/Class%E7%B1%BB%E8%AF%A6%E8%A7%A3/">Class类详解</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>Class</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java中Record关键字详解</title>
    <link href="/2023/02/20/java/java%E4%B8%ADRecord%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/02/20/java/java%E4%B8%ADRecord%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>Java 14 引入了一个新的关键字 record，它是一种轻量级的数据传输对象（DTO）类，被设计用来快速定义不可变的数据对象，以简化Java程序员在开发数据传输对象时的代码量。相较于传统的Java类，record关键字可以更加简洁地定义一个数据传输对象。</p><p>record类是一个类声明，但在语法上类似于接口声明。在record类中，可以声明字段、方法、构造函数、静态初始化块等，但与普通的Java类不同的是，record类默认为不可变的（immutable），其字段和方法默认为 public final 和 public abstract，且record类不支持继承。</p><p>以下是一个record类的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">Person</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHello</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, I&#x27;m &quot;</span> + name + <span class="hljs-string">&quot; and I&#x27;m &quot;</span> + age + <span class="hljs-string">&quot; years old.&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的代码中，Person是一个record类，它包含两个字段：name和age。Person类还定义了一个sayHello()方法，用于输出该对象的名称和年龄信息。</p><p>相较于使用普通Java类来定义DTO，record类具有以下优点:</p><ul><li>代码简洁：record类可以快速定义DTO，并且不需要编写大量的getter和setter方法。</li><li>不可变性：record类的字段默认是不可变的，可以防止因为修改对象属性而导致数据错误的问题。</li><li>自动生成方法：record类可以自动生成equals()、hashCode()和toString()等方法，可以方便地用于对象的比较和输出。</li></ul><p>以下是一些参考链接:</p><ul><li>JEP 359: Records (Preview)：<a href="https://openjdk.java.net/jeps/359">https://openjdk.java.net/jeps/359</a></li><li>Java 14 新特性：Records：<a href="https://www.jianshu.com/p/68e50f245df3">https://www.jianshu.com/p/68e50f245df3</a></li><li>A First Look at Records in Java 14：<a href="https://www.baeldung.com/java-14-records">https://www.baeldung.com/java-14-records</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人生而自由，却无往不在枷锁之中</title>
    <link href="/2023/02/20/other/%E4%BA%BA%E7%94%9F%E8%80%8C%E8%87%AA%E7%94%B1%EF%BC%8C%E5%8D%B4%E6%97%A0%E5%BE%80%E4%B8%8D%E5%9C%A8%E6%9E%B7%E9%94%81%E4%B9%8B%E4%B8%AD/"/>
    <url>/2023/02/20/other/%E4%BA%BA%E7%94%9F%E8%80%8C%E8%87%AA%E7%94%B1%EF%BC%8C%E5%8D%B4%E6%97%A0%E5%BE%80%E4%B8%8D%E5%9C%A8%E6%9E%B7%E9%94%81%E4%B9%8B%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<p>这是法国启蒙思想家卢梭（Jean-Jacques Rousseau）在其著作《社会契约论》中所阐述的一句名言。其含义是指，人类天生自由，但随着社会的发展，人们所处的环境和制度等因素逐渐限制了个人的行动自由。</p><p>从生理上讲，人类天生拥有自由意志和选择能力，这使得人类能够自主决定自己的行为和选择自己的人生道路。然而，在现代社会，人们所处的环境和制度等因素，例如文化、经济、政治、社会等方面的限制，都会对个人的自由产生影响。例如，一个人出生在一个穷困落后的地区，就可能受到贫困和文化上的限制，而不能获得更广阔的发展机会；或者一个人所处的政治制度不自由，无法享受言论自由等权利。</p><p>因此，尽管人类天生自由，但在现实生活中，个人的自由被环境和制度所限制，不能随心所欲地行动。这句话也提醒我们要重视和保护人类的自由权利，建立和维护一个更加自由和公正的社会。</p>]]></content>
    
    
    <categories>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>other</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>高并发的哲学原理</title>
    <link href="/2023/02/20/other/%20%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E5%93%B2%E5%AD%A6%E5%8E%9F%E7%90%86/"/>
    <url>/2023/02/20/other/%20%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E5%93%B2%E5%AD%A6%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>《高并发的哲学原理 Philosophical Principles of High Concurrency》开源图书已经发布，简称 PPHC</p><h2 id="article"><a href="#article" class="headerlink" title="article"></a>article</h2><ul><li><a href="https://lvwenhan.com/tech-epic/508.html">高并发的哲学原理（十）– 理论无限容量：站在地球表面</a></li><li><a href="https://lvwenhan.com/tech-epic/507.html">高并发的哲学原理（九）– 细数四代分布式数据库并拆解 TiDB 和 OceanBase（主从、中间件、KV、计算与存储分离、列存储、CAP定理）</a></li><li><a href="https://lvwenhan.com/tech-epic/506.html">高并发的哲学原理（八）– 将 InnoDB 剥的一丝不挂：B+ 树与 Buffer Pool</a></li><li><a href="https://lvwenhan.com/tech-epic/505.html">高并发的哲学原理（七）– 最难以解决的单点：数据库以及它背后的存储</a></li><li><a href="https://lvwenhan.com/tech-epic/504.html">高并发的哲学原理（六）– 拆分网络单点(下)：SDN 如何替代百万人民币的负载均衡硬件(网关、LVS、交换机)</a></li><li><a href="https://lvwenhan.com/tech-epic/503.html">高并发的哲学原理（五）– 拆分网络单点(上)：应用网关、负载均衡和路由器(网关)</a></li><li><a href="https://lvwenhan.com/tech-epic/502.html">高并发的哲学原理（四）– 隐藏在语言背后的魔鬼：运行架构为何会成为性能瓶颈</a></li><li><a href="https://lvwenhan.com/tech-epic/501.html">高并发的哲学原理（三）– 基础设施并发：虚拟机与 Kubernetes（k8s）</a></li><li><a href="https://lvwenhan.com/tech-epic/500.html">高并发的哲学原理（二）– Apache 的性能瓶颈与 Nginx 的性能优势</a></li><li><a href="https://lvwenhan.com/tech-epic/499.html">高并发的哲学原理（一）– 找出单点，进行拆分</a></li></ul><h2 id="github"><a href="#github" class="headerlink" title="github"></a>github</h2><ul><li><a href="https://github.com/johnlui/PPHC">PPHC</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springframework 中ROLE_APPLICATION ROLE_SUPPORT ROLE_INFRASTRUCTURE作用</title>
    <link href="/2023/02/20/spring/springframework%20%E4%B8%ADROLE_APPLICATION%20ROLE_SUPPORT%20ROLE_INFRASTRUCTURE%E4%BD%9C%E7%94%A8/"/>
    <url>/2023/02/20/spring/springframework%20%E4%B8%ADROLE_APPLICATION%20ROLE_SUPPORT%20ROLE_INFRASTRUCTURE%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>在Spring Framework中，ROLE_APPLICATION，ROLE_SUPPORT和ROLE_INFRASTRUCTURE是Spring Security权限层次结构中的三个不同层次的角色。</p><p>ROLE_APPLICATION是最高层的角色，表示应用程序特定的角色，这些角色仅适用于特定的应用程序。例如，在一个在线商店应用程序中，ROLE_APPLICATION可能包括管理员，顾客和销售代表等角色。</p><p>ROLE_SUPPORT是中间层的角色，表示Spring框架支持的角色，这些角色适用于不同的应用程序。例如，ROLE_SUPPORT可能包括用户身份验证，访问控制和加密解密等功能。</p><p>ROLE_INFRASTRUCTURE是最低层的角色，表示Spring框架内部使用的角色。这些角色对于应用程序开发人员来说不是必须的，但是了解这些角色可以帮助开发人员更好地理解Spring框架的工作原理。例如，ROLE_INFRASTRUCTURE可能包括AOP代理和BeanPostProcessor等。</p><p>需要注意的是，这些角色只是Spring Security框架中默认的角色，应用程序可以定义自己的角色，并在权限层次结构中定义它们的位置。</p>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java双亲委派机制</title>
    <link href="/2023/02/15/java/Java%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/"/>
    <url>/2023/02/15/java/Java%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>Java双亲委派机制是一种类加载机制，它在JVM中用于保证Java类的安全性和避免类的重复加载。</p><p>在Java双亲委派机制中，当一个类加载器要加载一个类时，它首先不会尝试自己去加载这个类，而是把这个请求委派给父类加载器去完成，如果父类加载器还存在父类加载器，则会一直委派给父类加载器去尝试加载，直到顶层的父类加载器，也就是启动类加载器为止。只有当父类加载器无法完成这个加载请求时，子加载器才会尝试自己去加载这个类。</p><p>这种机制可以避免Java类的重复加载，并且保证Java类的安全性，因为如果一个类已经被父类加载器加载过了，那么它就不会被子类加载器重复加载，这样就可以避免不同的类加载器加载了同一个类导致的类型不兼容的问题。同时，由于Java类加载器的层次结构是从上到下的，也就是由启动类加载器、扩展类加载器和应用程序类加载器组成，所以通过这种机制，可以保证Java类的加载过程是有序的，从而避免了不同的类加载器之间的干扰。</p><p>以下是一些参考链接：</p><ul><li>Java 双亲委派机制详解：<a href="https://www.cnblogs.com/duanxz/p/5301349.html">https://www.cnblogs.com/duanxz/p/5301349.html</a></li><li>Java ClassLoader 工作原理：<a href="https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html">https://www.ibm.com/developerworks/cn/java/j-lo-classloader/index.html</a></li><li>Understanding Java Classloading：<a href="https://www.javaworld.com/article/2077265/understanding-java-classloading.html">https://www.javaworld.com/article/2077265/understanding-java-classloading.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Selenium针对两种上传文件方式的实现方案</title>
    <link href="/2023/01/17/selenium/Selenium%E9%92%88%E5%AF%B9%E4%B8%A4%E7%A7%8D%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/"/>
    <url>/2023/01/17/selenium/Selenium%E9%92%88%E5%AF%B9%E4%B8%A4%E7%A7%8D%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>首先，将下面html代码保存到一个文件中</p><p>后续<strong>第一种上传文件方式</strong>的代码小案例都是访问此html的</p><pre><code class="hljs">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;      &lt;input type=&quot;file&quot; name=&quot;pic&quot; id=&quot;pic&quot; /&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h2 id="方式一：input标签上传文件"><a href="#方式一：input标签上传文件" class="headerlink" title="方式一：input标签上传文件"></a>方式一：input标签上传文件</h2><hr><p>比较简单，可以定位input标签后，直接 .send_keys() 就可以了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br><br>driver = webdriver.Chrome(<span class="hljs-string">&quot;../resources/chromedriver.exe&quot;</span>)<br><span class="hljs-comment"># 需要自己修改路径</span><br>driver.get(<span class="hljs-string">&quot;file:///C://上传文件.html&quot;</span>)<br>driver.maximize_window()<br><span class="hljs-comment"># 定位上传文件元素input[type=file]</span><br>pic = driver.find_element_by_id(<span class="hljs-string">&quot;pic&quot;</span>)<br><span class="hljs-comment"># 上传文件</span><br>pic.send_keys(<span class="hljs-string">r&quot;C:/上传文件.html&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="方式二：非input标签上传文件"><a href="#方式二：非input标签上传文件" class="headerlink" title="方式二：非input标签上传文件"></a>方式二：非input标签上传文件</h2><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">from pathlib import Path<br><br># 打开上传网站<br>driver.get(<span class="hljs-string">&quot;https://tinypng.com/&quot;</span>)<br>paths = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Path</span>.</span></span>cwd<span class="hljs-literal">()</span>.parent<br># 触发文件上传的操作<br>driver.find<span class="hljs-constructor">_element_by_css_selector(<span class="hljs-string">&quot;section.target&quot;</span>)</span>.click<span class="hljs-literal">()</span><br>time.sleep(<span class="hljs-number">2</span>)<br># 一级顶层窗口<br>dialog = win32gui.<span class="hljs-constructor">FindWindow(<span class="hljs-string">&quot;#32770&quot;</span>, <span class="hljs-string">&quot;打开&quot;</span>)</span><br># 二级窗口<br>comboBoxEx32 = win32gui.<span class="hljs-constructor">FindWindowEx(<span class="hljs-params">dialog</span>, 0, <span class="hljs-string">&quot;ComboBoxEx32&quot;</span>, None)</span><br># 三级窗口<br>comboBox = win32gui.<span class="hljs-constructor">FindWindowEx(<span class="hljs-params">comboBoxEx32</span>, 0, <span class="hljs-string">&quot;ComboBox&quot;</span>, None)</span><br># 四级窗口 -- 文件路径输入区域<br>edit = win32gui.<span class="hljs-constructor">FindWindowEx(<span class="hljs-params">comboBox</span>, 0, <span class="hljs-string">&quot;Edit&quot;</span>, None)</span><br># 二级窗口 -- 打开按钮<br>button = win32gui.<span class="hljs-constructor">FindWindowEx(<span class="hljs-params">dialog</span>, 0, <span class="hljs-string">&quot;Button&quot;</span>, None)</span><br># <span class="hljs-number">1</span>、输入文件路径<br>filepath = f<span class="hljs-string">&quot;&#123;paths&#125;resources11.png&quot;</span><br>win32gui.<span class="hljs-constructor">SendMessage(<span class="hljs-params">edit</span>, <span class="hljs-params">win32con</span>.WM_SETTEXT, None, <span class="hljs-params">filepath</span>)</span><br># <span class="hljs-number">2</span>、点击打开按钮<br>win32gui.<span class="hljs-constructor">SendMessage(<span class="hljs-params">dialog</span>, <span class="hljs-params">win32con</span>.WM_COMMAND, 1, <span class="hljs-params">button</span>)</span><br></code></pre></td></tr></table></figure><p>这个是写死的方法，直接照搬即可，因为涉及了第三方工具去定位Window元素，暂时不展开详解</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://developer.aliyun.com/article/910405">Selenium系列（十一） - 针对两种上传文件方式的实现方案</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Selenium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git撤销对文件的修改</title>
    <link href="/2023/01/09/git/git%E6%92%A4%E9%94%80%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9/"/>
    <url>/2023/01/09/git/git%E6%92%A4%E9%94%80%E5%AF%B9%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%AE%E6%94%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="文件未提交至本地仓库"><a href="#文件未提交至本地仓库" class="headerlink" title="文件未提交至本地仓库"></a>文件未提交至本地仓库</h2><p>如果你想撤销对文件的修改，并且你还没有将修改提交到本地仓库，可以使用如下命令：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">git checkout -- path<span class="hljs-regexp">/to/</span><span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><p>这样会把文件恢复到最近一次提交后的状态，并把所有未提交的修改都丢弃。</p><h2 id="文件已提交到本地仓库，未推送到远程仓库"><a href="#文件已提交到本地仓库，未推送到远程仓库" class="headerlink" title="文件已提交到本地仓库，未推送到远程仓库"></a>文件已提交到本地仓库，未推送到远程仓库</h2><p>如果你已经将修改提交到本地仓库，但是还没有推送到远程仓库，你可以使用如下命令来撤销对文件的修改：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gradle">git reset HEAD path<span class="hljs-regexp">/to/</span><span class="hljs-keyword">file</span><br>git checkout -- path<span class="hljs-regexp">/to/</span><span class="hljs-keyword">file</span><br></code></pre></td></tr></table></figure><p>这样会把文件恢复到最近一次提交后的状态，但是会保留所有未提交的修改。如果你希望丢弃所有未提交的修改，可以在第一条命令之后再执行一条 git stash 命令。</p><h2 id="已推送到远程仓库"><a href="#已推送到远程仓库" class="headerlink" title="已推送到远程仓库"></a>已推送到远程仓库</h2><p>请注意，如果你已经将修改推送到了远程仓库，你就不能使用上面的命令来撤销对文件的修改。在这种情况下，你需要使用 git revert 命令来撤销对文件的修改，或者使用 git push –force 命令强制推送本地修改。但是，请注意，这些操作会破坏远程仓库的历史记录，因此应该慎用。</p>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu docker设置普通用户执行权限</title>
    <link href="/2023/01/09/docker/Ubuntu%20docker%E8%AE%BE%E7%BD%AE%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E6%89%A7%E8%A1%8C%E6%9D%83%E9%99%90/"/>
    <url>/2023/01/09/docker/Ubuntu%20docker%E8%AE%BE%E7%BD%AE%E6%99%AE%E9%80%9A%E7%94%A8%E6%88%B7%E6%89%A7%E8%A1%8C%E6%9D%83%E9%99%90/</url>
    
    <content type="html"><![CDATA[<p>添加docker用户组，执行命令：</p><blockquote><p>sudo groupadd docker</p></blockquote><p>将当前普通用户加入docker用户组，执行命令：</p><blockquote><p>sudo usermod -aG docker ${USER}</p></blockquote><p>如果这个时候执行docker pull 还是提示如下：</p><blockquote><p>Using default tag: latest<br>Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Post “http:<br>//%2Fvar%2Frun%2Fdocker.sock/v1.24/images/create?fromImage=mysql&amp;tag=latest”: dial unix /var/run/docker.sock: connect:<br>permission denied</p></blockquote><p>则需要修改/run/docker.sock的执行权限，执行命令：</p><blockquote><p>sudo chmod a+rw /var/run/docker.sock</p></blockquote><p>最后重启docker既可以，执行命令：</p><blockquote><p>systemctl restart docker</p></blockquote><p>执行上述一系列命令后，docker pull就可以执行了</p><p>验证结果：</p><blockquote><p>docker ps</p></blockquote><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://blog.csdn.net/u011285281/article/details/128509503">Ubuntu docker设置普通用户执行权限</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Telegram 创建 bot 获取 token 和 chatId</title>
    <link href="/2023/01/09/other/Telegram%20%E5%88%9B%E5%BB%BA%20bot%20%E8%8E%B7%E5%8F%96%20token%20%E5%92%8C%20chatId/"/>
    <url>/2023/01/09/other/Telegram%20%E5%88%9B%E5%BB%BA%20bot%20%E8%8E%B7%E5%8F%96%20token%20%E5%92%8C%20chatId/</url>
    
    <content type="html"><![CDATA[<h1 id="打开-BotFather"><a href="#打开-BotFather" class="headerlink" title="打开 BotFather"></a>打开 <code>BotFather</code></h1><p>url: <a href="https://t.me/BotFather">https://t.me/BotFather</a> 打开与它的聊天界面，不论是 Windows mac 还是 Android iOS 的 telegram 客户端。</p><h1 id="创建-bot-以及获取-token"><a href="#创建-bot-以及获取-token" class="headerlink" title="创建 bot 以及获取 token"></a>创建 bot 以及获取 token</h1><ol><li>输入 <code>/newbot</code> 后回车 它会回你以下内容<blockquote><p>Alright, a new bot. How are we going to call it? Please choose a name for your bot.</p></blockquote></li><li>这个名字是显示名称 （display name）,不是唯一识别码，现在随便设置一下，之后可以通过 <code>/setname</code> 修改 比如设置成 <code>Zhang san&#39;s sweety bot</code></li><li>接着会让你设置唯一名称。字符串必须 endsWith <code>bot</code>，比如 <code>abc_bot</code> 或 <code>HelloWorldbot</code> 都是合法的。如果你设置的名字已经被占用需要重新设置。比如你设置成了 <code>test_bot</code><blockquote><p>Good. Now let’s choose a username for your bot. It must end in <code>bot</code>. Like this, for example: TetrisBot or tetris_bot.</p></blockquote></li><li>恭喜！设置成功。会返回给你重要的 API token，务必要保存好它。另外你的 bot 的唯一 url 就已经生成: <code>https://t.me/test_bot</code><blockquote><p>Done! Congratulations on your new bot. You will find it at t.me/test_bot. You can now add a description, about section and profile picture for your bot, see /help for a list of commands. By the way, when you’ve finished creating your cool bot, ping our Bot Support if you want a better username for it. Just make sure the bot is fully operational before you do this.</p><p>Use this token to access the HTTP API:<br>12345678:sdfsfadsfasdfasdfasdfgdfhdfghfgh<br>Keep your token secure and store it safely, it can be used by anyone to control your bot.</p><p>For a description of the Bot API, see this page: <a href="https://core.telegram.org/bots/api">https://core.telegram.org/bots/api</a></p></blockquote></li><li>一些其他必要的命令<ul><li>  <code>/setdescription</code> 帮助你设置 bot 的描述</li><li>  <code>/setuserpic</code> 设置 bot 的头像。上传的图片 size 需要大于等于 150x150。而且上传图片需要选择压缩，不能上传文件！</li></ul></li></ol><p>此时你的 bot 很快就可以使用了。</p><h1 id="获取-chatId"><a href="#获取-chatId" class="headerlink" title="获取 chatId"></a>获取 chatId</h1><p>观察这个 url <code>https://api.telegram.org/bot&#123;token&#125;/getUpdates</code></p><p>使用第二步获得的 <code>token</code> 替换上述 url 中的 <code>&#123;token&#125;</code> 然后得到新的 url，复制粘贴到浏览器地址栏，回车请求。不出意外你会得到如下 response</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;ok&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;result&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>很好。这时你打开你的 bot，随便和它说一句话，比如给它发一句 “Hello World”，然后重新请求一遍上述的 url（替换过 token 的），不出意外你收到的 response 是这样了</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;ok&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;result&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;update_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">123456</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;message_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">56</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;from&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">72384234234</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;is_bot&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;first_name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sdfsdf&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;last_name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sdfsdf&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sdfsdf&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;language_code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;en&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;chat&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">123456789</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;first_name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sdfsdf&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;last_name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sdfsdf&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sdfsdf&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;private&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;date&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1212121212</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/start&quot;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;entities&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>                    <span class="hljs-punctuation">&#123;</span><br>                        <span class="hljs-attr">&quot;offset&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">0</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-attr">&quot;length&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><span class="hljs-punctuation">,</span><br>                        <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;bot_command&quot;</span><br>                    <span class="hljs-punctuation">&#125;</span><br>                <span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>        <span class="hljs-punctuation">&#123;</span><br>            <span class="hljs-attr">&quot;update_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">123456</span><span class="hljs-punctuation">,</span><br>            <span class="hljs-attr">&quot;message&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                <span class="hljs-attr">&quot;message_id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">6</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;from&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">23232323</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;is_bot&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;first_name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sdfsdfsdf&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;last_name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sdfsdfsdf&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sdfsdfsdf&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;language_code&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;en&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;chat&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>                    <span class="hljs-attr">&quot;id&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">123456</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;first_name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sdfsdfsdf&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;last_name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sdfsfdsdf&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;sdfsdfsdf&quot;</span><span class="hljs-punctuation">,</span><br>                    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;private&quot;</span><br>                <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;date&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1234567</span><span class="hljs-punctuation">,</span><br>                <span class="hljs-attr">&quot;text&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Hello World&quot;</span><br>            <span class="hljs-punctuation">&#125;</span><br>        <span class="hljs-punctuation">&#125;</span><br>    <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>如果浏览器没有安装一些 json 美化插件，会得到 json string 原文，那么复制它们到任何一个在线 json 解析格式化网站，比如 <a href="https://www.sojson.com/">https://www.sojson.com/</a> 选择对应的格式化功能格式化文本。</p><p>其中的 result[0].message.chat.id 的值就是 <code>chatId</code> 也就是 <code>123456789</code></p><p>知道了 token 和 chatId 就可以使用 bot 了。</p><h1 id="curl-测试"><a href="#curl-测试" class="headerlink" title="curl 测试"></a>curl 测试</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl -s -X POST https://api.telegram.org/bot&#123;token&#125;/sendMessage -d chat_id=&#123;chatId&#125; -d text=&quot;Hello World&quot;<br></code></pre></td></tr></table></figure><p>这是发送 post 请求。使用实际的 <code>token</code> 和 <code>chatId</code> 替换 shell command 中的 <code>&#123;token&#125;</code> 和 <code>&#123;chatId&#125;</code></p><p>不出意外，你的 bot 会收到 “Hello World”，恭喜，这已经成功了！</p><h1 id="Java-测试"><a href="#Java-测试" class="headerlink" title="Java 测试"></a>Java 测试</h1><p>引入 <code>hutool-http</code>，maven based project</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.hutool<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hutool-http<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.7.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.hutool.http.HttpRequest;<br><br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;   <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpPostTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">apiUrl</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;https://api.telegram.org/bot%s/sendMessage&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12345:abcsdfsdf&quot;</span>;<br>        apiUrl = String.format(apiUrl, token);<br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">chatId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;123456&quot;</span>;<br>        map.put(<span class="hljs-string">&quot;chat_id&quot;</span>, chatId);<br>        map.put(<span class="hljs-string">&quot;parse_mode&quot;</span>, <span class="hljs-string">&quot;Markdown&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;disable_web_page_preview&quot;</span>, <span class="hljs-literal">true</span>);<br>        map.put(<span class="hljs-string">&quot;text&quot;</span>, <span class="hljs-string">&quot;Hello World&quot;</span>);<br><br>        HttpRequest.post(apiUrl)<br>                .form(map)<br>                .timeout(<span class="hljs-number">20000</span>) <span class="hljs-comment">// 设置请求超时: 20s</span><br>                .execute()<br>                .body();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://hellodk.cn/post/743">Telegram 创建 bot 获取 token 和 chatId 以及发送消息简明教程</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Telegram</tag>
      
      <tag>tg</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用iptables实现端口转发</title>
    <link href="/2023/01/03/network/%E5%88%A9%E7%94%A8iptables%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/"/>
    <url>/2023/01/03/network/%E5%88%A9%E7%94%A8iptables%E5%AE%9E%E7%8E%B0%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h3 id="1-、本地端口转发"><a href="#1-、本地端口转发" class="headerlink" title="1 、本地端口转发"></a>1 、本地端口转发</h3><p>将<strong>外网</strong>访问<strong>本地</strong>的4444端口的流量转发到本地的22端口：</p><blockquote><p>  iptables -t nat -A PREROUTING -p tcp –dport 4444 -j REDIRECT –to-ports 22</p><blockquote><p>  删除规则用-D参数<br>  iptables -t nat -D PREROUTING -p tcp –dport 4444 -j REDIRECT –to-ports 22</p></blockquote></blockquote><p>将<strong>本地</strong>访问<strong>本地</strong>的4444端口的流量转发到本地的22端口：</p><blockquote><p>  iptables -t nat -A OUTPUT -p tcp –dport 4444 -j REDIRECT –to-ports 22</p><blockquote><p> 删除规则用-D参数<br>iptables -t nat -D  OUTPUT -p tcp –dport 4444 -j REDIRECT –to-ports 22</p></blockquote></blockquote><h3 id="2、分流"><a href="#2、分流" class="headerlink" title="2、分流"></a>2、分流</h3><p>通过PREROUTING链，将172.16.250.1网段访问4444端口的包转发到本机22端口，其他网段则正常访问4444端口，MASQUERADE类似于SNAT，只是不用写源地址。</p><blockquote><p>iptables -t nat -A PREROUTING –source 172.16.250.1 -p tcp –dport 4444 -j DNAT –to-destination 172.16.250.3:22<br>iptables -t nat -A POSTROUTING -p TCP -j MASQUERADE<br>iptables -t nat -A POSTROUTING –dst 172.16.250.3 -p tcp –dport 22 -j MASQUERADE</p></blockquote><h3 id="3、远程端口转发"><a href="#3、远程端口转发" class="headerlink" title="3、远程端口转发"></a>3、远程端口转发</h3><p>假如我们想使用192.168.5.104:32001去访问192.168.49.2:32001端口，那么需要在192.168.5.104的机器上执行下面的命令：</p><blockquote><p>注意：该两个ip地址为同一台机器的两个ip，由于某种原因，该机器上只能使用<code>192.168.49.2:32001</code>可以访问，无法通过<code>192.168.5.104:32001</code>访问，因此可以使用iptables 处理，或者使用nginx实现端口转发</p><blockquote><p>使用场景：比如minikube 的集群ip，无法对外访问，是一个虚拟ip</p></blockquote></blockquote><blockquote><p>  sudo iptables -t nat -A PREROUTING –dst 192.168.5.104 -p tcp –dport 32001 -j DNAT –to-destination 192.168.49.2:32001<br>  sudo iptables -t nat -A POSTROUTING –dst 192.168.49.2 -p tcp –dport 32001 -j SNAT –to-source 192.168.5.104</p><p>  查看已有规则  </p><blockquote><p>iptables -t nat -nL –line </p></blockquote><p>  删除第二条规则</p><blockquote><p>iptables -t nat -D PREROUTING 2  </p></blockquote><p>  删除所有规则</p><blockquote><p>iptables -F -t nat </p></blockquote></blockquote><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><p><a href="https://blog.51cto.com/u_14318784/5194598">利用iptables实现端口转发</a></p></li><li><p><a href="https://wiki.archlinux.org/title/iptables_%28%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29">iptables</a>​</p></li><li><p><a href="https://mp.weixin.qq.com/s/QOfORsSIcxuRXFj1xkUFcA">内网穿透——iptables端口转发</a></p></li><li><p><a href="https://unpkg.com/linux-command@1.2.6/command/iptables.md">iptables详解</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iptables</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitOps 介绍</title>
    <link href="/2023/01/03/k8s/GitOps%20%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/01/03/k8s/GitOps%20%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p>GitOps 这个概念最早是由 Kubernetes 管理公司 Weaveworks 公司在 2017 年提出的，如今已经过去了 5 个年头，想必大家对这个概念早有耳闻，但你可能并不知道它到底是什么，它和 DevOps 到底是啥关系，本文就来帮大家一一解惑。</p><h2 id="基础设施即代码"><a href="#基础设施即代码" class="headerlink" title="基础设施即代码"></a>基础设施即代码</h2><p>在理解 GitOps 之前，我们需要先理解什么是<strong>基础设施即代码</strong>。</p><p>基础设施即代码（Infrastructure as Code, <strong>IaC</strong>），顾名思义，表示使用代码（而非手动流程）来定义基础设施，研发人员可以像对待应用软件一样对待基础设施，例如：</p><ul><li>  可以创建包含基础架构规范的声明式配置文件，从而便于编辑和分发配置。</li><li>  可以确保每次配置的环境都完全相同。</li><li>  可以进行版本控制，所有的变更都会被记录下来，方便溯源。</li><li>  可以将基础设施划分为若干个模块化组件，并通过自动化以不同的方式进行组合。</li></ul><p>当然，广义上的 IaC 不仅仅只关于基础设施，还包含了<strong>网络</strong>、<strong>安全</strong>、<strong>配置</strong>等等，所以广义上的 IaC 又叫 <strong>X as Code</strong>。<br><img src="img.png" alt="img.png"></p><p>比如你想在 AWS 中创建服务器，配置网络，部署 Kubernetes 集群以及各种工作负载，你只需要定义好 Terraform 或 Ansible 的声明式配置，以及 Kubernetes 的配置清单即可，免去一切繁杂的手动操作。</p><h2 id="GitOps-是什么"><a href="#GitOps-是什么" class="headerlink" title="GitOps 是什么"></a>GitOps 是什么</h2><p>GitOps = IaC + Git + CI/CD，即基于 IaC 的版本化 CI/CD。它的核心是使用 Git 仓库来管理基础设施和应用的配置，并且<strong>以 Git 仓库作为基础设施和应用的单一事实来源</strong>，你从其他地方修改配置（比如手动改线上配置）一概不予通过。</p><p>Git 仓库中的声明式配置描述了目标环境当前所需基础设施的期望状态，借助于 GitOps，如果集群的实际状态与 Git 仓库中定义的期望状态不匹配，Kubernetes reconcilers 会根据期望状态来调整当前的状态，最终使实际状态符合期望状态。</p><p>另一方面，现代应用的开发更多关注的是迭代速度和规模，拥有成熟 DevOps 文化的组织每天可以将代码部署到生成环境中数百次，DevOps 团队可以通过版本控制、代码审查以及自动测试和部署的 CI/CD 流水线等最佳实践来实现这一目标，这就是 GitOps 干的事情。</p><h2 id="GitOps-vs-DevOps"><a href="#GitOps-vs-DevOps" class="headerlink" title="GitOps vs DevOps"></a>GitOps vs DevOps</h2><p>从广义上来看，GitOps 与 DevOps 并不冲突，<strong>GitOps 是一种技术手段，而 DevOps 是一种文化</strong>。GitOps 是一种实现持续交付（Continuous Delivery）、持续部署（Continuous Deployment）和基础设施即代码（IaC）的工具和框架，它是支持 DevOps 文化的。</p><p>从狭义上来看，GitOps 与 DevOps 有以下几个区别：</p><p>首先，<strong>GitOps 是以目标为导向的</strong>。它使用 Git 来维护期望状态，并不断调整实际状态，最终与期望状态相匹配。而 <strong>DevOps 更多关注的是最佳实践</strong>，这些实践可以普遍应用于企业的每一个流程。</p><p>其次，<strong>GitOps 采取声明式的操作方法，而 DevOps 同时接受声明式和命令式的方法</strong>，所以 DevOps 除了适用于容器环境之外，还适用于虚拟机和裸机环境。</p><p>最后，<strong>GitOps 重新定义了云原生场景下的 CI/CD</strong>，它以 Git 作为中心的不可变状态声明，以加快持续部署速度。</p><h2 id="GitOps-的设计哲学"><a href="#GitOps-的设计哲学" class="headerlink" title="GitOps 的设计哲学"></a>GitOps 的设计哲学</h2><p>想要使用 GitOps 来管理你的基础设施和应用，需要践行以下几个原则：</p><h3 id="1-声明式"><a href="#1-声明式" class="headerlink" title="1 声明式"></a>1 声明式</h3><p>必须通过声明式来描述系统的期望状态。例如 Kubernetes，众多现代云原生工具都是声明式的，Kubernetes 只是其中的一种。</p><h3 id="2-版本控制-不可变"><a href="#2-版本控制-不可变" class="headerlink" title="2 版本控制/不可变"></a>2 版本控制/不可变</h3><p>因为所有的状态声明都存储在 Git 仓库中，并且把 Git 仓库作为单一事实来源，那么所有的操作都是从 Git 仓库里驱动的，而且保留了完整的版本历史，方便回滚。有了 Git 优秀的安全保障，也可以使用 SSH 密钥来签署 commits，对代码的作者和出处实施强有力的安全保障。</p><h3 id="3-自动应用变更"><a href="#3-自动应用变更" class="headerlink" title="3 自动应用变更"></a>3 自动应用变更</h3><p>Git 仓库中声明的期望状态发生了任何变更，都可以立即应用到系统中，而且不需要安装配置额外工具（比如 kubectl），也不需要配置 Kubernetes 的认证授权。</p><h3 id="4-持续的-Reconciliation"><a href="#4-持续的-Reconciliation" class="headerlink" title="4 持续的 Reconciliation"></a>4 持续的 Reconciliation</h3><p>Reconciliation 其实最早是 Kubernetes 里的一个概念，表示的是<strong>确保系统的实际状态与期望状态一致的过程</strong>。具体的实现方式是在目标环境中安装一个 agent，一旦实际状态与期望状态不匹配，agent 就会进行自动修复。这里的修复比 Kubernetes 的故障自愈更高级，即使是手动修改了集群的编排清单，集群也会被恢复到 Git 仓库中的清单所描述的状态。</p><p>鉴于以上这些设计哲学，我们来看一下 GitOps 的工作流：</p><p><img src="img_1.png" alt="img_1.png"></p><ul><li>  首先，团队中的任何一个成员都可以 Fork 仓库对配置进行更改，然后提交 Pull Request。</li><li>  接下来会运行 CI 流水线，一般会做这么几件事情：验证配置文件、执行自动化测试、检测代码的复杂性、构建 OCI 镜像、将镜像推送到镜像仓库等等。</li><li>  CI 流水线运行完成后，团队中拥有合并代码权限的人将会将这个 Pull Request 合并到主分支中 。一般拥有这个权限的都是研发人员、安全专家或者高级运维工程师。</li><li>  最后会运行 CD 流水线，将变更应用到目标系统中（比如 Kubernetes 集群或者 AWS） 。</li></ul><p>整个过程完全自动化且透明，通过多人协作和自动化测试来保证了基础设施声明配置的健壮性。而传统的模式是其中一个工程师在自己的电脑上操作这一切，其他人不知道发生了什么，也无法对其操作进行 Review。</p><h2 id="Push-vs-Pull"><a href="#Push-vs-Pull" class="headerlink" title="Push vs Pull"></a>Push vs Pull</h2><p>CD 流水线有两种模式：Push 和 Pull。</p><h3 id="Push-模式"><a href="#Push-模式" class="headerlink" title="Push 模式"></a>Push 模式</h3><p>目前大多数 CI/CD 工具都使用基于 Push 的部署模式，例如 Jenkins、CircleCI 等。这种模式一般都会在 CI 流水线运行完成后执行一个命令（比如 kubectl）将应用部署到目标环境中。</p><p><img src="img_2.png" alt="img_2.png"></p><p>这种 CD 模式的缺陷很明显：</p><ul><li>  需要安装配置额外工具（比如 kubectl）；</li><li>  需要 Kubernetes 对其进行授权；</li><li>  需要云平台授权；</li><li>  无法感知部署状态。也就无法感知期望状态与实际状态的偏差，需要借助额外的方案来保障一致性。</li></ul><p>Kubernetes 集群或者云平台对 CI 系统的授权凭证在集群或云平台的信任域之外，不受集群或云平台的安全策略保护，因此 CI 系统很容易被当成非法攻击的载体。</p><h3 id="Pull-模式"><a href="#Pull-模式" class="headerlink" title="Pull 模式"></a>Pull 模式</h3><p>Pull 模式会在目标环境中安装一个 Agent，例如在 Kubernetes 集群中就靠 Operator 来充当这个 Agent。Operator 会周期性地监控目标环境的实际状态，并与 Git 仓库中的期望状态进行比较，如果实际状态不符合期望状态，Operator 就会更新基础设施的实际状态以匹配期望状态。</p><p><img src="img_3.png" alt="img_3.png"></p><p>只有 Git 的变更可以作为期望状态的唯一来源，除此之外，任何人都不可以对集群进行任何更改，即使你修改了，也会被 Operator 还原为期望状态，这也就是传说中的<strong>不可变基础设施</strong>。</p><p>目前基于 Pull 模式的 CD 工具有 <a href="https://github.com/argoproj/argo-cd/">Argo CD</a>， <a href="https://github.com/fluxcd/flux">Flux CD</a> 以及 <a href="https://github.com/kubesphere/ks-devops">ks-devops</a>。</p><h2 id="GitOps-的优势"><a href="#GitOps-的优势" class="headerlink" title="GitOps 的优势"></a>GitOps 的优势</h2><p>一般 GitOps 首选的都是基于 Pull 的部署模式，因为这种模式有很多不可替代的优势。</p><h3 id="更强大的安全保障"><a href="#更强大的安全保障" class="headerlink" title="更强大的安全保障"></a>更强大的安全保障</h3><p>上面已经提到了，使用 GitOps 不需要任何 Kubernetes 或者云平台的凭证来执行部署，Kubernetes 集群内的 Argo CD 或者 Flux CD 只需要访问 Git 仓库，并通过 Pull 模式来更新即可。</p><p>另一方面，Git 由用于跟踪和管理代码变更的强大密码学支持，拥有对变更进行签名以证明作者身份和来源的能力，这是保障集群安全的关键。</p><h3 id="Git-作为事实的唯一真实来源"><a href="#Git-作为事实的唯一真实来源" class="headerlink" title="Git 作为事实的唯一真实来源"></a>Git 作为事实的唯一真实来源</h3><p>因为所有的应用包括基础设施的声明式配置都保存在 Git 中，并把 Git 作为应用系统的唯一事实来源，因此可以利用 Git 的强大功能操作所有东西，例如版本控制、历史记录、审计和回滚等等，无需使用 kubectl 这样的工具来操作。</p><h3 id="提高生产力"><a href="#提高生产力" class="headerlink" title="提高生产力"></a>提高生产力</h3><p>Git 也是开发人员非常熟悉的工具，通过 Git 不断迭代，可以提高生产率，加快开发和部署速度，更快地推出新产品，同时提高系统的稳定性和可靠性。</p><h3 id="更容易合规的审计"><a href="#更容易合规的审计" class="headerlink" title="更容易合规的审计"></a>更容易合规的审计</h3><p>使用 GitOps 的基础设施可以像任何软件项目一样使用 Git 来管理，所以同样可以对其进行质量审计。当有人需要对基础设施进行更改时，会创建一个 Pull Request，等相关人员对其进行 Code Review 之后，更改才可以应用到系统中。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>GitOps 是对现有 DevOps 文化的补充，它使用 Git 这样的版本控制系统来自动部署基础设施，部署过程清晰可见，可以查看和跟踪对系统进行的任何变更，提高了生产力、安全性和合规性。而且 GitOps 提供了更优雅的可观测性，可以实时观测部署状态，并采取行动使实际状态与期望状态保持一致。</p><p>而且在 GitOps 中，整个系统都是通过声明式来描述的，天然适合云原生环境，因为 Kubernetes 也是这么设计的。</p><h2 id="Refenences"><a href="#Refenences" class="headerlink" title="Refenences"></a>Refenences</h2><ul><li>  <a href="https://devs-group.medium.com/what-is-gitops-and-what-should-you-know-about-it-fcaa3e3c1dd5">What is GitOps and what should you know about it?</a></li><li>  <a href="https://www.tynybay.com/our-thinking/devops-vs-gitops-4-benefits-you-must-know-to-master-the-methodologies">DevOps vs GitOps: 4 Benefits you must know to Master the Methodologies</a></li><li>  <a href="https://www.weave.works/technologies/gitops/">Guide To GitOps</a></li><li>  <a href="https://icloudnative.io/posts/what-is-gitops">GitOps 介绍</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>GitOps</tag>
      
      <tag>devops</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TransactionalEventListener使用场景以及实现原理</title>
    <link href="/2022/12/29/spring/TransactionalEventListener%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <url>/2022/12/29/spring/TransactionalEventListener%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>这里举个业务场景，假如我们有个需求，用户创建成功后给用户发送一个邮件。这里有两个事情要做:</p><ol><li> 创建用户</li><li> 给用户发送邮件</li></ol><p>对于这种需求，我们可能会不假思索的有以下实现。</p><pre><code class="hljs">@Entitypublic class User &#123;    @Id    @GeneratedValue(strategy = GenerationType.IDENTITY)    private Long id;    private String name;    private String email;    public User() &#123;&#125;    ...    //getters    //equals and hashcode&#125;</code></pre><p>为User创建个Repository</p><pre><code class="hljs">public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;&#125;@Servicepublic class EmailService&#123;  @Transactional  public void sendEmail(String email) &#123;    //send email  &#125;&#125;@Servicepublic class UserService &#123;  private final EmailService emailService;  private final UserRepository userRepository;  public UserService(EmailService emailService, UserRepository userRepository) &#123;    this.emailService = emailService;    this.userRepository = userRepository;  &#125;  @Transactional  public User createUser(User user) &#123;    User newUser = userRepository.save(user);    emailService.sendEmail(user.getEmail());    return newUser;  &#125;&#125;</code></pre><p>对于上面的实现，是最容易实现的，但这种实现是有问题的。我们想一下，这个功能的核心是创建用户，而发送邮件是一个副作用（发送邮件不能影响用户的创建），如果把这两个操作放在一个事务中会有什么问题？其实很明显，如果创建用户时抛出异常，事务回滚，方法提前退出，那么也不会发送邮件，这是正常的。但是下面两个场景是不可接受的：</p><ol><li> 如果邮件发送失败，事务发生回滚，用户创建失败。</li><li> 如果邮件发送成功后，事务提交失败，这下就尴尬了，用户收到了邮件，可是用户创建失败。</li></ol><p>虽然这些情况出现的概率很小，但作为对自己有要求的程序猿，这是不可容忍的，我们要对自己写的业务负责。</p><p>好了，我们对上面的实现做个重构，直接将创建用户和发送邮件的业务代码拆开，使用Spring application event的方式解耦实现。</p><p>修改后的Service是这样的</p><pre><code class="hljs">@Servicepublic class CustomerService &#123;    private final UserRepository userRepository;    private final ApplicationEventPublisher applicationEventPublisher;    public CustomerService(UserRepository userRepository, ApplicationEventPublisher applicationEventPublisher) &#123;        this.userRepository = userRepository;        this.applicationEventPublisher = applicationEventPublisher;    &#125;    @Transactional    public Customer createCustomer(User user) &#123;        User newUser = userRepository.save(user);        final UserCreatedEvent event = new UserCreatedEvent(newUser);        applicationEventPublisher.publishEvent(event);        return newUser;    &#125;&#125;</code></pre><p>从上面的代码，我们知道<strong>UserService</strong>依赖两个beans：</p><ol><li><p>UserRepository - 做持久化工作</p></li><li><p>ApplicationEventPublisher - 发送Spring内部事件</p><p> public class UserCreatedEvent {</p><p> private final User user;</p><p> public UserCreatedEvent(User user) { this.user = user; }</p><p> public User getUser() { return user; }</p><p> … //equals and hashCode<br> }</p></li></ol><p>注意这个类只是个简单POJO对象，自从Spring 4.2，我们不用继承<strong>ApplicationEvent</strong>而能发布任何对象，Spring会把它们包装成<strong>PayloadApplicationEvent</strong>。</p><p>我们需要一个Event Listener处理上面的事件。</p><pre><code class="hljs">@Componentpublic class UserCreatedEventListener &#123;    private final EmailService emailService;    public UserCreatedEventListener(EmailService emailService) &#123;        this.emailService = emailService;    &#125;    @EventListener    public void processUserCreatedEvent(UserCreatedEvent event) &#123;        emailService.sendEmail(event.getUser().getEmail());    &#125;&#125;</code></pre><p>通过上面的重构，我们将创建用户和发送邮件的业务代码拆开来了，但是有解决上面提到的问题吗？答案是没有，虽然我们用<strong>EventListener</strong>的方式解耦了业务代码，可是这在底层两个功能还是在同一个事务中执行（有人可能想问在Listener方法上加@Async让异步执行可以吗？当然不行，邮件必须在用户创建成功后发送，这里有业务依赖），意思就是，上面的两种情况依然会发生。那么问题来了，有没有解决方案呢?</p><p>当然有，就是用@TransactionalEventListener替换@EventListener，结果就是在创建用户并提交事务后发送邮件通知。</p><h3 id="TransactionalEventListener"><a href="#TransactionalEventListener" class="headerlink" title="TransactionalEventListener"></a>TransactionalEventListener</h3><p>TransactionalEventListener是对EventListener的增强，被注解的方法可以在事务的不同阶段去触发执行，如果事件未在激活的事务中发布，除非显式设置了 <strong>fallbackExecution()</strong> 标志为true，否则该事件将被丢弃；如果事务正在运行，则根据其 TransactionPhase 处理该事件。</p><p>Notice：你可以通过注解@Order去排序所有的Listener，确保他们按自己的设定的预期顺序执行。</p><p>我们先看看TransactionPhase有哪些：</p><ul><li>  AFTER_COMMIT - 默认设置，在事务提交后执行</li><li>  AFTER_ROLLBACK - 在事务回滚后执行</li><li>  AFTER_COMPLETION - 在事务完成后执行（不管是否成功）</li><li>  BEFORE_COMMIT - 在事务提交前执行</li></ul><p>改造后的Listener是这样的</p><pre><code class="hljs">@Componentpublic class UserCreatedEventListener &#123;    private final EmailService emailService;    public UserCreatedEventListener(EmailService emailService) &#123;        this.emailService = emailService;    &#125;    @TransactionalEventListener    public void processUserCreatedEvent(UserCreatedEvent event) &#123;        emailService.sendEmail(event.getUser().getEmail());    &#125;&#125;</code></pre><p>好了，现在我们能保证我们的业务正常的运行，创建用户不会受发送邮件的影响。接下来我们深挖一下，看看TransactionalEventListener是怎么做到的。</p><h3 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h3><p>下面给出Spring的处理源码，大家会一目了然：</p><pre><code class="hljs">//org.springframework.transaction.event.ApplicationListenerMethodTransactionalAdapter#onApplicationEvent@Overridepublic void onApplicationEvent(ApplicationEvent event) &#123;    if (TransactionSynchronizationManager.isSynchronizationActive() &amp;&amp;            TransactionSynchronizationManager.isActualTransactionActive()) &#123;        TransactionSynchronization transactionSynchronization = createTransactionSynchronization(event);        TransactionSynchronizationManager.registerSynchronization(transactionSynchronization);    &#125;    else if (this.annotation.fallbackExecution()) &#123;        if (this.annotation.phase() == TransactionPhase.AFTER_ROLLBACK &amp;&amp; logger.isWarnEnabled()) &#123;            logger.warn(&quot;Processing &quot; + event + &quot; as a fallback execution on AFTER_ROLLBACK phase&quot;);        &#125;        processEvent(event);    &#125;    else &#123;        // No transactional event execution at all        if (logger.isDebugEnabled()) &#123;            logger.debug(&quot;No transaction is active - skipping &quot; + event);        &#125;    &#125;&#125;</code></pre><p>解释一下上面的代码：</p><ol><li> 如果当前处于激活的事务当中，那么会创建一个<strong>TransactionSynchronization</strong>，并把它放到一个集合当中。意思就是先不执行，只是临时存了起来。</li><li> 如果没有事务，并且明确设置了fallbackExecution为true，那么直接执行，该效果和EventListener一样。</li><li> 如果没有事务，并且fallbackExecution 为false，那么直接丢弃该Event不做任何处理。</li></ol><p>既然将TransactionSynchronization存放了起来，那么什么时机触发执行呢？</p><p>这里以<strong>AFTER_COMMIT</strong>为例（其他阶段实现差不多），看这段代码：</p><pre><code class="hljs">//org.springframework.transaction.support.AbstractPlatformTransactionManager.processCommitprivate void processCommit(DefaultTransactionStatus status) throws TransactionException &#123;        try &#123;            boolean beforeCompletionInvoked = false;            try &#123;                boolean unexpectedRollback = false;                prepareForCommit(status);                triggerBeforeCommit(status);                triggerBeforeCompletion(status);                beforeCompletionInvoked = true;                if (status.hasSavepoint()) &#123;                    if (status.isDebug()) &#123;                        logger.debug(&quot;Releasing transaction savepoint&quot;);                    &#125;                    unexpectedRollback = status.isGlobalRollbackOnly();                    status.releaseHeldSavepoint();                &#125;                else if (status.isNewTransaction()) &#123;                    if (status.isDebug()) &#123;                        logger.debug(&quot;Initiating transaction commit&quot;);                    &#125;                    unexpectedRollback = status.isGlobalRollbackOnly();                    doCommit(status);                &#125;                else if (isFailEarlyOnGlobalRollbackOnly()) &#123;                    unexpectedRollback = status.isGlobalRollbackOnly();                &#125;                // Throw UnexpectedRollbackException if we have a global rollback-only                // marker but still didn&#39;t get a corresponding exception from commit.                if (unexpectedRollback) &#123;                    throw new UnexpectedRollbackException(                            &quot;Transaction silently rolled back because it has been marked as rollback-only&quot;);                &#125;            &#125;            catch (UnexpectedRollbackException ex) &#123;                // can only be caused by doCommit                triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);                throw ex;            &#125;            catch (TransactionException ex) &#123;                // can only be caused by doCommit                if (isRollbackOnCommitFailure()) &#123;                    doRollbackOnCommitException(status, ex);                &#125;                else &#123;                    triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);                &#125;                throw ex;            &#125;            catch (RuntimeException | Error ex) &#123;                if (!beforeCompletionInvoked) &#123;                    triggerBeforeCompletion(status);                &#125;                doRollbackOnCommitException(status, ex);                throw ex;            &#125;            // Trigger afterCommit callbacks, with an exception thrown there            // propagated to callers but the transaction still considered as committed.            try &#123;                triggerAfterCommit(status);            &#125;            finally &#123;                triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);            &#125;        &#125;        finally &#123;            cleanupAfterCompletion(status);        &#125;    &#125;</code></pre><p>接着看<strong>triggerAfterCommit</strong>的实现</p><pre><code class="hljs">    /**     * Trigger &#123;@code afterCommit&#125; callbacks.     * @param status object representing the transaction     */    //org.springframework.transaction.support.AbstractPlatformTransactionManager.triggerAfterCommit    private void triggerAfterCommit(DefaultTransactionStatus status) &#123;        if (status.isNewSynchronization()) &#123;            if (status.isDebug()) &#123;                logger.trace(&quot;Triggering afterCommit synchronization&quot;);            &#125;            TransactionSynchronizationUtils.triggerAfterCommit();        &#125;    &#125;</code></pre><p>这里调用了TransactionSynchronizationUtils的triggerAfterCommit方法，继续往下跟</p><pre><code class="hljs">  public static void triggerAfterCommit() &#123;        invokeAfterCommit(TransactionSynchronizationManager.getSynchronizations());    &#125;  public static void invokeAfterCommit(@Nullable List&lt;TransactionSynchronization&gt; synchronizations) &#123;        if (synchronizations != null) &#123;            for (TransactionSynchronization synchronization : synchronizations) &#123;                synchronization.afterCommit();            &#125;        &#125;    &#125;</code></pre><p>看到了吧，先是拿到所有的<strong>TransactionSynchronization</strong>，然后调用他们的afterCommit方法，就会真正开始处理该Event。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>现在我们做一个总结，如果你遇到这样的业务，操作B需要在操作A事务提交后去执行，那么TransactionalEventListener是一个很好地选择。这里需要<strong>特别注意</strong>的一个点就是：当B操作有数据改动并持久化时，并希望在A操作的AFTER_COMMIT阶段执行，那么你需要将B事务声明为<strong>PROPAGATION_REQUIRES_NEW</strong>。这是因为A操作的事务提交后，事务资源可能仍然处于激活状态，如果B操作使用默认的<strong>PROPAGATION_REQUIRED</strong>的话，会直接加入到操作A的事务中，但是这时候事务A是不会再提交，结果就是程序写了修改和保存逻辑，但是数据库数据却没有发生变化，解决方案就是要明确的将操作B的事务设为<strong>PROPAGATION_REQUIRES_NEW</strong>。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://juejin.cn/post/7011685509567086606">TransactionalEventListener使用场景以及实现原理，最后要躲个大坑</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>TransactionalEventListener</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Top 10 Java idioms I wish I&#39;d learned earlier</title>
    <link href="/2022/12/29/java/Top%2010%20Java%20idioms%20I%20wish%20I&#39;d%20learned%20earlier/"/>
    <url>/2022/12/29/java/Top%2010%20Java%20idioms%20I%20wish%20I&#39;d%20learned%20earlier/</url>
    
    <content type="html"><![CDATA[<p>Hello guys, when your experience grow, your design, coding, refactoring and testing ability is the one which distinguish you from your competition. It’s quite possible that your experience grows but none of these skills grow because you are doing using them frequently in your day job. To be honest, you are not alone. Many people who works in big Investment banks like Citibank, Barclays Capital, UBS, or JP Morgan, spend more times fixing bugs and making config change, deployment and support then actually writing code from scratch or writing unit tests. While we will go with all those skills in coming articles, in this article, I am going to share popular Java coding idioms which can improve your coding skills.</p><p>Coding idioms are tried and tested way of writing code for a particular scenario. They are tested so they are bug free and by using them, you inherently rule out many corner cases and bugs which can occur if you write your own code. They are much like patterns and libraries for reusability but very low level.</p><p>One examples of idiom would include the most common way of writing an infinite loop (using where(true) rather than for(;;)).</p><p>The word ‘Idiom’ should be translated as ‘standard practice’. That is, if one were to look through a number of Java projects looking for the solution to a specific problem then the most common solution would be considered ‘Idiomatic”</p><p>So, if you want to improve your coding skills in Java, let’s take the first step and learn popular Java coding idioms</p><h2 id="10-Popular-Java-Coding-Idioms-to-write-better-code"><a href="#10-Popular-Java-Coding-Idioms-to-write-better-code" class="headerlink" title="10 Popular Java Coding Idioms to write better code"></a>10 Popular Java Coding Idioms to write better code</h2><p>Here is a list of my favorite Java coding idioms which you can use to write better, cleaner, and robust code in Java:</p><h3 id="1-Calling-equals-on-String-literal-or-Known-object"><a href="#1-Calling-equals-on-String-literal-or-Known-object" class="headerlink" title="1. Calling equals() on String literal or Known object"></a>1. Calling equals() on String literal or Known object</h3><p>For a long time while writing Java code, I used to invoke equals method like below:</p><p>if(givenString.equals(“YES”)){<br>// do something.<br>}</p><p>It’s natural because it reads better but its not safe. You can prevent a potential NPE by calling equals() on String literal, if one object is happen to be Sring literal or on known object e.g.</p><p>“TRUE”.equals(givenBoolean)<br>“YES”.equals(givenString)</p><p>if you do reverse e.g. givenBoolean.equals(“YES”) then it will throw NullPointerException if givenBoolean is null, but if you follow this idiom then it will just return false without throwing any NPE. This is a much better code, its safe and robust. In fact this is one of the <a href="https://javarevisited.blogspot.com/2013/05/ava-tips-and-best-practices-to-avoid-nullpointerexception-program-application.html">popular ways to avoid NullPointerException in Java</a>.</p><h3 id="2-Using-entrySet-to-loop-over-HashMap"><a href="#2-Using-entrySet-to-loop-over-HashMap" class="headerlink" title="2) Using entrySet to loop over HashMap"></a>2) Using entrySet to loop over HashMap</h3><p>I used to loop over HashMap using key set as shown below :</p><p>Set keySet = map.keyset();</p><p>for(Key k : keySet){<br>value v = map.get(k);<br>print(k, v)<br>}</p><p>This does another lookup to get the value from Map, which could be O(n) in worst case. if you need both key and value, then its better to iterate over entry set rather than key set.</p><p>Entry entrySet = map.entrySet();</p><p>for(Entry e : entrySet){<br>Key k = e.getKey();<br>Value v = e.getValue();<br>}</p><p>This is more efficient because you are getting value directly from object, which is always O(1).</p><h3 id="3-Using-Enum-as-Singleton"><a href="#3-Using-Enum-as-Singleton" class="headerlink" title="3) Using Enum as Singleton"></a>3) Using Enum as Singleton</h3><p>I wish, I had know that we can write Singleton in just one line in Java as :</p><p>public enum Singleton{<br>  INSTANCE;<br>}</p><p>It’s thread-safe, robust and Java guaranteed just one instance even in case of Serialization and Deserialization.</p><h3 id="4-Using-Arrays-asList-to-initialize-Collection-or-List-of-Set-of"><a href="#4-Using-Arrays-asList-to-initialize-Collection-or-List-of-Set-of" class="headerlink" title="4) Using Arrays.asList() to initialize Collection or List.of(), Set.of()"></a>4) Using Arrays.asList() to initialize Collection or List.of(), Set.of()</h3><p>Even If I know elements in advance, I used to initialize collection like this :</p><p>List listOfCurrencies = new ArrayList();<br>listOfCurrencies.add(“USD/AUD”);<br>listOfCurrencies.add(“USD/JPY”);<br>listOfCurrencies.add(“USD/INR”);</p><p>This is quite verbose, thankfully you can do all this in just one line by using this idiom, which take advantage and of Arrays.asList() and Collection’s copy constructor, as shown below :</p><p>List listOfPairs = new ArrayList(Arrays.asList(“USD/AUD”, “USD/JPY”, “USD/INR”);</p><p>Even though Arrays.asList returns a List, we need pass its output to ArrayList’s constructor because list returned by Arrays.asList() is of fixed length, you cannot add or remove elements there. BTW, its not just list but you can create Set or any other Collection as well e.g.</p><p>Set primes = new HashSet(Arrays.asList(2, 3, 5, 7);</p><p>And, from Java 9 onwards, you can use methods like List.of() and Set.of() to create a List and Set with values. They are actually better option because they return Immutable List and Set.</p><h3 id="5-Checking-wait-condition-in-loop"><a href="#5-Checking-wait-condition-in-loop" class="headerlink" title="5. Checking wait() condition in loop"></a>5. Checking wait() condition in loop</h3><p>When I first started writing inter-thread communication code using wait(), notify() and notifyAll() method, I used if block to check if waiting condition is true or not, before calling wait() and notify() as shown below :</p><p>synchronized(queue) {<br>  if(queue.isFull()){<br>  queue.wait();<br>  }<br>}</p><p>Thankfully, I didn’t face any issue but I realized my mistake when I read Effective Java Item of wait() and notify(), which states that you should check waiting condition in loop because it’s possible for threads to get spurious notification, and its also possible that before you do anything the waiting condition is imposed again. So correct idiom to call wait() and notify() is following :</p><p>synchronized(queue) {<br>  while(queue.isFull()){<br>   queue.wait();<br>  }<br>}</p><h3 id="6-Catching-CloneNotSupportedException-and-returning-SubClass-instance"><a href="#6-Catching-CloneNotSupportedException-and-returning-SubClass-instance" class="headerlink" title="6. Catching CloneNotSupportedException and returning SubClass instance"></a>6. Catching CloneNotSupportedException and returning SubClass instance</h3><p>Even though Object cloning functionality of Java is heavily criticized for its poor implementation, if you have to implement clone() then following couple of best practices and using below idiom will help reducing pain :</p><p>public Course clone() {<br>   Course c = null;<br>   try {<br>     c = (Course)super.clone();<br>   } catch (CloneNotSupportedException e) {} // Won’t happen</p><p>   return c;<br>}</p><p>This idiom leverages the fact that clone() will never throw CloneNotSupportedException, if a class implementers Cloneable interface. Returning Subtype is known as covariant method overriding and available from Java 5 but helps to reduce client side casting e.g. you client can now clone object without casting e.g.</p><p>Course javaBeginners = new Course(“Java”, 100, 10);<br>Course clone = javaBeginners.clone();</p><p>Earlier, even now with Date class, you have to explicitly cast the output of clone method as shown below :</p><p>Date d = new Date();<br>Date clone = (Date) d.clone();</p><h3 id="7-Using-interfaces-wherever-possible"><a href="#7-Using-interfaces-wherever-possible" class="headerlink" title="7. Using interfaces wherever possible"></a>7. Using interfaces wherever possible</h3><p>Even though I have been programming from long time, I have yet to realize full potential of interfaces. When I started coding, I used to use concrete classes e.g. ArrayList, Vector and HashMap to define return type of method, variable types or method argument types, as shown below :</p><p>ArrayList<Integer> listOfNumbers = new ArrayList();</p><p>public ArrayList<Integer> getNumbers(){<br>   return listOfNumbers;<br>}</p><p>public void setNumbers(ArrayList<Integer> numbers){<br>   listOfNumbers = numbers;<br>}</p><p>This is Ok, but its not flexible. You cannot pass another list to your methods, even though it is better than ArrayList and if tomorrow you need to switch to another implementation, you will have to change to all the places.</p><p>Instead of doing this, you should appropriate interface type e.g. if you need list i.e. ordered collection with duplicates then use java.util.List, if you need set i.e. unordered collection without duplicates then use java.util.Set and if you just need a container then use Collection. This gives flexibility to pass alternative implementation.</p><p>List<Integer> listOfNumbers;</p><p>public List<Integer> getNumberS(){<br>return listOfNumbers;<br>}</p><p>public void setNumbers(List<Integer> listOfNumbers){<br>this.listOfNumbers = listOfNumbers;<br>}</p><p>If you want, you can even go one step further and use extends keyword in Generics as well for example you can define List as List&lt;? extends Number&gt; and then you can pass List<Integer> or List<Short> to this method.</p><p><a href="https://javarevisited.blogspot.com/2020/12/top-5-course-to-improve-coding-skills.html"><img src="https://blogger.googleusercontent.com/img/a/AVvXsEiPzOPTl9SjiHdBst8xWV4YWgSTdjClqg-99oVVaR2nfNlDjM0ipaABtesrUzvbs_r7kwsULSF9fr5ok6G53-Yht0bntC34AAnEnM61OAtSdsZPO_QTvUE5vo5LKvLTLnj8ipQiGPH9eb-I6egF8nasOxzN6FV-rEJ2bU4jHT3kJZwK0D8tuWOPCHze=w577-h525" alt="Top 10 Java idioms I wish I&#39;d learned earlier"></a></p><h3 id="8-Using-Iterator-to-traverse-List"><a href="#8-Using-Iterator-to-traverse-List" class="headerlink" title="8. Using Iterator to traverse List"></a>8. Using Iterator to traverse List</h3><p>There are multiple ways to traverse or loop over a List in Java e.g. for loop with index, advanced for loop and Iterator. I used to use for loop with get() method as shown below :</p><p>for(int i =0; i&lt;list.size; i++){<br>  String name = list.get(i)<br>}</p><p>This works fine if you are iterating over ArrayList but given you are looping over List, its possible that List could be LinkedList or any other implementation, which might not support random access functionality e.g LinkedList. In that case time complexity of this loop will shoot up to N^2 becase get() is O(n) for LL. Using loop to go over List also has a disadvantage in terms of multi-threading e.g. <strong>CopyOnWriteArrayList</strong> - one thread changing list while another thread iterates over it using size() / get() leads to that IndexOutOfBoundsException.</p><p>On the other hand Iterator is the standard way or idiomatic way to traverse a List as shown below :</p><p>Iterator itr = list.iterator();<br>while(itr.hasNext()){<br>String name = itr.next();<br>}</p><p>It’s safe and also guard against unpredictable behavior.</p><h3 id="9-Writing-code-using-Dependency-Injection-in-mind"><a href="#9-Writing-code-using-Dependency-Injection-in-mind" class="headerlink" title="9) Writing code using Dependency Injection in mind"></a>9) Writing code using Dependency Injection in mind</h3><p>It was not long ago, I used to write code like this :</p><p>public Game {</p><p>   private HighScoreService service = HighScoreService.getInstance();</p><p>   public showLeaderBoeard(){<br>      List listOfTopPlayers = service.getLeaderBoard();<br>     System.out.println(listOfTopPlayers);<br>   }</p><p>}</p><p>This code looks quite familiar and many of us will pass it on code review but it’s not how you should write your modern Java code. This code has three main problems :</p><ol><li><p>Game class is tightly coupled with HighScoreService class, its not possible to test Game class in isolation. You must need HighScoreService class.</p></li><li><p>Even if you create a HighScoreService class you cannot test Game reliably if your HighScoreService is making network connection, downloading data from servers etc. Problem is, <strong>you can not use a Mock instead of actual object here.</strong></p></li></ol><p>You can get rid of these issues by writing your Java class as POJO and using DI as below :</p><p>public Game {</p><p>private HighScoreService service;</p><p>public Game(HighScoreService svc){<br>this.service = svc;<br>}</p><p>public showLeaderBoeard(){<br>List listOfTopPlayers = service.getLeaderBoard();<br>System.out.println(listOfTopPlayers);<br>}</p><p>}</p><h3 id="10-Closing-streams-in-their-own-try-block"><a href="#10-Closing-streams-in-their-own-try-block" class="headerlink" title="10. Closing streams in their own try block"></a>10. Closing streams in their own try block</h3><p>I used to close streams, InputStream and OutputStream like this :</p><p>InputStream is = null;<br>OutputStream os = null;</p><p>try {<br>is = new FileInputStream(“application.json”)<br>os = new FileOutPutStream(“application.log”)<br>}catch (IOException io) {</p><p>}finally {<br>     is.close();<br>     os.close()<br>}</p><p>problems, if first stream will throw exception then close from second will never be called. You can read more about this pattern in my earlier article, <a href="https://javarevisited.blogspot.com/2014/10/right-way-to-close-inputstream-file-resource-in-java.html">right way to close Stream in Java</a>.</p><p>That’s all about <strong>Java Idioms which can help you write better and more robust code</strong>. If you have been coding in Java for few years then most likely you already know these patterns but if you are just starting with Java or have 1 or 2 years of experience this idioms can help and open your mind with Java specific issues while writing code.</p><p>With new releases, these idioms may be replaced with better API methods like List.of() but knowing them still better than not knowing them. Also, if you know or follow any other Java coding idioms feel free to share with us on comments, I love to learn from knowledgeable readers.</p><p>I also plan to write second part of this article covering Java 8 idioms like using method reference instead of Lambdas etc. If you guys are interested, let me know in comments by saying yes, I would to see that article and any idiom you want to suggest.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://javarevisited.blogspot.com/2022/12/top-10-java-idioms-i-wish-id-learned.html">top-10-java-idioms-i-wish-id-learned</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Difference between 32-bit and 64-bit JVM in Java?</title>
    <link href="/2022/12/29/java/difference-between-32-bit-and-64-bit/"/>
    <url>/2022/12/29/java/difference-between-32-bit-and-64-bit/</url>
    
    <content type="html"><![CDATA[<p>One of the rather new or latest Java interview question is, “<strong>What is the difference between 32-bit and 64-bit JVM?</strong> or, <em>How do you choose between 32-bit vs 64-bit JVM?</em> or When to use 32-bit or 64-bit JVM? Some interviewer also use this concept to trick candidates by asking what would be the size of int variable in 32-bit and 64-bit Java? As mentioned in <a href="https://javarevisited.blogspot.sg/2015/10/133-java-interview-questions-answers-from-last-5-years.html">130+ Java questions from last 5 years</a>. Another tricky questions is, does same Java program can run on both 32-bit and 64-bit JVM? Short answer of this question is that <strong>Java is platform independent and same Java program will run absolutely fine in both 32-bit and 64-bit JVM</strong>.The real difference comes in addressable memory or<a href="https://javarevisited.blogspot.com/2011/05/java-heap-space-memory-size-jvm.html">heap memory</a>. In 32-bit JVM, the theoretical limit of<a href="https://javarevisited.blogspot.com/2012/12/invalid-initial-and-maximum-heap-size.html">maximum heap size</a>is around 4G but practically you get way less than that e.g. around 1.5 GB in Windows and close to 3 GB in Solaris, see here why it’s like that.</p><p>Choosing a <a href="https://javarevisited.blogspot.com/2012/01/find-jvm-is-32-or-64-bit-java-program.html">64-bit JVM</a> allows you to increase heap size beyond 4GB as addressable memory is way more now. But, it’s not all rosy because choosing 64-bit JVM and larger heap also has some disadvantages in terms of time required by <a href="https://javarevisited.blogspot.com/2012/10/10-garbage-collection-interview-question-answer.html">Garbage Collectors</a> and more memory needed by OOP pointers.</p><h2 id="Difference-between-32-bit-and-64-bit-JVM-Java-Virtual-Machine"><a href="#Difference-between-32-bit-and-64-bit-JVM-Java-Virtual-Machine" class="headerlink" title="Difference between 32-bit and 64-bit JVM (Java Virtual Machine)"></a>Difference between 32-bit and 64-bit JVM (Java Virtual Machine)</h2><p>As I said before, main difference between these two JVM comes from addressable memory or heap size. In 32-bit JVM, the maximum addressable memory is 4GB but its way more in 64-bit JVM, around 2^64. All other differences derives from this fact only.  </p><h3 id="1-Bigger-Heap-Memory"><a href="#1-Bigger-Heap-Memory" class="headerlink" title="1.Bigger Heap Memory"></a>1.Bigger Heap Memory</h3><p>64-bit JVM has bigger heap than 32-bit JVM. <a href="https://javarevisited.blogspot.com/2013/04/what-is-maximum-heap-size-for-32-bit-64-JVM-Java-memory.html">Maximum heap size for 32-bit JVM</a> is much smaller than 64-bit JVM. theoretically its 4GB but practically on average its around 2GB. Specifying more heap will throw error JVM cannot created, invalid heap size.  </p><h3 id="2-OOP-Pointer-Size"><a href="#2-OOP-Pointer-Size" class="headerlink" title="2.OOP Pointer Size"></a>2.OOP Pointer Size</h3><p>OOP pointer size gets doubled in 64-bit JVM but you can use <a href="https://javarevisited.blogspot.com/2012/06/what-is-xxusecompressedoops-in-64-bit.html">-XX:+UseCompressOops option</a> to reduce the size of OOP pointer. This is the reason why same Java program will take more memory in 64-bit JVM than in 32-bit JVM.</p><p>Increased size of OOP pointer also means that less data can be cached in register that’s why its very important to enable -XX:+CompressOop JVM option when moving to 64 bit JVM.  </p><h3 id="3-Long-GC-Pause"><a href="#3-Long-GC-Pause" class="headerlink" title="3.Long GC Pause"></a>3.Long GC Pause</h3><p>Due to larger heap, GC pause time may increase, so the size of JVM heap must be decided properly to strike a balance between memory required and GC pause time.</p><p><a href="https://medium.com/javarevisited/7-best-courses-to-learn-jvm-garbage-collection-and-performance-tuning-for-experienced-java-331705180686"><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi6VK8IQZcIU09VJHeXZZKDrjG8amP0DXSIzRnEF86JThLlI5PPO3TIYqkyr3w6mDM2UaRhS5uxk46OCoszlADDwimyxhKmEZ77h-Hbt06b_cJp4XrBiY-mXFYp5i88HjZd-KADzJpra_agTOKiV_7WsYMNJpfJTy7_VoNTSGbvii33BXKplItHIm5r/w619-h465/JVM%20JIT%20Components.PNG"></a></p><h2 id="Similarities-between-32-bit-and-64-bit-JVM"><a href="#Similarities-between-32-bit-and-64-bit-JVM" class="headerlink" title="Similarities between 32-bit and 64-bit JVM"></a>Similarities between 32-bit and 64-bit JVM</h2><p>As I said before, since Java is platform independent, same Java program will run fine in both 32-bit and 64-bit JVM. Java specification is also same for both 32-bit and 64-bit JVM e.g. size of all primitive variable like int, short, double, long and float is same i.e. int variable will take 4 bytes in both 32 and 64-bit JVM.</p><p>There is nothing like 32 or 64-bit Java. Though installation package for 32 and 64-bit JDK is different but Java specification is same. So, if you someone tries to trick you by saying that size of int variable will be double in 64-bit JVM then you can say no.</p><p><a href="https://javarevisited.blogspot.com/2011/04/garbage-collection-in-java.html"><img src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiQU6dauYgFEZPuz3HXjYAq-8IOcCP62OaUuim4O_tjNX4oXJmg_neZ-eujGmlFzKa5hgI5EOrZEDLhxhBvYBpvE-w8y0icAuRY9o0B6ZbQl_t9cDuXVN2cbWpe2L9SHlYqcFOOVZHS7rZlq2THJ-TfdLmovRO6ltDvRXhEoEtam0Map2yQVWWb0SOH/w479-h289/GarbageCollection%20in%20Java.jpg"></a></p><p>That’s all about <strong>difference between 32-bit and 64-bit JVM in Java</strong>. As I said, main difference is large heap memory available on 64-bit Java Virtual Machine and most people switch to 64-bit JVM for 2 reasons, a large heap and they are running their program on a 64-bit operating system.</p><p>Due to larger heap, Garbage collection can be long and that’s why you should allocate enough memory for your application to grow and don’t need to trigger Garbage collection until restart window kicks in. For example if your application is daily or weekly restart then just give it enough memory to run for the week without GC.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://javarevisited.blogspot.com/2022/12/difference-between-32-bit-and-64-bit.html">Difference between 32-bit and 64-bit JVM in Java</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Event的同步和异步，以及实现机制</title>
    <link href="/2022/12/09/spring/Spring%20Event%E7%9A%84%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/12/09/spring/Spring%20Event%E7%9A%84%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>Spring Event 通知机制，可以很有效的帮助项目中的代码解耦合。<br>咱们来看下它的同步和异步使用方式，以及相应的源码。</p><h3 id="1-spring-event-demo-同步模式"><a href="#1-spring-event-demo-同步模式" class="headerlink" title="1.spring event demo - 同步模式"></a>1.spring event demo - 同步模式</h3><p>定义一个事件，继承ApplicationEvent。<br>再定义一个eventPublisher，通过ApplicationEventPublisher来发布事件。<br>最后定义一个eventSubscriber，实现了ApplicationListener接口，用来监听事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyEvent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ApplicationEvent</span> &#123;<br>    <span class="hljs-keyword">private</span> String message;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyEvent</span><span class="hljs-params">(Object source, String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(source);<br>        <span class="hljs-built_in">this</span>.message = message;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMessage</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyEventPublisher</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ApplicationEventPublisher applicationEventPublisher;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">publishEvent</span><span class="hljs-params">(String message)</span> &#123;<br>        applicationEventPublisher.publishEvent(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyEvent</span>(<span class="hljs-built_in">this</span>, message));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyEventSubscriber</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span>&lt;MyEvent&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(MyEvent myEvent)</span> &#123;<br>        System.out.println(myEvent.getMessage());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>output:</strong><br>从output可以看出，主线程publish event，接下来依然是主线程执行subscriber的内容。</p><pre><code class="hljs">Thread main: Publish Eventmain: Subscribed event - test</code></pre><h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><p>AbstractApplicationContext的publishEvent方法，会让容器中的applicationEventMulticaster发布事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DefaultResourceLoader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ConfigurableApplicationContext</span> &#123;<br><span class="hljs-comment">//......</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">publishEvent</span><span class="hljs-params">(Object event, <span class="hljs-meta">@Nullable</span> ResolvableType eventType)</span> &#123;<br>        <span class="hljs-comment">//......</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.earlyApplicationEvents != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-built_in">this</span>.earlyApplicationEvents.add(applicationEvent);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.getApplicationEventMulticaster().multicastEvent((ApplicationEvent)applicationEvent, eventType);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.parent != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.parent <span class="hljs-keyword">instanceof</span> AbstractApplicationContext) &#123;<br>                ((AbstractApplicationContext)<span class="hljs-built_in">this</span>.parent).publishEvent(event, eventType);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">this</span>.parent.publishEvent(event);<br>            &#125;<br>        &#125;<br><br>    &#125;<br><span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的simpleApplicationEventMulticaster是spring容器中默认的multicaster。执行方法multicastEvent时，会看是否有指定的executor，如果没有，那么就由当前线程来invoke listener并执行subscriber的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleApplicationEventMulticaster</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractApplicationEventMulticaster</span> &#123;<br><span class="hljs-comment">//......</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">multicastEvent</span><span class="hljs-params">(ApplicationEvent event, <span class="hljs-meta">@Nullable</span> ResolvableType eventType)</span> &#123;<br>        <span class="hljs-type">ResolvableType</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> eventType != <span class="hljs-literal">null</span> ? eventType : <span class="hljs-built_in">this</span>.resolveDefaultEventType(event);<br>        <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getTaskExecutor();<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">var5</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getApplicationListeners(event, type).iterator();<br><br>        <span class="hljs-keyword">while</span>(var5.hasNext()) &#123;<br>            ApplicationListener&lt;?&gt; listener = (ApplicationListener)var5.next();<br>            <span class="hljs-keyword">if</span> (executor != <span class="hljs-literal">null</span>) &#123;<br>                executor.execute(() -&gt; &#123;<br>                    <span class="hljs-built_in">this</span>.invokeListener(listener, event);<br>                &#125;);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">this</span>.invokeListener(listener, event);<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//......</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doInvokeListener</span><span class="hljs-params">(ApplicationListener listener, ApplicationEvent event)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        listener.onApplicationEvent(event);<br>    &#125; <span class="hljs-keyword">catch</span> (ClassCastException var6) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> var6.getMessage();<br>        <span class="hljs-keyword">if</span> (msg != <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-built_in">this</span>.matchesClassCastMessage(msg, event.getClass())) &#123;<br>            <span class="hljs-keyword">throw</span> var6;<br>        &#125;<br><br>        <span class="hljs-type">Log</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LogFactory.getLog(<span class="hljs-built_in">this</span>.getClass());<br>        <span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>            logger.trace(<span class="hljs-string">&quot;Non-matching event type for listener: &quot;</span> + listener, var6);<br>        &#125;<br>    &#125;<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-spring-event-demo-异步模式"><a href="#2-spring-event-demo-异步模式" class="headerlink" title="2. spring event demo - 异步模式"></a>2. spring event demo - 异步模式</h3><p>加上配置，注入一个simpleApplicationEventMulticaster。将这个multicaster的taskexecutor设置为自定义的线程池。<br>当publish event时，当前线程会到从线程池里来取线程，进行invoke listener，以及执行subscriber逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EventConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean(AbstractApplicationContext.APPLICATION_EVENT_MULTICASTER_BEAN_NAME)</span><br>    <span class="hljs-keyword">public</span> SimpleApplicationEventMulticaster <span class="hljs-title function_">myEventMulticaster</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">SimpleApplicationEventMulticaster</span> <span class="hljs-variable">simpleApplicationEventMulticaster</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleApplicationEventMulticaster</span>();<br>        simpleApplicationEventMulticaster.setTaskExecutor(taskExecutor());<br>        <span class="hljs-keyword">return</span> simpleApplicationEventMulticaster;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> TaskExecutor <span class="hljs-title function_">taskExecutor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>();<br>        executor.setCorePoolSize(<span class="hljs-number">5</span>);<br>        executor.setMaxPoolSize(<span class="hljs-number">20</span>);<br>        executor.setQueueCapacity(<span class="hljs-number">100</span>);<br>        executor.setKeepAliveSeconds(<span class="hljs-number">300</span>);<br>        executor.setThreadNamePrefix(<span class="hljs-string">&quot;thread-&quot;</span>);<br>        executor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.DiscardPolicy());<br>        executor.setWaitForTasksToCompleteOnShutdown(<span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">return</span> executor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>output:</strong><br>从output可以看出，主线程publish event，而subscriber内容由线程池中的线程执行。</p><pre><code class="hljs">Thread main: Publish Eventthread-1: Subscribed event - test</code></pre><h5 id="源码解析-1"><a href="#源码解析-1" class="headerlink" title="源码解析"></a>源码解析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleApplicationEventMulticaster</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractApplicationEventMulticaster</span> &#123;<br><br><span class="hljs-comment">/*setTaskExecutor</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Set the TaskExecutor to execute application listeners with.</span><br><span class="hljs-comment">Default is a SyncTaskExecutor, executing the listeners synchronously in the calling thread.</span><br><span class="hljs-comment">Consider specifying an asynchronous TaskExecutor here to not block the caller until all listeners have been executed. However, note that asynchronous execution will not participate in the caller&#x27;s thread context (class loader, transaction association) unless the TaskExecutor explicitly supports this.</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTaskExecutor</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Executor taskExecutor)</span> &#123;<br>        <span class="hljs-built_in">this</span>.taskExecutor = taskExecutor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-Spring容器中的通知机制是如何实现的"><a href="#3-Spring容器中的通知机制是如何实现的" class="headerlink" title="3. Spring容器中的通知机制是如何实现的"></a>3. Spring容器中的通知机制是如何实现的</h3><h5 id="3-1-初始化SimpleApplicationEventMulticaster并注入容器"><a href="#3-1-初始化SimpleApplicationEventMulticaster并注入容器" class="headerlink" title="3.1 初始化SimpleApplicationEventMulticaster并注入容器"></a>3.1 初始化SimpleApplicationEventMulticaster并注入容器</h5><p>Spring在初始化bean时，会进行ApplicationEventMulticaster的初始化。<br>会先检查是否有local的applicationEventMulticaster，如果有，那么就会创建local也就是自定义的applicationEventMulticaster，放入容器；如果没有，就会创建默认的SimpleApplicationEventMulticaster放入容器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DefaultResourceLoader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ConfigurableApplicationContext</span> &#123;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initApplicationEventMulticaster</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ConfigurableListableBeanFactory</span> <span class="hljs-variable">beanFactory</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getBeanFactory();<br>        <span class="hljs-keyword">if</span> (beanFactory.containsLocalBean(<span class="hljs-string">&quot;applicationEventMulticaster&quot;</span>)) &#123;<br>            <span class="hljs-built_in">this</span>.applicationEventMulticaster = (ApplicationEventMulticaster)beanFactory.getBean(<span class="hljs-string">&quot;applicationEventMulticaster&quot;</span>, ApplicationEventMulticaster.class);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isTraceEnabled()) &#123;<br>                <span class="hljs-built_in">this</span>.logger.trace(<span class="hljs-string">&quot;Using ApplicationEventMulticaster [&quot;</span> + <span class="hljs-built_in">this</span>.applicationEventMulticaster + <span class="hljs-string">&quot;]&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.applicationEventMulticaster = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleApplicationEventMulticaster</span>(beanFactory);<br>            beanFactory.registerSingleton(<span class="hljs-string">&quot;applicationEventMulticaster&quot;</span>, <span class="hljs-built_in">this</span>.applicationEventMulticaster);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isTraceEnabled()) &#123;<br>                <span class="hljs-built_in">this</span>.logger.trace(<span class="hljs-string">&quot;No &#x27;applicationEventMulticaster&#x27; bean, using [&quot;</span> + <span class="hljs-built_in">this</span>.applicationEventMulticaster.getClass().getSimpleName() + <span class="hljs-string">&quot;]&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-2-注册所有的监听器"><a href="#3-2-注册所有的监听器" class="headerlink" title="3.2 注册所有的监听器"></a>3.2 注册所有的监听器</h5><p>接下来，spring容器会注册所有的监听器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DefaultResourceLoader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ConfigurableApplicationContext</span> &#123;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerListeners</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Iterator</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getApplicationListeners().iterator();<br><br>        <span class="hljs-keyword">while</span>(var1.hasNext()) &#123;<br>            ApplicationListener&lt;?&gt; listener = (ApplicationListener)var1.next();<br>            <span class="hljs-built_in">this</span>.getApplicationEventMulticaster().addApplicationListener(listener);<br>        &#125;<br><br>        String[] listenerBeanNames = <span class="hljs-built_in">this</span>.getBeanNamesForType(ApplicationListener.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>        String[] var7 = listenerBeanNames;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> listenerBeanNames.length;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">var4</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; var4 &lt; var3; ++var4) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">listenerBeanName</span> <span class="hljs-operator">=</span> var7[var4];<br>            <span class="hljs-built_in">this</span>.getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);<br>        &#125;<br><br>        Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="hljs-built_in">this</span>.earlyApplicationEvents;<br>        <span class="hljs-built_in">this</span>.earlyApplicationEvents = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(earlyEventsToProcess)) &#123;<br>            <span class="hljs-type">Iterator</span> <span class="hljs-variable">var9</span> <span class="hljs-operator">=</span> earlyEventsToProcess.iterator();<br><br>            <span class="hljs-keyword">while</span>(var9.hasNext()) &#123;<br>                <span class="hljs-type">ApplicationEvent</span> <span class="hljs-variable">earlyEvent</span> <span class="hljs-operator">=</span> (ApplicationEvent)var9.next();<br>                <span class="hljs-built_in">this</span>.getApplicationEventMulticaster().multicastEvent(earlyEvent);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>addApplicationListener会将listener和相应的事件类型记录下来:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractApplicationEventMulticaster</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationEventMulticaster</span>, BeanClassLoaderAware, BeanFactoryAware &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addApplicationListener</span><span class="hljs-params">(ApplicationListener&lt;?&gt; listener)</span> &#123;<br>        <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>.defaultRetriever) &#123;<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">singletonTarget</span> <span class="hljs-operator">=</span> AopProxyUtils.getSingletonTarget(listener);<br>            <span class="hljs-keyword">if</span> (singletonTarget <span class="hljs-keyword">instanceof</span> ApplicationListener) &#123;<br>                <span class="hljs-built_in">this</span>.defaultRetriever.applicationListeners.remove(singletonTarget);<br>            &#125;<br><br>            <span class="hljs-built_in">this</span>.defaultRetriever.applicationListeners.add(listener);<br>            <span class="hljs-built_in">this</span>.retrieverCache.clear();<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-3-事件发生时，multicast-event"><a href="#3-3-事件发生时，multicast-event" class="headerlink" title="3.3 事件发生时，multicast event"></a>3.3 事件发生时，multicast event</h5><ul><li><p>调用multicaster的multicastEvent方法<br>  上面已经提到，事件发生时，会调用AbstractApplicationContext的publishEvent方法，它会调用注入到容器里的multicaster执行multicastEvent。</p></li><li><p>根据事件类型，找到所有监听这类事件的listener</p><pre><code class="hljs">      Iterator var5 = this.getApplicationListeners(event, type).iterator();</code></pre></li></ul><p>详细看下getApplicationListeners方法:</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs haxe">protected Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners(ApplicationEvent event, ResolvableType eventType) &#123;<br>    Object source = event.getSource();<br>    Class&lt;?&gt; sourceType = source != <span class="hljs-literal">null</span> ? source.getClass() : <span class="hljs-type">null</span>;<br>    AbstractApplicationEventMulticaster.ListenerCacheKey cacheKey = <span class="hljs-keyword">new</span> <span class="hljs-type">AbstractApplicationEventMulticaster</span>.ListenerCacheKey(eventType, sourceType);<br>    AbstractApplicationEventMulticaster.CachedListenerRetriever <span class="hljs-keyword">new</span><span class="hljs-type">Retriever</span> = <span class="hljs-literal">null</span>;<br>    AbstractApplicationEventMulticaster.CachedListenerRetriever existingRetriever = (AbstractApplicationEventMulticaster.CachedListenerRetriever)<span class="hljs-built_in">this</span>.retrieverCache.<span class="hljs-keyword">get</span>(cacheKey);<br>    <span class="hljs-keyword">if</span> (existingRetriever == <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-built_in">this</span>.beanClassLoader == <span class="hljs-literal">null</span> || ClassUtils.isCacheSafe(event.getClass(), <span class="hljs-built_in">this</span>.beanClassLoader) &amp;&amp; (sourceType == <span class="hljs-literal">null</span> || ClassUtils.isCacheSafe(sourceType, <span class="hljs-built_in">this</span>.beanClassLoader)))) &#123;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Retriever</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">AbstractApplicationEventMulticaster</span>.CachedListenerRetriever();<br>        existingRetriever = (AbstractApplicationEventMulticaster.CachedListenerRetriever)<span class="hljs-built_in">this</span>.retrieverCache.putIfAbsent(cacheKey, <span class="hljs-keyword">new</span><span class="hljs-type">Retriever</span>);<br>        <span class="hljs-keyword">if</span> (existingRetriever != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Retriever</span> = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (existingRetriever != <span class="hljs-literal">null</span>) &#123;<br>        Collection&lt;ApplicationListener&lt;?&gt;&gt; result = existingRetriever.getApplicationListeners();<br>        <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.retrieveApplicationListeners(eventType, sourceType, <span class="hljs-keyword">new</span><span class="hljs-type">Retriever</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>  对于每一个listener，invoke该listener</li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">while</span>(var5.has<span class="hljs-constructor">Next()</span>) &#123;<br>    ApplicationListener&lt;?&gt; listener = (ApplicationListener)var5.next<span class="hljs-literal">()</span>;<br>    <span class="hljs-keyword">if</span> (executor != null) &#123;<br>        executor.execute(<span class="hljs-literal">()</span> -&gt; &#123;<br>            this.invoke<span class="hljs-constructor">Listener(<span class="hljs-params">listener</span>, <span class="hljs-params">event</span>)</span>;<br>        &#125;);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        this.invoke<span class="hljs-constructor">Listener(<span class="hljs-params">listener</span>, <span class="hljs-params">event</span>)</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.jianshu.com/p/96181bba0326">Spring Event的同步和异步，以及实现机制</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>咱们从头到尾说一次 Spring 事务管理（器）</title>
    <link href="/2022/11/29/spring/%E5%92%B1%E4%BB%AC%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%E8%AF%B4%E4%B8%80%E6%AC%A1%20Spring%20%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%EF%BC%88%E5%99%A8%EF%BC%89/"/>
    <url>/2022/11/29/spring/%E5%92%B1%E4%BB%AC%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%E8%AF%B4%E4%B8%80%E6%AC%A1%20Spring%20%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%EF%BC%88%E5%99%A8%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><strong>事务管理</strong>，一个被说烂的也被看烂的话题，还是八股文中的基础股之一。但除了八股文中需要熟读并背诵的那些个传播行为之外，背后的“为什么”和核心原理更为重要。  </p><p>写这篇文章之前，我也翻过一些事务管理器原理介绍文章，但大多都是生硬的翻译源码，一个劲的给源码加注释。这种源码翻译的文章虽说有帮助，但对读者来说体验并不好，很容易陷入代码的一些细节里，并不能帮助读者快速的了解事务管理的全貌，以及设计思路。  </p><p>本文会从设计角度，一步步的剖析 Spring 事务管理的设计思路（都会设计事务管理器了，还能不不会用么？）</p><h2 id="为什么需要事务管理？"><a href="#为什么需要事务管理？" class="headerlink" title="为什么需要事务管理？"></a>为什么需要事务管理？</h2><p>先看看如果没有事务管理器的话，如果<strong>想让多个操作（方法/类）处在一个事务里</strong>应该怎么做：</p><pre><code class="hljs">// MethodA:public void methodA()&#123;    Connection connection = acquireConnection();    try&#123;        int updated = connection.prepareStatement().executeUpdate();        methodB(connection);        connection.commit();    &#125;catch (Exception e)&#123;        rollback(connection);    &#125;finally &#123;        releaseConnection(connection);    &#125;&#125;// MethodB:public void methodB(Connection connection)&#123;    int updated = connection.prepareStatement().executeUpdate();&#125;</code></pre><p>或者用 ThreadLocal 存储 Connection？</p><pre><code class="hljs">static ThreadLocal&lt;Connection&gt; connHolder = new ThreadLocal&lt;&gt;();// MethodA:public void methodA()&#123;    Connection connection = acquireConnection();    connHolder.set(connection);    try&#123;        int updated = connection.prepareStatement().executeUpdate();        methodB();        connection.commit();    &#125;catch (Exception e)&#123;        rollback(connection);    &#125;finally &#123;        releaseConnection(connection);        connHolder.remove();    &#125;&#125;// MethodB:public void methodB()&#123;    Connection connection = connHolder.get();    int updated = connection.prepareStatement().executeUpdate();&#125;</code></pre><p>还是有点恶心，再抽象一下？将绑定 Connection 的操作提取为公共方法：</p><pre><code class="hljs">static ThreadLocal&lt;Connection&gt; connHolder = new ThreadLocal&lt;&gt;();private void bindConnection()&#123;    Connection connection = acquireConnection();    connHolder.set(connection);&#125;private void unbindConnection()&#123;    releaseConnection(connection);    connHolder.remove();&#125;// MethodA:public void methodA()&#123;    try&#123;        bindConnection();        int updated = connection.prepareStatement().executeUpdate();        methoB();        connection.commit();    &#125;catch (Exception e)&#123;        rollback(connection);    &#125;finally &#123;        unbindConnection();    &#125;&#125;// MethodB:public void methodB()&#123;    Connection connection = connHolder.get();    int updated = connection.prepareStatement().executeUpdate();&#125;</code></pre><p>现在看起来好点了，不过我有一个新的需求：想让 methodB 独立一个新事务，单独提交和回滚，不影响 methodA  </p><p>这……可就有点难搞了，ThreadLocal 中已经绑定了一个 Connection，再新事务的话就不好办了  </p><p>那如果再复杂点呢，methodB 中需要调用 methodC，methodC 也需要一个独立事务……  </p><p>而且，每次 bind/unbind 的操作也有点太傻了，万一哪个方法忘了写 unbind ，最后来一个连接泄露那不是完蛋了！  </p><p>好在 Spring 提供了事务管理器，帮我们解决了这一系列痛点。</p><h2 id="Spring-事务管理解决了什么问题？"><a href="#Spring-事务管理解决了什么问题？" class="headerlink" title="Spring 事务管理解决了什么问题？"></a>Spring 事务管理解决了什么问题？</h2><p>Spring 提供的事务管理可以帮我们管理事务相关的资源，比如 JDBC 的 Connection、Hibernate 的 Session、Mybatis 的 SqlSession。如说上面的 Connection 绑定到 ThreadLocal 来解决共享一个事务的这种方式，Spring 事务管理就已经帮我们做好了。  </p><p>还可以帮我们处理复杂场景下的嵌套事务，比如前面说到的 methodB/methodC 独立事务。</p><h3 id="什么是嵌套事务？"><a href="#什么是嵌套事务？" class="headerlink" title="什么是嵌套事务？"></a>什么是嵌套事务？</h3><p>还是拿上面的例子来说， methodA 中调用了 methodB，两个方法都有对数据库的操作，而且都需要事务：</p><pre><code class="hljs">// MethodA:public void methodA()&#123;    int updated = connection.prepareStatement().executeUpdate();    methodB();    // ...&#125;// MethodB:public void methodB()&#123;    // ...&#125;</code></pre><p><strong>这种多个方法调用链中都有事务的场景，就是嵌套事务。</strong>不过要注意的是，并不是说多个方法使用一个事务才叫嵌套，哪怕是不同的事务，只要在这个方法的调用链中，都是嵌套事务。</p><h3 id="什么是事务传播行为？"><a href="#什么是事务传播行为？" class="headerlink" title="什么是事务传播行为？"></a>什么是事务传播行为？</h3><p>那调用链中的子方法，是用一个新事务，还是使用当前事务呢？这个子方法决定使用新事务还是当前事务（或不使用事务）的策略，就叫事务传播。  </p><p>在 Spring 的事务管理中，<strong>这个子方法的事务处理策略叫做事务传播行为（Propogation Behavior）</strong>。</p><h3 id="有哪些事务传播行为？"><a href="#有哪些事务传播行为？" class="headerlink" title="有哪些事务传播行为？"></a>有哪些事务传播行为？</h3><p>Spring 的事务管理支持多种传播行为</p><p>REQUIRED：支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。</p><p>SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。</p><p>MANDATORY：支持当前事务，如果当前没有事务，就抛出异常。</p><p>REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。</p><p>NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p><p>NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</p><p>NESTED：支持当前事务，如果当前事务存在，则执行一个嵌套事务，如果当前没有事务，就新建一个事务。</p><p>但给这些传播行为分类之后，无非是以下三种：</p><ol><li> 优先使用当前事务</li><li> 不使用当前事务，新建事务</li><li> 不使用任何事务</li></ol><p>比如上面的例子中，methodB/methodC 独立事务，就属于第 2 种传播行为 - 不使用当前事务，新建事务</p><h3 id="看个栗子"><a href="#看个栗子" class="headerlink" title="看个栗子"></a>看个栗子</h3><p>以 Spring JDBC + Spring <strong>注解版</strong>的事务举例。在默认的事务传播行为下，methodA 和 methodB 会使用同一个 Connection，在一个事务中</p><pre><code class="hljs">@Transactionalpublic void methodA()&#123;    jdbcTemplate.batchUpdate(updateSql, params);    methodB();&#125;@Transactionalpublic void methodB()&#123;    jdbcTemplate.batchUpdate(updateSql, params);&#125;</code></pre><p>如果我想让 methodB 不使用 methodA 的事务，自己新建一个连接/事务呢？只需要简单的配置一下 @Transactional 注解：</p><pre><code class="hljs">@Transactionalpublic void methodA()&#123;    jdbcTemplate.batchUpdate(updateSql, params);    methodB();&#125;// 传播行为配置为 - 方式2，不使用当前事务，独立一个新事务@Transactional(propagation = Propagation.REQUIRES_NEW)public void methodB()&#123;    jdbcTemplate.batchUpdate(updateSql, params);&#125;</code></pre><p>就是这么简单，获取 Connection/多方法共享 Connection/多方法共享+独享 Connection/提交/释放连接之类的操作，完全不需要我们操心，Spring 都替我们做好了。</p><h3 id="怎么回滚？"><a href="#怎么回滚？" class="headerlink" title="怎么回滚？"></a>怎么回滚？</h3><p>在注解版的事务管理中，默认的的回滚策略是：抛出异常就回滚。这个默认策略挺好，连回滚都帮我们解决了，再也不用手动回滚。  </p><p>但是如果在嵌套事务中，子方法独立新事务呢？这个时候哪怕抛出异常，也只能回滚子事务，不能直接影响前一个事务</p><p>可如果这个抛出的异常不是 sql 导致的，比如校验不通过或者其他的异常，此时应该将当前的事务回滚吗？  </p><p>这个还真不一定，谁说抛异常就要回滚，异常也不回滚行不行？  </p><p>当然可以！抛异常和回滚事务本来就是两个问题，可以连在一起，也可以分开处理</p><pre><code class="hljs">// 传播行为配置为 - 方式2，不使用当前事务，独立一个新事务// 指定 Exception 也不会滚@Transactional(propagation = Propagation.REQUIRES_NEW, noRollbackFor = Exception.class)public void methodB()&#123;    jdbcTemplate.batchUpdate(updateSql, params);&#125;</code></pre><h3 id="每个事务-连接使用不同配置"><a href="#每个事务-连接使用不同配置" class="headerlink" title="每个事务/连接使用不同配置"></a>每个事务/连接使用不同配置</h3><p>除了传播和回滚之外，还可以给每个事务/连接使用不同的配置，比如不同的隔离级别：</p><pre><code class="hljs">@Transactionalpublic void methodA()&#123;    jdbcTemplate.batchUpdate(updateSql, params);    methodB();&#125;// 传播行为配置为 - 方式2，不使用当前事务，独立一个新事务// 这个事务/连接中使用 RC 隔离级别，而不是默认的 RR@Transactional(propagation = Propagation.REQUIRES_NEW, isolation = Isolation.READ_UNCOMMITTED)public void methodB()&#123;    jdbcTemplate.batchUpdate(updateSql, params);&#125;</code></pre><p>除了隔离级别之外，其他的 JDBC Connection 配置当然也是支持的，比如 readOnly。这样一来，虽然我们不用显示的获取 connection/session，但还是可以给嵌套中的每一个事务配置不同的参数，非常灵活。</p><h3 id="功能总结"><a href="#功能总结" class="headerlink" title="功能总结"></a>功能总结</h3><p>好了，现在已经了解了 Spring 事务管理的所有核心功能，来总结一下这些核心功能点：</p><ol><li> 连接/资源管理 - 无需手动获取资源、共享资源、释放资源</li><li> 嵌套事务的支持 - 支持嵌套事务中使用不同的资源策略、回滚策略</li><li> 每个事务/连接使用不同的配置</li></ol><h2 id="事务管理器（TransactionManager）模型"><a href="#事务管理器（TransactionManager）模型" class="headerlink" title="事务管理器（TransactionManager）模型"></a>事务管理器（TransactionManager）模型</h2><p>其实仔细想想，事务管理的核心操作只有两个：提交和回滚。前面所谓的传播、嵌套、回滚之类的，都是基于这两个操作。  </p><p>所以 Spring 将事务管理的核心功能抽象为一个<strong>事务管理器（Transaction Manager）</strong>，基于这个事务管理器核心，可以实现多种事务管理的方式。  </p><p>这个核心的事务管理器只有三个功能接口：</p><ol><li><p> <strong>获取事务资源</strong>，资源可以是任意的，比如jdbc connection/hibernate mybatis session之类，然后绑定并存储</p></li><li><p> <strong>提交事务</strong> - 提交指定的事务资源</p></li><li><p><strong>回滚事务</strong> - 回滚指定的事务资源</p><p> interface PlatformTransactionManager{</p><pre><code class="hljs"> // 获取事务资源，资源可以是任意的，比如jdbc connection/hibernate mybatis session之类 TransactionStatus getTransaction(TransactionDefinition definition)         throws TransactionException;  // 提交事务 void commit(TransactionStatus status) throws TransactionException;  // 回滚事务 void rollback(TransactionStatus status) throws TransactionException;</code></pre><p> }</p></li></ol><h3 id="事务定义-TransactionDefinition"><a href="#事务定义-TransactionDefinition" class="headerlink" title="事务定义 - TransactionDefinition"></a>事务定义 - TransactionDefinition</h3><p>还记得上面的 @Transactional 注解吗，里面定义了传播行为、隔离级别、回滚策略、只读之类的属性，这个就是一次事务操作的定义。  </p><p>在获取事务资源时，需要根据这个事务的定义来进行不同的配置：</p><ol><li> 比如配置了使用新事务，那么在获取事务资源时就需要创建一个新的，而不是已有的</li><li> 比如配置了隔离级别，那么在首次创建资源（Connection）时，就需要给 Connection 设置 propagation</li><li> 比如配置了只读属性，那么在首次创建资源（Connection）时，就需要给 Connection 设置 readOnly</li></ol><p>为什么要单独用一个 TransactionDefinition 来存储事务定义，直接用注解的属性不行吗？  </p><p>当然可以，但注解的事务管理只是 Spring 提供的自动挡，还有适合老司机的手动挡事务管理（后面会介绍）；手动挡可用不了注解，所以单独建一个事务定义的模型，这样就可以实现通用。</p><h3 id="事务状态-TransactionStatus"><a href="#事务状态-TransactionStatus" class="headerlink" title="事务状态 - TransactionStatus"></a>事务状态 - TransactionStatus</h3><p>那既然嵌套事务下，每个子方法的事务可能不同，所以还得有一个子方法事务的状态 - TransactionStatus，用来存储当前事务的一些数据和状态，比如事务资源（Connection）、回滚状态等。</p><h3 id="获取事务资源"><a href="#获取事务资源" class="headerlink" title="获取事务资源"></a>获取事务资源</h3><p>事务管理器的第一步，就是根据事务定义来获取/创建资源了，这一步最麻烦的是要区分传播行为，不同传播行为下的逻辑不太一样。  </p><p>“默认的传播行为下，使用当前事务”，怎么算有当前事务呢？  </p><p>把事务资源存起来嘛，只要已经存在那就是有当前事务，直接获取已存储的事务资源就行。文中开头的例子也演示了，如果想让多个方法无感的使用同一个事务，可以用 ThreadLocal 存储起来，简单粗暴。  </p><p>Spring 也是这么做的，不过它实现的更复杂一些，抽象了一层<strong>事务资源同步管理器 - TransactionSynchronizationManager（本文后面会简称 TxSyncMgr）</strong>，在这个同步管理器里使用 ThreadLocal 存储了事务资源（本文为了方便理解，尽可能的不贴非关键源码）。  </p><p>剩下的就是根据不同传播行为，执行不同的策略了，分类之后只有 3 个条件分支：</p><ol><li><p> 当前有事务 - 根据不同传播行为处理不同</p></li><li><p> 当前没事务，但需要开启新事务</p></li><li><p>彻底不用事务 - 这个很少用</p><p> public final TransactionStatus getTransaction(TransactionDefinition definition) {</p><pre><code class="hljs"> //创建事务资源 - 比如 Connection Object transaction = doGetTransaction();  if (isExistingTransaction(transaction)) &#123;     // 处理当前已有事务的场景     return handleExistingTransaction(def, transaction, debugEnabled); &#125;else if (def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||             def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||             def.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED)&#123;          // 开启新事务     return startTransaction(def, transaction, debugEnabled, suspendedResources); &#125;else &#123;     // 彻底不用事务 &#125;  // ...</code></pre><p> }</p></li></ol><p>先介绍一下<strong>分支 2 - 当前没事务，但需要开启新事务</strong>，这个逻辑相对简单一些。只需要新建事务资源，然后绑定到 ThreadLocal 即可：</p><pre><code class="hljs">private TransactionStatus startTransaction(TransactionDefinition definition, Object transaction,            boolean debugEnabled, SuspendedResourcesHolder suspendedResources) &#123;                // 创建事务        DefaultTransactionStatus status = newTransactionStatus(                definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);                // 开启事务（beginTx或者setAutoCommit之类的操作）        // 然后将事务资源绑定到事务资源管理器 TransactionSynchronizationManager        doBegin(transaction, definition);</code></pre><p>现在回到分支 <strong>1 - 当前有事务 - 根据不同传播行为处理不同</strong>，这个就稍微有点麻烦了。因为有子方法独立事务的需求，可是 TransactionSynchronizationManager 却只能存一个事务资源。</p><h3 id="挂起（Suspend）和恢复（Resume）"><a href="#挂起（Suspend）和恢复（Resume）" class="headerlink" title="挂起（Suspend）和恢复（Resume）"></a>挂起（Suspend）和恢复（Resume）</h3><p>Spring 采用了一种<strong>挂起（Suspend） - 恢复（Resume）</strong>的设计来解决这个嵌套资源处理的问题。当子方法需要独立事务时，就将当前事务挂起，从 TxSyncMgr 中移除当前事务资源，创建新事务的状态时，将挂起的事务资源保存至新的事务状态 TransactionStatus 中；在子方法结束时，只需要再从子方法的事务状态中，再次拿出挂起的事务资源，重新绑定至 TxSyncMgr 即可完成恢复的操作。  </p><p>整个挂起 - 恢复的流程，如下图所示：  </p><p><img src="img_3.png"><br><strong>注意：挂起操作是在获取事务资源这一步做的，而恢复的操作是在子方法结束时（提交或者回滚）中进行的。</strong>  </p><p>这样一来，每个 TransactionStatus 都会保存挂起的前置事务资源，如果方法调用链很长，每次都是新事务的话，那这个 TransactionStatus 看起来就会像一个链表：  </p><p><img src="img.png"></p><h3 id="提交事务"><a href="#提交事务" class="headerlink" title="提交事务"></a>提交事务</h3><p>获取资源、操作完毕后来到了提交事务这一步，这个提交操作比较简单，只有两步：</p><ol><li> 当前是新事务才提交</li><li> 处理挂起资源</li></ol><p>怎么知道是新事务？  </p><p>每经过一次事务嵌套，都会创建一个新的 TransactionStatus，这个事务状态里会记录当前是否是新事务。如果多个子方法都使用一个事务资源，那么除了第一个创建事务资源的 TransactionStatus 之外，其他都不是新事务。  </p><p>如下图所示，A -&gt; B -&gt; C 时，由于 BC 都使用当前事务，那么虽然 ABC 所使用的事务资源是一样的，但是只有 A 的 TransactionStatus 是新事务，BC 并不是；那么在 BC 提交事务时，就不会真正的调用提交，只有回到 A 执行 commit 操作时，才会真正的调用提交操作。<br><img src="img_1.png"><br>这里再解释下，为什么新事务才需要提交，而已经有事务却什么都不用做：</p><p>因为对于新事务来说，这里的提交操作已经是事务完成了；而对于非新事务的场景，前置事务（即当前事务）还没有执行完，可能后面还有其他数据库操作，所以这个提交的操作得让当前事务创建方去做，这里并不能提交。</p><h3 id="回滚事务"><a href="#回滚事务" class="headerlink" title="回滚事务"></a>回滚事务</h3><p>除了提交，还有回滚呢，回滚事务的逻辑和提交事务类似：</p><ol><li> 如果是新事务才回滚，原因上面已经介绍过了</li><li> 如果不是新事务则只设置回滚标记</li><li> 处理挂起资源</li></ol><p><strong>注意：事务管理器是不包含回滚策略这个东西的，回滚策略是 AOP 版的事务管理增强的功能，但这个功能并不属于核心的事务管理器</strong></p><h2 id="自动挡与手动挡"><a href="#自动挡与手动挡" class="headerlink" title="自动挡与手动挡"></a>自动挡与手动挡</h2><p>Spring 的事务管理功能都是围绕着上面这个事务管理器运行的，提供了三种管理事务的方式，分别是：</p><ol><li> XML AOP 的事务管理 - 比较古老现在用的不多</li><li> 注解版本的事务管理 - @Transactional</li><li> TransactionTemplate - 手动挡的事务管理，也称编程式事务管理</li></ol><h3 id="自动挡"><a href="#自动挡" class="headerlink" title="自动挡"></a>自动挡</h3><p>XML/@Transactional 两种基于 AOP 的注解管理，其入口类是 TransactionInterceptor，是一个 AOP 的 Interceptor，负责调用事务管理器来实现事务管理。  </p><p>因为核心功能都在事务管理器里实现，所以这个 AOP Interceptor 很简单，只是调用一下事务管理器，核心（伪）代码如下：</p><pre><code class="hljs">public Object invoke(MethodInvocation invocation) throws Throwable &#123;        // 获取事务资源    Object transaction = transactionManager.getTransaction(txAttr);        Object retVal;        try &#123;        // 执行业务代码        retVal = invocation.proceedWithInvocation();                // 提交事务        transactionManager.commit(txStatus);    &#125; catch (Throwable ex)&#123;        // 先判断异常回滚策略，然后调用事务管理器的 rollback        rollbackOn(ex, txStatus);    &#125; &#125;</code></pre><p>并且 AOP 这种自动挡的事务管理还增加了一个回滚策略的玩法，这个是手动挡 TransactionTemplate 所没有的，但这个功能并不在事务管理器中，只是 AOP 版事务的一个增强。</p><h3 id="手动挡"><a href="#手动挡" class="headerlink" title="手动挡"></a>手动挡</h3><p>TransactionTemplate 这个是手动挡的事务管理，虽然没有注解的方便，但是好在灵活，异常/回滚啥的都可以自己控制。  </p><p>所以这个实现更简单，连异常回滚策略都没有，特殊的回滚方式还要自己设置（默认是任何异常都会回滚），核心（伪）代码如下：</p><pre><code class="hljs">public &lt;T&gt; T execute(TransactionCallback&lt;T&gt; action) throws TransactionException &#123;        // 获取事务资源    TransactionStatus status = this.transactionManager.getTransaction(this);    T result;    try &#123;                // 执行 callback 业务代码        result = action.doInTransaction(status);    &#125;    catch (Throwable ex) &#123;                // 调用事务管理器的 rollback        rollbackOnException(status, ex);    &#125;        提交事务    this.transactionManager.commit(status);    &#125;&#125;</code></pre><h3 id="为什么有这么方便的自动挡，还要手动挡？"><a href="#为什么有这么方便的自动挡，还要手动挡？" class="headerlink" title="为什么有这么方便的自动挡，还要手动挡？"></a>为什么有这么方便的自动挡，还要手动挡？</h3><p>因为手动挡更灵活啊，想怎么玩就怎么玩，比如我可以在一个方法中，执行多个数据库操作，但使用不同的事务资源：</p><pre><code class="hljs">Integer rows = new TransactionTemplate((PlatformTransactionManager) transactionManager,                                       new DefaultTransactionDefinition(TransactionDefinition.ISOLATION_READ_UNCOMMITTED))    .execute(new TransactionCallback&lt;Integer&gt;() &#123;        @Override        public Integer doInTransaction(TransactionStatus status) &#123;            // update 0            int rows0 = jdbcTemplate.update(...);                        // update 1            int rows1 = jdbcTemplate.update(...);            return rows0 + rows1;        &#125;    &#125;);Integer rows2 = new TransactionTemplate((PlatformTransactionManager) transactionManager,                                        new DefaultTransactionDefinition(TransactionDefinition.ISOLATION_READ_UNCOMMITTED))    .execute(new TransactionCallback&lt;Integer&gt;() &#123;        @Override        public Integer doInTransaction(TransactionStatus status) &#123;                        // update 2            int rows2 = jdbcTemplate.update(...);            return rows2;        &#125;    &#125;);</code></pre><p>在上面这个例子里，通过 TransactionTemplate 我们可以精确的控制 update0/update1 使用同一个事务资源和隔离级别，而 update2 单独使用一个事务资源，并且不需要新建类加注解的方式。</p><h3 id="手自一体可以吗？"><a href="#手自一体可以吗？" class="headerlink" title="手自一体可以吗？"></a>手自一体可以吗？</h3><p>当然可以，只要我们使用的是同一个事务管理器的实例，因为绑定资源到同步资源管理器这个操作是在事务管理器中进行的。  </p><p>AOP 版本的事务管理里，同样可以使用手动挡的事务管理继续操作，而且还可以使用同一个事务资源 。  </p><p>比如下面这段代码，update1/update2 仍然在一个事务内，并且 update2 的 callback 结束后并不会提交事务，事务最终会在 methodA 结束时，TransactionInterceptor 中才会提交</p><pre><code class="hljs">@Transactionalpublic void methodA()&#123;        // update 1    jdbcTemplate.update(...);    new TransactionTemplate((PlatformTransactionManager) transactionManager,                                        new DefaultTransactionDefinition(TransactionDefinition.ISOLATION_READ_UNCOMMITTED))    .execute(new TransactionCallback&lt;Integer&gt;() &#123;        @Override        public Integer doInTransaction(TransactionStatus status) &#123;                        // update 2            int rows2 = jdbcTemplate.update(...);            return rows2;        &#125;    &#125;);   &#125;</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Spring 的事务管理，其核心是一个抽象的事务管理器，XML/@Transactional/TransactionTemplate 几种方式都是基于这个事务管理器的，三中方式的核心实现区别并不大，只是入口不同而已。<br><img src="img_2.png"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://segmentfault.com/a/1190000040130617">咱们从头到尾说一次 Spring 事务管理（器）</a></li><li><a href="https://www.cnblogs.com/520playboy/p/5532768.html">Spring AOP propagation七种属性值</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>springboot-starter中的SPI 机制</title>
    <link href="/2022/11/22/spring/springboot-starter%E4%B8%AD%E7%9A%84SPI%20%E6%9C%BA%E5%88%B6/"/>
    <url>/2022/11/22/spring/springboot-starter%E4%B8%AD%E7%9A%84SPI%20%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>SPI的全称是Service Provider Interface, 直译过来就是”服务提供接口”, 听起来挺别扭的, 所以我试着去就将它翻译为”服务提供商接口”吧.  </p><p>我们都知道, 一个接口是可以有很多种实现的. 例如搜索,可以是搜索系统的硬盘,也可以是搜索数据库.系统的设计者为了降低耦合,并不想在硬编码里面写死具体的搜索方式,而是希望由服务提供者来选择使用哪种搜索方式, 这个时候就可以选择使用SPI机制.</p><p>SPI机制被大量应用在各种开源框架中,例如:</p><ol><li> 大家都熟悉的dubbo中的ExtensionLoader,可以通过这些拓展点增加一些自定义的插件功能,比如增加filter实现白名单访问, 实现接口限流等功能;或者还可以直接替换它原生的protocol, transport等</li><li> 在进行idea intellij的插件开发的时候,需要定义一个/META-INF/plugin.xml文件, 这个plugin.xml中有很多地方可以配置serviceInterface和 serviceImplementation,这也是一种SPI机制,通过这种机制, idea能使得插件开发者既能使用到它底层SDK提供的api,又能让开发者具备定制化的功能,耦合相当的低.intellij的插件开发的时候直接用了JDK中的ServiceLoader</li><li> spring中也是大量用到了SPI机制,本文要分析的就是其中的一部分.</li></ol><h1 id="JDK中的SPI"><a href="#JDK中的SPI" class="headerlink" title="JDK中的SPI"></a>JDK中的SPI</h1><p>SPI估计大家都有所了解,让我们通过一个非常简单的例子,来温习一下java里面的SPI机制吧.  </p><ol><li>定义一个搜索接口Search<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.north.spilat.service;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Search</span> &#123;<br>    List&lt;String&gt; <span class="hljs-title function_">search</span><span class="hljs-params">(String keyword)</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li> 实现接口从数据库查询</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.north.spilat.service.impl;<br><span class="hljs-keyword">import</span> com.north.spilat.service.Search;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lhh</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseSearch</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Search</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">search</span><span class="hljs-params">(String keyword)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;now use database search. keyword:&quot;</span> + keyword);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="3"><li> 实现接口从文件系统查询</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.north.spilat.service.impl;<br><span class="hljs-keyword">import</span> com.north.spilat.service.Search;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lhh</span><br><span class="hljs-comment">   */</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSearch</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Search</span> &#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">search</span><span class="hljs-params">(String keyword)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;now use file system search. keyword:&quot;</span> + keyword);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>在src\main\resources创建一个目录 META-INF\services\com.north.spilat.service.Search,然后在com.north.spilat.service.Search下面创建两个文件,以上面接口的具体实现类的全限定名称为文件名,即:<br> com.north.spilat.service.impl.DatabaseSearch<br> com.north.spilat.service.impl.FileSearch  </li></ol><p>整个工程目录如下:  </p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/7/15/16bf5d743f810034~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="image"></p><ol start="6"><li>新建一个main方法测试一下<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.north.spilat.main;<br><span class="hljs-keyword">import</span> com.north.spilat.service.Search;<br><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.ServiceLoader;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);<br>        ServiceLoader&lt;Search&gt; s = ServiceLoader.load(Search.class);<br>        Iterator&lt;Search&gt; searchList = s.iterator();<br>        <span class="hljs-keyword">while</span> (searchList.hasNext()) &#123;<br>            <span class="hljs-type">Search</span> <span class="hljs-variable">curSearch</span> <span class="hljs-operator">=</span> searchList.next();<br>            curSearch.search(<span class="hljs-string">&quot;test&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><p>运行一下,输出如下:  </p><pre><code class="hljs">Hello World!now use database search. keyword:testnow use file system search. keyword:test</code></pre><p>如你所见, SPI机制已经定义好了加载服务的流程框架, 你只需要按照约定, 在META-INF/services目录下面, 以接口的全限定名称为名创建一个文件夹(com.north.spilat.service.Search), 文件夹下再放具体的实现类的全限定名称(com.north.spilat.service.impl.DatabaseSearch), 系统就能根据这些文件,加载不同的实现类.这就是SPI的大体流程.</p><h1 id="ServiceLoader类分析"><a href="#ServiceLoader类分析" class="headerlink" title="ServiceLoader类分析"></a>ServiceLoader类分析</h1><p>回到上面的main方法,其实没有什么特别的,除了一句<br><strong>ServiceLoader.load(Search.class);</strong>  </p><p>ServiceLoader.class是一个工具类,根据META-INF/services/xxxInterfaceName下面的文件名,加载具体的实现类.  </p><p>从load(Search.class)进去,我们来扒一下这个类,下面主要是贴代码,分析都在代码注释内.</p><ol><li> 可以看到,里面并没有很多逻辑,主要逻辑都交给了LazyIterator这类</li></ol><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*入口, 获取一下当前类的类加载器,然后调用下一个静态方法</span><br><span class="hljs-comment">*/</span><br>public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) &#123;<br>    ClassLoader cl = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Thread</span>.</span></span>current<span class="hljs-constructor">Thread()</span>.get<span class="hljs-constructor">ContextClassLoader()</span>;<br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ServiceLoader</span>.</span></span>load(service, cl);<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">*这个也没有什么逻辑,直接调用构造方法</span><br><span class="hljs-comment">*/</span><br>public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service, ClassLoader loader)<br>&#123;<br>    return <span class="hljs-keyword">new</span> ServiceLoader&lt;&gt;(service, loader);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 也没有什么逻辑,直接调用reload</span><br><span class="hljs-comment">*/</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-constructor">ServiceLoader(Class&lt;S&gt; <span class="hljs-params">svc</span>, ClassLoader <span class="hljs-params">cl</span>)</span> &#123;<br>    service = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Objects</span>.</span></span>require<span class="hljs-constructor">NonNull(<span class="hljs-params">svc</span>, <span class="hljs-string">&quot;Service interface cannot be null&quot;</span>)</span>;<br>    loader = (cl<span class="hljs-operator"> == </span>null) ? <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ClassLoader</span>.</span></span>get<span class="hljs-constructor">SystemClassLoader()</span> : cl;<br>    acc = (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>get<span class="hljs-constructor">SecurityManager()</span> != null) ? <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AccessController</span>.</span></span>get<span class="hljs-constructor">Context()</span> : null;<br>    reload<span class="hljs-literal">()</span>;<br>   &#125;<br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">* 直接实例化一个懒加载的迭代器</span><br><span class="hljs-comment">*/</span><br>   public void reload<span class="hljs-literal">()</span> &#123;<br>    providers.clear<span class="hljs-literal">()</span>;<br>    lookupIterator = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LazyIterator(<span class="hljs-params">service</span>, <span class="hljs-params">loader</span>)</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><ol start="2"><li> LazyIterator这个迭代器只需要关心hasNext()和next(), hasNext()里面又只是单纯地调用hasNextService(). 不用说, next()里面肯定也只是单纯地调用了nextService();</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">hasNextService</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">if</span> (nextName != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// nextName不为空,说明加载过了,而且服务不为空 </span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// configs就是所有名字为PREFIX + service.getName()的资源</span><br>    <span class="hljs-keyword">if</span> (configs == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// PREFIX是 /META-INF/services</span><br>            <span class="hljs-comment">// service.getName() 是接口的全限定名称</span><br>            <span class="hljs-title class_">String</span> fullName = <span class="hljs-variable constant_">PREFIX</span> + service.<span class="hljs-title function_">getName</span>();<br>            <span class="hljs-comment">// loader == null, 说明是bootstrap类加载器</span><br>            <span class="hljs-keyword">if</span> (loader == <span class="hljs-literal">null</span>)<br>                configs = <span class="hljs-title class_">ClassLoader</span>.<span class="hljs-title function_">getSystemResources</span>(fullName);<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 通过名字加载所有文件资源</span><br>                configs = loader.<span class="hljs-title function_">getResources</span>(fullName);<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">IOException</span> x) &#123;<br>                <span class="hljs-title function_">fail</span>(service, <span class="hljs-string">&quot;Error locating configuration files&quot;</span>, x);<br>            &#125;<br>    &#125;<br>    <span class="hljs-comment">//遍历所有的资源,pending用于存放加载到的实现类</span><br>    <span class="hljs-keyword">while</span> ((pending == <span class="hljs-literal">null</span>) || !pending.<span class="hljs-title function_">hasNext</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (!configs.<span class="hljs-title function_">hasMoreElements</span>()) &#123;<br>                <span class="hljs-comment">//遍历完所有的文件了,直接返回</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            <br>            <span class="hljs-comment">// parse方法主要调用了parseLine,功能:</span><br>            <span class="hljs-comment">// 1. 分析每个PREFIX + service.getName() 目录下面的所有文件</span><br>            <span class="hljs-comment">// 2. 判断每个文件是否是合法的java类的全限定名称,如果是就add到pending变量中</span><br>            pending = <span class="hljs-title function_">parse</span>(service, configs.<span class="hljs-title function_">nextElement</span>());<br>    &#125;<br>    <span class="hljs-comment">// 除了第一次进来,后面每次调用都是直接到这一步了</span><br>    nextName = pending.<span class="hljs-title function_">next</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>再来看看nextService干了啥<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs haxe"> <span class="hljs-keyword">private</span> S nextService() &#123;<br>    <span class="hljs-comment">// 校验一下</span><br>    <span class="hljs-keyword">if</span> (!hasNextService())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">NoSuchElementException</span>();<br>    <span class="hljs-keyword">String</span> cn = nextName;<br>    nextName = <span class="hljs-literal">null</span>;<br>    Class&lt;?&gt; c = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 尝试一下是否能加载该类</span><br>        c = Class.forName(cn, <span class="hljs-literal">false</span>, loader);<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException x) &#123;<br>        fail(service,<span class="hljs-string">&quot;Provider &quot;</span> + cn + <span class="hljs-string">&quot; not found&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 是不是service的子类,或者同一个类</span><br>    <span class="hljs-keyword">if</span> (!service.isAssignableFrom(c)) &#123;<br>        fail(service,<span class="hljs-string">&quot;Provider &quot;</span> + cn  + <span class="hljs-string">&quot; not a subtype&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 实例化这个类, 然后向上转一下</span><br>        S p = service.<span class="hljs-keyword">cast</span>(c.<span class="hljs-keyword">new</span><span class="hljs-type">Instance</span>());<br>        <span class="hljs-comment">// 缓存起来,避免重复加载</span><br>        providers.put(cn, p);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>        fail(service,<span class="hljs-string">&quot;Provider &quot;</span> + cn + <span class="hljs-string">&quot; could not be instantiated&quot;</span>,x);<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">Error</span>();          <span class="hljs-comment">// This cannot happen</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li></ol><p>从上面的代码就可以看出来, 所谓的懒加载,就是等到调用hasNext()再查找服务, 调用next()才实例化服务类.</p><p>JDK的SPI大概就是这么一个逻辑了, 服务提供商按照约定,将具体的实现类名称放到/META-INF/services/xxx下, ServiceLoader就可以根据服务提供者的意愿, 加载不同的实现了, 避免硬编码写死逻辑, 从而达到解耦的目的.</p><p>当然, 从上面这个简单的例子可能大家会看不出来,SPI是如何达到解耦的效果的. 所以下面, 我们一起来看看,开源框架中是怎么利用SPI机制来解耦的. 体会一下SPI的魅力.</p><h1 id="springboot-中的SPI"><a href="#springboot-中的SPI" class="headerlink" title="springboot 中的SPI"></a>springboot 中的SPI</h1><p>作为一个程序员,没事可以多点研究开源框架,因为这些开源代码每天都不知道被人撸几遍,所以他们的代码从设计到实现,都是非常优秀的,我们可以从中学到不少东西.</p><p>而spring框架这些年来,基本上可以说是开源界扛把子,江湖上无人不知无人不晓.其源码的设计也是出了名的优雅,超高拓展性超低耦合性.</p><p>那它是怎么解耦的呢? 拓展点机制便是其中法宝之一</p><h2 id="从神奇的starter说起"><a href="#从神奇的starter说起" class="headerlink" title="从神奇的starter说起"></a>从神奇的starter说起</h2><p>刚刚接触springboot的时候, 真的觉得各种spring-xx-starter和xx-spring-starter非常的神奇. 为什么在pom文件添加一个依赖就能引入一个复杂的插件了呢? 带着这个疑问,我开始了我的走进科学之旅.</p><p>dubbo框架在国内用的公司挺多的,所以这里, 我们就以dubbo-spring-boot-starter为例,来看看springboot中是如何高效解耦的.</p><p>回想一下, 如果我们要在springboot工程里面引入dubbo模块, 需要怎么做.</p><ol><li><p>在pom文件引入dubbo-spring-boot-starter的依赖.</p><pre><code class="hljs">     &lt;dependency&gt;         &lt;groupId&gt;com.alibaba.spring.boot&lt;/groupId&gt;         &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;         &lt;version&gt;2.0.0&lt;/version&gt;     &lt;/dependency&gt;</code></pre></li><li><p> 在application.properties文件配置好dubbo相关参数</p></li></ol><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/7/15/16bf5d743f26aaf4~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="image"></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">spring.dubbo.server</span>=<span class="hljs-literal">true</span><br><span class="hljs-attr">spring.dubbo.application.name</span>=north-spilat-server<br><span class="hljs-attr">spring.dubbo.registry.id</span>=defaultRegistry<br><span class="hljs-attr">spring.dubbo.registry.address</span>=<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-attr">spring.dubbo.registry.port</span>=<span class="hljs-number">2181</span><br><span class="hljs-attr">spring.dubbo.registry.protocol</span>=zookeeper<br><span class="hljs-attr">spring.dubbo.protocol.name</span>=dubbo<br><span class="hljs-attr">spring.dubbo.protocol.port</span>=<span class="hljs-number">20881</span><br><span class="hljs-attr">spring.dubbo.module.name</span>=north-spilat-server<br><span class="hljs-attr">spring.dubbo.consumer.check</span>=<span class="hljs-literal">false</span><br><span class="hljs-attr">spring.dubbo.provider.timeout</span>=<span class="hljs-number">3000</span><br><span class="hljs-attr">spring.dubbo.consumer.retries</span>=<span class="hljs-number">0</span><br><span class="hljs-attr">spring.dubbo.consumer.timeout</span>=<span class="hljs-number">3000</span><br></code></pre></td></tr></table></figure><ol start="3"><li>在spring-boot的启动类加上对应的注解<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.north.spilat.main;<br><br><span class="hljs-keyword">import</span> com.alibaba.dubbo.spring.boot.<span class="hljs-keyword">annotation</span>.EnableDubboConfiguration;<br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.ComponentScan;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> lhh</span><br><span class="hljs-comment"> */</span><br>  <span class="hljs-meta">@SpringBootApplication</span><br>  <span class="hljs-meta">@ComponentScan(basePackages = &#123;<span class="hljs-string">&quot;com.north.*&quot;</span>&#125;)</span><br>  <span class="hljs-meta">@EnableDubboConfiguration</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringBootMain</span> </span>&#123;<br><br>    <span class="hljs-keyword">public</span> static void main(String[] args) &#123;<br>        SpringApplication.run(SpringBootMain.<span class="hljs-keyword">class</span>, args);<br>    &#125;<br>  &#125; <br><br></code></pre></td></tr></table></figure></li><li> 定义接口, 实现并调用</li></ol><p>接口</p><pre><code class="hljs">package com.north.spilat.service;/** * @author lhh */public interface DubboDemoService &#123;    String test(String params);&#125;</code></pre><p>实现接口</p><pre><code class="hljs">package com.north.spilat.service.impl;import com.alibaba.dubbo.config.annotation.Service;import com.north.spilat.service.DubboDemoService;import org.springframework.stereotype.Repository;/** * @author lhh */@Service@Repository(&quot;dubboDemoService&quot;) public class DubboDemoServiceImpl implements DubboDemoService &#123;    @Override    public String test(String params) &#123;        return System.currentTimeMillis() + &quot;-&quot; + params ;    &#125;&#125;</code></pre><p>写个controller调用dubbo接口</p><pre><code class="hljs">package com.north.spilat.controller;import com.north.spilat.service.DubboDemoService;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * @author lhh */@RestControllerpublic class HelloWorldController &#123;    @Resource    private DubboDemoService dubboDemoService;    @RequestMapping(&quot;/saveTheWorld&quot;)    public String index(String name) &#123;        return   dubboDemoService.test(name);    &#125;&#125;</code></pre><p>做完以上4步(zookeeper等环境自己装一下)后, 启动SpringBootMain类, 一个带有dubbo模块的springboot工程就这样搭好了, 真的就这么简单.</p><p>然而, 世界上哪有什么岁月静好,只不过是有人替你负重前行而已, 这个替你负重的人就是”dubbo-spring-boot-starter”</p><h2 id="dubbo-spring-boot-starter的奥秘"><a href="#dubbo-spring-boot-starter的奥秘" class="headerlink" title="dubbo-spring-boot-starter的奥秘"></a>dubbo-spring-boot-starter的奥秘</h2><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/7/15/16bf5d743fb11195~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="image"></p><p>上图是dubbo-spring-boot-starter.jar包的结构. 内容还真不少, 但是聪明的你肯定想到了, 既然我们上一节说到了SPI是跟META-INF息息相关的,那我们这一节也必然是这样.<br>因此, 这里我们先看一下META-INF目录下面有什么.</p><p>dubbo/com.alibaba.dubbo.rpc.InvokerListener</p><pre><code class="hljs">dubbosubscribe=com.alibaba.dubbo.spring.boot.listener.ConsumerSubscribeListener</code></pre><p>这个目录下的文件只有一行,看着和上面的jdk的SPI真的是像.没错, 这的确是一种拓展点, 是dubbo里面的一种拓展点约定, 就是我们开篇说的ExtensionLoader啦</p><ol start="2"><li>spring.factories<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span>.EnableAutoConfiguration=\<br>com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.DubboAutoConfiguration</span>,\<br>com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.DubboProviderAutoConfiguration</span>,\<br>com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.DubboConsumerAutoConfiguration</span><br><br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.context</span>.ApplicationListener=\<br>com<span class="hljs-selector-class">.alibaba</span><span class="hljs-selector-class">.dubbo</span><span class="hljs-selector-class">.spring</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.event</span><span class="hljs-selector-class">.DubboBannerApplicationListener</span><br><br></code></pre></td></tr></table></figure></li></ol><p>哇哇哇,文件就是以spring命名,文件内容还涉及到这么多spring类. 确认过眼神, 我遇上对的…文件. 但是别急, 下面还有一个spring.providers文件</p><ol start="3"><li><p>spring.providers</p><p> <code>provides: dubbo-spring-boot-starter</code></p></li></ol><p>spring.providers就这么简单的一句, 有点失望了.所以我们还是来关注一下spring.factories吧.</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/7/15/16bf5d7446bc1ae6~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="imager"></p><p>在IDEA里面搜一下spring.factories这个文件. 不搜不知道, 一搜吓一跳. 原来基本上每一个springboot相关的jar包里面都会有一个这样的文件.</p><p>物理学家在做实验之前, 总是喜欢推理一番, 得到一个预测的结论, 然后再通过实验结果来证实或推翻预测的结论.</p><p>因此, 基于JDK里面的SPI机制, 在这里我们也可以做一个大胆的预测:spring框架里面一定是有一个类似于ServiceLoader的类, 专门从META-INF/spring.factories里面的配置,加载特定接口的实现.</p><p>结果不用说, 这个预测肯定是准确, 不然我上面这么多字不就白写啦. 但是怎么证明我们的预测是准确的呢. 让我们也来做一次”实验”.</p><h2 id="springboot的启动过程"><a href="#springboot的启动过程" class="headerlink" title="springboot的启动过程"></a>springboot的启动过程</h2><p>要弄清楚springboot的启动过程, 最好的办法就研读它的源码了.</p><p>而springboot的代码还是非常”人性化”的,springboot明明确确地告诉你了, 它的入口就是main方法.因此, 读springboot的代码, 还算是比较惬意的,从main方法一路看下去就可以了.</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/7/15/16bf5d7446ce6cb6~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="image"></p><p>上图就是一个springboot工程的启动过程.首先是连续两个重载的静态run方法, 静态run方法内部会调用构造方法实例化SpringApplication对象, 构造方法内部是调用initialiaze()进行初始化的,实例化,再调用一个成员方法run()来正式启动.</p><p>可见,整个启动过程主要的逻辑都在initialiaze方法和成员run方法内部了.</p><p>看一下initialiaze()的逻辑, 下面也是老规矩,主要贴代码,分析都在代码注释中</p><pre><code class="hljs">   @SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)   private void initialize(Object[] sources) &#123;       // sources一般是Configuration类或main方法所在类       // 可以有多个       if (sources != null &amp;&amp; sources.length &gt; 0) &#123;           this.sources.addAll(Arrays.asList(sources));       &#125;       // 判断是否是web环境       // classLoader能加载到       // &quot;javax.servlet.Servlet&quot;,       //    &quot;org.springframework.web.context.ConfigurableWebApplicationContext&quot;       // 这两个类就是web环境           this.webEnvironment = deduceWebEnvironment();       // 加载initializers 和listeners       // getSpringFactoriesInstances顾名思义,       // 就是加载某个接口的工厂实例,       // 看起来像是我们要找的&quot;ServiceLoader&quot;了       setInitializers((Collection) getSpringFactoriesInstances(               ApplicationContextInitializer.class));       setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));       // 找到main方法所在的类       this.mainApplicationClass = deduceMainApplicationClass();   &#125;</code></pre><p>运气还算不错,”嫌疑犯”getSpringFactoriesInstances就露出水面了, 来看看它的逻辑</p><pre><code class="hljs">    /**    * 参数type就是要加载的接口的class    */    private &lt;T&gt; Collection&lt;? extends T&gt;    getSpringFactoriesInstances(Class&lt;T&gt; type) &#123;        // 直接调用重载方法getSpringFactoriesInstances        return getSpringFactoriesInstances(type, new Class&lt;?&gt;[] &#123;&#125;);    &#125;    private &lt;T&gt; Collection&lt;? extends T&gt;            getSpringFactoriesInstances(Class&lt;T&gt; type,            Class&lt;?&gt;[] parameterTypes,             Object... args) &#123;        // 获取当前线程的classLoader            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();        // Use names and ensure unique to protect against duplicates        // 翻译一下原文注释就是用names来去重        // 注意这里, 我们寻找的&quot;ServiceLoader&quot;终于出现了        // 就是SpringFactoriesLoader        Set&lt;String&gt; names = new LinkedHashSet&lt;String&gt;(                SpringFactoriesLoader.loadFactoryNames(type, classLoader));        // 是用java反射来实例化                List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes,                classLoader, args, names);        // 根据@Order注解来排一下序                AnnotationAwareOrderComparator.sort(instances);        // 返回这个接口的所有实现实例        return instances;    &#125;</code></pre><p>然后很快就找到了我们想找的SpringFactoriesLoader, 而且这个类非常小, 代码比JDK的ServiceLoader还少. 那我们仔细看一下他里面都有啥.</p><ol><li> FACTORIES_RESOURCE_LOCATION 正是指向我们上面所说的META-INF/spring.factories</li><li> loadFactories, 从META-INF/spring.factories查找指定的接口实现类并实例化, 其中查找是通过调用loadFactoryNames</li><li> loadFactoryNames从指定的位置查找特定接口的实现类的全限定名称</li><li> instantiateFactory 实例化</li></ol><p>这个类就是springboot里面的”ServiceLoader”,它提供了一种机制,可以让服务提供商指定某种接口的实现(可以是多个),例如上面的ApplicationContextInitializer.class和ApplicationListener.class接口, 如果我们想在我们的模块里面指定我们的实现,或者想在现有的代码上加上我们的某个实现,就可以在/META-INF/spring.factories里面指定. 等一下下面我会写一个具体的例子, 可以让大家更好的理解一下.</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 省略import</span><br><span class="hljs-comment">**/</span><br><span class="hljs-keyword">public</span> abstract <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringFactoriesLoader</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Log</span> logger <span class="hljs-operator">=</span> <span class="hljs-type">LogFactory</span>.getLog(<span class="hljs-type">SpringFactoriesLoader</span>.class);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The location to look for factories.</span><br><span class="hljs-comment"> *  查找工厂实现类的位置</span><br><span class="hljs-comment"> * &lt;p&gt;Can be present in multiple JAR files.</span><br><span class="hljs-comment"> *   可以在多个jar包中</span><br><span class="hljs-comment"> * 这不就是我们一直在寻找的META-INF/spring.factories嘛</span><br><span class="hljs-comment"> * 终于找到了</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-type">FACTORIES_RESOURCE_LOCATION</span> <span class="hljs-operator">=</span><br><span class="hljs-string">&quot;META-INF/spring.factories&quot;</span>;<br><br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 查找并实例化指定的工厂类实现</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-operator">&lt;</span><span class="hljs-type">T</span><span class="hljs-operator">&gt;</span> <span class="hljs-type">List</span>&lt;<span class="hljs-type">T</span>&gt; loadFactories(<span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt;<br>factoryClass, <span class="hljs-type">ClassLoader</span> classLoader) &#123;<br><span class="hljs-type">Assert</span>.notNull(factoryClass, <span class="hljs-string">&quot;&#x27;factoryClass&#x27; </span><br><span class="hljs-string">must not be null&quot;</span>);<br><span class="hljs-type">ClassLoader</span> classLoaderToUse <span class="hljs-operator">=</span> classLoader;<br><span class="hljs-keyword">if</span> (classLoaderToUse <span class="hljs-operator">==</span> null) &#123;<br>classLoaderToUse <span class="hljs-operator">=</span><br><span class="hljs-type">SpringFactoriesLoader</span>.class.getClassLoader();<br>&#125;<br><span class="hljs-comment">// 最终是调用loadFactoryNames</span><br><span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt; factoryNames <span class="hljs-operator">=</span> loadFactoryNames(factoryClass, classLoaderToUse);<br><span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>logger.trace(<span class="hljs-string">&quot;Loaded [&quot;</span> <span class="hljs-operator">+</span> factoryClass.getName() <span class="hljs-operator">+</span> <span class="hljs-string">&quot;] names: &quot;</span> <span class="hljs-operator">+</span> factoryNames);<br>&#125;<br><span class="hljs-type">List</span>&lt;<span class="hljs-type">T</span>&gt; result <span class="hljs-operator">=</span> new <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">T</span>&gt;(factoryNames.size());<br><span class="hljs-keyword">for</span> (<span class="hljs-type">String</span> factoryName : factoryNames) &#123;<br>    <span class="hljs-comment">// 一个个的实例化</span><br>result.add(instantiateFactory(factoryName, factoryClass, classLoaderToUse));<br>&#125;<br><span class="hljs-comment">// 排序</span><br><span class="hljs-type">AnnotationAwareOrderComparator</span>.sort(result);<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从META-INF/spring.factories查找指定接口的实现类的</span><br><span class="hljs-comment"> * 全限定类名称</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt; loadFactoryNames(<br><span class="hljs-type">Class</span>&lt;?&gt; factoryClass, <span class="hljs-type">ClassLoader</span> classLoader) &#123;<br>    <span class="hljs-comment">// 接口的类名称</span><br><span class="hljs-type">String</span> factoryClassName <span class="hljs-operator">=</span> factoryClass.getName();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//加载所有的META-INF/spring.factories文件资源</span><br><span class="hljs-type">Enumeration</span>&lt;<span class="hljs-type">URL</span>&gt; urls <span class="hljs-operator">=</span> <br>(classLoader <span class="hljs-operator">!=</span> null <span class="hljs-operator">?</span> classLoader.getResources(<span class="hljs-type">FACTORIES_RESOURCE_LOCATION</span>) :<br><span class="hljs-type">ClassLoader</span>.getSystemResources(<span class="hljs-type">FACTORIES_RESOURCE_LOCATION</span>));<br><span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt; result <span class="hljs-operator">=</span> new <span class="hljs-type">ArrayList</span>&lt;<span class="hljs-type">String</span>&gt;();<br><span class="hljs-keyword">while</span> (urls.hasMoreElements()) &#123;<br>    <span class="hljs-comment">// 一个url代表一个spring.factories文件</span><br><span class="hljs-type">URL</span> url <span class="hljs-operator">=</span> urls.nextElement();<br><span class="hljs-comment">// 加载所有的属性, 一般是 xxx接口=impl1,impl2 这种形式的</span><br><span class="hljs-type">Properties</span> properties <span class="hljs-operator">=</span> <span class="hljs-type">PropertiesLoaderUtils</span>.loadProperties(new <span class="hljs-type">UrlResource</span>(url));<br><span class="hljs-comment">// 根据接口名获取的类似&quot;impl1,impl2&quot;的字符串</span><br><span class="hljs-type">String</span> factoryClassNames <span class="hljs-operator">=</span> properties.getProperty(factoryClassName)<br><span class="hljs-comment">// 以逗号分隔,转化成列表</span><br>result.addAll(<span class="hljs-type">Arrays</span>.asList(<span class="hljs-type">StringUtils</span>.commaDelimitedListToStringArray(factoryClassNames)));<br>&#125;<br><span class="hljs-comment">// 返回实现类名的列表</span><br><span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-keyword">catch</span> (<span class="hljs-type">IOException</span> ex) &#123;<br><span class="hljs-keyword">throw</span> new <span class="hljs-type">IllegalArgumentException</span>(<span class="hljs-string">&quot;Unable to load [&quot;</span> <span class="hljs-operator">+</span> factoryClass.getName() <span class="hljs-operator">+</span><br><span class="hljs-string">&quot;] factories from location [&quot;</span> <span class="hljs-operator">+</span> <span class="hljs-type">FACTORIES_RESOURCE_LOCATION</span> <span class="hljs-operator">+</span> <span class="hljs-string">&quot;]&quot;</span>, ex);<br>&#125;<br>&#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 根据类名的全限定名称实例化</span><br><span class="hljs-comment">    */</span><br><span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>)<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-operator">&lt;</span><span class="hljs-type">T</span><span class="hljs-operator">&gt;</span> <span class="hljs-type">T</span> instantiateFactory(<span class="hljs-type">String</span> instanceClassName, <span class="hljs-type">Class</span>&lt;<span class="hljs-type">T</span>&gt; factoryClass, <span class="hljs-type">ClassLoader</span> classLoader) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 查找类</span><br><span class="hljs-type">Class</span>&lt;?&gt; instanceClass <span class="hljs-operator">=</span> <span class="hljs-type">ClassUtils</span>.forName(instanceClassName, classLoader);<br><span class="hljs-comment">// 校验是不是该接口类或该接口类的实现类</span><br><span class="hljs-keyword">if</span> (<span class="hljs-operator">!</span>factoryClass.isAssignableFrom(instanceClass)) &#123;<br><span class="hljs-keyword">throw</span> new <span class="hljs-type">IllegalArgumentException</span>(<br><span class="hljs-string">&quot;Class [&quot;</span> <span class="hljs-operator">+</span> instanceClassName <span class="hljs-operator">+</span> <span class="hljs-string">&quot;] is not assignable to [&quot;</span> <span class="hljs-operator">+</span> factoryClass.getName() <span class="hljs-operator">+</span> <span class="hljs-string">&quot;]&quot;</span>);<br>&#125;<br><span class="hljs-type">Constructor</span>&lt;?&gt; constructor <span class="hljs-operator">=</span> instanceClass.getDeclaredConstructor();<br><span class="hljs-type">ReflectionUtils</span>.makeAccessible(constructor);<br><span class="hljs-comment">// 反射实例化</span><br><span class="hljs-keyword">return</span> (<span class="hljs-type">T</span>) constructor.newInstance();<br>&#125;<br><span class="hljs-keyword">catch</span> (<span class="hljs-type">Throwable</span> ex) &#123;<br><span class="hljs-keyword">throw</span> new <span class="hljs-type">IllegalArgumentException</span>(<span class="hljs-string">&quot;Unable to instantiate factory class: &quot;</span> <span class="hljs-operator">+</span> factoryClass.getName(), ex);<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>看完SpringFactoriesLoader这个类, initialize()方法的逻辑也就看完了. 接着再看另外一个重要方法run(String… args)</p><pre><code class="hljs">    /**     * Run the Spring application, creating and refreshing a new     * &#123;@link ApplicationContext&#125;.     * @param args the application arguments (usually passed from a Java main method)     * @return a running &#123;@link ApplicationContext&#125;     */    public ConfigurableApplicationContext run(String... args) &#123;        // 用于监测启动时长等等        StopWatch stopWatch = new StopWatch();        stopWatch.start();        // springboot的上下文        ConfigurableApplicationContext context = null;        FailureAnalyzers analyzers = null;        // 配置headless模式        configureHeadlessProperty();        // 启动监听器, 可以配置到spring.factories中去        SpringApplicationRunListeners listeners = getRunListeners(args);        listeners.starting();        try &#123;            // 封装参数            ApplicationArguments applicationArguments = new DefaultApplicationArguments(                    args);            //     配置environment                ConfigurableEnvironment environment = prepareEnvironment(listeners,                    applicationArguments);            // 打印banner                    Banner printedBanner = printBanner(environment);            // 创建上下文            context = createApplicationContext();            analyzers = new FailureAnalyzers(context);            // 先初始化上下文            prepareContext(context, environment, listeners, applicationArguments,                    printedBanner);            // spring 经典的refresh()过程, 大部分的逻辑都在里面            // 这里不再深入, 读者可以自行研读代码或搜索引擎            refreshContext(context);            afterRefresh(context, applicationArguments);            listeners.finished(context, null);            stopWatch.stop();            if (this.logStartupInfo) &#123;                new StartupInfoLogger(this.mainApplicationClass)                        .logStarted(getApplicationLog(), stopWatch);            &#125;            return context;        &#125;        catch (Throwable ex) &#123;            handleRunFailure(context, listeners, analyzers, ex);            throw new IllegalStateException(ex);        &#125;    &#125;</code></pre><p>这个方法就是springboot启动的主要逻辑了,内容很多,如果要全部说清楚的话, 恐怕再写几遍文章也说不完(给人家springboot一点最起码的尊重好不好, 想一篇文章就理解透彻人家整个框架,人家不要面子的呀).所以这里就不会再深入,对于本文,只要知道这个run()方法是启动的主要逻辑就可以了, 另外记住<br>context = createApplicationContext();<br>refreshContext(context);<br>这两行代码,等下我们还会看到它的.</p><h2 id="dubbo-spring-boot-starter的原理"><a href="#dubbo-spring-boot-starter的原理" class="headerlink" title="dubbo-spring-boot-starter的原理"></a>dubbo-spring-boot-starter的原理</h2><p>上面说了很多, 但是为什么springboot引入一个starter的依赖,就能引入一个复杂的模块. 这里通过dubbo-spring-boot-starter来研究一下.</p><p>我们查看一下dubbo-spring-boot-starter里面spring.factories. 可以发现里面配置了两个接口, 一个是EnableAutoConfiguration,一个是ApplicationListener.</p><pre><code class="hljs">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\com.alibaba.dubbo.spring.boot.DubboAutoConfiguration,\com.alibaba.dubbo.spring.boot.DubboProviderAutoConfiguration,\com.alibaba.dubbo.spring.boot.DubboConsumerAutoConfigurationorg.springframework.context.ApplicationListener=\com.alibaba.dubbo.spring.boot.context.event.DubboBannerApplicationListener</code></pre><p>监听器看名称就知道了是用于启动的时候打印banner, 所以这里暂时不看, 我们先来看一下EnableAutoConfiguration是哪里用到的.</p><p>从main方法开始一路debug,终于在AutoConfigurationImportSelector类中发现了一行代码:<br>SpringFactoriesLoader.loadFactoryNames( getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader())  </p><p>其中getSpringFactoriesLoaderFactoryClass()就是写死了返回EnableAutoConfiguration.class</p><pre><code class="hljs"> protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata,         AnnotationAttributes attributes) &#123;     List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(             getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());     Assert.notEmpty(configurations,             &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;                     + &quot;are using a custom packaging, make sure that file is correct.&quot;);     return configurations; &#125; /**  * Return the class used by &#123;@link SpringFactoriesLoader&#125; to load configuration  * candidates.  * @return the factory class  */ protected Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;     return EnableAutoConfiguration.class; &#125;</code></pre><p>如下图可以发现,EnableAutoConfiguration.class的实现会有很多, 只要你在spring.fatories配置了,它都会给你加载进来</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/7/15/16bf5d74464a10c6~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="image"></p><p>加载了之后,又干嘛呢, 往下看,可以发现大概流程是这样:</p><ol><li> this.reader.loadBeanDefinitions(configClasses); configClasses就是所有的实现类,把这些类读进来准备解析</li><li> registerBeanDefinition注册到beanDefinitionNames</li><li> spring的refresh()操作中,最后有一步是finishBeanFactoryInitialization(beanFactory), 这一步时会初始化所有的单例对象, 最后会从beanDefinitionNames读取所有的BeanDefinition,也包括了上面的所有EnableAutoConfiguration实现, 然后进行实例化</li><li>实例化EnableAutoConfiguration的具体实现的时候,会执行这些实现类里面的具体逻辑, 以Dubbo为例,会初始化com.alibaba.dubbo.spring.boot.DubboAutoConfiguration,<br> com.alibaba.dubbo.spring.boot.DubboProviderAutoConfiguration,<br> com.alibaba.dubbo.spring.boot.DubboConsumerAutoConfiguration 这三个实现类, 就把dubbo启动并注册到spring容器中去了.</li></ol><h2 id="实现一个spring-boot-starter"><a href="#实现一个spring-boot-starter" class="headerlink" title="实现一个spring-boot-starter"></a>实现一个spring-boot-starter</h2><p>清楚了原理之后, 要实现一个自己的starter就很简单了.</p><p>假设我有一个组件,非常牛逼,具有拯救世界的能力, 你的系统接入后,也就具有了拯救世界的能力了. 那怎么让你的spring-boot系统可以快速接入这个牛逼的组件呢. 我来实现一个starter, 你依赖我这个starter就可以了</p><p>首先定义一个拯救世界的接口</p><pre><code class="hljs">package com.north.lat.service;/*** @author lhh*/public interface SaveTheWorldService &#123; /**  *  拯救世界  * @param name 留名  * @return  */ String saveTheWorld(String name);&#125;</code></pre><p>抽象类</p><pre><code class="hljs">package com.north.lat.service;import lombok.extern.log4j.Log4j;import java.util.Random;/** * @author lhh */@Log4jpublic abstract  class AbstractSaveTheWorldService implements SaveTheWorldService &#123;    private final static Random RANDOM = new Random();    private final static String SUCCESS_MSG = &quot;WAOOOOOOO! 大英雄&quot;;    private final static String FAIL_MSG = &quot;拯救世界是个高风险行业&quot;;    @Override    public String saveTheWorld(String name) &#123;        int randomInt = RANDOM.nextInt(100);        String msg;        if((randomInt +  1) &gt; getDieRate())&#123;            msg = SUCCESS_MSG +&quot;,&quot; + name + &quot;拯救了这个世界!&quot;;        &#125;else&#123;            msg = FAIL_MSG + &quot;,&quot; + name + &quot;,你失败了,下辈子再来吧&quot;;        &#125;        log.info(msg);        return msg;    &#125;    /**     * 指定死亡率     * @return     */    public abstract int getDieRate();&#125;</code></pre><p>普通人去拯救世界,一般失败率是99%</p><pre><code class="hljs">package com.north.lat.service.impl;import com.north.lat.service.AbstractSaveTheWorldService;/** * 普通人拯救世界 * @author lhh */public class CommonSaveTheWorldServiceImpl extends AbstractSaveTheWorldService &#123;    private final static int DIE_RATE = 99;    @Override    public int getDieRate() &#123;        return DIE_RATE;    &#125;&#125;</code></pre><p>以英雄角色去拯救世界,成功率是99%</p><pre><code class="hljs">package com.north.lat.service.impl;import com.north.lat.service.AbstractSaveTheWorldService;/** * 英雄拯救世界 * @author lhh */public class HeroSaveTheWorldImpl extends AbstractSaveTheWorldService &#123;    private final static int DIE_RATE = 1;    @Override    public int getDieRate() &#123;        return DIE_RATE;    &#125;&#125;</code></pre><p>好, 我们这个超级牛逼的组件就诞生了, 下面为接入springboot准备一下, 实现一个NbAutoConfiguration如下:</p><pre><code class="hljs">package com.north.lat;import com.north.lat.service.SaveTheWorldService;import org.springframework.beans.BeansException;import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;import org.springframework.beans.factory.support.BeanDefinitionRegistry;import org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor;import org.springframework.beans.factory.support.GenericBeanDefinition;import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.context.EnvironmentAware;import org.springframework.context.annotation.Configuration;import org.springframework.core.env.Environment;import org.springframework.core.io.support.SpringFactoriesLoader;import java.util.List;/** * @author lhh * 注入environment和applicationContext 以便做一些后续操作 */@Configuration@ConditionalOnClass(SaveTheWorldService.class)public class NbAutoConfiguration implements EnvironmentAware,ApplicationContextAware,BeanDefinitionRegistryPostProcessor &#123;    private Environment environment;    private ApplicationContext applicationContext;    @Override    public void setEnvironment(Environment environment) &#123;            this.environment = environment;    &#125;    @Override    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123;           this.applicationContext = applicationContext;    &#125;    @Override    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123;        // 我这里是从spring.factories加载了SaveTheWorldService的所有实现,        List&lt;SaveTheWorldService&gt; saveTheWorldServices = SpringFactoriesLoader.loadFactories(SaveTheWorldService.class, this.getClass().getClassLoader());        // 然后用BeanDefinitionRegistry 注册到BeanDefinitions        saveTheWorldServices.forEach(saveTheWorldService-&gt;&#123;            GenericBeanDefinition beanDefinition = new GenericBeanDefinition();            beanDefinition.setBeanClass(saveTheWorldService.getClass());            beanDefinition.setLazyInit(false);            beanDefinition.setAbstract(false);            beanDefinition.setAutowireCandidate(true);            beanDefinition.setScope(&quot;singleton&quot;);            registry.registerBeanDefinition(saveTheWorldService.getClass().getSimpleName(), beanDefinition);        &#125;);    &#125;    @Override    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;    &#125;&#125;</code></pre><p>再配置一下spring.factories<br>在组件开发初期,英雄还没找到,只能派个普通人去,所以niubility-spring-starter-1.0-SNAPSHOT.jar的spring.factories是这样的</p><pre><code class="hljs">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\com.north.lat.NbAutoConfigurationcom.north.lat.service.SaveTheWorldService=\com.north.lat.service.impl.CommonSaveTheWorldServiceImpl</code></pre><p>后来经过开发人员无数个日日夜夜的加班,终于找到了英雄,所以niubility-spring-starter-2.0-SNAPSHOT.jar的spring.factories变成了这样</p><pre><code class="hljs">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\com.north.lat.NbAutoConfigurationcom.north.lat.service.SaveTheWorldService=\com.north.lat.service.impl.HeroSaveTheWorldImpl</code></pre><p>这样就完成了,项目结构如下图所示:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/7/15/16bf5d7465cd62c4~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="image"></p><p>那该怎么接入呢? 我们在刚刚的spilat工程接入一下试试:</p><p>依赖jar包,这个时候是接入1.0版本的;这样就完成接入了</p><pre><code class="hljs">        &lt;dependency&gt;            &lt;groupId&gt;com.north.lat&lt;/groupId&gt;            &lt;artifactId&gt;niubility-spring-starter&lt;/artifactId&gt;            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>所谓的完成接入是指, spring中已经注册了SaveTheWorldService的所有实现, 即CommonSaveTheWorldServiceImpl(1.0版本)或HeroSaveTheWorldImpl(2.0版本).  </p><p>我们在controller中注入调用一下</p><pre><code class="hljs">package com.north.spilat.controller;import com.north.lat.service.SaveTheWorldService;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;/** * @author lhh */@RestControllerpublic class HelloWorldController &#123;    @Resource    private SaveTheWorldService saveTheWorldService;    @RequestMapping(&quot;/saveTheWorld&quot;)    public String index(String name) &#123;        return  saveTheWorldService.saveTheWorld(name);    &#125;&#125;</code></pre><p>使用1.0版本的时候,果然是失败率99%,运行结果如下:</p><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/7/15/16bf5d746cb32727~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="image"></p><p>等2.0版本出来后, 赶紧换上2.0版本, 在pom.xml更新一下版本号:</p><pre><code class="hljs">    &lt;dependency&gt;        &lt;groupId&gt;com.north.lat&lt;/groupId&gt;        &lt;artifactId&gt;niubility-spring-starter&lt;/artifactId&gt;        &lt;version&gt;2.0-SNAPSHOT&lt;/version&gt;    &lt;/dependency&gt;再看看运行结果, 就非常完美啦</code></pre><p><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/7/15/16bf5d74719905ed~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image" alt="image"></p><p>在上面的例子中, 不管是我们接入还是升级组件, 都是简单的依赖jar包就可以了,真正的实现了可拔插,低耦合. 当然, 实际的应用场景中, 可能还需要我们增加少许的配置,例如上面的spring-boot-starter-dubbo, 以及我们经常用的druid-spring-boot-starter,spring-boot-starter-disconf等等</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>解耦,可以说是数代程序员都穷极一生都在追求的东西, 这些年来提出和实现了无数的工具和思想, SPI便是沉淀出来的一种。</p><p>SPI机制在各种开源框架中都是非常常见的,而各种框架的SPI机制又各有不同, 或多或少都有一些演变;但是其实背后的原理都是大同小异.</p><p>因此, 了解一下这些机制, 一方面可以让我们更清楚开源框架的运行原理,少走弯路; 另一方面,也可以作为我们日常写代码和系统设计的一种参考,从而写出更加优雅的代码.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://juejin.cn/post/6844903890173837326">springboot-starter中的SPI 机制</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql select for update</title>
    <link href="/2022/11/18/mysql/mysql%20select%20for%20update/"/>
    <url>/2022/11/18/mysql/mysql%20select%20for%20update/</url>
    
    <content type="html"><![CDATA[<p>　　最近的项目中，因为涉及到Mysql数据中乐观锁和悲观锁的使用，所以结合项目和网上的知识点对乐观锁和悲观锁的知识进行总结。</p><h2 id="悲观锁介绍"><a href="#悲观锁介绍" class="headerlink" title="悲观锁介绍"></a>悲观锁介绍</h2><p>　　悲观锁是对数据是否被修改持悲观态度（认为数据在被修改的时候一定会存在并发问题），因此在整个数据处理过程中将数据锁定。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在应用层中实现了加锁机制，也无法保证外部系统不会修改数据）。</p><p>使用场景举例</p><p>　　商品goods表中有一个字段status，status为1代表商品未被下单，status为2代表商品已经被下单，那么我们对某个商品下单时必须确保该商品status为1。假设商品的id为1。如果不采用锁，那么操作方法如下：</p><pre><code class="hljs">//1.查询出商品信息select status from t_goods where id=1;//2.根据商品信息生成订单insert into t_orders (id,goods_id) values (null,1);//3.修改商品status为2update t_goods set status=2;</code></pre><p>　　上面这种场景在高并发访问的情况下很可能会出现问题。前面已经提到，只有当goods status为1时才能对该商品下单，上面第一步操作中，查询出来的商品status为1。但是当我们执行第三步Update操作的时候，有可能出现其他人先一步对商品下单把goods status修改为2了，但是我们并不知道数据已经被修改了，这样就可能造成同一个商品被下单2次，使得数据不一致。所以说这种方式是不安全的。</p><h2 id="使用悲观锁来实现"><a href="#使用悲观锁来实现" class="headerlink" title="使用悲观锁来实现"></a>使用悲观锁来实现</h2><p>　　在上面的场景中，商品信息从查询出来到修改，中间有一个处理订单的过程，使用悲观锁的原理就是，当我们在查询出goods信息后就把当前的数据锁定，直到我们修改完毕后再解锁。那么在这个过程中，因为goods被锁定了，就不会出现有第三者来对其进行修改了。要使用悲观锁，我们必须关闭mysql数据库的自动提交属性。</p><pre><code class="hljs">set autocommit=0;　　//设置完autocommit后，我们就可以执行我们的正常业务了。具体如下：//0.开始事务begin;/begin work;/start transaction; (三者选一就可以)//1.查询出商品信息select status from t_goods where id=1 for update;//2.根据商品信息生成订单insert into t_orders (id,goods_id) values (null,1);//3.修改商品status为2update t_goods set status=2;//4.提交事务commit;/commit work;</code></pre><p>　　注：上面的begin/commit为事务的开始和结束，因为在前一步我们关闭了mysql的autocommit，所以需要手动控制事务的提交，在这里就不细表了。</p><p>　　上面的第一步我们执行了一次查询操作：select status from t_goods where id=1 for update;与普通查询不一样的是，我们使用了select…for update的方式，这样就通过数据库实现了悲观锁。此时在t_goods表中，id为1的那条数据就被我们锁定了，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。</p><p>　　注：需要注意的是，在事务中，只有SELECT … FOR UPDATE 或LOCK IN SHARE MODE 相同数据时会等待其它事务结束后才执行，一般SELECT … 则不受此影响。拿上面的实例来说，当我执行select status from t_goods where id=1 for update;后。我在另外的事务中如果再次执行select status from t_goods where id=1 for update;则第二个事务会一直等待第一个事务的提交，此时第二个查询处于阻塞的状态，但是如果我是在第二个事务中执行select status from t_goods where id=1;则能正常查询出数据，不会受第一个事务的影响。</p><p><strong>补充</strong>：MySQL select…for update的Row Lock与Table Lock</p><p>　　上面我们提到，使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认Row-Level Lock，所以只有「明确」地指定主键，MySQL 才会执行Row lock (只锁住被选取的数据) ，否则MySQL 将会执行Table Lock (将整个数据表单给锁住)。</p><p>举例说明：</p><p>　　数据库表t_goods，包括id,status,name三个字段，id为主键，数据库中记录如下;</p><p><img src="img.png"></p><p>　　注：为了测试数据库锁，我使用两个console来模拟不同的事务操作，分别用console1、console2来表示。</p><p><strong>例1:</strong> (明确指定主键，并且有此数据，row lock)</p><p>　　console1：查询出结果，但是把该条数据锁定了</p><pre><code class="hljs">set autocommit=0;SELECT * from t_goods where id=1 for update;</code></pre><p><img src="img_1.png"></p><p>　　console2：查询被阻塞</p><p>　　console2：如果console1长时间未提交，则会报错</p><p><img src="img_2.png"></p><p><strong>例2:</strong> (明确指定主键，若查无此数据，无lock)</p><p>　　console1：查询结果为空</p><pre><code class="hljs">set autocommit=0;SELECT * from t_goods where id=4 for update;</code></pre><p>　　console2：查询结果为空，查询无阻塞，说明console1没有对数据执行锁定</p><pre><code class="hljs">set autocommit=0;SELECT * from t_goods where id=4 for update;</code></pre><p><strong>例3:</strong> (无主键，table lock)</p><p>　　console1：</p><pre><code class="hljs">set autocommit=0;SELECT * from t_goods where status=1 for update;</code></pre><p><img src="img_3.png"></p><p>　　console2：</p><pre><code class="hljs">select * from person where state=2 for UPDATE　</code></pre><p>　　查询阻塞，说明console1把表给锁住了.若console1长时间未提交，则返回锁超时。</p><p><img src="img_4.png"></p><p><strong>例4:</strong> (主键不明确，table lock)</p><p>　　console1：查询正常</p><pre><code class="hljs">set autocommit=0;SELECT * from t_goods where id&gt;1 for update;</code></pre><p>　　console2：查询被阻塞，说明console1把表给锁住了。</p><pre><code class="hljs">select * from person where id&gt;=2 for UPDATE</code></pre><p>　　以上就是关于数据库主键对MySQL锁级别的影响实例，需要注意的是，除了主键外，使用索引也会影响数据库的锁定级别。</p><p>　　举例：我们修改t_goods表，给status字段创建一个索引。</p><p><strong>例5:</strong> (明确指定索引，并且有此数据，row lock)</p><p>　　console1：</p><pre><code class="hljs">set autocommit=0;SELECT * from t_goods where status=1 for update;</code></pre><p>　　console2：查询status=1的数据时阻塞，超时后返回为空，说明数据被console1锁定了</p><p><strong>例6:</strong> (明确指定索引，若查无此数据，无lock)</p><p>　　console1：查询status=3的数据，返回空数据</p><pre><code class="hljs">set autocommit=0;SELECT * from t_goods where status=3 for update;</code></pre><p>　　console2：查询status=3的数据，返回空数据</p><pre><code class="hljs">SELECT * from t_goods where status=3 for update;</code></pre><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.cnblogs.com/wxgblogs/p/6849064.html">MySQL的SELECT …for update</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>悲观锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解maven命令package、install、deploy的联系与区别</title>
    <link href="/2022/11/16/maven/%E7%90%86%E8%A7%A3maven%E5%91%BD%E4%BB%A4package%E3%80%81install%E3%80%81deploy%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/11/16/maven/%E7%90%86%E8%A7%A3maven%E5%91%BD%E4%BB%A4package%E3%80%81install%E3%80%81deploy%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>我们在用maven构建java项目时，最常用的打包命令有mvn package、mvn install、deploy，这三个命令都可完成打jar包或war（当然也可以是其它形式的包）的功能，但这三个命令还是有区别的。下面通过分别执行这三个命令的输出结果，来分析各自所执行的maven的生命周期。</p><h2 id="mvn-clean-package"><a href="#mvn-clean-package" class="headerlink" title="mvn clean package"></a>mvn clean package</h2><p><img src="img.png"></p><p><img src="img_1.png"></p><h2 id="mvn-clean-install"><a href="#mvn-clean-install" class="headerlink" title="mvn clean install"></a>mvn clean install</h2><p><img src="img_2.png"></p><p><img src="img_3.png"></p><h2 id="mvn-clean-deploy（忽略最后的BUILD-FAILURE）"><a href="#mvn-clean-deploy（忽略最后的BUILD-FAILURE）" class="headerlink" title="mvn clean deploy（忽略最后的BUILD FAILURE）"></a>mvn clean deploy（忽略最后的BUILD FAILURE）</h2><p><img src="img_4.png"></p><p><img src="img_5.png"></p><p>通过三个命令的输出我们可以看出三者的区别在于包函的maven生命的阶段和执行目标(goal)不同。上一篇文章 <code>https://blog.csdn.net/zhaojianting/article/details/80321488</code>　中介绍了maven的生命周期和各种插件，不明白的请参考此博文。maven生命周期（lifecycle）由各个阶段组成，每个阶段由maven的插件plugin来执行完成。生命周期（lifecycle）主要包括clean、resources、complie、install、pacakge、testResources、testCompile、deploy等，其中带test开头的都是用业编译测试代码或运行单元测试用例的。</p><p>仔细查看上面的输出结果截图，可以发现，</p><ul><li>  <strong>mvn clean package依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)等７个阶段。</strong></li><li>  <strong>mvn clean install依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)、install等8个阶段。</strong></li><li>  <strong>mvn clean deploy依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)、install、deploy等９个阶段。</strong></li></ul><p>由上面的分析可知主要区别如下，</p><ul><li>  <strong>package命令完成了项目编译、单元测试、打包功能，但没有把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库</strong></li><li>  <strong>install命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库，但没有布署到远程maven私服仓库</strong></li><li>  <strong>deploy命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库</strong></li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://blog.csdn.net/zhaojianting/article/details/80324533">理解maven命令package、install、deploy的联系与区别</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>maven命令</tag>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Idea Spring Boot配置文件.yaml或.properties不能自动提示的有效解决办法</title>
    <link href="/2022/11/16/idea/Idea%20Spring%20Boot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.yaml%E6%88%96.properties%E4%B8%8D%E8%83%BD%E8%87%AA%E5%8A%A8%E6%8F%90%E7%A4%BA%E7%9A%84%E6%9C%89%E6%95%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <url>/2022/11/16/idea/Idea%20Spring%20Boot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.yaml%E6%88%96.properties%E4%B8%8D%E8%83%BD%E8%87%AA%E5%8A%A8%E6%8F%90%E7%A4%BA%E7%9A%84%E6%9C%89%E6%95%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>SpringBoot项目的配置文件.yaml/.yml/.properties文件编写的时候没有自动提示，网上的解决办法五花八门，不一定适合具体个人的IDE环境，下面总结一套能解决绝大部分情况的方案：</p><p>先给出能自动识别的图样：</p><p><img src="https://img-blog.csdnimg.cn/20200706173341248.png"></p><h1 id="步骤1"><a href="#步骤1" class="headerlink" title="步骤1"></a>步骤1</h1><p>先检查IDEA是否安装了支持SpringBoot项目的插件（如果是通过IDEA创建的SpringBoot项目都集成了），如下图所示：</p><blockquote><p>注意: 旗舰版IDEA 不要使<a href="https://github.com/flikas/idea-spring-boot-assistant"><code>Spring Boot Assistant</code></a>插件，不然会出现无法读取自定义配置问题，使用内置的<code>Spring Boot</code>插件即可</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200706172519407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hmd2R4dA==,size_16,color_FFFFFF,t_70"></p><h1 id="步骤2"><a href="#步骤2" class="headerlink" title="步骤2"></a>步骤2</h1><p>检查IDEA的文件类型识别器File Types是否支持.yaml,.yml,.properties结尾的文件</p><p><img src="https://img-blog.csdnimg.cn/20200706172951189.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hmd2R4dA==,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20200706173204672.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hmd2R4dA==,size_16,color_FFFFFF,t_70"></p><h1 id="步骤3"><a href="#步骤3" class="headerlink" title="步骤3"></a>步骤3</h1><p>查看.yaml,.yml,.properties文件的图标是否变成绿叶形状，如果没有，则重启Idea看看（正常情况重启后应该可以）。</p><h1 id="步骤4"><a href="#步骤4" class="headerlink" title="步骤4"></a>步骤4</h1><p>查看如果经过上面三步后还没有，则删掉.yaml文件，重新建一个.yaml文件（或.properties文件）。然后按下图所示把配置文件添加到工程的module中的配置文件目录下：（这一步主要针对application.properties文件正常了，但是自定义的.properties如开始给出的图中custom.properties文件没有变绿叶状的情况）</p><p>鼠标选中项目根目录，邮件，点击Open Module Settings<img src="https://img-blog.csdnimg.cn/2020070617471625.png"></p><p><img src="https://img-blog.csdnimg.cn/20200706174756544.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hmd2R4dA==,size_16,color_FFFFFF,t_70"></p><p>到这里，小伙伴们的Spring Boot配置文件就能正常自动识别啦~~，快去体验一下吧</p><p><img src="https://img-blog.csdnimg.cn/20200706174939284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hmd2R4dA==,size_16,color_FFFFFF,t_70"></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://blog.csdn.net/xfwdxt/article/details/107163389">Idea Spring Boot配置文件.yaml或.properties不能自动提示的有效解决办法</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spring-boot-configuration-processor 的作用</title>
    <link href="/2022/11/16/spring/spring-boot-configuration-processor%20%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <url>/2022/11/16/spring/spring-boot-configuration-processor%20%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>为什么在IDEA中使用SpringBoot的时候, 我们在配置文件中总能在输入spring时会得到很多的输入提示?</p><p><img src="img.png"></p><p>这是由于在Spring的项目中 (我们依赖的jar) 包含了很多 <code>meta-data</code>, 也就是元数据, 这些数据并不是在项目运行中有什么作用. 而是在开发期间能够通过ide的处理给我们更多的便捷提示.</p><hr><p>下面我们一起来看一下依赖的jar里面都有什么?</p><p><img src="img_1.png"></p><p>spring-configuration-metadata.json 这个就是<code>spring配置元数据</code>. 我们经常输入的server.port在这里面就有配置.  </p><p><img src="img_2.png"></p><p>上图就是自动提示的内容. 我们一起看看在metadata中都是怎么写的<br><img src="img_3.png"></p><pre><code class="hljs">    &#123;      &quot;name&quot;: &quot;server.port&quot;,                          # 配置名称      &quot;type&quot;: &quot;java.lang.Integer&quot;,                    # 数据类型      &quot;description&quot;: &quot;Server HTTP port.&quot;,             # 描述      &quot;sourceType&quot;: &quot;org.springframework.boot.autoconfigure.web.ServerProperties&quot;,  # 配置项来源      &quot;defaultValue&quot;: 8080  # 默认值    &#125;</code></pre><p>再来看看来源的类<br><img src="img_4.png"></p><p>这样就看到了数据出处了.<br>显而易见的是, 除了默认值之外, 字段的注释也会一并被写到metadata中.</p><p>那么接下来看看如何添加默认值.<br><img src="img_5.png"></p><p>给字段配置上默认值之后会自动的被处理到metadata中</p><p><img src="img_6.png">  </p><p>这样在输入的时候就会有提示<br><img src="img_7.png"></p><p>以上就是spring-boot-configuration-processor大致的作用了.</p><p>maven依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>版本号随着你的spring-boot版本变化</p><p>当你编写好属性文件， 并添加注解之后, 需要你编译一下项目才能在配置文件编写的时候弹出提示。如果不编译是不会有提示的。 编译好的文件在target包下可以看到<br><img src="img_8.png"></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://www.jianshu.com/p/ca22783b0a35">spring-boot-configuration-processor 的作用</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>原生linux安装docker方式(WSL)</title>
    <link href="/2022/11/16/docker/%E5%8E%9F%E7%94%9Flinux%E5%AE%89%E8%A3%85docker%E6%96%B9%E5%BC%8F(WSL)/"/>
    <url>/2022/11/16/docker/%E5%8E%9F%E7%94%9Flinux%E5%AE%89%E8%A3%85docker%E6%96%B9%E5%BC%8F(WSL)/</url>
    
    <content type="html"><![CDATA[<p>wsl2已经完整使用了linux内核了，此种方式和先前在linux虚拟机安装docker类似，步骤如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl -fsSL https://get.docker.com -o get-docker.sh</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo sh get-docker.sh</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">sudo service docker start</span><br><br></code></pre></td></tr></table></figure><p>执行脚本安装过程中，脚本提示“建议使用Docker Desktop for windows”，20s内按Ctrl+C会退出安装，所以需要等待20s，另外此种方式需要访问外网。</p><blockquote><p>export http_proxy=<a href="http://172.16.10.133:7890/">http://172.16.10.133:7890</a><br>export https_proxy=<a href="http://172.16.10.133:7890/">http://172.16.10.133:7890</a></p></blockquote><p>检查docker安装正常</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">检查dockerd进程启动</span><br>service docker status<br>ps aux|grep docker<br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查拉取镜像等正常</span><br>docker pull busybox<br>docker images<br></code></pre></td></tr></table></figure><blockquote><p>注意：不同于完全linux虚拟机方式，WLS2下通过apt install docker-ce命令安装的docker无法启动，因为WSL2方式的ubuntu里面没有systemd。上述官方get-docker.sh安装的docker，dockerd进程是用ubuntu传统的init方式而非systemd启动的。</p></blockquote><p>对于使用 systemd 的系统，请在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在请新建该文件）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">&#123;<br>    &quot;registry-mirrors&quot; : [<br>        &quot;http://registry-1.docker.io&quot;,<br>        &quot;http://mirror.baidubce.com&quot;,<br>        &quot;http://docker.mirrors.ustc.edu.cn&quot;<br>    ],<br>    &quot;insecure-registries&quot;:[&quot;harbor.xxx.com&quot;]<br>&#125;<br>&gt;注意：该文件必须符合 json 规范，否则 Docker 将不能启动。<br></code></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/148511634">win10利用WSL2安装docker的2种方式</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>WSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>类与对象的比较</title>
    <link href="/2022/11/14/java/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <url>/2022/11/14/java/%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<h1 id="Content"><a href="#Content" class="headerlink" title="Content"></a>Content</h1><p><strong>面向对象设计的一个核心概念就是对象 (obiect) 与类(class)的区分。对象是指运行期间在程序中实际存在的具体实体(enity)，而类是指在程序源码中存在的静态事物。对象是动态的，它拥有你在程序运行期间所能得到的具体的值和属性。例如，你可以定义一个名为 Person 的类，它具有姓名年龄、性别等属性。在程序运行期间，你可以有 nancy、hank、diane、tony 等对象一一它们是类的具体实例。如果你熟悉数据库术语的话，类与对象的关系就如同“模式(schema)”与“实例(instance)”一样。你可以把类看做是蛋糕模具而把对象看做是蛋糕。在本书中，对这两个术语的使用并非十分正规，一般情况也会或多或少互换地使用类和对象这两个术语。</strong></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li>代码大全（第2版）</li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>class</tag>
      
      <tag>object</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>spotless-maven-plugin</title>
    <link href="/2022/11/09/maven/%E4%BD%BF%E7%94%A8spotless-maven-plugin%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/"/>
    <url>/2022/11/09/maven/%E4%BD%BF%E7%94%A8spotless-maven-plugin%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在一些大型项目或开源项目，由于开发人员太多，导致各个代码格式不统一。会让整体项目的代码可读性变差， spotless-maven-plugin就是不错的选择</p><h2 id="Spotless-是什么"><a href="#Spotless-是什么" class="headerlink" title="Spotless 是什么"></a>Spotless 是什么</h2><p>Spotless 是支持多种语言的代码格式化工具，支持 Maven 和 Gradle 以 Plugin 的形式构建。目前github已经有4000+开源项目在使用<code>Spotless</code>进行格式化代码</p><blockquote><p>我们下面使用<code>maven</code>进行演示</p></blockquote><h2 id="Spotless-常用命令"><a href="#Spotless-常用命令" class="headerlink" title="Spotless 常用命令"></a>Spotless 常用命令</h2><h3 id="检查代码格式"><a href="#检查代码格式" class="headerlink" title="检查代码格式"></a>检查代码格式</h3><pre><code class="hljs">mvn spotless:check</code></pre><h3 id="自动格式化代码"><a href="#自动格式化代码" class="headerlink" title="自动格式化代码"></a>自动格式化代码</h3><pre><code class="hljs">mvn spotless:apply</code></pre><h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>自动为代码添加<code>licenseHeader</code>和格式化代码</p><h3 id="添加配置文件"><a href="#添加配置文件" class="headerlink" title="添加配置文件"></a>添加配置文件</h3><ol><li> 设置自动添加请求头文件</li></ol><p>这里我们设置自动添加<code>Apache-2.0 license</code>请求头</p><p><img src="https://img-blog.csdnimg.cn/img_convert/6dcc8ab5058e8da7d70c607b6bc8bdfb.png"></p><blockquote><p>注意， <code>license-header</code>最后要留有一行空格。不然<code>license-header</code>和<code>package</code>之间将没有空隙。</p></blockquote><ol start="2"><li> 设置代码格式配置</li></ol><blockquote><p>项目根目录添加 spotless_formatter.xml 和 license-header 文件</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> standalone=<span class="hljs-string">&quot;no&quot;</span>?&gt;</span><br><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Licensed to the Apache Software Foundation (ASF) under one</span><br><span class="hljs-comment"> * or more contributor license agreements.  See the NOTICE file</span><br><span class="hljs-comment"> * distributed with this work for additional information</span><br><span class="hljs-comment"> * regarding copyright ownership.  The ASF licenses this file</span><br><span class="hljs-comment"> * to you under the Apache License, Version 2.0 (the</span><br><span class="hljs-comment"> * &quot;License&quot;); you may not use this file except in compliance</span><br><span class="hljs-comment"> * with the License.  You may obtain a copy of the License at</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *     http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="hljs-comment"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="hljs-comment"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="hljs-comment"> * See the License for the specific language governing permissions and</span><br><span class="hljs-comment"> * limitations under the License.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;13&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span> <span class="hljs-attr">kind</span>=<span class="hljs-string">&quot;CodeFormatterProfile&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;&#x27;Hippo4j Current&#x27;&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;13&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.compiler.source&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1.8&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.compiler.compliance&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1.8&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.compiler.codegen.targetPlatform&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1.8&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.indent_empty_lines&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.tabulation.size&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;4&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.lineSplit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;200&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.comment.line_length&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;200&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.tabulation.char&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;space&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.indentation.size&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.comment.format_javadoc_comments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.join_wrapped_lines&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_colon_in_conditional&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;insert&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_colon_in_default&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_enum_constants&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_colon_in_labeled_statement&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.insert_space_before_colon_in_case&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;do not insert&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_conditional_expression&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;80&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_assignment&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.blank_lines_after_package&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.continuation_indentation_for_array_initializer&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_resources_in_try&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;160&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_method_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;10&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_parameters_in_method_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;106&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_parameters_in_constructor_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;106&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_throws_clause_in_constructor_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;106&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.blank_lines_before_first_class_body_declaration&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;org.eclipse.jdt.core.formatter.alignment_for_arguments_in_explicit_constructor_call.count_dependent&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;16|5|80&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="添加maven插件配置"><a href="#添加maven插件配置" class="headerlink" title="添加maven插件配置"></a>添加maven插件配置</h3><p>我们在项目pom中添加插件及配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.diffplug.spotless<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spotless-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.22.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">applySkip</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">applySkip</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">eclipse</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>spotless_formatter.xml<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">eclipse</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">licenseHeader</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>license-header<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">licenseHeader</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">java</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>apply<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="格式化代码"><a href="#格式化代码" class="headerlink" title="格式化代码"></a>格式化代码</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/2f9b21db101293ab650faa3b19b7b7df.png"></p><p>可以看到格式化成功了</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5cc41588831c1a31c848d1b21f78dca3.png"></p><p>然后我们看看代码<br><img src="https://img-blog.csdnimg.cn/90caef30a7494ceb9fd2f0a2b56681fa.png" alt="在这里插入图片描述"></p><p>可以看到自动帮我们添加了文件头和格式化了代码</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://github.com/diffplug/spotless">spotless</a></li><li><a href="https://www.pudn.com/news/633da67c272bb74d442fbc1f.html">开发人员太多代码格式不统一？来试试 Spotless maven插件解决代码格式化问题</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>maven-plugin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jacoco-maven-plugin</title>
    <link href="/2022/11/09/maven/%E4%BD%BF%E7%94%A8jacoco-maven-plugin%E7%94%9F%E6%88%90%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87%E6%8A%A5%E5%91%8A/"/>
    <url>/2022/11/09/maven/%E4%BD%BF%E7%94%A8jacoco-maven-plugin%E7%94%9F%E6%88%90%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E8%A6%86%E7%9B%96%E7%8E%87%E6%8A%A5%E5%91%8A/</url>
    
    <content type="html"><![CDATA[<blockquote><p>没人能够保证自己的代码万无一失，除非其代码执行覆盖率达到100%</p></blockquote><p>我们在项目开发中，期望能够对接口和代码进行单元测试，并且要求代码覆盖率要高于80%。这样做的目的是为了后续交接代码之后，其他人修改了代码，可能会影响到其他的系统，我们能够在代码执行单元测试的时候将问题暴露出来。那么我们期望开发人员在本地跑单元测试的时候，能够看到自己代码的覆盖率是多少，并且展示具体是哪里的代码覆盖到了，哪些没有覆盖。本文就是介绍使用jacoco插件来生成单元测试覆盖率报告，并且查看覆盖明细。</p><h2 id="1-创建Maven工程"><a href="#1-创建Maven工程" class="headerlink" title="1.创建Maven工程"></a>1.创建Maven工程</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>JacocoDemo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">jacoco.version</span>&gt;</span>0.8.6<span class="hljs-tag">&lt;/<span class="hljs-name">jacoco.version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- junit 5 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-params<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.jupiter<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-jupiter-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-comment">&lt;!-- jacoco: generate test coverage report --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jacoco<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jacoco-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;jacoco.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>prepare-agent<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>generate-code-coverage-report<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>report<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>我们使用了Junit5，并创建一个web工程进行测试，我在pom中进行了备注。</p><h2 id="2-创建SpringBoot启动类"><a href="#2-创建SpringBoot启动类" class="headerlink" title="2.创建SpringBoot启动类"></a>2.创建SpringBoot启动类</h2><p><code>org.example.jacocodemo.App</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.jacocodemo;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">App</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        SpringApplication.run(App.class, args);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-创建Controller"><a href="#3-创建Controller" class="headerlink" title="3.创建Controller:"></a>3.创建Controller:</h2><p><code>DemoController</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.jacocodemo;<br><br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(path = &quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(path = &quot;/&#123;branchId&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBranch</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;branchId&quot;)</span> <span class="hljs-type">int</span> branchId)</span> &#123;<br>        <span class="hljs-keyword">if</span> (branchId == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;master&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (branchId == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;dev&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;release&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>我们这里的思路非常简单，我们通过传递过来的branchId来做代码分支的划分，通过设计不同的测试用例，来实现不同的代码覆盖率。</p><h2 id="4-创建单元测试"><a href="#4-创建单元测试" class="headerlink" title="4.创建单元测试"></a>4.创建单元测试</h2><p><code>DemoControllerTest</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.jacocodemo;<br><br><span class="hljs-keyword">import</span> org.junit.jupiter.api.BeforeAll;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.extension.ExtendWith;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.http.MediaType;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit.jupiter.SpringExtension;<br><span class="hljs-keyword">import</span> org.springframework.test.web.servlet.MockMvc;<br><span class="hljs-keyword">import</span> org.springframework.test.web.servlet.request.MockMvcRequestBuilders;<br><span class="hljs-keyword">import</span> org.springframework.test.web.servlet.result.MockMvcResultMatchers;<br><span class="hljs-keyword">import</span> org.springframework.test.web.servlet.setup.MockMvcBuilders;<br><br><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-meta">@ExtendWith(SpringExtension.class)</span><br><span class="hljs-meta">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DemoControllerTest</span> &#123;<br>    <span class="hljs-keyword">static</span> MockMvc mockMvc;<br><br>    <span class="hljs-meta">@BeforeAll</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUp</span><span class="hljs-params">()</span> &#123;<br>        mockMvc = MockMvcBuilders.standaloneSetup(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DemoController</span>()).build();<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGetBranch</span><span class="hljs-params">()</span> &#123;<br>        Map&lt;Integer, String&gt; testCases = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        testCases.put(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;master&quot;</span>);<br>        testCases.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;dev&quot;</span>);<br>        testCases.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;release&quot;</span>);<br>        testCases.forEach((key, value) -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                mockMvc<br>                    .perform(MockMvcRequestBuilders.get(<span class="hljs-string">&quot;/test/&#123;branchId&#125;&quot;</span>, key)<br>                        .accept(MediaType.APPLICATION_JSON)<br>                        .characterEncoding(StandardCharsets.UTF_8.name()))<br>                    .andExpect(MockMvcResultMatchers.status().isOk())<br>                    .andExpect(MockMvcResultMatchers.content().string(value))<br>                    .andReturn();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这里使用了junit5的语法，使用SpringBootTest和ExtendWith注解来启动单元测试，指定了使用随机端口，并通过MockMvc来模拟Controller调用。MockMvc的初始化工作在setUp中完成，用Map来模拟测试用例和期望的结果。</p><h2 id="5-运行单元测试"><a href="#5-运行单元测试" class="headerlink" title="5.运行单元测试"></a>5.运行单元测试</h2><p>在工程根目录下执行<code>mvn clean test</code>来执行单元测试并生成覆盖率报告，生成后的报告为<code>./target/site/jacoco/index.html</code>，通过浏览器打开该文件，可以看到整体的覆盖率以及单元测试的情况： <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5758df5cad924b8a85172d891fc6605f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image"> 按照层级点击到我们的DemoController可以看到代码的覆盖率和分支覆盖率，点击进入文件，选择方法可以看到执行了方法中的哪些行代码： <img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dfb17f19d8940e796121bdb0253fa85~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image"></p><p>PS：由于SpringBoot默认使用的是junit4，在junit4的情况下我执行<code>mvn clean test</code>的时候，mvn-surfire-maven-plugin不执行我的单元测试，运行的测试那里一直显示0。查询了一些解决方法，没有生效，最后改为使用junit5，各位也可以根据自己项目中使用的技术酌情处理和修改。如果有解决junit4下单元测试不执行的方法，还请评论留言，供大家学习。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://juejin.cn/post/6916441120075415560">使用jacoco-maven-plugin生成单元测试覆盖率报告</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>maven-plugin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java泛型与Json反序列化</title>
    <link href="/2022/11/08/java/Java%E6%B3%9B%E5%9E%8B%E4%B8%8EJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2022/11/08/java/Java%E6%B3%9B%E5%9E%8B%E4%B8%8EJson%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>Java的JSON库有很多，本文分析google的Gson和alibaba的fastjson，在Java泛型场景反序列化的一些有意思的行为。考虑下面的json字符串：</p><pre><code class="hljs">[    &quot;2147483648&quot;,    &quot;2147483647&quot;]</code></pre><p>用fastjson在不指定类型的情况下解析，下面的代码输出啥：</p><pre><code class="hljs">JSON.parseArray(s).forEach(o -&gt; &#123; System.out.println(o.getClass()); &#125;);</code></pre><p>答案是：</p><pre><code class="hljs">class java.lang.Longclass java.lang.Integer</code></pre><p>是不是感觉有点儿奇怪，两个都是数字啊，居然输出了不同的类型，原因我们下面细讲。再看看Gson， 用Gson解析并且不指定泛型类型的话，下面的代码输出啥：</p><pre><code class="hljs">new Gson().fromJson(s, List.class).forEach(o -&gt; &#123; System.out.println(o.getClass()); &#125;);</code></pre><p>答案是：</p><pre><code class="hljs">class java.lang.Doubleclass java.lang.Double</code></pre><p>这次两个都是Double类型，明明是整数啊，为啥到Gson这里变成Double了？</p><p>我们试了两个Json库，解析相同的json字符串，得到全然不同的结果。如果在实际使用的时候，用这种方式反序列化JSON，很容易出现BUG，而且是运行时才可能出现，这种问题一旦出现往往很难排查。因此为了保证泛型类型Json反序列化的正确性，一定要明确指定泛型的类型。下面我们先看看正确的解析应该怎么写，再深度探讨一下内部的原理。</p><h2 id="正确的泛型Json反序列化"><a href="#正确的泛型Json反序列化" class="headerlink" title="正确的泛型Json反序列化"></a>正确的泛型Json反序列化</h2><p>fastjson和Gson都提供了泛型类型的反序列化方案，先来看看fastjson，对于上面的case，正确的反序列化代码如下：</p><pre><code class="hljs">JSON.parseObject(s, new TypeReference&lt;List&lt;Long&gt;&gt;()&#123;&#125;).forEach(o -&gt; &#123; System.out.println(o.getClass()); &#125;);</code></pre><p>创建一个确定泛型类型的<code>TypeReference</code>子类（这里是匿名内部类），将这个子类传递给fastjson以帮助fastjson在运行时获得泛型的具体类型信息，从而实现泛型正确反序列化。Gson的方案与fastjson相同，或者应该反过来说fastjson的方案与Gson相同。大家感兴趣的话可以看看fastjson的<code>TypeReference</code>和Gson的<code>TypeToken</code>代码，基本上fastjson就是抄袭Gson，连注释都抄了……。Gson指定泛型类型的反序列化方法如下，也是创建一个确定泛型类型的匿名子类：</p><pre><code class="hljs">new Gson().&lt;List&lt;Long&gt;&gt;fromJson(s, new TypeToken&lt;List&lt;Long&gt;&gt;()&#123;&#125;.getType()).forEach(o -&gt; &#123; System.out.println(o.getClass()); &#125;);</code></pre><p>由于fastjson的方案是来自Gson，以下只讨论Gson的泛型反序列化原理。为什么泛型的反序列化显得这么麻烦呢，非要通过子类化的方式，不能直接告诉Gson泛型的类型吗？是的，Java是真的做不到，其实理由很简单，泛型类既然是泛型，意味着就不应该带有具体泛型类型的信息，因此泛型类的字节码本身就不应该也无法保存泛型类型，但是子类如果继承一个明确泛型类型的父类（父类是一个泛型类型，Gson里面就是TypeToken），子类必须保存父类的明确类型信息，通过<code>Class</code>类的<code>getGenericSuperclass</code>方法能够获得父类类型信息，该类型信息包含了父类具体的泛型类型信息。这个方法帮助Java的泛型体系完整化了，是非常重要的一个方法。</p><h2 id="类库设计分析"><a href="#类库设计分析" class="headerlink" title="类库设计分析"></a>类库设计分析</h2><p>面对相同的设计问题，fastjson与Gson在很多点上的选择不同，借此机会可以一窥类库设计的思想，让我们一一来看。</p><h3 id="是静态方法还是实例化"><a href="#是静态方法还是实例化" class="headerlink" title="是静态方法还是实例化"></a>是静态方法还是实例化</h3><p>使用Gson之前，必须进行实例化，Gson提供了两种方式：一种是无参数构造器，一种是通过GsonBuilder，后者能够进行更多的定制，但无论是哪种方法，都需要实例化一个Gson对象。但是Fastjson使用之前是不需要实例化的，直接使用JSON类的静态方法即可实现json序列化和反序列化。这一点上来讲，Fastjson比较方便，虽然Gson是线程安全的，可以用static变量来声明一个Gson实例（饿汉模式的单例）然后全局使用，但是还是比Fastjson多了一步。但是Gson这么做的好处是如果序列化（反序列化）的定制比较多，可以在初始化的时候完成复杂的扩展定制，使用的时候依然保持简单，Fastjson就需要每次都传递额外的参数来实现。总体来讲各有优化，Gson是线程安全的，大部分场景都是定义全局的静态单例，用起来跟Fastjson差不多。<strong>Gson在这里的选择倾向于希望对外的接口保持一致和简单</strong>，即无论怎么定制逻辑，Json的序列化和反序列化就那么几个方法，内部逻辑可以定制，但是使用接口不用改变。</p><h3 id="数字的默认类型"><a href="#数字的默认类型" class="headerlink" title="数字的默认类型"></a>数字的默认类型</h3><p>对于数字类型，如果没有明确指定类型，Gson默认都解析成Double类型，而Fastjson会根据数字的不同，解析成Long、Integer或者BigDecimal。我们在生产中用Fastjson就遇到这种问题：由于集合没有指定泛型类型，反序列化的时候，不同大小的数字被反序列化成了不同的类型，导致业务逻辑出错。这种未制定类型情况下，感觉Gson的处理更合适一些，既然未指定类型，对外的默认类型始终是Double，接口对外的心智更稳定。</p><h3 id="集合类型反序列化"><a href="#集合类型反序列化" class="headerlink" title="集合类型反序列化"></a>集合类型反序列化</h3><p>对于列表类型的反序列化，Fastjson提供了parseArray系列方法，这样很多情况下可以避免使用<code>TypeReference</code>，代码写起来更简单。但是Gson就没有这种方法，如果需要解析列表，必须使用<code>TypeToken&lt;List&lt;Xxx&gt;&gt;</code>，并没有为列表设置特殊的方法，这里依然能看到 <strong>Gson希望对外的接口保持一致和简单</strong> ，即便牺牲一点儿方便性。</p><h3 id="泛型反序列化"><a href="#泛型反序列化" class="headerlink" title="泛型反序列化"></a>泛型反序列化</h3><p>为了解析泛型，Gson和Fastjson都提供了类似的机制（Gson使用TypeToken承载类型，而Fastjson使用TypeReference承载类型），利用子类继承确定泛型父类的方式，获得类型，区别是Gson的接口只接受Type类型的参数，不接受TypeToken参数，这是因为Type是JDK的自带类型，而TypeToken是Gson额外引入的，这种设计的效果是<strong>Gson的接口非常简单</strong>。Fastjson的接口可以支持Type参数，也支持TypeReference参数。</p><h3 id="Gson和Fastjson的对外方法对比"><a href="#Gson和Fastjson的对外方法对比" class="headerlink" title="Gson和Fastjson的对外方法对比"></a>Gson和Fastjson的对外方法对比</h3><p>说了这么多，下面两张图，对比一下Fastjson对外同的公共方法数量和Gson提供的公共方法数量，有比较直观的感觉：</p><p><img src="img.png"><br>Gson对外接口-数量明显更少<br><img src="fastjson1.jpg"><br><img src="fastjson2.jpg"><br><img src="fastjson3.jpg"></p><p>FastJson对外接口-数量明显非常多</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>整体上能明显看出来fastjson更多是长出来的，接口多而全，应该是不断有人提需求不断实现的结果，而Gson是设计出来的，接口的一致性很强，高内聚低耦合，有些时候宁愿牺牲接口的便利性，也要保证接口对外的一致性、简单和概念完整，从设计上我是崇尚Gson的设计理念的，但实际的开发过程更容易演变成fastjson的模式，在中国程序员的地位真的不够高。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.jianshu.com/p/f0fe42636d19">Java泛型与Json反序列化</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码大全（第2版）</title>
    <link href="/2022/11/04/book/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/"/>
    <url>/2022/11/04/book/%E4%BB%A3%E7%A0%81%E5%A4%A7%E5%85%A8%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><img src="img.png"></p><h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>史蒂夫·迈克康奈尔</p><h2 id="原文摘录"><a href="#原文摘录" class="headerlink" title="原文摘录"></a>原文摘录</h2><ul><li><p><strong>程序员是软件食物链的最后一环.架构师吃掉需求,设计师吃掉架构,程序员则消化设计</strong></p></li><li><p><strong>用错误处理代码来处理预期会发生的情况,用断言来处理绝对不应该发生的情况</strong></p></li></ul><h2 id="短评"><a href="#短评" class="headerlink" title="短评"></a>短评</h2><p><strong>构建的核心就是管理复杂度,要把主要精力集中于构建活动,采用自上而下的思考,自下而上的执行,这样才能提高工作效率.</strong></p><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li><a href="https://book.douban.com/subject/1477390/">豆瓣读书</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件设计</tag>
      
      <tag>史蒂夫·迈克康奈尔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven之scope详解</title>
    <link href="/2022/11/04/maven/Maven%E4%B9%8Bscope%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/11/04/maven/Maven%E4%B9%8Bscope%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><strong>Maven</strong>中使用 <code>scope</code> 来指定当前包的依赖范围和依赖的传递性。常见的可选值有：<strong>compile</strong>, <strong>provided</strong>, <strong>runtime</strong>, <strong>test</strong>, <strong>system</strong> 等。<code>scope</code> 主要是用在 <code>pom.xml</code> 文件中的依赖定义部分，例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.1.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="scope各种取值详解"><a href="#scope各种取值详解" class="headerlink" title="scope各种取值详解"></a>scope各种取值详解</h2><table><thead><tr><th>scope取值</th><th>有效范围（compile, runtime, test）</th><th>依赖传递</th><th>例子</th></tr></thead><tbody><tr><td><strong>compile</strong></td><td>all</td><td>是</td><td>spring-core</td></tr><tr><td><strong>provided</strong></td><td>compile, test</td><td><strong>否</strong></td><td>servlet-api</td></tr><tr><td><strong>runtime</strong></td><td>runtime, test</td><td>是</td><td>JDBC驱动</td></tr><tr><td><strong>test</strong></td><td>test</td><td><strong>否</strong></td><td>JUnit</td></tr><tr><td><strong>system</strong></td><td>compile, test</td><td>是</td><td></td></tr></tbody></table><p>正如上表所示，</p><p><strong>compile</strong> ：为<strong>默认的</strong>依赖有效范围。如果在定义依赖关系的时候，没有明确指定依赖有效范围的话，则默认采用该依赖有效范围。</p><p>此种依赖，在编译、运行、测试时均有效。</p><p><strong>provided</strong> ：在编译、测试时有效，但是在运行时无效。</p><p>provided意味着打包的时候可以不用包进去，别的设施(Web Container)会提供。</p><p>事实上该依赖理论上可以参与编译，测试，运行等周期。相当于compile，但是在打包阶段做了exclude的动作。</p><p>例如：servlet-api，运行项目时，容器已经提供，就不需要Maven重复地引入一遍了。</p><p><strong>runtime</strong> ：在运行、测试时有效，但是在编译代码时无效。</p><p>说实话在终端的项目（非开源，企业内部系统）中，和compile区别不是很大。比较常见的如JSR×××的实现，对应的API jar是compile的，具体实现是runtime的，compile只需要知道接口就足够了。</p><p>例如：JDBC驱动实现，项目代码编译只需要JDK提供的JDBC接口，只有在测试或运行项目时才需要实现上述接口的具体JDBC驱动。</p><p>另外runntime的依赖通常和optional搭配使用，optional为true。我可以用A实现，也可以用B实现。</p><p><strong>test</strong> ：只在测试时有效，包括测试代码的编译，执行。例如：JUnit。</p><p>PS: test表示只能在src下的test文件夹下面才可以使用，你如果在a项目中引入了这个依赖，在b项目引入了a项目作为依赖，在b项目中这个注解不会生效，因为scope为test时无法传递依赖。</p><p><strong>system</strong> ：在编译、测试时有效，但是在<strong>运行时无效</strong>。</p><p>和provided的区别是，使用system范围的依赖时必须通过<strong>systemPath元素显式地指定依赖文件的路径</strong>。由于此类依赖<strong>不是通过Maven仓库解析的，而且往往与本机系统绑定</strong>，可能造成构建的不可移植，因此应该谨慎使用。</p><p>systemPath元素可以引用环境变量。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.sql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jdbc-stdext<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>system<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">systemPath</span>&gt;</span>$&#123;java.home&#125;/lib/rt.jar<span class="hljs-tag">&lt;/<span class="hljs-name">systemPath</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="scope的依赖传递"><a href="#scope的依赖传递" class="headerlink" title="scope的依赖传递"></a>scope的依赖传递</h2><p>A–&gt;B–&gt;C。当前项目为A，A依赖于B，B依赖于C。知道B在A项目中的scope，那么怎么知道C在A中的scope呢？</p><p>答案是：</p><p>当C是test或者provided时，C直接被丢弃，A不依赖C； 否则A依赖C，C的scope继承于B的scope。</p><h2 id="scope的值官方解释"><a href="#scope的值官方解释" class="headerlink" title="scope的值官方解释"></a>scope的值官方解释</h2><ul><li><strong>compile</strong>  This is the default scope, used if none is specified. Compile dependencies are available in all classpaths of a project. Furthermore, those dependencies are propagated to dependent projects.</li><li><strong>provided</strong>  This is much like compile, but indicates you expect the JDK or a container to provide the dependency at runtime. For example, when building a web application for the Java Enterprise Edition, you would set the dependency on the Servlet API and related Java EE APIs to scope provided because the web container provides those classes. This scope is only available on the compilation and test classpath, and is not transitive.</li><li><strong>runtime</strong>  This scope indicates that the dependency is not required for compilation, but is for execution. It is in the runtime and test classpaths, but not the compile classpath.</li><li><strong>test</strong>  This scope indicates that the dependency is not required for normal use of the application, and is only available for the test compilation and execution phases. This scope is not transitive.</li><li><strong>system</strong>  This scope is similar to provided except that you have to provide the JAR which contains it explicitly. The artifact is always available and is not looked up in a repository.<br>  import (only available in Maven 2.0.9 or later)<br>  This scope is only supported on a dependency of type pom in the section. It indicates the dependency to be replaced with the effective list of dependencies in the specified POM’s section. Since they are replaced, dependencies with a scope of import do not actually participate in limiting the transitivity of a dependency.</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.cnblogs.com/satire/p/15068971.html">Maven之scope详解</a></li><li><a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html">Introduction to the Dependency Mechanism</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>scope</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring 中的bean 是线程安全的吗？</title>
    <link href="/2022/11/01/spring/Spring%E4%B8%AD%E7%9A%84bean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F/"/>
    <url>/2022/11/01/spring/Spring%E4%B8%AD%E7%9A%84bean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>不是线程安全的</strong></p></blockquote><p>Spring容器中的Bean是否线程安全，容器本身并没有提供Bean的线程安全策略，因此可以说Spring容器中的Bean本身不具备线程安全的特性，但是具体还是要结合具体scope的Bean去研究。</p><p>Spring 的 bean 作用域（scope）类型  </p><ol><li>singleton:单例，默认作用域。</li><li>prototype:原型，每次创建一个新对象。</li><li>request:请求，每次Http请求创建一个新对象，适用于WebApplicationContext环境下。</li><li>session:会话，同一个会话共享一个实例，不同会话使用不用的实例。</li><li>global-session:全局会话，所有会话共享一个实例。</li></ol><p>线程安全这个问题，要从单例与原型Bean分别进行说明。</p><blockquote><p>对于原型Bean,每次创建一个新对象，也就是线程之间并不存在Bean共享，自然是不会有线程安全的问题。</p><p>对于单例Bean,所有线程都共享一个单例实例Bean,因此是存在资源的竞争。</p></blockquote><p>如果单例Bean,是一个无状态Bean，也就是线程中的操作不会对Bean的成员执行<strong>查询</strong>以外的操作，那么这个单例Bean是线程安全的。比如Spring mvc 的 Controller、Service、Dao等，这些Bean大多是无状态的，只关注于方法本身。</p><p><strong>spring单例，为什么controller、service和dao确能保证线程安全？</strong></p><p>Spring中的Bean默认是单例模式的，框架并没有对bean进行多线程的封装处理。<br>实际上大部分时间Bean是无状态的（比如Dao） 所以说在某种程度上来说Bean其实是安全的。<br>但是如果Bean是有状态的 那就需要开发人员自己来进行线程安全的保证，最简单的办法就是改变bean的作用域 把 <code>singleton</code>改为<code>protopyte</code> 这样每次请求Bean就相当于是 new Bean() 这样就可以保证线程的安全了。</p><blockquote><p>有状态就是有数据存储功能<br>无状态就是不会保存数据  　　</p></blockquote><p>controller、service和dao层本身并不是线程安全的，只是如果只是调用里面的方法，而且多线程调用一个实例的方法，会在内存中复制变量，这是自己的线程的工作内存，是安全的。</p><blockquote><p>想理解原理可以看看《深入理解JVM虚拟机》，2.2.2节：</p><p>Java虚拟机栈是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。</p></blockquote><blockquote><p>《Java并发编程实战》第3.2.2节：</p><p>局部变量的固有属性之一就是封闭在执行线程中。<br>它们位于执行线程的栈中，其他线程无法访问这个栈。</p></blockquote><p>所以其实任何无状态单例都是线程安全的。Spring的根本就是通过大量这种单例构建起系统，以事务脚本的方式提供服务</p><p>也可以看看这篇加深理解：<a href="https://blog.csdn.net/u012843361/article/details/84023869" title="关于Spring的@Controller @Service等的线程安全问题">关于Spring的@Controller @Service等的线程安全问题</a></p><p>首先问@Controller @Service是不是线程安全的？<br>默认配置下不是的。为啥呢？因为默认情况下@Controller没有加上@Scope，没有加@Scope就是默认值singleton，单例的。意思就是系统只会初始化一次Controller容器，所以每次请求的都是同一个Controller容器，当然是非线程安全的。举个栗子：</p><pre><code class="hljs">@RestControllerpublic class TestController &#123;    private int var = 0;        @GetMapping(value = &quot;/test_var&quot;)    public String test() &#123;        System.out.println(&quot;普通变量var:&quot; + (++var));        return &quot;普通变量var:&quot; + var ;    &#125;&#125;</code></pre><p>在postman里面发三次请求，结果如下：</p><pre><code class="hljs">普通变量var:1普通变量var:2普通变量var:3</code></pre><p>说明他不是线程安全的。怎么办呢？可以给他加上上面说的@Scope注解，如下：　　</p><pre><code class="hljs">@RestController@Scope(value = &quot;prototype&quot;) // 加上@Scope注解，他有2个取值：单例-singleton 多实例-prototypepublic class TestController &#123;    private int var = 0;        @GetMapping(value = &quot;/test_var&quot;)    public String test() &#123;        System.out.println(&quot;普通变量var:&quot; + (++var));        return &quot;普通变量var:&quot; + var ;    &#125;&#125;</code></pre><p>这样一来，每个请求都单独创建一个Controller容器，所以各个请求之间是线程安全的，三次请求结果：</p><pre><code class="hljs">普通变量var:1普通变量var:1普通变量var:1</code></pre><p>加了@Scope注解多的实例prototype是不是一定就是线程安全的呢？　　</p><pre><code class="hljs">@RestController@Scope(value = &quot;prototype&quot;) // 加上@Scope注解，他有2个取值：单例-singleton 多实例-prototypepublic class TestController &#123;    private int var = 0;    private static int staticVar = 0;    @GetMapping(value = &quot;/test_var&quot;)    public String test() &#123;        System.out.println(&quot;普通变量var:&quot; + (++var)+ &quot;---静态变量staticVar:&quot; + (++staticVar));        return &quot;普通变量var:&quot; + var + &quot;静态变量staticVar:&quot; + staticVar;    &#125;&#125;</code></pre><p>看三次请求结果：</p><pre><code class="hljs">普通变量var:1---静态变量staticVar:1普通变量var:1---静态变量staticVar:2普通变量var:1---静态变量staticVar:3</code></pre><p>虽然每次都是单独创建一个Controller但是扛不住他变量本身是static的呀，所以说呢，即便是加上@Scope注解也不一定能保证Controller 100%的线程安全。所以是否线程安全在于怎样去定义变量以及Controller的配置。所以来个全乎一点的实验，代码如下：　　</p><pre><code class="hljs">@RestController@Scope(value = &quot;singleton&quot;) // prototype singletonpublic class TestController &#123;    private int var = 0; // 定义一个普通变量        private static int staticVar = 0; // 定义一个静态变量    @Value(&quot;$&#123;test-int&#125;&quot;)    private int testInt; // 从配置文件中读取变量    ThreadLocal&lt;Integer&gt; tl = new ThreadLocal&lt;&gt;(); // 用ThreadLocal来封装变量    @Autowired    private User user; // 注入一个对象来封装变量    @GetMapping(value = &quot;/test_var&quot;)    public String test() &#123;        tl.set(1);        System.out.println(&quot;先取一下user对象中的值：&quot;+user.getAge()+&quot;===再取一下hashCode:&quot;+user.hashCode());        user.setAge(1);        System.out.println(&quot;普通变量var:&quot; + (++var) + &quot;===静态变量staticVar:&quot; + (++staticVar) + &quot;===配置变量testInt:&quot; + (++testInt)                + &quot;===ThreadLocal变量tl:&quot; + tl.get()+&quot;===注入变量user:&quot; + user.getAge());        return &quot;普通变量var:&quot; + var + &quot;,静态变量staticVar:&quot; + staticVar + &quot;,配置读取变量testInt:&quot; + testInt + &quot;,ThreadLocal变量tl:&quot;                + tl.get() + &quot;注入变量user:&quot; + user.getAge();    &#125;&#125;</code></pre><p>补充Controller以外的代码,config里面自己定义的Bean:User</p><pre><code class="hljs">@Configurationpublic class MyConfig &#123;    @Bean    public User user()&#123;        return new User();    &#125;&#125;</code></pre><p>我暂时能想到的定义变量的方法就这么多了，三次http请求结果如下：</p><pre><code class="hljs">先取一下user对象中的值：0===再取一下hashCode:241165852普通变量var:1===静态变量staticVar:1===配置变量testInt:1===ThreadLocal变量tl:1===注入变量user:1先取一下user对象中的值：1===再取一下hashCode:241165852普通变量var:2===静态变量staticVar:2===配置变量testInt:2===ThreadLocal变量tl:1===注入变量user:1先取一下user对象中的值：1===再取一下hashCode:241165852普通变量var:3===静态变量staticVar:3===配置变量testInt:3===ThreadLocal变量tl:1===注入变量user:1</code></pre><p>可以看到，在单例模式下Controller中只有用ThreadLocal封装的变量是线程安全的。为什么这样说呢？我们可以看到3次请求结果里面只有ThreadLocal变量值每次都是从0+1=1的，其他的几个都是累加的，而user对象呢，默认值是0，第二交取值的时候就已经是1了，关键他的hashCode是一样的，说明每次请求调用的都是同一个user对象。  </p><p>下面将TestController 上的@Scope注解的属性改一下改成多实例的：@Scope(value = “prototype”)，其他都不变，再次请求，结果如下：  </p><pre><code class="hljs">先取一下user对象中的值：0===再取一下hashCode:853315860普通变量var:1===静态变量staticVar:1===配置变量testInt:1===ThreadLocal变量tl:1===注入变量user:1先取一下user对象中的值：1===再取一下hashCode:853315860普通变量var:1===静态变量staticVar:2===配置变量testInt:1===ThreadLocal变量tl:1===注入变量user:1先取一下user对象中的值：1===再取一下hashCode:853315860普通变量var:1===静态变量staticVar:3===配置变量testInt:1===ThreadLocal变量tl:1===注入变量user:1</code></pre><p>分析这个结果发现，多实例模式下普通变量，取配置的变量还有ThreadLocal变量都是线程安全的，而静态变量和user（看他的hashCode都是一样的）对象中的变量都是非线程安全的。也就是说尽管TestController 是每次请求的时候都初始化了一个对象，但是静态变量始终是只有一份的，而且这个注入的user对象也是只有一份的。静态变量只有一份这是当然的咯，那么有没有办法让user对象可以每次都new一个新的呢？当然可以：  </p><pre><code class="hljs">public class MyConfig &#123;    @Bean    @Scope(value = &quot;prototype&quot;)    public User user()&#123;        return new User();    &#125;    &#125;</code></pre><p>在config里面给这个注入的Bean加上一个相同的注解<code>@Scope(value = &quot;prototype&quot;)</code>就可以了，再来请求一下看看：</p><pre><code class="hljs">先取一下user对象中的值：0===再取一下hashCode:1612967699普通变量var:1===静态变量staticVar:1===配置变量testInt:1===ThreadLocal变量tl:1===注入变量user:1先取一下user对象中的值：0===再取一下hashCode:985418837普通变量var:1===静态变量staticVar:2===配置变量testInt:1===ThreadLocal变量tl:1===注入变量user:1先取一下user对象中的值：0===再取一下hashCode:1958952789普通变量var:1===静态变量staticVar:3===配置变量testInt:1===ThreadLocal变量tl:1===注入变量user:1</code></pre><p>可以看到每次请求的user对象的hashCode都不是一样的，每次赋值前取user中的变量值也都是默认值0。  </p><p>下面总结一下：</p><ol><li>在@Controller/@Service等容器中，默认情况下，scope值是单例-singleton的，也是线程不安全的。  </li><li>尽量不要在@Controller/@Service等容器中定义静态变量，不论是单例(singleton)还是多实例(prototype)他都是线程不安全的。  </li><li>默认注入的Bean对象，在不设置scope的时候他也是线程不安全的。  </li><li>一定要定义变量的话，用ThreadLocal来封装，这个是线程安全的  </li></ol><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://www.cnblogs.com/myseries/p/11729800.html">Spring 中的bean 是线程安全的吗？</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式一致性 Raft 与 JRaft</title>
    <link href="/2022/10/31/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%20Raft%20%E4%B8%8E%20JRaft/"/>
    <url>/2022/10/31/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%80%E8%87%B4%E6%80%A7%20Raft%20%E4%B8%8E%20JRaft/</url>
    
    <content type="html"><![CDATA[<h2 id="如何理解分布式共识"><a href="#如何理解分布式共识" class="headerlink" title="如何理解分布式共识?"></a>如何理解分布式共识?</h2><ul><li>  <strong>多个参与者</strong> 针对 <strong>某一件事</strong> 达成完全 <strong>一致</strong> ：一件事，一个结论</li><li>  已达成一致的结论，不可推翻</li></ul><h2 id="有哪些分布式共识算法"><a href="#有哪些分布式共识算法" class="headerlink" title="有哪些分布式共识算法?"></a>有哪些分布式共识算法?</h2><ul><li>  Paxos：被认为是分布式共识算法的根本，其他都是其变种，但是 paxos 论文中只给出了单个提案的过程，并没有给出复制状态机中需要的 multi-paxos 的相关细节的描述，实现 paxos 具有很高的工程复杂度（如多点可写，允许日志空洞等）</li><li>  Zab：被应用在 zookeeper 中，业界使用广泛，但没有抽象成通用的 library</li><li>  Raft：以容易理解著称，业界也涌现出很多 raft 实现，比如大名鼎鼎的 etcd, braft, tikv 等</li></ul><h1 id="什么是-Raft？"><a href="#什么是-Raft？" class="headerlink" title="什么是 Raft？"></a>什么是 Raft？</h1><p><a href="https://raft.github.io/">Raft</a> 是一种更易于理解的分布式共识算法，核心协议本质上还是师承 paxos 的精髓，不同的是依靠 raft 模块化的拆分以及更加简化的设计，raft 协议相对更容易实现。</p><p>模块化的拆分主要体现在：Raft 把一致性协议划分为 Leader 选举、MemberShip 变更、日志复制、Snapshot 等几个几乎完全解耦的模块</p><p>更加简化的设计则体现在：Raft 不允许类似 paxos 中的乱序提交、简化系统中的角色状态（只有 Leader、Follower、Candidate三种角色）、限制仅 Leader 可写入、使用随机化的超时时间来设计 Leader Election 等等</p><h2 id="特点：Strong-Leader"><a href="#特点：Strong-Leader" class="headerlink" title="特点：Strong Leader"></a>特点：Strong Leader</h2><ol><li> 系统中必须存在且同一时刻只能有一个 leader，只有 leader 可以接受 clients 发过来的请求</li><li> Leader 负责主动与所有 followers 通信，负责将’提案’发送给所有 followers，同时收集多数派的 followers 应答</li><li> Leader 还需向所有 followers 主动发送心跳维持领导地位(保持存在感)</li></ol><p>一句话总结 Strong Leader: <strong>“你们不要 BB! 按我说的做，做完了向我汇报!”</strong> 另外，身为 leader 必须保持一直 BB(heartbeat) 的状态，否则就会有别人跳出来想要 BB</p><p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*5Cw5Qp1oyYQAAAAAAAAAAABjARQnAQ" alt="strong-leader.png | left | 350x250"></p><h2 id="复制状态机"><a href="#复制状态机" class="headerlink" title="复制状态机"></a>复制状态机</h2><p>对于一个无限增长的序列 a[1, 2, 3…]，如果对于任意整数 i，a[i] 的值满足分布式一致性，这个系统就满足一致性状态机的要求 基本上所有的真实系统都会有源源不断的操作，这时候单独对某个特定的值达成一致显然是不够的。为了让真实系统保证所有的副本的一致性，通常会把操作转化为 <a href="https://en.wikipedia.org/wiki/Write-ahead_logging">write-ahead-log</a>(WAL)。然后让系统中所有副本对 WAL 保持一致，这样每个副本按照顺序执行 WAL 里的操作，就能保证最终的状态是一致的</p><p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*OiwGTZnO2uMAAAAAAAAAAABjARQnAQ" alt="st.png | left | 450x250"></p><ol><li> Client 向 leader 发送写请求</li><li> Leader 把’操作’转化为 WAL 写本地 log 的同时也将 log 复制到所有 followers</li><li> Leader 收到多数派应答, 将 log 对应的’操作’ 应用到状态机</li><li> 回复 client 处理结果</li></ol><h2 id="Raft-中的基本概念"><a href="#Raft-中的基本概念" class="headerlink" title="Raft 中的基本概念"></a>Raft 中的基本概念</h2><h3 id="Raft-node-的-3-种角色-状态"><a href="#Raft-node-的-3-种角色-状态" class="headerlink" title="Raft-node 的 3 种角色/状态"></a>Raft-node 的 3 种角色/状态</h3><p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*EK6gQYwiBXkAAAAAAAAAAABjARQnAQ" alt="raft-node | left | 400x250"></p><ol><li> Follower：完全被动，不能发送任何请求，只接受并响应来自 leader 和 candidate 的 message，每个节点启动后的初始状态一定是 follower</li><li> Leader：处理所有来自客户端的请求，以及复制 log 到所有 followers</li><li> Candidate：用来竞选一个新 leader （candidate 由 follower 触发超时而来）</li></ol><h3 id="Message-的-3-种类型"><a href="#Message-的-3-种类型" class="headerlink" title="Message 的 3 种类型"></a>Message 的 3 种类型</h3><ol><li> RequestVote RPC：由 candidate 发出，用于发送投票请求</li><li> AppendEntries (Heartbeat) RPC：由 leader 发出，用于 leader 向 followers 复制日志条目，也会用作 Heartbeat （日志条目为空即为 Heartbeat）</li><li> InstallSnapshot RPC：由 leader 发出，用于快照传输，虽然多数情况都是每个服务器独立创建快照，但是leader 有时候必须发送快照给一些落后太多的 follower，这通常发生在 leader 已经丢弃了下一条要发给该follower 的日志条目(Log Compaction 时清除掉了) 的情况下</li></ol><h3 id="任期逻辑时钟"><a href="#任期逻辑时钟" class="headerlink" title="任期逻辑时钟"></a>任期逻辑时钟</h3><ol><li> 时间被划分为一个个任期 (term)，term id 按时间轴单调递增</li><li> 每一个任期的开始都是 leader 选举，选举成功之后，leader 在任期内管理整个集群，也就是 <strong>‘选举 + 常规操作’</strong></li><li> 每个任期最多一个 leader，可能没有 leader (spilt-vote 导致)</li></ol><p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*CTpYRa_CB_4AAAAAAAAAAABjARQnAQ" alt="term.png | left | 500x200"></p><h2 id="Raft-功能分解"><a href="#Raft-功能分解" class="headerlink" title="Raft 功能分解"></a>Raft 功能分解</h2><h3 id="Leader-选举"><a href="#Leader-选举" class="headerlink" title="Leader 选举"></a>Leader 选举</h3><ul><li>  超时驱动：Heartbeat/Election timeout</li><li>  随机的超时时间：降低选举碰撞导致选票被瓜分的概率</li><li>选举流程：<ul><li>Follower –&gt; Candidate (选举超时触发)<ul><li>  赢得选举：Candidate –&gt; Leader</li><li>  另一个节点赢得选举：Candidate –&gt; Follower</li><li>  一段时间内没有任何节点器赢得选举：Candidate –&gt; Candidate</li></ul></li></ul></li><li>选举动作：<ul><li>  Current term++</li><li>  发送 RequestVote RPC</li></ul></li><li>New Leader 选取原则 (最大提交原则)<ul><li>  Candidates include log info in RequestVote RPCs(index &amp; term of last log entry)</li><li>  During elections, choose candidate with log most likely to contain all committed entries</li><li>  Voting server V denies vote if its log is “more complete”: (lastTermV &gt; lastTermC) || ((lastTermV == lastTermC) &amp;&amp; (lastIndexV &gt; lastIndexC))</li><li>  Leader will have “most complete” log among electing majority</li></ul></li><li>  安全性：一个 term，最多选出一个 leader，可以没 leader，下一个 term 再选</li></ul><p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*vC1PR4snguoAAAAAAAAAAABjARQnAQ" alt="safe-term | left | 450x80"></p><ul><li>影响 raft 选举成功率的几个时间参数：<ul><li>  RTT(Round Trip Time)：网络延时</li><li>  Heartbeat timeout：心跳间隔，通常应该比 election timeout 小一个数量级，目的是让 leader 能够持续发送心跳来阻止 followers 触发选举</li><li>  Election timeout：Leader 与 followers 间通信超时触发选举的时间</li><li>  MTBF(Meantime Between Failure)：Servers 连续常规故障时间间隔 <code>RTT &lt;&lt; Heartbeat timeout &lt; Election timeout(ET) &lt;&lt; MTBF</code></li></ul></li><li>  随机选主触发时间：<code>Random(ET, 2ET)</code></li></ul><h3 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h3><p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*dY0aTYArhPIAAAAAAAAAAABjARQnAQ" alt="log-replication | left | 450x200"></p><ul><li>Raft 日志格式<ul><li>  <code>(TermId, LogIndex, LogValue)</code></li><li>  其中 <code>(TermId, LogIndex)</code> 能确定唯一一条日志</li></ul></li><li>Log replication 关键点<ul><li>  连续性：日志不允许出现空洞</li><li>有效性：<ul><li>  不同节点，拥有相同 term 和 logIndex 的日志 value 一定相同</li><li>  Leader 上的日志一定是有效的</li><li>  Follower 上的日志是否有效，通过 leader 日志对比判断</li></ul></li></ul></li><li>Followers 日志有效性检查<ul><li>  AppendEntries RPC 中还会携带前一条日志的唯一标识 <code>(prevTermId, prevLogIndex)</code></li><li>  递归推导</li></ul></li><li>Followers 日志恢复<ul><li>  Leader 将 nextIndex 递减并重发 AppendEntries，直到与 leader 日志一致</li></ul></li></ul><p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*8xqPR7ZR7EsAAAAAAAAAAABjARQnAQ" alt="log-replication-2.png | left | 400x150"></p><h3 id="Commit-Index-推进"><a href="#Commit-Index-推进" class="headerlink" title="Commit Index 推进"></a>Commit Index 推进</h3><ul><li>CommitIndex <code>(TermId, LogIndex)</code>：<ul><li>  所谓 commitIndex，就是已达成多数派，可以应用到状态机的最新的日志位置</li><li>  日志被复制到 followers 后，先持久化，并不能马上被应用到状态机</li><li>  只有 leader 知道日志是否达成多数派，是否可以应用到状态机</li><li>  Followers 记录 leader 发来的当前 commitIndex，所有小于等于 commitIndex 的日志均可以应用到状态机</li></ul></li><li>CommitIndex推进：<ul><li>  Leader 在下一个 AppendEntries RPC (也包括 Heartbeat)中携带当前的 commitIndex</li><li>  Followers 检查日志有效性通过则接受 AppendEntries 并同时更新本地 commitIndex，最后把所有小于等于 commitIndex 的日志应用到状态机</li></ul></li></ul><h3 id="AppendEntries-RPC"><a href="#AppendEntries-RPC" class="headerlink" title="AppendEntries RPC"></a>AppendEntries RPC</h3><ul><li>  完整信息: (currentTerm, logEntries[], prevTerm, prevLogIndex, commitTerm, commitLogIndex)</li><li>  currentTerm, logEntries[]：日志信息，为了效率，日志通常为多条</li><li>  prevTerm, prevLogIndex：日志有效性检查</li><li>  commitTerm, commitLogIndex：最新的提交日志位点(commitIndex)</li></ul><h3 id="阶段小结：现在我们能用-raft-做什么"><a href="#阶段小结：现在我们能用-raft-做什么" class="headerlink" title="阶段小结：现在我们能用 raft 做什么?"></a>阶段小结：现在我们能用 raft 做什么?</h3><ul><li>  连续确定多个提案，确保集群中各个系统节点状态完全一致</li><li>  自动选主，保证在只有少数派宕机的情况下持续可用</li><li>  日志强同步，宕机后零数据丢失</li></ul><h1 id="什么是-JRaft？"><a href="#什么是-JRaft？" class="headerlink" title="什么是 JRaft？"></a>什么是 JRaft？</h1><p>JRaft 是一个基于 <a href="https://raft.github.io/">RAFT</a> 一致性算法的生产级高性能 Java 实现，支持 MULTI-RAFT-GROUP，适用于高负载低延迟的场景。 使用 JRaft 你可以专注于自己的业务领域，由 JRaft 负责处理所有与 RAFT 相关的技术难题，并且 JRaft 非常易于使用，你可以通过几个示例在很短的时间内掌握它。</p><p>JRaft 是从百度的 <a href="https://github.com/brpc/braft">braft</a> 移植而来，做了一些优化和改进，感谢百度 braft 团队开源了如此优秀的 C++ RAFT 实现</p><h2 id="JRaft-整体功能-amp-性能优化"><a href="#JRaft-整体功能-amp-性能优化" class="headerlink" title="JRaft 整体功能&amp;性能优化"></a>JRaft 整体功能&amp;性能优化</h2><p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*68HaTJZQxVUAAAAAAAAAAABjARQnAQ" alt="feature | left | 500x450"></p><h3 id="功能支持"><a href="#功能支持" class="headerlink" title="功能支持"></a>功能支持</h3><ul><li>  Leader election：Leader 选举，这个不多说，上面已介绍过 raft 中的 leader 机制</li><li>Log replication and recovery：日志复制和日志恢复<ul><li>  Log replication 就是要保证已经被 commit 的数据一定不会丢失，即一定要成功复制到多数派</li><li>Log recovery 包含两个方面：<ul><li>Current term 日志恢复<ul><li>  主要针对一些 follower 节点重启加入集群或者是新增 follower 节点后如何追日志</li></ul></li><li>Prev term 日志恢复<ul><li>  主要针对 leader 切换前后的日志一致性</li></ul></li></ul></li></ul></li><li>  Snapshot and log compaction：定时生成 snapshot，实现 log compaction 加速启动和恢复，以及 InstallSnapshot 给 followers 拷贝数据，如下图：</li></ul><p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*a3xDT5mfSP4AAAAAAAAAAABjARQnAQ" alt="snapshot.png | left | 250x200"></p><ul><li>  Membership change：用于集群线上配置变更，比如增加节点、删除节点、替换节点等</li><li>  Transfer leader：主动变更 leader，用于重启维护，leader 负载平衡等</li><li>Symmetric network partition tolerance：对称网络分区容忍性  <img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*N_rBQ6oKsv4AAAAAAAAAAABjARQnAQ" alt="symmetric-net-partition-tolerance | left | 200x150">  如上图 S1 为当前 leader，网络分区造成 S2 不断增加本地 term，为了避免网络恢复后 S2 发起选举导致正在工作的 leader step-down，从而导致整个集群重新发起选举，JRaft 中增加了 pre-vote 来避免这个问题的发生。<ul><li>  JRaft 中在 request-vote 之前会先进行 pre-vote(currentTerm + 1, lastLogIndex, lastLogTerm)，多数派成功后才会转换状态为 candidate 发起真正的 request-vote，所以分区后的节点，pre-vote 不会成功，也就不会导致集群一段时间内无法正常提供服务</li></ul></li><li>Asymmetric network partition tolerance：非对称网络分区容忍性  <img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*sHgoQa2jywwAAAAAAAAAAABjARQnAQ" alt="asymmetric-net-partition-tolerance | left | 200x150">  如上图 S1 为当前 leader，S2 不断超时触发选主，S3 提升 term 打断当前 lease，从而拒绝 leader 的更新。<ul><li>  在 JRaft 中增加了一个 tick 的检查，每个 follower 维护一个时间戳记录下收到 leader 上数据更新的时间(也包括心跳)，只有超过 election timeout 之后才允许接受 request-vote 请求</li></ul></li><li>Fault tolerance：容错性，少数派故障不影响系统整体可用性，包括但不限于：<ul><li>  机器掉电</li><li>  强杀应用</li><li>  慢节点(GC, OOM 等)</li><li>  网络故障</li><li>  其他各种奇葩原因导致 raft 节点无法正常工作</li></ul></li><li>Workaround when quorate peers are dead：多数派故障时，整个 grop 已不具备可用性，安全的做法是等待多数节点恢复，只有这样才能保证数据安全；但是如果业务更加追求系统可用性，可以放弃数据一致性的话，JRaft 提供了手动触发 reset_peers 的指令以迅速重建整个集群，恢复集群可用</li><li>Metrics：JRaft 内置了基于 <a href="https://metrics.dropwizard.io/4.0.0/getting-started.html">metrics</a> 类库的性能指标统计，具有丰富的性能统计指标，利用这些指标数据可以帮助用户更容易找出系统性能瓶颈</li><li>Jepsen：除了几百个单元测试以及部分 chaos 测试之外, JRaft 还使用 <a href="https://github.com/jepsen-io/jepsen">jepsen</a> 这个分布式验证和故障注入测试框架模拟了很多种情况，都已验证通过：<ul><li>  随机分区，一大一小两个网络分区</li><li>  随机增加和移除节点</li><li>  随机停止和启动节点</li><li>  随机 kill -9 和启动节点</li><li>  随机划分为两组，互通一个中间节点，模拟分区情况</li><li>  随机划分为不同的 majority 分组</li></ul></li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><p>除了功能上的完整性，JRaft 还做了很多性能方面的优化，这里有一份 KV 场景（get/put）的 <a href="https://github.com/alipay/sofa-jraft/wiki/Benchmark-%E6%95%B0%E6%8D%AE">benchmark</a> 数据, 在小数据包，读写比例为 9:1，保证线性一致读的场景下，三副本最高可以达到 40w+ 的 ops。</p><p>这里挑重点介绍几个优化点:</p><ul><li>Batch: 我们知道互联网两大优化法宝便是 cache 和 batch，JRaft 在 batch 上花了较大心思，整个链路几乎都是 batch 的，依靠 disruptor 的 MPSC 模型批量消费，对整体性能有着极大的提升，包括但不限于：<ul><li>  批量提交 task</li><li>  批量网络发送</li><li>本地 IO batch 写入<ul><li>  要保证日志不丢，一般每条 log entry 都要进行 fsync 同步刷盘，比较耗时，JRaft 中做了合并写入的优化</li></ul></li><li>  批量应用到状态机 需要说明的是，虽然 JRaft 中大量使用了 batch 技巧，但对单个请求的延时并无任何影响，JRaft 中不会对请求做延时的攒批处理</li></ul></li><li>  Replication pipeline：流水线复制，通常 leader 跟 followers 节点的 log 同步是串行 batch 的方式，每个 batch 发送之后需要等待 batch 同步完成之后才能继续发送下一批(ping-pong)，这样会导致较长的延迟。JRaft 中通过 leader 跟 followers 节点之间的 pipeline 复制来改进，非常有效降低了数据同步的延迟, 提高吞吐。经我们测试，开启 pipeline 可以将吞吐提升 30% 以上，详细数据请参照 <a href="https://github.com/alipay/sofa-jraft/wiki/Benchmark-%E6%95%B0%E6%8D%AE">benchmark</a></li><li>  Append log in parallel：在 JRaft 中 leader 持久化 log entries 和向 followers 发送 log entries 是并行的</li><li>  Fully concurrent replication：Leader 向所有 follwers 发送 log 也是完全相互独立和并发的</li><li>  Asynchronous：JRaft 中整个链路几乎没有任何阻塞，完全异步的，是一个完全的 callback 编程模型</li><li>  ReadIndex：优化 raft read 走 raft log 的性能问题，每次 read，仅记录 commitIndex，然后发送所有 peers heartbeat 来确认 leader 身份，如果 leader 身份确认成功，等到 appliedIndex &gt;= commitIndex，就可以返回 client read 了，基于 ReadIndex follower 也可以很方便的提供线性一致读，不过 commitIndex 是需要从 leader 那里获取，多了一轮 RPC；关于线性一致读文章后面会详细分析</li><li>  Lease Read：JRaft 还支持通过租约 (lease) 保证 leader 的身份，从而省去了 ReadIndex 每次 heartbeat 确认 leader 身份，性能更好，但是通过时钟维护 lease 本身并不是绝对的安全（时钟漂移问题，所以 JRaft 中默认配置是 ReadIndex，因为通常情况下 ReadIndex 性能已足够好</li></ul><h2 id="JRaft-设计"><a href="#JRaft-设计" class="headerlink" title="JRaft 设计"></a>JRaft 设计</h2><p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*b3tDQoaFCNkAAAAAAAAAAABjARQnAQ" alt="jraft-design | left | 700x550"></p><ul><li>  Node：Raft 分组中的一个节点，连接封装底层的所有服务，用户看到的主要服务接口，特别是 <code>apply(task)</code> 用于向 raft group 组成的复制状态机集群提交新任务应用到业务状态机</li><li>存储：上图靠下的部分均为存储相关<ul><li>Log 存储，记录 raft 用户提交任务的日志，将日志从 leader 复制到其他节点上。<ul><li>  LogStorage 是存储实现，默认实现基于 RocksDB 存储，你也可以很容易扩展自己的日志存储实现</li><li>  LogManager 负责对底层存储的调用，对调用做缓存、批量提交、必要的检查和优化</li></ul></li><li>  Metadata 存储，元信息存储，记录 raft 实现的内部状态，比如当前 term、投票给哪个节点等信息</li><li>Snapshot 存储，用于存放用户的状态机 snapshot 及元信息，可选。<ul><li>  SnapshotStorage 用于 snapshot 存储实现。</li><li>  SnapshotExecutor 用于 snapshot 实际存储、远程安装、复制的管理</li></ul></li></ul></li><li>状态机<ul><li>  StateMachine：用户核心逻辑的实现，核心是 <code>onApply(Iterator)</code> 方法, 应用通过 <code>Node#apply(task)</code> 提交的日志到业务状态机</li><li>  FSMCaller:封装对业务 StateMachine 的状态转换的调用以及日志的写入等,一个有限状态机的实现,做必要的检查、请求合并提交和并发处理等</li></ul></li><li>复制<ul><li>  Replicator：用于 leader 向 followers 复制日志，也就是 raft 中的 AppendEntries 调用，包括心跳存活检查等</li><li>  ReplicatorGroup：用于单个 raft group 管理所有的 replicator，必要的权限检查和派发</li></ul></li><li>RPC：RPC 模块用于节点之间的网络通讯<ul><li>  RPC Server：内置于 Node 内的 RPC 服务器，接收其他节点或者客户端发过来的请求，转交给对应服务处理</li><li>  RPC Client：用于向其他节点发起请求，例如投票、复制日志、心跳等</li></ul></li><li>  KV Store：KV Store 是各种 Raft 实现的一个典型应用场景，JRaft 中包含了一个嵌入式的分布式 KV 存储实现（JRaft-RheaKV）。</li></ul><h3 id="JRaft-Group"><a href="#JRaft-Group" class="headerlink" title="JRaft Group"></a>JRaft Group</h3><p>单个节点的 JRaft-node 是没什么实际意义的，下面是三副本的 JRaft 架构图</p><p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*1wYDQJvcbSEAAAAAAAAAAABjARQnAQ" alt="jraft-group | left | 700x550"></p><h3 id="JRaft-Multi-Group"><a href="#JRaft-Multi-Group" class="headerlink" title="JRaft Multi Group"></a>JRaft Multi Group</h3><p>单个 Raft group 是无法解决大流量的读写瓶颈的，JRaft 自然也要支持 multi-raft-group</p><p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*DFDHRbIAh0sAAAAAAAAAAABjARQnAQ" alt="jraft-multi-group | left | 700x550"></p><h2 id="JRaft-实现细节解析之高效的线性一致读"><a href="#JRaft-实现细节解析之高效的线性一致读" class="headerlink" title="JRaft 实现细节解析之高效的线性一致读"></a>JRaft 实现细节解析之高效的线性一致读</h2><p>什么是线性一致读? 所谓线性一致读，一个简单的例子就是在 t1 的时刻我们写入了一个值，那么在 t1 之后，我们一定能读到这个值，不可能读到 t1 之前的旧值 (想想 java 中的 volatile 关键字，说白了线性一致读就是在分布式系统中实现 java volatile 语义)</p><p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*hVE6RZ9SElEAAAAAAAAAAABjARQnAQ" alt="read-only-safe | left | 700x250"></p><p>如上图 Client A、B、C、D 均符合线性一致读，其中 D 看起来是 stale read，其实并不是，D 请求横跨了 3 个阶段，而读可能发生在任意时刻，所以读到 1 或 2 都行</p><p><strong>重要：接下来的讨论均基于一个大前提，就是业务状态机的实现必须是满足线性一致性的，简单说就是也要具有 java volatile 的语义</strong></p><ul><li>要实现线性一致读，首先我们简单直接一些，是否可以直接从当前 leader 节点读?<ul><li>  仔细一想，这显然行不通，因为你无法确定这一刻当前的 ‘leader’ 真的是 leader，比如在网络分区的情况下，它可能已经被推翻王朝却不自知</li></ul></li><li>最简单易懂的实现方式：同 ‘写’ 请求一样，’读’ 请求也走一遍 raft 协议 (raft log)  <img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*ofC8QJB_2McAAAAAAAAAAABjARQnAQ" alt="raft-log | left | 400x160"><ul><li>  这一定是可以的，但性能上显然不会太出色，走 raft log 不仅仅有日志落盘的开销，还有日志复制的网络开销，另外还有一堆的 raft ‘读日志’ 造成的磁盘占用开销，这在读比重很大的系统中通常是无法被接受的</li></ul></li><li>ReadIndex Read<ul><li>这是 raft 论文中提到的一种优化方案，具体来说：<ul><li>  (1) Leader 将自己当前 log 的 commitIndex 记录到一个 local 变量 ReadIndex 里面</li><li>  (2) 接着向 followers 发起一轮 heartbeat，如果半数以上节点返回了对应的 heartbeat response，那么 leader 就能够确定现在自己仍然是 leader (证明了自己是自己)</li><li>  (3) Leader 等待自己的状态机执行，直到 applyIndex 超过了 ReadIndex，这样就能够安全的提供 Linearizable Read 了，也不必管读的时刻是否 leader 已飘走 (思考：为什么等到 applyIndex 超过了 ReadIndex 就可以执行读请求?)</li><li>  (4) Leader 执行 read 请求，将结果返回给 Client</li></ul></li><li>通过ReadIndex，也可以很容易在 followers 节点上提供线性一致读：<ul><li>  Follower 节点向 leader 请求最新的 ReadIndex</li><li>  Leader 执行上面前 3 步的过程(确定自己真的是 leader)，并返回 ReadIndex 给 follower</li><li>  Follower 等待自己的 applyIndex 超过了 ReadIndex</li><li>  Follower 执行 read 请求，将结果返回给 client （JRaft 中可配置是否从 follower 读取，默认不打开）</li></ul></li><li>ReadIndex小结<ul><li>  相比较于走 raft log 的方式，ReadIndex 省去了磁盘的开销，能大幅度提升吞吐，结合 JRaft 的 batch + pipeline ack + 全异步机制，三副本的情况下 leader 读的吞吐可以接近于 RPC 的吞吐上限</li><li>  延迟取决于多数派中最慢的一个 heartbeat response，理论上对于降低延时的效果不会非常显著</li></ul></li></ul></li><li>Lease Read<ul><li>  Lease read 与 ReadIndex 类似，但更进一步，不仅省去了 log，还省去了网络交互。它可以大幅提升读的吞吐也能显著降低延时</li><li>  基本的思路是 leader 取一个比 election timeout 小的租期(最好小一个数量级)，在租约期内不会发生选举，这就确保了 leader 不会变，所以可以跳过 ReadIndex 的第二步，也就降低了延时。可以看到 Lease read 的正确性和时间是挂钩的，因此时间的实现至关重要，如果时钟漂移严重，这套机制就会有问题</li><li>实现方式：<ul><li>  定时 heartbeat 获得多数派响应，确认 leader 的有效性 (在 JRaft 中默认的 heartbeat 间隔是 election timeout 的十分之一)</li><li>  在租约有效时间内，可以认为当前 leader 是 raft group 内的唯一有效 leader，可忽略 ReadIndex 中的 heartbeat 确认步骤(2)</li><li>  Leader 等待自己的状态机执行，直到 applyIndex 超过了 ReadIndex，这样就能够安全的提供 Linearizable Read 了</li></ul></li></ul></li><li>更进一步：Wait Free<ul><li>  到目前为止 lease 省去了 ReadIndex 的第 2 步(heartbeat)，实际上还能再进一步，继续省去第 3 步</li><li>我们想想前面的实现方案的本质是什么：<ul><li>  首先我们定义两个状态：日志状态（log_state）和状态机状态（st_state），Leader 的 log_state 反映了当前 raft group 最新的数据状态，因为所有的写请求一定都先记录在 raft log 中</li><li>  当 leader 接收到 read_request 那一刻，以 log_state 作为逻辑时间参考点，等到 st_state 追上之前记录 log_state 时，显然 read_request 那个时间点的所有数据已经全部应用到状态机，自然是能保证线性一致读了(只要你的业务状态机能保证可见性)</li><li>  <strong>总结起来即是等待当前节点的状态机达到了接收 read_request 那一刻的时间点相同甚至更新的状态（applyIndex &gt;= commitIndex）</strong></li></ul></li><li>  通过以上分析可以看到 applyIndex &gt;= commitIndex 的约束其实很保守，<strong>本质上我们只要保证当前时刻，当前节点状态机一定是最新即可</strong></li><li>那么问题来了，leader 节点的状态机能保证一定是最新的吗?<ul><li>  首先 leader 节点的 log 一定是最新的，即使新选举产生的 leader，它也一定包含全部的 commit log，但它的状态机却可能落后于旧的 leader</li><li>  不过等到 leader 成功应用了自己当前 term 的第一条 log 之后，它的状态机就一定是最新的</li><li>  所以可以得出结论：当 leader 已经成功应用了自己 term 的第一条 log 之后，不需要再取 commitIndex，也不用等状态机，直接读，一定是线性一致读</li></ul></li><li>  小结：可以想象，Wait Free 机制将最大程度的降低读延迟，JRaft 暂未实现 wait free 这一优化, 不过已经在计划中</li></ul></li></ul><p>在 JRaft 中发起一次线性一致读请求的代码展示：</p><pre><code class="hljs">// KV 存储实现线性一致读public void readFromQuorum(String key, AsyncContext asyncContext) &#123;    // 请求 ID 作为请求上下文传入    byte[] reqContext = new byte[4];    Bits.putInt(reqContext, 0, requestId.incrementAndGet());    // 调用 readIndex 方法, 等待回调执行    this.node.readIndex(reqContext, new ReadIndexClosure() &#123;        @Override        public void run(Status status, long index, byte[] reqCtx) &#123;            if (status.isOk()) &#123;                try &#123;                    // ReadIndexClosure 回调成功，可以从状态机读取最新数据返回                    // 如果你的状态实现有版本概念，可以根据传入的日志 index 编号做读取                    asyncContext.sendResponse(new ValueCommand(fsm.getValue(key)));                &#125; catch (KeyNotFoundException e) &#123;                    asyncContext.sendResponse(GetCommandProcessor.createKeyNotFoundResponse());                &#125;            &#125; else &#123;                // 特定情况下，比如发生选举，该读请求将失败                asyncContext.sendResponse(new BooleanCommand(false, status.getErrorMsg()));            &#125;        &#125;    &#125;);&#125;</code></pre><h1 id="JRaft-应用场景？"><a href="#JRaft-应用场景？" class="headerlink" title="JRaft 应用场景？"></a>JRaft 应用场景？</h1><ol><li> Leader 选举</li><li> 分布式锁服务，比如 zookeeper，在 JRaft 中的 RheaKV 模块提供了完整的分布式锁实现</li><li> 高可靠的元信息管理，可直接基于 JRaft-RheaKV 存储</li><li> 分布式存储系统，如分布式消息队列、分布式文件系统、分布式块系统等等</li></ol><h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><ol><li> RheaKV：基于 JRaft 实现的嵌入式、分布式、高可用、强一致的 KV 存储类库</li><li> AntQ Streams QCoordinator：使用 JRaft 在 Coordinator 集群内做选举、使用 JRaft-RheaKV 做元信息存储等功能</li><li> Schema Registry：高可靠 schema 管理服务，类似 kafka schema registry，存储部分基于 JRaft-RheaKV</li><li> SOFA 服务注册中心元信息管理模块：IP 数据信息注册，要求写数据达到各个节点一致，并且在少数派节点挂掉时保证不影响数据正常存储</li></ol><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="一、基于-JRaft-设计一个简单的-KV-Store"><a href="#一、基于-JRaft-设计一个简单的-KV-Store" class="headerlink" title="一、基于 JRaft 设计一个简单的 KV Store"></a>一、基于 JRaft 设计一个简单的 KV Store</h3><p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*D1N5TZSqQlgAAAAAAAAAAABjARQnAQ" alt="kv | left | 700x550"></p><h3 id="二、基于-JRaft-的-RheaKV-的设计"><a href="#二、基于-JRaft-的-RheaKV-的设计" class="headerlink" title="二、基于 JRaft 的 RheaKV 的设计"></a>二、基于 JRaft 的 RheaKV 的设计</h3><p><img src="https://gw.alipayobjects.com/mdn/rms_da499f/afts/img/A*6K1mTq0z-TkAAAAAAAAAAABjARQnAQ" alt="rheakv | left | 700x550"></p><h4 id="功能名词"><a href="#功能名词" class="headerlink" title="功能名词"></a>功能名词</h4><p><strong>PD</strong> 全局的中心总控节点，负责整个集群的调度，不需要自管理的集群可不启用 PD (一个 PD 可管理多个集群，基于 clusterId 隔离)</p><p><strong>Store</strong> 集群中的一个物理存储节点，一个 store 包含一个或多个 region</p><p><strong>Region</strong> 最小的 KV 数据单元，每个 region 都有一个左闭右开的区间 [startKey, endKey), 可根据请求流量/负载/数据量大小等指标自动分裂以及自动副本搬迁</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>  嵌入式</li><li>  强一致性</li><li>自驱动<ul><li>  自诊断, 自优化, 自决策</li></ul></li></ul><p>以上几点(尤其2，3) 基本都是依托于 JRaft 自身的功能来实现，详细介绍请参考 JRaft 文档</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://www.sofastack.tech/projects/sofa-jraft/consistency-raft-jraft/">分布式一致性 Raft 与 JRaft</a></li><li><a href="https://github.com/alipay/sofa-jraft">JRaft 源码</a></li><li><a href="https://raft.github.io/">https://raft.github.io/</a></li><li><a href="https://raft.github.io/slides/raftuserstudy2013.pdf">https://raft.github.io/slides/raftuserstudy2013.pdf</a></li><li><a href="https://github.com/hedengcheng/tech/tree/master/distributed">Paxos/Raft：分布式一致性算法原理剖析及其在实战中的应用</a></li><li><a href="https://github.com/brpc/braft/blob/master/docs/cn/raft_protocol.md">braft 文档</a></li><li><a href="https://pingcap.com/blog-cn/linearizability-and-raft/">https://pingcap.com/blog-cn/linearizability-and-raft/</a></li><li><a href="https://aphyr.com/posts/313-strong-consistency-models">https://aphyr.com/posts/313-strong-consistency-models</a></li><li><a href="https://zhuanlan.zhihu.com/p/51063866">https://zhuanlan.zhihu.com/p/51063866</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Raft</tag>
      
      <tag>算法</tag>
      
      <tag>JRaft</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RestTemplate为何必须搭配MultiValueMap</title>
    <link href="/2022/10/31/spring/RestTemplate%E4%B8%BA%E4%BD%95%E5%BF%85%E9%A1%BB%E6%90%AD%E9%85%8DMultiValueMap/"/>
    <url>/2022/10/31/spring/RestTemplate%E4%B8%BA%E4%BD%95%E5%BF%85%E9%A1%BB%E6%90%AD%E9%85%8DMultiValueMap/</url>
    
    <content type="html"><![CDATA[<p>微服务之间的大多都是使用 HTTP 通信，这自然少不了使用 HttpClient。<br>在不使用 Spring 前，一般使用 Apache HttpClient 和 Ok HttpClient 等，而一旦引入 Spring，就有了更好选择 - RestTemplate。</p><p>接口：</p><pre><code class="hljs">@PostMapping(&quot;/restTempReq&quot;)public String restTempReq(@RequestParam(&quot;para1&quot;) String para1,                          @RequestParam(&quot;para2&quot;) String para2) &#123;    return &quot;The param is :&quot; + para1 + &quot;,&quot; + para2;&#125;</code></pre><p>想接受一个 Form 表单请求，读取表单定义的两个参数 para1 和 para2，然后作为响应返回给客户端。</p><p>定义完接口后，使用 RestTemplate 来发送一个这样的表单请求，代码示例如下：</p><pre><code class="hljs">@SpringBootApplicationpublic class YydsApplication &#123;    public static void main(String[] args) &#123;        ConfigurableApplicationContext context = SpringApplication.run(YydsApplication.class, args);            RestTemplate restTemplate = new RestTemplate();        Map&lt;String, Object&gt; paramMap = new HashMap&lt;&gt;();        paramMap.put(&quot;para1&quot;, &quot;001&quot;);        paramMap.put(&quot;para2&quot;, &quot;002&quot;);            String url = &quot;http://localhost:8080/reqType/restTempReq/&quot;;        String result = restTemplate.postForObject(url, paramMap, String.class);        System.out.println(result);            context.close();    &#125;&#125;</code></pre><p>上述代码定义了一个 Map，包含了 2 个表单参数，然后使用 RestTemplate 的 postForObject 提交这个表单。<br>执行代码提示 400 错误，即请求出错：</p><p><img src="img.png"></p><p>就是缺少 para1 表单参数，why？</p><p>解析<br>RestTemplate 提交的表单，最后提交请求啥样？ 可以抓包看下请求 Content-Type: application/json</p><p>实际上是将定义的表单数据以 JSON 提交过去了，所以我们的接口处理自然取不到任何表单参数。<br>why？怎么变成 JSON 请求体提交数据呢？注意 RestTemplate 执行调用栈：</p><p>最终使用的 Jackson 工具序列化了表单</p><p>用到 JSON 的关键原因在</p><pre><code class="hljs">RestTemplate.HttpEntityRequestCallback#doWithRequest        public void doWithRequest(ClientHttpRequest httpRequest) throws IOException &#123;            super.doWithRequest(httpRequest);            Object requestBody = this.requestEntity.getBody();            if (requestBody == null) &#123;                HttpHeaders httpHeaders = httpRequest.getHeaders();                HttpHeaders requestHeaders = this.requestEntity.getHeaders();                if (!requestHeaders.isEmpty()) &#123;                    requestHeaders.forEach((key, values) -&gt; &#123;                        httpHeaders.put(key, new ArrayList(values));                    &#125;);                &#125;                    if (httpHeaders.getContentLength() &lt; 0L) &#123;                    httpHeaders.setContentLength(0L);                &#125;                &#125; else &#123;                Class&lt;?&gt; requestBodyClass = requestBody.getClass();                Type requestBodyType = this.requestEntity instanceof RequestEntity ? ((RequestEntity)this.requestEntity).getType() : requestBodyClass;                HttpHeaders httpHeadersx = httpRequest.getHeaders();                HttpHeaders requestHeadersx = this.requestEntity.getHeaders();                MediaType requestContentType = requestHeadersx.getContentType();                Iterator var8 = RestTemplate.this.getMessageConverters().iterator();                    while(var8.hasNext()) &#123;                    HttpMessageConverter&lt;?&gt; messageConverter = (HttpMessageConverter)var8.next();                    if (messageConverter instanceof GenericHttpMessageConverter) &#123;                        GenericHttpMessageConverter&lt;Object&gt; genericConverter = (GenericHttpMessageConverter)messageConverter;                        if (genericConverter.canWrite((Type)requestBodyType, requestBodyClass, requestContentType)) &#123;                            if (!requestHeadersx.isEmpty()) &#123;                                requestHeadersx.forEach((key, values) -&gt; &#123;                                    httpHeadersx.put(key, new ArrayList(values));                                &#125;);                            &#125;                                this.logBody(requestBody, requestContentType, genericConverter);                            genericConverter.write(requestBody, (Type)requestBodyType, requestContentType, httpRequest);                            return;                        &#125;                    &#125; else if (messageConverter.canWrite(requestBodyClass, requestContentType)) &#123;                        if (!requestHeadersx.isEmpty()) &#123;                            requestHeadersx.forEach((key, values) -&gt; &#123;                                httpHeadersx.put(key, new ArrayList(values));                            &#125;);                        &#125;                            this.logBody(requestBody, requestContentType, messageConverter);                        messageConverter.write(requestBody, requestContentType, httpRequest);                        return;                    &#125;                &#125;                    String message = &quot;No HttpMessageConverter for &quot; + requestBodyClass.getName();                if (requestContentType != null) &#123;                    message = message + &quot; and content type &quot;&quot; + requestContentType + &quot;&quot;&quot;;                &#125;                    throw new RestClientException(message);            &#125;        &#125;</code></pre><p>根据当前要提交的 Body 内容，遍历当前支持的所有编解码器:</p><p>若找到合适编解码器，用之完成 Body 转化<br>看下 JSON 的编解码器对是否合适的判断</p><pre><code class="hljs">AbstractJackson2HttpMessageConverter#canWrite    public boolean canWrite(Class&lt;?&gt; clazz, @Nullable MediaType mediaType) &#123;        if (!this.canWrite(mediaType)) &#123;            return false;        &#125; else &#123;            if (mediaType != null &amp;&amp; mediaType.getCharset() != null) &#123;                Charset charset = mediaType.getCharset();                if (!ENCODINGS.containsKey(charset.name())) &#123;                    return false;                &#125;            &#125;                ObjectMapper objectMapper = this.selectObjectMapper(clazz, mediaType);            if (objectMapper == null) &#123;                return false;            &#125; else &#123;                AtomicReference&lt;Throwable&gt; causeRef = new AtomicReference();                if (objectMapper.canSerialize(clazz, causeRef)) &#123;                    return true;                &#125; else &#123;                    this.logWarningIfNecessary(clazz, (Throwable)causeRef.get());                    return false;                &#125;            &#125;        &#125;    &#125;</code></pre><p>可见，当使用的 Body 为 HashMap，是可完成 JSON 序列化的。<br>所以后续将这个表单序列化为请求 Body了。</p><p>但我还是疑问，为何适应表单处理的编解码器不行？<br>那就该看编解码器判断是否支持的实现：</p><pre><code class="hljs">FormHttpMessageConverter#canWrite    public boolean canWrite(Class&lt;?&gt; clazz, @Nullable MediaType mediaType) &#123;        if (!MultiValueMap.class.isAssignableFrom(clazz)) &#123;            return false;        &#125; else if (mediaType != null &amp;&amp; !MediaType.ALL.equals(mediaType)) &#123;            Iterator var3 = this.getSupportedMediaTypes().iterator();                MediaType supportedMediaType;            do &#123;                if (!var3.hasNext()) &#123;                    return false;                &#125;                    supportedMediaType = (MediaType)var3.next();            &#125; while(!supportedMediaType.isCompatibleWith(mediaType));                return true;        &#125; else &#123;            return true;        &#125;    &#125;</code></pre><p>可见只有当我们发送的 Body 是 MultiValueMap 才能使用表单来提交。<br>原来使用 RestTemplate 提交表单必须是 MultiValueMap！<br>而我们案例定义的就是普通的 HashMap，最终是按请求 Body 的方式发送出去的。</p><p>修正<br>换成 MultiValueMap 类型存储表单数据即可：</p><pre><code class="hljs">    MultiValueMap&lt;String, Object&gt; paramMap = new LinkedMultiValueMap&lt;&gt;();    paramMap.add(&quot;para1&quot;, &quot;001&quot;);    paramMap.add(&quot;para2&quot;, &quot;002&quot;);</code></pre><p>修正后，表单数据最终使用下面的代码进行了编码：</p><p>FormHttpMessageConverter#write</p><p><img src="img_1.png"></p><p>发送出的数据Content-Type: application/x-www-form-urlencoded;charset=UTF-8</p><p>这就对了！其实官方文档也说明了：</p><p><img src="img_2.png"></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://blog.csdn.net/qq_33589510/article/details/121527830">Spring RestTemplate为何必须搭配MultiValueMap？</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>MultiValueMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dubbo相关图</title>
    <link href="/2022/10/31/dubbo/dubbo%E5%9B%BE/"/>
    <url>/2022/10/31/dubbo/dubbo%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="consumer调用provider链路图"><a href="#consumer调用provider链路图" class="headerlink" title="consumer调用provider链路图"></a>consumer调用provider链路图</h1><p><img src="consumer.png"></p><h1 id="provider接收consumer调用后链路图"><a href="#provider接收consumer调用后链路图" class="headerlink" title="provider接收consumer调用后链路图"></a>provider接收consumer调用后链路图</h1><p><img src="provider.png"></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>-<a href="https://dubbo.apache.org/zh/docs/v2.7/dev/source/service-invoking-process/">服务调用过程</a></p>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>flatten-maven-plugin</title>
    <link href="/2022/10/31/maven/flatten-maven-plugin%EF%BC%9A%E5%A4%84%E7%90%86%E7%89%88%E6%9C%AC%E5%8D%A0%E4%BD%8D%E7%AC%A6/"/>
    <url>/2022/10/31/maven/flatten-maven-plugin%EF%BC%9A%E5%A4%84%E7%90%86%E7%89%88%E6%9C%AC%E5%8D%A0%E4%BD%8D%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p>自 Maven 3.5.0-beta-1 开始，可以使用 ${revision}, ${sha1} and/or ${changelist} 这样的变量作为版本占位符。</p><p>像这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.ci<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ci-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>First CI Friendly<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;revision&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">revision</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">revision</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p>或者像这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.ci<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ci-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>First CI Friendly<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;revision&#125;$&#123;sha1&#125;$&#123;changelist&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">revision</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">revision</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">changelist</span>&gt;</span>-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">changelist</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sha1</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br><br></code></pre></td></tr></table></figure><p>可以使用这样的命令</p><pre><code class="hljs">mvn -Drevision=2.7.8 -Dchangelist=-RELEASE -Dsha1=ssbd clean package</code></pre><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>Install / Deploy 时，版本占位符将不能被替换。这将导致 Install / Deploy 后， maven 不能识别。<br>使用 flatten-maven-plugin 解决这个问题。</p><h1 id="flatten-maven-plugin"><a href="#flatten-maven-plugin" class="headerlink" title="flatten-maven-plugin"></a>flatten-maven-plugin</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.ci<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ci-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>First CI Friendly<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;revision&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">revision</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">revision</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br> <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.mojo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>flatten-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">updatePomFile</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">updatePomFile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">flattenMode</span>&gt;</span>oss<span class="hljs-tag">&lt;/<span class="hljs-name">flattenMode</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>flatten<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>process-resources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>flatten<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>flatten.clean<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>clean<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>clean<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://blog.csdn.net/sayyy/article/details/103994302">【maven插件】flatten-maven-plugin ： 处理版本占位符</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>maven-plugin</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBeanLifeCycle</title>
    <link href="/2022/10/17/spring/SpringBeanLifeCycle/"/>
    <url>/2022/10/17/spring/SpringBeanLifeCycle/</url>
    
    <content type="html"><![CDATA[<p>Today we will look into Spring Bean Life Cycle. <strong>Spring Beans</strong> are the most important part of any Spring application. Spring <strong>ApplicationContext</strong> is responsible to initialize the Spring Beans defined in spring bean configuration file.</p><h2 id="Spring-Bean-Life-Cycle"><a href="#Spring-Bean-Life-Cycle" class="headerlink" title="Spring Bean Life Cycle"></a>Spring Bean Life Cycle</h2><p><a href="https://journaldev.nyc3.digitaloceanspaces.com/2014/04/spring-bean-life-cycle.jpg"><img src="https://journaldev.nyc3.digitaloceanspaces.com/2014/04/spring-bean-life-cycle.jpg" alt="spring bean life cycle"></a> </p><p>Spring Context is also responsible for <strong>injection dependencies</strong> in the bean, either through setter or constructor methods or by <strong>spring autowiring</strong>. Sometimes we want to initialize resources in the bean classes, for example creating database connections or validating third party services at the time of initialization before any client request. Spring framework provide different ways through which we can provide post-initialization and pre-destroy methods in a spring bean life cycle.</p><ol><li> By implementing <strong>InitializingBean</strong> and <strong>DisposableBean</strong> interfaces - Both these interfaces declare a single method where we can initialize/close resources in the bean. For post-initialization, we can implement <code>InitializingBean</code> interface and provide implementation of <code>afterPropertiesSet()</code> method. For pre-destroy, we can implement <code>DisposableBean</code> interface and provide implementation of <code>destroy()</code> method. These methods are the callback methods and similar to servlet listener implementations. This approach is simple to use but it’s not recommended because it will create tight coupling with the Spring framework in our bean implementations.</li><li> Providing <strong>init-method</strong> and <strong>destroy-method</strong> attribute values for the bean in the spring bean configuration file. This is the recommended approach because of no direct dependency to spring framework and we can create our own methods.</li></ol><p>Note that both <em>post-init</em> and <em>pre-destroy</em> methods should have no arguments but they can throw Exceptions. We would also require to get the bean instance from the spring application context for these methods invocation.</p><h3 id="PostConstruct-PreDestroy-Annotations"><a href="#PostConstruct-PreDestroy-Annotations" class="headerlink" title="@PostConstruct, @PreDestroy Annotations"></a>@PostConstruct, @PreDestroy Annotations</h3><p>Spring framework also support <code>@PostConstruct</code> and <code>@PreDestroy</code> annotations for defining post-init and pre-destroy methods. These annotations are part of <code>javax.annotation</code> package. However for these annotations to work, we need to configure our spring application to look for annotations. We can do this either by defining bean of type <code>org.springframework.context.annotation.CommonAnnotationBeanPostProcessor</code> or by <code>context:annotation-config</code> element in spring bean configuration file. Let’s write a simple Spring application to showcase the use of above configurations for spring bean life cycle management. Create a Spring Maven project in Spring Tool Suite, final project will look like below image. <a href="https://journaldev.nyc3.digitaloceanspaces.com/2014/04/spring-bean-life-cycle-project.png"><img src="https://journaldev.nyc3.digitaloceanspaces.com/2014/04/spring-bean-life-cycle-project-411x450.png" alt="spring bean life cycle example methods"></a></p><h3 id="Maven-Dependencies"><a href="#Maven-Dependencies" class="headerlink" title="Maven Dependencies"></a>Maven Dependencies</h3><p>We don’t need to include any extra dependencies for configuring spring bean life cycle methods, our pom.xml file is like any other standard spring maven project.</p><pre><code class="hljs">&lt;project xmlns=&quot;https://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;https://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;org.springframework.samples&lt;/groupId&gt;  &lt;artifactId&gt;SpringBeanLifeCycle&lt;/artifactId&gt;  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;properties&gt;        &lt;!-- Generic properties --&gt;        &lt;java.version&gt;1.7&lt;/java.version&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;        &lt;!-- Spring --&gt;        &lt;spring-framework.version&gt;4.0.2.RELEASE&lt;/spring-framework.version&gt;        &lt;!-- Logging --&gt;        &lt;logback.version&gt;1.0.13&lt;/logback.version&gt;        &lt;slf4j.version&gt;1.7.5&lt;/slf4j.version&gt;    &lt;/properties&gt;        &lt;dependencies&gt;        &lt;!-- Spring and Transactions --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring-framework.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;            &lt;version&gt;$&#123;spring-framework.version&#125;&lt;/version&gt;        &lt;/dependency&gt;        &lt;!-- Logging with SLF4J &amp; LogBack --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;            &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;            &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt;            &lt;scope&gt;compile&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;            &lt;version&gt;$&#123;logback.version&#125;&lt;/version&gt;            &lt;scope&gt;runtime&lt;/scope&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;/project&gt;</code></pre><h3 id="Model-Class"><a href="#Model-Class" class="headerlink" title="Model Class"></a>Model Class</h3><p>Let’s create a simple java bean class that will be used in service classes.</p><pre><code class="hljs">package com.journaldev.spring.bean;public class Employee &#123;    private String name;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    &#125;</code></pre><h3 id="InitializingBean-DisposableBean"><a href="#InitializingBean-DisposableBean" class="headerlink" title="InitializingBean, DisposableBean"></a>InitializingBean, DisposableBean</h3><p>Let’s create a service class where we will implement both the interfaces for post-init and pre-destroy methods.</p><pre><code class="hljs">package com.journaldev.spring.service;import org.springframework.beans.factory.DisposableBean;import org.springframework.beans.factory.InitializingBean;import com.journaldev.spring.bean.Employee;public class EmployeeService implements InitializingBean, DisposableBean&#123;    private Employee employee;    public Employee getEmployee() &#123;        return employee;    &#125;    public void setEmployee(Employee employee) &#123;        this.employee = employee;    &#125;        public EmployeeService()&#123;        System.out.println(&quot;EmployeeService no-args constructor called&quot;);    &#125;    @Override    public void destroy() throws Exception &#123;        System.out.println(&quot;EmployeeService Closing resources&quot;);    &#125;    @Override    public void afterPropertiesSet() throws Exception &#123;        System.out.println(&quot;EmployeeService initializing to dummy value&quot;);        if(employee.getName() == null)&#123;            employee.setName(&quot;Pankaj&quot;);        &#125;    &#125;&#125;</code></pre><h3 id="Custom-post-init-pre-destroy"><a href="#Custom-post-init-pre-destroy" class="headerlink" title="Custom post-init, pre-destroy"></a>Custom post-init, pre-destroy</h3><p>Since we don’t want our services to have direct spring framework dependency, let’s create another form of Employee Service class where we will have post-init and pre-destroy spring life cycle methods and we will configure them in the spring bean configuration file.</p><pre><code class="hljs">package com.journaldev.spring.service;import com.journaldev.spring.bean.Employee;public class MyEmployeeService&#123;    private Employee employee;    public Employee getEmployee() &#123;        return employee;    &#125;    public void setEmployee(Employee employee) &#123;        this.employee = employee;    &#125;        public MyEmployeeService()&#123;        System.out.println(&quot;MyEmployeeService no-args constructor called&quot;);    &#125;    //pre-destroy method    public void destroy() throws Exception &#123;        System.out.println(&quot;MyEmployeeService Closing resources&quot;);    &#125;    //post-init method    public void init() throws Exception &#123;        System.out.println(&quot;MyEmployeeService initializing to dummy value&quot;);        if(employee.getName() == null)&#123;            employee.setName(&quot;Pankaj&quot;);        &#125;    &#125;&#125;</code></pre><p>We will look into the spring bean configuration file in a bit. Before that let’s create another service class that will use @PostConstruct and @PreDestroy annotations.</p><h3 id="PostConstruct-PreDestroy"><a href="#PostConstruct-PreDestroy" class="headerlink" title="@PostConstruct, @PreDestroy"></a>@PostConstruct, @PreDestroy</h3><p>Below is a simple class that will be configured as spring bean and for post-init and pre-destroy methods, we are using @PostConstruct and @PreDestroy annotations.</p><pre><code class="hljs">package com.journaldev.spring.service;import javax.annotation.PostConstruct;import javax.annotation.PreDestroy;public class MyService &#123;    @PostConstruct    public void init()&#123;        System.out.println(&quot;MyService init method called&quot;);    &#125;        public MyService()&#123;        System.out.println(&quot;MyService no-args constructor called&quot;);    &#125;        @PreDestroy    public void destory()&#123;        System.out.println(&quot;MyService destroy method called&quot;);    &#125;&#125;</code></pre><h3 id="Configuration-File"><a href="#Configuration-File" class="headerlink" title="Configuration File"></a>Configuration File</h3><p>Let’s see how we will configure our beans in spring context file.</p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;https://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;https://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;!-- Not initializing employee name variable--&gt;&lt;bean name=&quot;employee&quot; class=&quot;com.journaldev.spring.bean.Employee&quot; /&gt;&lt;bean name=&quot;employeeService&quot; class=&quot;com.journaldev.spring.service.EmployeeService&quot;&gt;    &lt;property name=&quot;employee&quot; ref=&quot;employee&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean name=&quot;myEmployeeService&quot; class=&quot;com.journaldev.spring.service.MyEmployeeService&quot;        init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;    &lt;property name=&quot;employee&quot; ref=&quot;employee&quot;&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- initializing CommonAnnotationBeanPostProcessor is same as context:annotation-config --&gt;&lt;bean class=&quot;org.springframework.context.annotation.CommonAnnotationBeanPostProcessor&quot; /&gt;&lt;bean name=&quot;myService&quot; class=&quot;com.journaldev.spring.service.MyService&quot; /&gt;&lt;/beans&gt;</code></pre><p>Notice that I am not initializing employee name in it’s bean definition. Since EmployeeService is using interfaces, we don’t need any special configuration here. For MyEmployeeService bean, we are using init-method and destroy-method attributes to let spring framework know our custom methods to execute. MyService bean configuration doesn’t have anything special, but as you can see that I am enabling annotation based configuration for this. Our application is ready, let’s write a test program to see how different methods get executed.</p><h3 id="Test-Program"><a href="#Test-Program" class="headerlink" title="Test Program"></a>Test Program</h3><pre><code class="hljs">package com.journaldev.spring.main;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.journaldev.spring.service.EmployeeService;import com.journaldev.spring.service.MyEmployeeService;public class SpringMain &#123;    public static void main(String[] args) &#123;        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);        System.out.println(&quot;Spring Context initialized&quot;);                //MyEmployeeService service = ctx.getBean(&quot;myEmployeeService&quot;, MyEmployeeService.class);        EmployeeService service = ctx.getBean(&quot;employeeService&quot;, EmployeeService.class);        System.out.println(&quot;Bean retrieved from Spring Context&quot;);                System.out.println(&quot;Employee Name=&quot;+service.getEmployee().getName());                ctx.close();        System.out.println(&quot;Spring Context Closed&quot;);    &#125;&#125;</code></pre><p>When we run above test program, we get below output.</p><pre><code class="hljs">Apr 01, 2014 10:50:50 PM org.springframework.context.support.ClassPathXmlApplicationContext prepareRefreshINFO: Refreshing org[email protected]c1b9b03: startup date [Tue Apr 01 22:50:50 PDT 2014]; root of context hierarchyApr 01, 2014 10:50:50 PM org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitionsINFO: Loading XML bean definitions from class path resource [spring.xml]EmployeeService no-args constructor calledEmployeeService initializing to dummy valueMyEmployeeService no-args constructor calledMyEmployeeService initializing to dummy valueMyService no-args constructor calledMyService init method calledSpring Context initializedBean retrieved from Spring ContextEmployee Name=PankajApr 01, 2014 10:50:50 PM org.springframework.context.support.ClassPathXmlApplicationContext doCloseINFO: Closing org[email protected]c1b9b03: startup date [Tue Apr 01 22:50:50 PDT 2014]; root of context hierarchyMyService destroy method calledMyEmployeeService Closing resourcesEmployeeService Closing resourcesSpring Context Closed</code></pre><p><strong>Spring Bean Life Cycle Important Points</strong>:</p><ul><li>  From the console output it’s clear that Spring Context is first using no-args constructor to initialize the bean object and then calling the post-init method.</li><li>  The order of bean initialization is same as it’s defined in the spring bean configuration file.</li><li>  The context is returned only when all the spring beans are initialized properly with post-init method executions.</li><li>  Employee name is printed as “Pankaj” because it was initialized in the post-init method.</li><li>  When context is getting closed, beans are destroyed in the reverse order in which they were initialized i.e in LIFO (Last-In-First-Out) order.</li></ul><p>You can uncomment the code to get bean of type <code>MyEmployeeService</code> and confirm that output will be similar and follow all the points mentioned above.</p><h2 id="Spring-Aware-Interfaces"><a href="#Spring-Aware-Interfaces" class="headerlink" title="Spring Aware Interfaces"></a>Spring Aware Interfaces</h2><p>Sometimes we need Spring Framework objects in our beans to perform some operations, for example reading ServletConfig and ServletContext parameters or to know the bean definitions loaded by the ApplicationContext. That’s why spring framework provides a bunch of *Aware interfaces that we can implement in our bean classes. <code>org.springframework.beans.factory.Aware</code> is the root marker interface for all these Aware interfaces. All of the *Aware interfaces are sub-interfaces of Aware and declare a single setter method to be implemented by the bean. Then spring context uses setter-based dependency injection to inject the corresponding objects in the bean and make it available for our use. Spring Aware interfaces are similar to servlet listeners with callback methods and implementing observer design pattern Some of the important Aware interfaces are:</p><ul><li>  <strong>ApplicationContextAware</strong> - to inject ApplicationContext object, example usage is to get the array of bean definition names.</li><li>  <strong>BeanFactoryAware</strong> - to inject BeanFactory object, example usage is to check scope of a bean.</li><li>  <strong>BeanNameAware</strong> - to know the bean name defined in the configuration file.</li><li>  <strong>ResourceLoaderAware</strong> - to inject ResourceLoader object, example usage is to get the input stream for a file in the classpath.</li><li>  <strong>ServletContextAware</strong> - to inject ServletContext object in MVC application, example usage is to read context parameters and attributes.</li><li>  <strong>ServletConfigAware</strong> - to inject ServletConfig object in MVC application, example usage is to get servlet config parameters.</li></ul><p>Let’s see these Aware interfaces usage in action by implementing few of them in a class that we will configure as spring bean.</p><pre><code class="hljs">package com.journaldev.spring.service;import java.util.Arrays;import org.springframework.beans.BeansException;import org.springframework.beans.factory.BeanClassLoaderAware;import org.springframework.beans.factory.BeanFactory;import org.springframework.beans.factory.BeanFactoryAware;import org.springframework.beans.factory.BeanNameAware;import org.springframework.context.ApplicationContext;import org.springframework.context.ApplicationContextAware;import org.springframework.context.ApplicationEventPublisher;import org.springframework.context.ApplicationEventPublisherAware;import org.springframework.context.EnvironmentAware;import org.springframework.context.ResourceLoaderAware;import org.springframework.context.annotation.ImportAware;import org.springframework.core.env.Environment;import org.springframework.core.io.Resource;import org.springframework.core.io.ResourceLoader;import org.springframework.core.type.AnnotationMetadata;public class MyAwareService implements ApplicationContextAware,        ApplicationEventPublisherAware, BeanClassLoaderAware, BeanFactoryAware,        BeanNameAware, EnvironmentAware, ImportAware, ResourceLoaderAware &#123;    @Override    public void setApplicationContext(ApplicationContext ctx)            throws BeansException &#123;        System.out.println(&quot;setApplicationContext called&quot;);        System.out.println(&quot;setApplicationContext:: Bean Definition Names=&quot;                + Arrays.toString(ctx.getBeanDefinitionNames()));    &#125;    @Override    public void setBeanName(String beanName) &#123;        System.out.println(&quot;setBeanName called&quot;);        System.out.println(&quot;setBeanName:: Bean Name defined in context=&quot;                + beanName);    &#125;    @Override    public void setBeanClassLoader(ClassLoader classLoader) &#123;        System.out.println(&quot;setBeanClassLoader called&quot;);        System.out.println(&quot;setBeanClassLoader:: ClassLoader Name=&quot;                + classLoader.getClass().getName());    &#125;    @Override    public void setResourceLoader(ResourceLoader resourceLoader) &#123;        System.out.println(&quot;setResourceLoader called&quot;);        Resource resource = resourceLoader.getResource(&quot;classpath:spring.xml&quot;);        System.out.println(&quot;setResourceLoader:: Resource File Name=&quot;                + resource.getFilename());    &#125;    @Override    public void setImportMetadata(AnnotationMetadata annotationMetadata) &#123;        System.out.println(&quot;setImportMetadata called&quot;);    &#125;    @Override    public void setEnvironment(Environment env) &#123;        System.out.println(&quot;setEnvironment called&quot;);    &#125;    @Override    public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;        System.out.println(&quot;setBeanFactory called&quot;);        System.out.println(&quot;setBeanFactory:: employee bean singleton=&quot;                + beanFactory.isSingleton(&quot;employee&quot;));    &#125;    @Override    public void setApplicationEventPublisher(            ApplicationEventPublisher applicationEventPublisher) &#123;        System.out.println(&quot;setApplicationEventPublisher called&quot;);    &#125;&#125;</code></pre><h3 id="Spring-Aware-Example-Configuration-File"><a href="#Spring-Aware-Example-Configuration-File" class="headerlink" title="Spring *Aware Example Configuration File"></a>Spring *Aware Example Configuration File</h3><p>Very simple spring bean configuration file.</p><pre><code class="hljs">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;https://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;https://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;https://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;&lt;bean name=&quot;employee&quot; class=&quot;com.journaldev.spring.bean.Employee&quot; /&gt;&lt;bean name=&quot;myAwareService&quot; class=&quot;com.journaldev.spring.service.MyAwareService&quot; /&gt;&lt;/beans&gt;</code></pre><h3 id="Spring-Aware-Test-Program"><a href="#Spring-Aware-Test-Program" class="headerlink" title="Spring *Aware Test Program"></a>Spring *Aware Test Program</h3><pre><code class="hljs">package com.journaldev.spring.main;import org.springframework.context.support.ClassPathXmlApplicationContext;import com.journaldev.spring.service.MyAwareService;public class SpringAwareMain &#123;    public static void main(String[] args) &#123;        ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;spring-aware.xml&quot;);        ctx.getBean(&quot;myAwareService&quot;, MyAwareService.class);                ctx.close();    &#125;&#125;</code></pre><p>Now when we execute above class, we get following output.</p><pre><code class="hljs">Apr 01, 2014 11:27:05 PM org.springframework.context.support.ClassPathXmlApplicationContext prepareRefreshINFO: Refreshing org[email protected]60a2f435: startup date [Tue Apr 01 23:27:05 PDT 2014]; root of context hierarchyApr 01, 2014 11:27:05 PM org.springframework.beans.factory.xml.XmlBeanDefinitionReader loadBeanDefinitionsINFO: Loading XML bean definitions from class path resource [spring-aware.xml]setBeanName calledsetBeanName:: Bean Name defined in context=myAwareServicesetBeanClassLoader calledsetBeanClassLoader:: ClassLoader Name=sun.misc.Launcher$AppClassLoadersetBeanFactory calledsetBeanFactory:: employee bean singleton=truesetEnvironment calledsetResourceLoader calledsetResourceLoader:: Resource File Name=spring.xmlsetApplicationEventPublisher calledsetApplicationContext calledsetApplicationContext:: Bean Definition Names=[employee, myAwareService]Apr 01, 2014 11:27:05 PM org.springframework.context.support.ClassPathXmlApplicationContext doCloseINFO: Closing org[email protected]60a2f435: startup date [Tue Apr 01 23:27:05 PDT 2014]; root of context hierarchy</code></pre><p>Console output of the test program is simple to understand, I won’t go into much detail about that. That’s all for the Spring Bean Life Cycle methods and injecting framework specific objects into the spring beans. Please download sample project from below link and analyze it to learn more about them.</p><p><a href="https://journaldev.nyc3.digitaloceanspaces.com/spring/SpringBeanLifeCycle.zip">Download Spring Bean Lifycycle Project</a></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://www.digitalocean.com/community/tutorials/spring-bean-life-cycle">Spring Bean Life Cycle</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Springboot启动扩展点超详细总结</title>
    <link href="/2022/10/17/spring/Springboot%E5%90%AF%E5%8A%A8%E6%89%A9%E5%B1%95%E7%82%B9%E8%B6%85%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/"/>
    <url>/2022/10/17/spring/Springboot%E5%90%AF%E5%8A%A8%E6%89%A9%E5%B1%95%E7%82%B9%E8%B6%85%E8%AF%A6%E7%BB%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><p>Spring的核心思想就是容器，当容器refresh的时候，外部看上去风平浪静，其实内部则是一片惊涛骇浪，汪洋一片。Springboot更是封装了Spring，遵循约定大于配置，加上自动装配的机制。很多时候我们只要引用了一个依赖，几乎是零配置就能完成一个功能的装配。</p><p>我非常喜欢这种自动装配的机制，所以在自己开发中间件和公共依赖工具的时候也会用到这个特性。让使用者以最小的代价接入。想要把自动装配玩的转，就必须要了解spring对于bean的构造生命周期以及各个扩展接口。当然了解了bean的各个生命周期也能促进我们加深对spring的理解。业务代码也能合理利用这些扩展点写出更加漂亮的代码。</p><p>在网上搜索spring扩展点，发现很少有博文说的很全的，只有一些常用的扩展点的说明。</p><p>所以在这篇文章里，我总结了几乎Spring &amp; Springboot所有的扩展接口，以及各个扩展点的使用场景。并且整理出了一个bean在spring内部从被加载到最后初始化完成所有可扩展点的顺序调用图。从而我们也能窥探到bean是如何一步步加载到spring容器中的。</p><h2 id="2-可扩展的接口启动调用顺序图"><a href="#2-可扩展的接口启动调用顺序图" class="headerlink" title="2.可扩展的接口启动调用顺序图"></a>2.可扩展的接口启动调用顺序图</h2><p>以下是我整理的spring容器中Bean的生命周期内所有可扩展的点的调用顺序，下面会一个个分析</p><p>  <img src="img.png"></p><h2 id="3-ApplicationContextInitializer"><a href="#3-ApplicationContextInitializer" class="headerlink" title="3.ApplicationContextInitializer"></a>3.ApplicationContextInitializer</h2><blockquote><p>org.springframework.context.ApplicationContextInitializer</p></blockquote><p>这是整个spring容器在刷新之前初始化<code>ConfigurableApplicationContext</code>的回调接口，简单来说，就是在容器刷新之前调用此类的<code>initialize</code>方法。这个点允许被用户自己扩展。用户可以在整个spring容器还没被初始化之前做一些事情。</p><p>可以想到的场景可能为，在最开始激活一些配置，或者利用这时候class还没被类加载器加载的时机，进行动态字节码注入等操作。</p><p>扩展方式为：</p><pre><code class="hljs">public class TestApplicationContextInitializer implements ApplicationContextInitializer &#123;    @Override    public void initialize(ConfigurableApplicationContext applicationContext) &#123;        System.out.println(&quot;[ApplicationContextInitializer]&quot;);    &#125;&#125;</code></pre><p>因为这时候spring容器还没被初始化，所以想要自己的扩展的生效，有以下三种方式：</p><ul><li>  在启动类中用<code>springApplication.addInitializers(new TestApplicationContextInitializer())</code>语句加入</li><li>  配置文件配置<code>context.initializer.classes=com.example.demo.TestApplicationContextInitializer</code></li><li>Spring SPI扩展，在spring.factories中加入<code>org.springframework.context.ApplicationContextInitializer=com.example.demo.TestApplicationContextInitializer</code></li></ul><h2 id="4-BeanDefinitionRegistryPostProcessor"><a href="#4-BeanDefinitionRegistryPostProcessor" class="headerlink" title="4.BeanDefinitionRegistryPostProcessor"></a>4.BeanDefinitionRegistryPostProcessor</h2><blockquote><p>org.springframework.beans.factory.support.BeanDefinitionRegistryPostProcessor</p></blockquote><p>这个接口在读取项目中的<code>beanDefinition</code>之后执行，提供一个补充的扩展点</p><p>使用场景：你可以在这里动态注册自己的<code>beanDefinition</code>，可以加载classpath之外的bean</p><p>扩展方式为:</p><pre><code class="hljs">public class TestBeanDefinitionRegistryPostProcessor implements BeanDefinitionRegistryPostProcessor &#123;    @Override    public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) throws BeansException &#123;        System.out.println(&quot;[BeanDefinitionRegistryPostProcessor] postProcessBeanDefinitionRegistry&quot;);    &#125;    @Override    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;        System.out.println(&quot;[BeanDefinitionRegistryPostProcessor] postProcessBeanFactory&quot;);    &#125;&#125;</code></pre><h2 id="5-BeanFactoryPostProcessor"><a href="#5-BeanFactoryPostProcessor" class="headerlink" title="5.BeanFactoryPostProcessor"></a>5.BeanFactoryPostProcessor</h2><blockquote><p>org.springframework.beans.factory.config.BeanFactoryPostProcessor</p></blockquote><p>这个接口是<code>beanFactory</code>的扩展接口，调用时机在spring在读取<code>beanDefinition</code>信息之后，实例化bean之前。</p><p>在这个时机，用户可以通过实现这个扩展接口来自行处理一些东西，比如修改已经注册的<code>beanDefinition</code>的元信息。</p><p>扩展方式为：</p><pre><code class="hljs">public class TestBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;    @Override    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;        System.out.println(&quot;[BeanFactoryPostProcessor]&quot;);    &#125;&#125;</code></pre><h2 id="6-InstantiationAwareBeanPostProcessor"><a href="#6-InstantiationAwareBeanPostProcessor" class="headerlink" title="6.InstantiationAwareBeanPostProcessor"></a>6.InstantiationAwareBeanPostProcessor</h2><blockquote><p>org.springframework.beans.factory.config.InstantiationAwareBeanPostProcessor</p></blockquote><p>该接口继承了<code>BeanPostProcess</code>接口，区别如下：</p><p><code>BeanPostProcess</code>接口只在bean的初始化阶段进行扩展（注入spring上下文前后），而<code>InstantiationAwareBeanPostProcessor</code>接口在此基础上增加了3个方法，把可扩展的范围增加了实例化阶段和属性注入阶段。</p><p>该类主要的扩展点有以下5个方法，主要在bean生命周期的两大阶段：<strong>实例化阶段</strong>和<strong>初始化阶段</strong>，下面一起进行说明，按调用顺序为：</p><ul><li>  <code>postProcessBeforeInstantiation</code>：实例化bean之前，相当于new这个bean之前</li><li>  <code>postProcessAfterInstantiation</code>：实例化bean之后，相当于new这个bean之后</li><li>  <code>postProcessPropertyValues</code>：bean已经实例化完成，在属性注入时阶段触发，<code>@Autowired</code>,<code>@Resource</code>等注解原理基于此方法实现</li><li>  <code>postProcessBeforeInitialization</code>：初始化bean之前，相当于把bean注入spring上下文之前</li><li>  <code>postProcessAfterInitialization</code>：初始化bean之后，相当于把bean注入spring上下文之后</li></ul><p>使用场景：这个扩展点非常有用 ，无论是写中间件和业务中，都能利用这个特性。比如对实现了某一类接口的bean在各个生命期间进行收集，或者对某个类型的bean进行统一的设值等等。</p><p>扩展方式为：</p><pre><code class="hljs">public class TestInstantiationAwareBeanPostProcessor implements InstantiationAwareBeanPostProcessor &#123;    @Override    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;        System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] before initialization &quot; + beanName);        return bean;    &#125;    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;        System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] after initialization &quot; + beanName);        return bean;    &#125;    @Override    public Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123;        System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] before instantiation &quot; + beanName);        return null;    &#125;    @Override    public boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException &#123;        System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] after instantiation &quot; + beanName);        return true;    &#125;    @Override    public PropertyValues postProcessPropertyValues(PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException &#123;        System.out.println(&quot;[TestInstantiationAwareBeanPostProcessor] postProcessPropertyValues &quot; + beanName);        return pvs;    &#125;</code></pre><h2 id="7-SmartInstantiationAwareBeanPostProcessor"><a href="#7-SmartInstantiationAwareBeanPostProcessor" class="headerlink" title="7.SmartInstantiationAwareBeanPostProcessor"></a>7.SmartInstantiationAwareBeanPostProcessor</h2><blockquote><p>org.springframework.beans.factory.config.SmartInstantiationAwareBeanPostProcessor</p></blockquote><p>该扩展接口有3个触发点方法：</p><ul><li>  <code>predictBeanType</code>：该触发点发生在<code>postProcessBeforeInstantiation</code>之前(在图上并没有标明，因为一般不太需要扩展这个点)，这个方法用于预测Bean的类型，返回第一个预测成功的Class类型，如果不能预测返回null；当你调用<code>BeanFactory.getType(name)</code>时当通过bean的名字无法得到bean类型信息时就调用该回调方法来决定类型信息。</li><li>  <code>determineCandidateConstructors</code>：该触发点发生在<code>postProcessBeforeInstantiation</code>之后，用于确定该bean的构造函数之用，返回的是该bean的所有构造函数列表。用户可以扩展这个点，来自定义选择相应的构造器来实例化这个bean。</li><li>  <code>getEarlyBeanReference</code>：该触发点发生在<code>postProcessAfterInstantiation</code>之后，当有循环依赖的场景，当bean实例化好之后，为了防止有循环依赖，会提前暴露回调方法，用于bean实例化的后置处理。这个方法就是在提前暴露的回调方法中触发。</li></ul><p>扩展方式为：</p><pre><code class="hljs">public class TestSmartInstantiationAwareBeanPostProcessor implements SmartInstantiationAwareBeanPostProcessor &#123;    @Override    public Class&lt;?&gt; predictBeanType(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123;        System.out.println(&quot;[TestSmartInstantiationAwareBeanPostProcessor] predictBeanType &quot; + beanName);        return beanClass;    &#125;    @Override    public Constructor&lt;?&gt;[] determineCandidateConstructors(Class&lt;?&gt; beanClass, String beanName) throws BeansException &#123;        System.out.println(&quot;[TestSmartInstantiationAwareBeanPostProcessor] determineCandidateConstructors &quot; + beanName);        return null;    &#125;    @Override    public Object getEarlyBeanReference(Object bean, String beanName) throws BeansException &#123;        System.out.println(&quot;[TestSmartInstantiationAwareBeanPostProcessor] getEarlyBeanReference &quot; + beanName);        return bean;    &#125;&#125;</code></pre><h2 id="8-BeanFactoryAware"><a href="#8-BeanFactoryAware" class="headerlink" title="8.BeanFactoryAware"></a>8.BeanFactoryAware</h2><blockquote><p>org.springframework.beans.factory.BeanFactoryAware</p></blockquote><p>这个类只有一个触发点，发生在bean的实例化之后，注入属性之前，也就是Setter之前。这个类的扩展点方法为<code>setBeanFactory</code>，可以拿到<code>BeanFactory</code>这个属性。</p><p>使用场景为，你可以在bean实例化之后，但还未初始化之前，拿到 <code>BeanFactory</code>，在这个时候，可以对每个bean作特殊化的定制。也或者可以把<code>BeanFactory</code>拿到进行缓存，日后使用。</p><p>扩展方式为：</p><pre><code class="hljs">public class TestBeanFactoryAware implements BeanFactoryAware &#123;    @Override    public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;        System.out.println(&quot;[TestBeanFactoryAware] &quot; + beanFactory.getBean(TestBeanFactoryAware.class).getClass().getSimpleName());    &#125;&#125;</code></pre><h2 id="9-ApplicationContextAwareProcessor"><a href="#9-ApplicationContextAwareProcessor" class="headerlink" title="9.ApplicationContextAwareProcessor"></a>9.ApplicationContextAwareProcessor</h2><blockquote><p>org.springframework.context.support.ApplicationContextAwareProcessor</p></blockquote><p>该类本身并没有扩展点，但是该类内部却有6个扩展点可供实现 ，这些类触发的时机在bean实例化之后，初始化之前</p><p><img src="img_1.png"></p><p>可以看到，该类用于执行各种驱动接口，在bean实例化之后，属性填充之后，通过执行以上红框标出的扩展接口，来获取对应容器的变量。<strong>所以这里应该来说是有6个扩展点</strong>，这里就放一起来说了</p><ul><li>  <code>EnvironmentAware</code>：用于获取<code>EnviromentAware</code>的一个扩展类，这个变量非常有用， 可以获得系统内的所有参数。当然个人认为这个Aware没必要去扩展，因为spring内部都可以通过注入的方式来直接获得。</li><li>  <code>EmbeddedValueResolverAware</code>：用于获取<code>StringValueResolver</code>的一个扩展类， <code>StringValueResolver</code>用于获取基于<code>String</code>类型的properties的变量，一般我们都用<code>@Value</code>的方式去获取，如果实现了这个Aware接口，把<code>StringValueResolver</code>缓存起来，通过这个类去获取<code>String</code>类型的变量，效果是一样的。</li><li>  <code>ResourceLoaderAware</code>：用于获取<code>ResourceLoader</code>的一个扩展类，<code>ResourceLoader</code>可以用于获取classpath内所有的资源对象，可以扩展此类来拿到<code>ResourceLoader</code>对象。</li><li>  <code>ApplicationEventPublisherAware</code>：用于获取<code>ApplicationEventPublisher</code>的一个扩展类，<code>ApplicationEventPublisher</code>可以用来发布事件，结合<code>ApplicationListener</code>来共同使用，下文在介绍<code>ApplicationListener</code>时会详细提到。这个对象也可以通过spring注入的方式来获得。</li><li>  <code>MessageSourceAware</code>：用于获取<code>MessageSource</code>的一个扩展类，<code>MessageSource</code>主要用来做国际化。</li><li><code>ApplicationContextAware</code>：用来获取<code>ApplicationContext</code>的一个扩展类，<code>ApplicationContext</code>应该是很多人非常熟悉的一个类了，就是spring上下文管理器，可以手动的获取任何在spring上下文注册的bean，我们经常扩展这个接口来缓存spring上下文，包装成静态方法。同时<code>ApplicationContext</code>也实现了<code>BeanFactory</code>，<code>MessageSource</code>，<code>ApplicationEventPublisher</code>等接口，也可以用来做相关接口的事情。</li></ul><h2 id="10-BeanNameAware"><a href="#10-BeanNameAware" class="headerlink" title="10.BeanNameAware"></a>10.BeanNameAware</h2><blockquote><p>org.springframework.beans.factory.BeanNameAware</p></blockquote><p>可以看到，这个类也是Aware扩展的一种，触发点在bean的初始化之前，也就是<code>postProcessBeforeInitialization</code>之前，这个类的触发点方法只有一个：<code>setBeanName</code></p><p>使用场景为：用户可以扩展这个点，在初始化bean之前拿到spring容器中注册的的beanName，来自行修改这个beanName的值。</p><p>扩展方式为：</p><pre><code class="hljs">public class NormalBeanA implements BeanNameAware&#123;    public NormalBeanA() &#123;        System.out.println(&quot;NormalBean constructor&quot;);    &#125;    @Override    public void setBeanName(String name) &#123;        System.out.println(&quot;[BeanNameAware] &quot; + name);    &#125;&#125;</code></pre><h2 id="11-PostConstruct"><a href="#11-PostConstruct" class="headerlink" title="11.@PostConstruct"></a>11.@PostConstruct</h2><blockquote><p>javax.annotation.PostConstruct</p></blockquote><p>这个并不算一个扩展点，其实就是一个标注。其作用是在bean的初始化阶段，如果对一个方法标注了<code>@PostConstruct</code>，会先调用这个方法。这里重点是要关注下这个标准的触发点，这个触发点是在<code>postProcessBeforeInitialization</code>之后，<code>InitializingBean.afterPropertiesSet</code>之前。</p><p>使用场景：用户可以对某一方法进行标注，来进行初始化某一个属性</p><p>扩展方式为：</p><pre><code class="hljs">public class NormalBeanA &#123;    public NormalBeanA() &#123;        System.out.println(&quot;NormalBean constructor&quot;);    &#125;    @PostConstruct    public void init()&#123;        System.out.println(&quot;[PostConstruct] NormalBeanA&quot;);    &#125;&#125;</code></pre><h2 id="12-InitializingBean"><a href="#12-InitializingBean" class="headerlink" title="12.InitializingBean"></a>12.InitializingBean</h2><blockquote><p>org.springframework.beans.factory.InitializingBean</p></blockquote><p>这个类，顾名思义，也是用来初始化bean的。<code>InitializingBean</code>接口为bean提供了初始化方法的方式，它只包括<code>afterPropertiesSet</code>方法，凡是继承该接口的类，在初始化bean的时候都会执行该方法。这个扩展点的触发时机在<code>postProcessAfterInitialization</code>之前。</p><p>使用场景：用户实现此接口，来进行系统启动的时候一些业务指标的初始化工作。</p><p>扩展方式为：</p><pre><code class="hljs">public class NormalBeanA implements InitializingBean&#123;    @Override    public void afterPropertiesSet() throws Exception &#123;        System.out.println(&quot;[InitializingBean] NormalBeanA&quot;);    &#125;&#125;</code></pre><h2 id="13-FactoryBean"><a href="#13-FactoryBean" class="headerlink" title="13.FactoryBean"></a>13.FactoryBean</h2><blockquote><p>org.springframework.beans.factory.FactoryBean</p></blockquote><p>一般情况下，Spring通过反射机制利用bean的class属性指定支线类去实例化bean，在某些情况下，实例化Bean过程比较复杂，如果按照传统的方式，则需要在bean中提供大量的配置信息。配置方式的灵活性是受限的，这时采用编码的方式可能会得到一个简单的方案。Spring为此提供了一个<code>org.springframework.bean.factory.FactoryBean</code>的工厂类接口，用户可以通过实现该接口定制实例化Bean的逻辑。<code>FactoryBean</code>接口对于Spring框架来说占用重要的地位，Spring自身就提供了70多个<code>FactoryBean</code>的实现。它们隐藏了实例化一些复杂bean的细节，给上层应用带来了便利。从Spring3.0开始，<code>FactoryBean</code>开始支持泛型，即接口声明改为<code>FactoryBean&lt;T&gt;</code>的形式</p><p>使用场景：用户可以扩展这个类，来为要实例化的bean作一个代理，比如为该对象的所有的方法作一个拦截，在调用前后输出一行log，模仿<code>ProxyFactoryBean</code>的功能。</p><p>扩展方式为：</p><pre><code class="hljs">public class TestFactoryBean implements FactoryBean&lt;TestFactoryBean.TestFactoryInnerBean&gt; &#123;    @Override    public TestFactoryBean.TestFactoryInnerBean getObject() throws Exception &#123;        System.out.println(&quot;[FactoryBean] getObject&quot;);        return new TestFactoryBean.TestFactoryInnerBean();    &#125;    @Override    public Class&lt;?&gt; getObjectType() &#123;        return TestFactoryBean.TestFactoryInnerBean.class;    &#125;    @Override    public boolean isSingleton() &#123;        return true;    &#125;    public static class TestFactoryInnerBean&#123;    &#125;&#125;</code></pre><h2 id="14-SmartInitializingSingleton"><a href="#14-SmartInitializingSingleton" class="headerlink" title="14.SmartInitializingSingleton"></a>14.SmartInitializingSingleton</h2><blockquote><p>org.springframework.beans.factory.SmartInitializingSingleton</p></blockquote><p>这个接口中只有一个方法<code>afterSingletonsInstantiated</code>，其作用是是 在spring容器管理的所有单例对象（非懒加载对象）初始化完成之后调用的回调接口。其触发时机为<code>postProcessAfterInitialization</code>之后。</p><p>使用场景：用户可以扩展此接口在对所有单例对象初始化完毕后，做一些后置的业务处理。</p><p>扩展方式为：</p><pre><code class="hljs">public class TestSmartInitializingSingleton implements SmartInitializingSingleton &#123;    @Override    public void afterSingletonsInstantiated() &#123;        System.out.println(&quot;[TestSmartInitializingSingleton]&quot;);    &#125;&#125;</code></pre><h2 id="15-CommandLineRunner"><a href="#15-CommandLineRunner" class="headerlink" title="15.CommandLineRunner"></a>15.CommandLineRunner</h2><blockquote><p>org.springframework.boot.CommandLineRunner</p></blockquote><p>这个接口也只有一个方法：<code>run(String... args)</code>，触发时机为整个项目启动完毕后，自动执行。如果有多个<code>CommandLineRunner</code>，可以利用<code>@Order</code>来进行排序。</p><p>使用场景：用户扩展此接口，进行启动项目之后一些业务的预处理。</p><p>扩展方式为：</p><pre><code class="hljs">public class TestCommandLineRunner implements CommandLineRunner &#123;    @Override    public void run(String... args) throws Exception &#123;        System.out.println(&quot;[TestCommandLineRunner]&quot;);    &#125;&#125;</code></pre><h2 id="16-DisposableBean"><a href="#16-DisposableBean" class="headerlink" title="16.DisposableBean"></a>16.DisposableBean</h2><blockquote><p>org.springframework.beans.factory.DisposableBean</p></blockquote><p>这个扩展点也只有一个方法：<code>destroy()</code>，其触发时机为当此对象销毁时，会自动执行这个方法。比如说运行<code>applicationContext.registerShutdownHook</code>时，就会触发这个方法。</p><p>扩展方式为：</p><pre><code class="hljs">public class NormalBeanA implements DisposableBean &#123;    @Override    public void destroy() throws Exception &#123;        System.out.println(&quot;[DisposableBean] NormalBeanA&quot;);    &#125;&#125;</code></pre><h2 id="17-ApplicationListener"><a href="#17-ApplicationListener" class="headerlink" title="17.ApplicationListener"></a>17.ApplicationListener</h2><blockquote><p>org.springframework.context.ApplicationListener</p></blockquote><p>准确的说，这个应该不算spring&amp;springboot当中的一个扩展点，<code>ApplicationListener</code>可以监听某个事件的<code>event</code>，触发时机可以穿插在业务方法执行过程中，用户可以自定义某个业务事件。但是spring内部也有一些内置事件，这种事件，可以穿插在启动调用中。我们也可以利用这个特性，来自己做一些内置事件的监听器来达到和前面一些触发点大致相同的事情。</p><p>接下来罗列下spring主要的内置事件：</p><ul><li>ContextRefreshedEvent  ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在<code>ConfigurableApplicationContext</code>接口中使用 <code>refresh()</code>方法来发生。此处的初始化是指：所有的Bean被成功装载，后处理Bean被检测并激活，所有Singleton Bean 被预实例化，<code>ApplicationContext</code>容器已就绪可用。</li><li>ContextStartedEvent  当使用 <code>ConfigurableApplicationContext</code> （ApplicationContext子接口）接口中的 start() 方法启动 <code>ApplicationContext</code>时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</li><li>ContextStoppedEvent  当使用 <code>ConfigurableApplicationContext</code>接口中的 <code>stop()</code>停止<code>ApplicationContext</code> 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作</li><li>ContextClosedEvent  当使用 <code>ConfigurableApplicationContext</code>接口中的 <code>close()</code>方法关闭 <code>ApplicationContext</code> 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启</li><li>RequestHandledEvent  这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。只能应用于使用DispatcherServlet的Web应用。在使用Spring作为前端的MVC控制器时，当Spring处理用户请求结束后，系统会自动触发该事件</li></ul><h2 id="18-最后"><a href="#18-最后" class="headerlink" title="18.最后"></a>18.最后</h2><p>我们从这些spring&amp;springboot的扩展点当中，大致可以窥视到整个bean的生命周期。在业务开发或者写中间件业务的时候，可以合理利用spring提供给我们的扩展点，在spring启动的各个阶段内做一些事情。以达到自定义初始化的目的。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://www.jianshu.com/p/38d834db7413">Springboot启动扩展点超详细总结，再也不怕面试官问了</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring使用技巧</title>
    <link href="/2022/10/11/spring/Spring%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/2022/10/11/spring/Spring%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title=" 前言"></a> 前言</h2><p>我们一说到spring，可能第一个想到的是 <code>IOC</code>（控制反转） 和 <code>AOP</code>（面向切面编程）。</p><p>没错，它们是spring的基石，得益于它们的优秀设计，使得spring能够从众多优秀框架中脱颖而出。</p><p>除此之外，我们在使用spring的过程中，有没有发现它的<code>扩展能力非常强</code>。由于这个优势的存在，让spring拥有强大的包容能力，让很多第三方应用能够轻松投入spring的怀抱。比如：rocketmq、mybatis、redis等。</p><p>今天跟大家一起聊聊，在Spring中最常用的11个扩展点。<br><img src="img_2.png"></p><h2 id="1-自定义拦截器"><a href="#1-自定义拦截器" class="headerlink" title="1.自定义拦截器"></a>1.自定义拦截器</h2><p>spring mvc拦截器根spring拦截器相比，它里面能够获取<code>HttpServletRequest</code>和<code>HttpServletResponse</code>等web对象实例。</p><p>spring mvc拦截器的顶层接口是：<code>HandlerInterceptor</code>，包含三个方法：</p><ul><li>preHandle 目标方法执行前执行</li><li>postHandle 目标方法执行后执行</li><li>afterCompletion 请求完成时执行</li></ul><p>为了方便我们一般情况会用<code>HandlerInterceptor</code>接口的实现类<code>HandlerInterceptorAdapter</code>类。</p><p>假如有权限认证、日志、统计的场景，可以使用该拦截器。</p><p>第一步，继承<code>HandlerInterceptorAdapter</code>类定义拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HandlerInterceptorAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span><br>            <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">requestUrl</span> <span class="hljs-operator">=</span> request.getRequestURI();<br>        <span class="hljs-keyword">if</span> (checkAuth(requestUrl)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkAuth</span><span class="hljs-params">(String requestUrl)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;===权限校验===&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二步，将该拦截器注册到spring容器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebAuthConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebMvcConfigurerAdapter</span> &#123;<br> <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> AuthInterceptor <span class="hljs-title function_">getAuthInterceptor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AuthInterceptor</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AuthInterceptor</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第三步，在请求接口时spring mvc通过该拦截器，能够自动拦截该接口，并且校验权限。</p><h2 id="2-获取Spring容器对象"><a href="#2-获取Spring容器对象" class="headerlink" title="2.获取Spring容器对象"></a>2.获取Spring容器对象</h2><p>在我们日常开发中，经常需要从Spring容器中获取Bean，但你知道如何获取Spring容器对象吗？</p><h3 id="2-1-BeanFactoryAware接口"><a href="#2-1-BeanFactoryAware接口" class="headerlink" title="2.1 BeanFactoryAware接口"></a>2.1 BeanFactoryAware接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryAware</span> &#123;<br>    <span class="hljs-keyword">private</span> BeanFactory beanFactory;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-built_in">this</span>.beanFactory = beanFactory;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) beanFactory.getBean(<span class="hljs-string">&quot;person&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现<code>BeanFactoryAware</code>接口，然后重写<code>setBeanFactory</code>方法，就能从该方法中获取到spring容器对象。</p><h3 id="2-2-ApplicationContextAware接口"><a href="#2-2-ApplicationContextAware接口" class="headerlink" title="2.2 ApplicationContextAware接口"></a>2.2 ApplicationContextAware接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonService2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextAware</span> &#123;<br>    <span class="hljs-keyword">private</span> ApplicationContext applicationContext;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-built_in">this</span>.applicationContext = applicationContext;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) applicationContext.getBean(<span class="hljs-string">&quot;person&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现<code>ApplicationContextAware</code>接口，然后重写<code>setApplicationContext</code>方法，也能从该方法中获取到spring容器对象。</p><h3 id="2-3-ApplicationListener接口"><a href="#2-3-ApplicationListener接口" class="headerlink" title="2.3 ApplicationListener接口"></a>2.3 ApplicationListener接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonService3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; &#123;<br>    <span class="hljs-keyword">private</span> ApplicationContext applicationContext;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span> &#123;<br>        applicationContext = event.getApplicationContext();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) applicationContext.getBean(<span class="hljs-string">&quot;person&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-全局异常处理"><a href="#3-全局异常处理" class="headerlink" title="3.全局异常处理"></a>3.全局异常处理</h2><p>以前我们在开发接口时，如果出现异常，为了给用户一个更友好的提示，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/test&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestController</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/add&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> / <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;成功&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不做任何处理请求add接口结果直接报错：<br><img src="img_1.png"><br>what？用户能直接看到错误信息？</p><p>这种交互方式给用户的体验非常差，为了解决这个问题，我们通常会在接口中捕获异常：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/add&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title class_">String</span> result = <span class="hljs-string">&quot;成功&quot;</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        int a = <span class="hljs-number">10</span> / <span class="hljs-number">0</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br>        result = <span class="hljs-string">&quot;数据异常&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>接口改造后，出现异常时会提示：“数据异常”，对用户来说更友好。</p><p>看起来挺不错的，但是有问题。。。</p><p>如果只是一个接口还好，但是如果项目中有成百上千个接口，都要加上异常捕获代码吗？</p><p>答案是否定的，这时全局异常处理就派上用场了：<code>RestControllerAdvice</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br><br>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">handleException</span><span class="hljs-params">(Exception e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> ArithmeticException) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;数据异常&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> Exception) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;服务器内部异常&quot;</span>;<br>        &#125;<br>        retur nnull;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只需在<code>handleException</code>方法中处理异常情况，业务接口中可以放心使用，不再需要捕获异常（有人统一处理了）。真是爽歪歪。</p><h2 id="4-类型转换器"><a href="#4-类型转换器" class="headerlink" title="4.类型转换器"></a>4.类型转换器</h2><p>spring目前支持3中类型转换器：</p><ul><li>Converter&lt;S,T&gt;：将 S 类型对象转为 T 类型对象</li><li>ConverterFactory&lt;S, R&gt;：将 S 类型对象转为 R 类型及子类对象</li><li>GenericConverter：它支持多个source和目标类型的转化，同时还提供了source和目标类型的上下文，这个上下文能让你实现基于属性上的注解或信息来进行类型转换。</li></ul><p>这3种类型转换器使用的场景不一样，我们以<code>Converter&lt;S,T&gt;为</code>例。假如：接口中接收参数的实体对象中，有个字段的类型是Date，但是实际传参的是字符串类型：2021-01-03 10:20:15，要如何处理呢？</p><p>第一步，定义一个实体User：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Date registerDate;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二步，实现<code>Converter</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DateConverter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Converter</span>&lt;String, Date&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">simpleDateFormat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Date <span class="hljs-title function_">convert</span><span class="hljs-params">(String source)</span> &#123;<br>        <span class="hljs-keyword">if</span> (source != <span class="hljs-literal">null</span> &amp;&amp; !<span class="hljs-string">&quot;&quot;</span>.equals(source)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                simpleDateFormat.parse(source);<br>            &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第三步，将新定义的类型转换器注入到spring容器中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WebMvcConfigurerAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addFormatters</span><span class="hljs-params">(FormatterRegistry registry)</span> &#123;<br>        registry.addConverter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DateConverter</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第四步，调用接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/save&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">save</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>请求接口时User对象中registerDate字段会被自动转换成Date类型。</p><h2 id="5-导入配置"><a href="#5-导入配置" class="headerlink" title="5.导入配置"></a>5.导入配置</h2><p>有时我们需要在某个配置类中引入另外一些类，被引入的类也加到spring容器中。这时可以使用<code>@Import</code>注解完成这个功能。</p><p>如果你看过它的源码会发现，引入的类支持三种不同类型。</p><p>但是我认为最好将普通类和@Configuration注解的配置类分开讲解，所以列了四种不同类型：<br><img src="img.png"></p><h3 id="5-1-普通类"><a href="#5-1-普通类" class="headerlink" title="5.1 普通类"></a>5.1 普通类</h3><p>这种引入方式是最简单的，被引入的类会被实例化bean对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>&#125;<br><br><span class="hljs-meta">@Import(A.class)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestConfiguration</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>@Import</code>注解引入A类，spring就能自动实例化A对象，然后在需要使用的地方通过<code>@Autowired</code>注解注入即可：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> A a;<br></code></pre></td></tr></table></figure><p>是不是挺让人意外的？不用加<code>@Bean</code>注解也能实例化bean。</p><h3 id="5-2-配置类"><a href="#5-2-配置类" class="headerlink" title="5.2 配置类"></a>5.2 配置类</h3><p>这种引入方式是最复杂的，因为<code>@Configuration</code>注解还支持多种组合注解，比如：</p><ul><li>@Import</li><li>@ImportResource</li><li>@PropertySource等。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br>&#125;<br><br><span class="hljs-meta">@Import(B.class)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> A <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Import(AConfiguration.class)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestConfiguration</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过@Import注解引入@Configuration注解的配置类，会把该配置类相关<code>@Import</code>、<code>@ImportResource</code>、<code>@PropertySource</code>等注解引入的类进行递归，一次性全部引入。</p><h3 id="5-3-ImportSelector"><a href="#5-3-ImportSelector" class="headerlink" title="5.3 ImportSelector"></a>5.3 ImportSelector</h3><p>这种引入方式需要实现<code>ImportSelector</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportSelector</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">CLASS_NAME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;com.sue.cache.service.test13.A&quot;</span>;<br>    <br> <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;CLASS_NAME&#125;;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Import(AImportSelector.class)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestConfiguration</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式的好处是<code>selectImports</code>方法返回的是数组，意味着可以同时引入多个类，还是非常方便的。</p><h3 id="5-4-ImportBeanDefinitionRegistrar"><a href="#5-4-ImportBeanDefinitionRegistrar" class="headerlink" title="5.4 ImportBeanDefinitionRegistrar"></a>5.4 ImportBeanDefinitionRegistrar</h3><p>这种引入方式需要实现<code>ImportBeanDefinitionRegistrar</code>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AImportBeanDefinitionRegistrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportBeanDefinitionRegistrar</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;<br>        <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">rootBeanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(A.class);<br>        registry.registerBeanDefinition(<span class="hljs-string">&quot;a&quot;</span>, rootBeanDefinition);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Import(AImportBeanDefinitionRegistrar.class)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestConfiguration</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>这种方式是最灵活的，能在<code>registerBeanDefinitions</code>方法中获取到<code>BeanDefinitionRegistry</code>容器注册对象，可以手动控制BeanDefinition的创建和注册。</p><h2 id="6-项目启动时"><a href="#6-项目启动时" class="headerlink" title="6.项目启动时"></a>6.项目启动时</h2><p>有时候我们需要在项目启动时定制化一些附加功能，比如：加载一些系统参数、完成初始化、预热本地缓存等，该怎么办呢？</p><p>好消息是springboot提供了：</p><ul><li>CommandLineRunner</li><li>ApplicationRunner</li></ul><p>这两个接口帮助我们实现以上需求。</p><p>它们的用法还是挺简单的，以<code>ApplicationRunner</code>接口为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationRunner</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoadDataService loadDataService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        loadDataService.load();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现<code>ApplicationRunner</code>接口，重写<code>run</code>方法，在该方法中实现自己定制化需求。</p><p>如果项目中有多个类实现了ApplicationRunner接口，他们的执行顺序要怎么指定呢？</p><p>答案是使用<code>@Order(n)</code>注解，n的值越小越先执行。当然也可以通过<code>@Priority</code>注解指定顺序。</p><h2 id="7-修改BeanDefinition"><a href="#7-修改BeanDefinition" class="headerlink" title="7.修改BeanDefinition"></a>7.修改BeanDefinition</h2><p>Spring IOC在实例化Bean对象之前，需要先读取Bean的相关属性，保存到<code>BeanDefinition</code>对象中，然后通过BeanDefinition对象，实例化Bean对象。</p><p>如果想修改BeanDefinition对象中的属性，该怎么办呢？</p><p>答：我们可以实现<code>BeanFactoryPostProcessor</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> &#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory configurableListableBeanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-type">DefaultListableBeanFactory</span> <span class="hljs-variable">defaultListableBeanFactory</span> <span class="hljs-operator">=</span> (DefaultListableBeanFactory) configurableListableBeanFactory;<br>        <span class="hljs-type">BeanDefinitionBuilder</span> <span class="hljs-variable">beanDefinitionBuilder</span> <span class="hljs-operator">=</span> BeanDefinitionBuilder.genericBeanDefinition(User.class);<br>        beanDefinitionBuilder.addPropertyValue(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-number">123</span>);<br>        beanDefinitionBuilder.addPropertyValue(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;苏三说技术&quot;</span>);<br>        defaultListableBeanFactory.registerBeanDefinition(<span class="hljs-string">&quot;user&quot;</span>, beanDefinitionBuilder.getBeanDefinition());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在postProcessBeanFactory方法中，可以获取BeanDefinition的相关对象，并且修改该对象的属性。</p><h2 id="8-初始化Bean前后"><a href="#8-初始化Bean前后" class="headerlink" title="8.初始化Bean前后"></a>8.初始化Bean前后</h2><p>有时，你想在初始化Bean前后，实现一些自己的逻辑。</p><p>这时可以实现：<code>BeanPostProcessor</code>接口。</p><p>该接口目前有两个方法：</p><ul><li>postProcessBeforeInitialization 该在初始化方法之前调用。</li><li>postProcessAfterInitialization 该方法再初始化方法之后调用。</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> User) &#123;<br>            ((User) bean).setUserName(<span class="hljs-string">&quot;苏三说技术&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果spring中存在User对象，则将它的userName设置成：苏三说技术。</p><p>其实，我们经常使用的注解，比如：@Autowired、@Value、@Resource、@PostConstruct等，是通过AutowiredAnnotationBeanPostProcessor和CommonAnnotationBeanPostProcessor实现的。</p><h2 id="9-初始化方法"><a href="#9-初始化方法" class="headerlink" title="9.初始化方法"></a>9.初始化方法</h2><p>目前spring中使用比较多的初始化bean的方法有：</p><ol><li>使用@PostConstruct注解</li><li>实现InitializingBean接口</li></ol><h3 id="9-1-使用-PostConstruct注解"><a href="#9-1-使用-PostConstruct注解" class="headerlink" title="9.1 使用@PostConstruct注解"></a>9.1 使用@PostConstruct注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AService</span> &#123;<br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;===初始化===&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在需要初始化的方法上增加<code>@PostConstruct</code>注解，这样就有初始化的能力。</p><h3 id="9-2-实现InitializingBean接口"><a href="#9-2-实现InitializingBean接口" class="headerlink" title="9.2 实现InitializingBean接口"></a>9.2 实现InitializingBean接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;===初始化===&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现<code>InitializingBean</code>接口，重写<code>afterPropertiesSet</code>方法，该方法中可以完成初始化功能。</p><h2 id="10-关闭容器前"><a href="#10-关闭容器前" class="headerlink" title="10.关闭容器前"></a>10.关闭容器前</h2><p>有时候，我们需要在关闭spring容器前，做一些额外的工作，比如：关闭资源文件等。</p><p>这时可以实现<code>DisposableBean</code>接口，并且重写它的<code>destroy</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span>, DisposableBean &#123;<br><br> <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  System.out.println(<span class="hljs-string">&quot;DisposableBean destroy&quot;</span>);<br> &#125;<br><br> <span class="hljs-meta">@Override</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  System.out.println(<span class="hljs-string">&quot;InitializingBean afterPropertiesSet&quot;</span>);<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样spring容器销毁前，会调用该destroy方法，做一些额外的工作。</p><p>通常情况下，我们会同时实现InitializingBean和DisposableBean接口，重写初始化方法和销毁方法。</p><h2 id="11-自定义作用域"><a href="#11-自定义作用域" class="headerlink" title="11.自定义作用域"></a>11.自定义作用域</h2><p>我们都知道spring默认支持的<code>Scope</code>只有两种：</p><ul><li>singleton 单例，每次从spring容器中获取到的bean都是同一个对象。</li><li>prototype 多例，每次从spring容器中获取到的bean都是不同的对象。</li></ul><p>spring web又对Scope进行了扩展，增加了：</p><ul><li>RequestScope 同一次请求从spring容器中获取到的bean都是同一个对象。</li><li>SessionScope 同一个会话从spring容器中获取到的bean都是同一个对象。</li></ul><p>即便如此，有些场景还是无法满足我们的要求。</p><p>比如，我们想在同一个线程中从spring容器获取到的bean都是同一个对象，该怎么办？</p><p>这就需要自定义Scope了。</p><p>第一步实现Scope接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalScope</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Scope</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ThreadLocal</span> <span class="hljs-variable">THREAD_LOCAL_SCOPE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(String name, ObjectFactory&lt;?&gt; objectFactory)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> THREAD_LOCAL_SCOPE.get();<br>        <span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> objectFactory.getObject();<br>        THREAD_LOCAL_SCOPE.set(object);<br>        <span class="hljs-keyword">return</span> object;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">remove</span><span class="hljs-params">(String name)</span> &#123;<br>        THREAD_LOCAL_SCOPE.remove();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerDestructionCallback</span><span class="hljs-params">(String name, Runnable callback)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">resolveContextualObject</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getConversationId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第二步将新定义的Scope注入到spring容器中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        beanFactory.registerScope(<span class="hljs-string">&quot;threadLocalScope&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalScope</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第三步使用新定义的Scope：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Scope(&quot;threadLocalScope&quot;)</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CService</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://mp.weixin.qq.com/s/Dkk84xmZoJ7T-hQZ5K9Zrw">看了我的Spring使用技巧，同事也开始悄悄模仿了…</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty之Channel</title>
    <link href="/2022/10/10/network/Netty%E4%B9%8BChannel/"/>
    <url>/2022/10/10/network/Netty%E4%B9%8BChannel/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Channel"><a href="#1-Channel" class="headerlink" title="1. Channel"></a>1. Channel</h2><pre><code class="hljs">Channel是Netty的核心概念之一，它是Netty网络通信的主体，由它负责同对端进行网络通信、注册和数据操作等功能。</code></pre><h3 id="1-1-工作原理"><a href="#1-1-工作原理" class="headerlink" title="1.1 工作原理"></a>1.1 工作原理</h3><p><img src="img.png"></p><p>如上图所示：</p><ul><li>  一旦用户端连接成功，将新建一个channel同该用户端进行绑定</li><li>  channel从EventLoopGroup获得一个EventLoop，并注册到该EventLoop，channel生命周期内都和该EventLoop在一起（注册时获得selectionKey）</li><li>  channel同用户端进行网络连接、关闭和读写，生成相对应的event（改变selectinKey信息），触发eventloop调度线程进行执行</li><li>  如果是读事件，执行线程调度pipeline来处理用户业务逻辑</li></ul><h3 id="1-2-状态转换"><a href="#1-2-状态转换" class="headerlink" title="1.2 状态转换"></a>1.2 状态转换</h3><p><img src="img_1.png"></p><blockquote><p>如上图所示，Channel包含注册、活跃、非活跃和非注册状态，在一般情况下是从注册-&gt;活跃-&gt;非活跃-&gt;非注册,但用户可以从eventloop取消和重注册channel，因此在此情况下活跃-&gt;非注册-&gt;注册</p></blockquote><h3 id="1-3-线程"><a href="#1-3-线程" class="headerlink" title="1.3 线程"></a>1.3 线程</h3><pre><code class="hljs">多个channel可以注册到一个eventloop上，所有的操作都是顺序执行的，eventloop会依据channel的事件调用channel的方法进行相关操作，每个channel的操作和处理在eventloop中都是顺序的，如下图：</code></pre><p><img src="img_2.png"></p><h2 id="2-ChannelPipeline和ChannelHandler"><a href="#2-ChannelPipeline和ChannelHandler" class="headerlink" title="2. ChannelPipeline和ChannelHandler"></a>2. ChannelPipeline和ChannelHandler</h2><pre><code class="hljs">ChannelPipeline和ChannelHandler用于channel事件的拦截和处理，Netty使用类似责任链的模式来设计ChannelPipeline和ChannelHandlerChannelPipeline相当于ChannelHandler的容器，channel事件消息在ChannelPipeline中流动和传播，相应的事件能够被ChannelHandler拦截处理、传递、忽略或者终止，如下图所示：</code></pre><p><img src="img_3.png"></p><h3 id="2-1-INBOUD和OUTBOUND事件"><a href="#2-1-INBOUD和OUTBOUND事件" class="headerlink" title="2.1 INBOUD和OUTBOUND事件"></a>2.1 INBOUD和OUTBOUND事件</h3><pre><code class="hljs">inbound:当发生某个I/O操作时由IO线程流向用户业务处理线程的事件，如链路建立、链路关闭或者读完成等outbound:由用户线程或者代码发起的IO操作事件</code></pre><h3 id="2-2-ChannelHandlerContext"><a href="#2-2-ChannelHandlerContext" class="headerlink" title="2.2 ChannelHandlerContext"></a>2.2 ChannelHandlerContext</h3><pre><code class="hljs">每个ChannelHandler 被添加到ChannelPipeline 后，都会创建一个ChannelHandlerContext 并与之创建的ChannelHandler 关联绑定。如下图：</code></pre><p><img src="img_4.png"></p><pre><code class="hljs">ChannelHandler通过ChannelHandlerContext来操作channel和channelpipeline</code></pre><h3 id="2-3-ChannelHandler"><a href="#2-3-ChannelHandler" class="headerlink" title="2.3 ChannelHandler"></a>2.3 ChannelHandler</h3><pre><code class="hljs">ChannelHandler负责I/O事件或者I/O操作进行拦截和处理，用户可以通过ChannelHandlerAdapter来选择性的实现自己感兴趣的事件拦截和处理。</code></pre><blockquote><p>由于Channel只负责实际的I/O操作，因此数据的编解码和实际处理都需要通过ChannelHandler进行处理。</p></blockquote><h3 id="2-4-注意"><a href="#2-4-注意" class="headerlink" title="2.4 注意"></a>2.4 注意</h3><blockquote><p>ChannelPipeline是线程安全的，多个业务线程可以并发的操作ChannelPipeline；ChannelHandler不是线程安全的，用户需要自己保重ChannelHandler的线程安全</p></blockquote><h2 id="3-ChannelFuture与ChannelPromise"><a href="#3-ChannelFuture与ChannelPromise" class="headerlink" title="3. ChannelFuture与ChannelPromise"></a>3. ChannelFuture与ChannelPromise</h2><pre><code class="hljs">在Netty中，所有的I/O操作都是异步的，因此调用一个I/O操作后，将继续当前线程的执行，但I/O操作的结果怎么获得？——ChannelFuture。</code></pre><p><img src="img_5.png"></p><blockquote><p>如上图，当前线程A异步发起I/O操作后，不阻塞继续执行相关操作，当IO线程B完成后，通过回调执行A设置的回调方法。</p></blockquote><pre><code class="hljs">回调方法通过监听的形式实现:ChannelFutureListener。</code></pre><p><strong>ChannelPromise是ChannelFuture的扩展，允许设置I/O操作的结果，使ChannelFutureListener可以执行相关操作</strong></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://www.cnblogs.com/TomSnail/p/6192885.html">Netty学习四:Channel</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>超详细Netty入门</title>
    <link href="/2022/10/09/network/%E8%B6%85%E8%AF%A6%E7%BB%86Netty%E5%85%A5%E9%97%A8/"/>
    <url>/2022/10/09/network/%E8%B6%85%E8%AF%A6%E7%BB%86Netty%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>简介：</strong> 本文主要讲述Netty框架的一些特性以及重要组件，希望看完之后能对Netty框架有一个比较直观的感受，希望能帮助读者快速入门Netty，减少一些弯路。</p><h1 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h1><p><img src="img_5.png" alt="img_5.png"></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要讲述Netty框架的一些特性以及重要组件，希望看完之后能对Netty框架有一个比较直观的感受，希望能帮助读者快速入门Netty，减少一些弯路。</p><h1 id="一、Netty概述"><a href="#一、Netty概述" class="headerlink" title="一、Netty概述"></a>一、Netty概述</h1><p>官方的介绍：</p><blockquote><p>Netty is <em>an asynchronous event-driven network application framework</em><br>for rapid development of maintainable high performance protocol servers &amp; clients.</p></blockquote><p><strong>Netty</strong>是 一个<strong>异步事件驱动</strong>的网络应用程序框架，用于<strong>快速开发可维护的高性能协议服务器和客户端</strong>。</p><h1 id="二、为什么使用Netty"><a href="#二、为什么使用Netty" class="headerlink" title="二、为什么使用Netty"></a>二、为什么使用Netty</h1><p>从官网上介绍，Netty是一个网络应用程序框架，开发服务器和客户端。也就是用于网络编程的一个框架。既然是网络编程，Socket就不谈了，为什么不用NIO呢？</p><h2 id="2-1-NIO的缺点"><a href="#2-1-NIO的缺点" class="headerlink" title="2.1 NIO的缺点"></a>2.1 NIO的缺点</h2><p>对于这个问题，之前我写了一篇文章<a href="https://mp.weixin.qq.com/s/GfV9w2B0mbT7PmeBS45xLw">《NIO入门》</a>对NIO有比较详细的介绍，NIO的主要问题是：</p><ul><li>  NIO的类库和API繁杂，学习成本高，你需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等。</li><li>  需要熟悉Java多线程编程。这是因为NIO编程涉及到Reactor模式，你必须对多线程和网络编程非常熟悉，才能写出高质量的NIO程序。</li><li>  臭名昭著的epoll bug。它会导致Selector空轮询，最终导致CPU 100%。直到JDK1.7版本依然没得到根本性的解决。</li></ul><h2 id="2-2-Netty的优点"><a href="#2-2-Netty的优点" class="headerlink" title="2.2 Netty的优点"></a>2.2 Netty的优点</h2><p>相对地，Netty的优点有很多：</p><ul><li>  API使用简单，学习成本低。</li><li>  功能强大，内置了多种解码编码器，支持多种协议。</li><li>  性能高，对比其他主流的NIO框架，Netty的性能最优。</li><li>  社区活跃，发现BUG会及时修复，迭代版本周期短，不断加入新的功能。</li><li>  Dubbo、Elasticsearch都采用了Netty，质量得到验证。</li></ul><h1 id="三、架构图"><a href="#三、架构图" class="headerlink" title="三、架构图"></a>三、架构图</h1><p><img src="img_6.png"></p><p>上面这张图就是在官网首页的架构图，我们从上到下分析一下。</p><blockquote><p>绿色的部分<strong>Core</strong>核心模块，包括零拷贝、API库、可扩展的事件模型。</p><p>橙色部分<strong>Protocol Support</strong>协议支持，包括Http协议、webSocket、SSL(安全套接字协议)、谷歌Protobuf协议、zlib/gzip压缩与解压缩、Large File Transfer大文件传输等等。</p><p>红色的部分<strong>Transport Services</strong>传输服务，包括Socket、Datagram、Http Tunnel等等。</p></blockquote><p>以上可看出Netty的功能、协议、传输方式都比较全，比较强大。</p><h1 id="四、永远的Hello-Word"><a href="#四、永远的Hello-Word" class="headerlink" title="四、永远的Hello Word"></a>四、永远的Hello Word</h1><p>首先搭建一个HelloWord工程，先熟悉一下API，还有为后面的学习做铺垫。以下面这张图为依据：</p><p><img src="img_7.png"></p><h2 id="4-1-引入Maven依赖"><a href="#4-1-引入Maven依赖" class="headerlink" title="4.1 引入Maven依赖"></a>4.1 引入Maven依赖</h2><p>使用的版本是4.1.20，相对比较稳定的一个版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.netty<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>netty-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.1.20.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-2-创建服务端启动类"><a href="#4-2-创建服务端启动类" class="headerlink" title="4.2 创建服务端启动类"></a>4.2 创建服务端启动类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//创建两个线程组 boosGroup、workerGroup</span><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建服务端的启动对象，设置参数</span><br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>            <span class="hljs-comment">//设置两个线程组boosGroup和workerGroup</span><br>            bootstrap.group(bossGroup, workerGroup)<br>                <span class="hljs-comment">//设置服务端通道实现类型    </span><br>                .channel(NioServerSocketChannel.class)<br>                <span class="hljs-comment">//设置线程队列得到连接个数    </span><br>                .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)<br>                <span class="hljs-comment">//设置保持活动连接状态    </span><br>                .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>)<br>                <span class="hljs-comment">//使用匿名内部类的形式初始化通道对象    </span><br>                .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-comment">//给pipeline管道设置处理器</span><br>                            socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServerHandler</span>());<br>                        &#125;<br>                    &#125;);<span class="hljs-comment">//给workerGroup的EventLoop对应的管道设置处理器</span><br>            System.out.println(<span class="hljs-string">&quot;java技术爱好者的服务端已经准备就绪...&quot;</span>);<br>            <span class="hljs-comment">//绑定端口号，启动服务端</span><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.bind(<span class="hljs-number">6666</span>).sync();<br>            <span class="hljs-comment">//对关闭通道进行监听</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-创建服务端处理器"><a href="#4-3-创建服务端处理器" class="headerlink" title="4.3 创建服务端处理器"></a>4.3 创建服务端处理器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义的Handler需要继承Netty规定好的HandlerAdapter</span><br><span class="hljs-comment"> * 才能被Netty框架所关联，有点类似SpringMVC的适配器模式</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//获取客户端发送过来的消息</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">&quot;收到客户端&quot;</span> + ctx.channel().remoteAddress() + <span class="hljs-string">&quot;发送的消息：&quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//发送消息给客户端</span><br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;服务端已收到消息，并给你发送一个问号?&quot;</span>, CharsetUtil.UTF_8));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//发生异常，关闭通道</span><br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-4-创建客户端启动类"><a href="#4-4-创建客户端启动类" class="headerlink" title="4.4 创建客户端启动类"></a>4.4 创建客户端启动类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClient</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">eventExecutors</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建bootstrap对象，配置参数</span><br>            <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>            <span class="hljs-comment">//设置线程组</span><br>            bootstrap.group(eventExecutors)<br>                <span class="hljs-comment">//设置客户端的通道实现类型    </span><br>                .channel(NioSocketChannel.class)<br>                <span class="hljs-comment">//使用匿名内部类初始化通道</span><br>                .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-comment">//添加客户端通道的处理器</span><br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClientHandler</span>());<br>                        &#125;<br>                    &#125;);<br>            System.out.println(<span class="hljs-string">&quot;客户端准备就绪，随时可以起飞~&quot;</span>);<br>            <span class="hljs-comment">//连接服务端</span><br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>).sync();<br>            <span class="hljs-comment">//对通道关闭进行监听</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//关闭线程组</span><br>            eventExecutors.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-5-创建客户端处理器"><a href="#4-5-创建客户端处理器" class="headerlink" title="4.5 创建客户端处理器"></a>4.5 创建客户端处理器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//发送消息到服务端</span><br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;歪比巴卜~茉莉~Are you good~马来西亚~&quot;</span>, CharsetUtil.UTF_8));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//接收服务端发送过来的消息</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">&quot;收到服务端&quot;</span> + ctx.channel().remoteAddress() + <span class="hljs-string">&quot;的消息：&quot;</span> + byteBuf.toString(CharsetUtil.UTF_8));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-6-测试"><a href="#4-6-测试" class="headerlink" title="4.6 测试"></a>4.6 测试</h2><p>先启动服务端，再启动客户端，就可以看到结果：</p><p>MyServer打印结果:<br><img src="img_8.png"><br>MyClient打印结果：<br><img src="img_9.png"><br>五、Netty的特性与重要组件<br>===============</p><h2 id="5-1-taskQueue任务队列"><a href="#5-1-taskQueue任务队列" class="headerlink" title="5.1 taskQueue任务队列"></a>5.1 taskQueue任务队列</h2><p>如果Handler处理器有一些长时间的业务处理，可以交给<strong>taskQueue异步处理</strong>。怎么用呢，请看代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//获取到线程池eventLoop，添加线程，执行</span><br>        ctx.channel().eventLoop().execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//长时间操作，不至于长时间的业务操作导致Handler阻塞</span><br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    System.out.println(<span class="hljs-string">&quot;长时间的业务处理&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们打一个debug调试，是可以看到添加进去的taskQueue有一个任务。<br><img src="img_10.png"></p><h2 id="5-2-scheduleTaskQueue延时任务队列"><a href="#5-2-scheduleTaskQueue延时任务队列" class="headerlink" title="5.2 scheduleTaskQueue延时任务队列"></a>5.2 scheduleTaskQueue延时任务队列</h2><p>延时任务队列和上面介绍的任务队列非常相似，只是多了一个可延迟一定时间再执行的设置，请看代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">ctx.channel().eventLoop().schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//长时间操作，不至于长时间的业务操作导致Handler阻塞</span><br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            System.out.println(<span class="hljs-string">&quot;长时间的业务处理&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;,<span class="hljs-number">5</span>, TimeUnit.SECONDS);<span class="hljs-comment">//5秒后执行</span><br></code></pre></td></tr></table></figure><p>依然打开debug进行调试查看，我们可以有一个scheduleTaskQueue任务待执行中</p><p><img src="img.png" alt="img.png"></p><h2 id="5-3-Future异步机制"><a href="#5-3-Future异步机制" class="headerlink" title="5.3 Future异步机制"></a>5.3 Future异步机制</h2><p>在搭建HelloWord工程的时候，我们看到有一行这样的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6666</span>);<br></code></pre></td></tr></table></figure><p>很多操作都返回这个ChannelFuture对象，究竟这个ChannelFuture对象是用来做什么的呢？</p><p>ChannelFuture提供操作完成时一种异步通知的方式。一般在Socket编程中，等待响应结果都是同步阻塞的，而Netty则不会造成阻塞，因为ChannelFuture是采取类似观察者模式的形式进行获取结果。请看一段代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//添加监听器</span><br>channelFuture.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>    <span class="hljs-comment">//使用匿名内部类，ChannelFutureListener接口</span><br>    <span class="hljs-comment">//重写operationComplete方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//判断是否操作成功    </span><br>        <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;连接成功&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;连接失败&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="5-4-Bootstrap与ServerBootStrap"><a href="#5-4-Bootstrap与ServerBootStrap" class="headerlink" title="5.4 Bootstrap与ServerBootStrap"></a>5.4 Bootstrap与ServerBootStrap</h2><p>Bootstrap和ServerBootStrap是Netty提供的一个创建客户端和服务端启动器的工厂类，使用这个工厂类非常便利地创建启动类，根据上面的一些例子，其实也看得出来能大大地减少了开发的难度。首先看一个类图：</p><p><img src="img_17.png"><br>可以看出都是继承于AbstractBootStrap抽象类，所以大致上的配置方法都相同。</p><p>一般来说，使用Bootstrap创建启动器的步骤可分为以下几步：<br><img src="img_11.png"></p><h3 id="5-4-1-group"><a href="#5-4-1-group" class="headerlink" title="5.4.1 group()"></a>5.4.1 group()</h3><p>在上一篇文章<a href="https://mp.weixin.qq.com/s/vWbbn1qXRFVva8Y9yET18Q">《Reactor模式》</a>中，我们就讲过服务端要使用两个线程组：</p><ul><li>  bossGroup 用于监听客户端连接，专门负责与客户端创建连接，并把连接注册到workerGroup的Selector中。</li><li>  workerGroup用于处理每一个连接发生的读写事件。</li></ul><p>一般创建线程组直接使用以下new就完事了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br></code></pre></td></tr></table></figure><p>有点好奇的是，既然是线程组，那线程数默认是多少呢？深入源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用一个常量保存</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> DEFAULT_EVENT_LOOP_THREADS;<br><br><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-comment">//NettyRuntime.availableProcessors() * 2，cpu核数的两倍赋值给常量</span><br>    DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="hljs-number">1</span>, SystemPropertyUtil.getInt(<br>            <span class="hljs-string">&quot;io.netty.eventLoopThreads&quot;</span>, NettyRuntime.availableProcessors() * <span class="hljs-number">2</span>));<br><br>    <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>        logger.debug(<span class="hljs-string">&quot;-Dio.netty.eventLoopThreads: &#123;&#125;&quot;</span>, DEFAULT_EVENT_LOOP_THREADS);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-title function_">MultithreadEventLoopGroup</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, Executor executor, Object... args)</span> &#123;<br>    <span class="hljs-comment">//如果不传入，则使用常量的值，也就是cpu核数的两倍</span><br>    <span class="hljs-built_in">super</span>(nThreads == <span class="hljs-number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过源码可以看到，默认的线程数是cpu核数的两倍。假设想自定义线程数，可以使用有参构造器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置bossGroup线程数为1</span><br><span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">//设置workerGroup线程数为16</span><br><span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><h3 id="5-4-2-channel"><a href="#5-4-2-channel" class="headerlink" title="5.4.2 channel()"></a>5.4.2 channel()</h3><p>这个方法用于设置通道类型，当建立连接后，会根据这个设置创建对应的Channel实例。</p><p><img src="img_1.png" alt="img_1.png"><br>使用debug模式可以看到</p><p><img src="img_3.png" alt="img_3.png"><br>通道类型有以下：</p><p><strong>NioSocketChannel</strong>： 异步非阻塞的客户端 TCP Socket 连接。</p><p><strong>NioServerSocketChannel</strong>： 异步非阻塞的服务器端 TCP Socket 连接。</p><blockquote><p>常用的就是这两个通道类型，因为是异步非阻塞的。所以是首选。</p></blockquote><p>OioSocketChannel： 同步阻塞的客户端 TCP Socket 连接。</p><p>OioServerSocketChannel： 同步阻塞的服务器端 TCP Socket 连接。</p><blockquote><p>稍微在本地调试过，用起来和Nio有一些不同，是阻塞的，所以API调用也不一样。因为是阻塞的IO，几乎没什么人会选择使用Oio，所以也很难找到例子。我稍微琢磨了一下，经过几次报错之后，总算调通了。代码如下：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//server端代码，跟上面几乎一样，只需改三个地方</span><br><span class="hljs-comment">//这个地方使用的是OioEventLoopGroup</span><br><span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OioEventLoopGroup</span>();<br><span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>bootstrap.group(bossGroup)<span class="hljs-comment">//只需要设置一个线程组boosGroup</span><br>        .channel(OioServerSocketChannel.class)<span class="hljs-comment">//设置服务端通道实现类型</span><br><br><span class="hljs-comment">//client端代码，只需改两个地方</span><br><span class="hljs-comment">//使用的是OioEventLoopGroup</span><br><span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">eventExecutors</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OioEventLoopGroup</span>();<br><span class="hljs-comment">//通道类型设置为OioSocketChannel</span><br>bootstrap.group(eventExecutors)<span class="hljs-comment">//设置线程组</span><br>        .channel(OioSocketChannel.class)<span class="hljs-comment">//设置客户端的通道实现类型</span><br></code></pre></td></tr></table></figure><p>NioSctpChannel： 异步的客户端 Sctp（Stream Control Transmission Protocol，流控制传输协议）连接。</p><p>NioSctpServerChannel： 异步的 Sctp 服务器端连接。</p><blockquote><p>本地没启动成功，网上看了一些网友的评论，说是只能在linux环境下才可以启动。从报错信息看：SCTP not supported on this platform，不支持这个平台。因为我电脑是window系统，所以网友说的有点道理。</p></blockquote><h3 id="5-4-3-option-与childOption"><a href="#5-4-3-option-与childOption" class="headerlink" title="5.4.3 option()与childOption()"></a>5.4.3 option()与childOption()</h3><p>首先说一下这两个的区别。</p><p>option()设置的是服务端用于接收进来的连接，也就是boosGroup线程。</p><p>childOption()是提供给父管道接收到的连接，也就是workerGroup线程。</p><p>搞清楚了之后，我们看一下常用的一些设置有哪些：</p><p>SocketChannel参数，也就是childOption()常用的参数：</p><blockquote><p><strong>SO_RCVBUF</strong> Socket参数，TCP数据接收缓冲区大小。<br><strong>TCP_NODELAY</strong> TCP参数，立即发送数据，默认值为Ture。<br><strong>SO_KEEPALIVE</strong> Socket参数，连接保活，默认值为False。启用该功能时，TCP会主动探测空闲连接的有效性。</p></blockquote><p>ServerSocketChannel参数，也就是option()常用参数：</p><blockquote><p><strong>SO_BACKLOG</strong> Socket参数，服务端接受连接的队列长度，如果队列已满，客户端连接将被拒绝。默认值，Windows为200，其他为128。</p></blockquote><p>由于篇幅限制，其他就不列举了，大家可以去网上找资料看看，了解一下。</p><h3 id="5-4-4-设置流水线-重点"><a href="#5-4-4-设置流水线-重点" class="headerlink" title="5.4.4 设置流水线(重点)"></a>5.4.4 设置流水线(重点)</h3><p>ChannelPipeline是Netty处理请求的责任链，ChannelHandler则是具体处理请求的处理器。实际上每一个channel都有一个处理器的流水线。</p><p>在Bootstrap中childHandler()方法需要初始化通道，实例化一个ChannelInitializer，这时候需要重写initChannel()初始化通道的方法，装配流水线就是在这个地方进行。代码演示如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//使用匿名内部类的形式初始化通道对象</span><br>bootstrap.childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//给pipeline管道设置自定义的处理器</span><br>        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServerHandler</span>());<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>处理器Handler主要分为两种：</p><blockquote><p>ChannelInboundHandlerAdapter(入站处理器)、ChannelOutboundHandler(出站处理器)</p></blockquote><p>入站指的是数据从底层java NIO Channel到Netty的Channel。</p><p>出站指的是通过Netty的Channel来操作底层的java NIO Channel。</p><p><strong>ChannelInboundHandlerAdapter处理器常用的事件有</strong>：</p><ol><li> 注册事件 fireChannelRegistered。</li><li> 连接建立事件 fireChannelActive。</li><li> 读事件和读完成事件 fireChannelRead、fireChannelReadComplete。</li><li> 异常通知事件 fireExceptionCaught。</li><li> 用户自定义事件 fireUserEventTriggered。</li><li> Channel 可写状态变化事件 fireChannelWritabilityChanged。</li><li> 连接关闭事件 fireChannelInactive。</li></ol><p><strong>ChannelOutboundHandler处理器常用的事件有</strong>：</p><ol><li> 端口绑定 bind。</li><li> 连接服务端 connect。</li><li> 写事件 write。</li><li> 刷新时间 flush。</li><li> 读事件 read。</li><li> 主动断开连接 disconnect。</li><li> 关闭 channel 事件 close。</li></ol><blockquote><p>还有一个类似的handler()，主要用于装配parent通道，也就是bossGroup线程。一般情况下，都用不上这个方法。</p></blockquote><h3 id="5-4-5-bind"><a href="#5-4-5-bind" class="headerlink" title="5.4.5 bind()"></a>5.4.5 bind()</h3><p>提供用于服务端或者客户端绑定服务器地址和端口号，默认是异步启动。如果加上sync()方法则是同步。</p><p>有五个同名的重载方法，作用都是用于绑定地址端口号。不一一介绍了。</p><h3 id="5-4-6-优雅地关闭EventLoopGroup"><a href="#5-4-6-优雅地关闭EventLoopGroup" class="headerlink" title="5.4.6 优雅地关闭EventLoopGroup"></a>5.4.6 优雅地关闭EventLoopGroup</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//释放掉所有的资源，包括创建的线程</span><br>bossGroup.shutdownGracefully();<br>workerGroup.shutdownGracefully();<br></code></pre></td></tr></table></figure><p>会关闭所有的child Channel。关闭之后，释放掉底层的资源。</p><h2 id="5-5-Channel"><a href="#5-5-Channel" class="headerlink" title="5.5 Channel"></a>5.5 Channel</h2><p>Channel是什么？不妨看一下官方文档的说明：</p><blockquote><p>A nexus to a network socket or a component which is capable of I/O operations such as read, write, connect, and bind</p></blockquote><p>翻译大意：一种连接到网络套接字或能进行读、写、连接和绑定等I/O操作的组件。</p><p>如果上面这段说明比较抽象，下面还有一段说明：</p><blockquote><p>A channel provides a user:</p><p>the current state of the channel (e.g. is it open? is it connected?),<br>the configuration parameters of the channel (e.g. receive buffer size),<br>the I/O operations that the channel supports (e.g. read, write, connect, and bind), and<br>the ChannelPipeline which handles all I/O events and requests associated with the channel.</p></blockquote><p>翻译大意：</p><p>channel为用户提供：</p><ol><li> 通道当前的状态（例如它是打开？还是已连接？）</li><li> channel的配置参数（例如接收缓冲区的大小）</li><li> channel支持的IO操作（例如读、写、连接和绑定），以及处理与channel相关联的所有IO事件和请求的ChannelPipeline。</li></ol><h3 id="5-5-1-获取channel的状态"><a href="#5-5-1-获取channel的状态" class="headerlink" title="5.5.1 获取channel的状态"></a>5.5.1 获取channel的状态</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">isOpen</span><span class="hljs-params">()</span>; <span class="hljs-comment">//如果通道打开，则返回true</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isRegistered</span><span class="hljs-params">()</span>;<span class="hljs-comment">//如果通道注册到EventLoop，则返回true</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isActive</span><span class="hljs-params">()</span>;<span class="hljs-comment">//如果通道处于活动状态并且已连接，则返回true</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">isWritable</span><span class="hljs-params">()</span>;<span class="hljs-comment">//当且仅当I/O线程将立即执行请求的写入操作时，返回true。</span><br></code></pre></td></tr></table></figure><p>以上就是获取channel的四种状态的方法。</p><h3 id="5-5-2-获取channel的配置参数"><a href="#5-5-2-获取channel的配置参数" class="headerlink" title="5.5.2 获取channel的配置参数"></a>5.5.2 获取channel的配置参数</h3><p>获取单条配置信息，使用getOption()，代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ChannelConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> channel.config();<span class="hljs-comment">//获取配置参数</span><br><span class="hljs-comment">//获取ChannelOption.SO_BACKLOG参数,</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">soBackLogConfig</span> <span class="hljs-operator">=</span> config.getOption(ChannelOption.SO_BACKLOG);<br><span class="hljs-comment">//因为我启动器配置的是128，所以我这里获取的soBackLogConfig=128</span><br></code></pre></td></tr></table></figure><p>获取多条配置信息，使用getOptions()，代码演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ChannelConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> channel.config();<br>Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = config.getOptions();<br><span class="hljs-keyword">for</span> (Map.Entry&lt;ChannelOption&lt;?&gt;, Object&gt; entry : options.entrySet()) &#123;<br>    System.out.println(entry.getKey() + <span class="hljs-string">&quot; : &quot;</span> + entry.getValue());<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">SO_REUSEADDR : false</span><br><span class="hljs-comment">WRITE_BUFFER_LOW_WATER_MARK : 32768</span><br><span class="hljs-comment">WRITE_BUFFER_WATER_MARK : WriteBufferWaterMark(low: 32768, high: 65536)</span><br><span class="hljs-comment">SO_BACKLOG : 128</span><br><span class="hljs-comment">以下省略...</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="5-5-3-channel支持的IO操作"><a href="#5-5-3-channel支持的IO操作" class="headerlink" title="5.5.3 channel支持的IO操作"></a>5.5.3 channel支持的IO操作</h3><p><strong>写操作</strong>，这里演示从服务端写消息发送到客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    ctx.channel().writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;这波啊，这波是肉蛋葱鸡~&quot;</span>, CharsetUtil.UTF_8));<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端控制台：</p><pre><code class="hljs">//收到服务端/127.0.0.1:6666的消息：这波啊，这波是肉蛋葱鸡~</code></pre><p><strong>连接</strong>操作，代码演示：</p><pre><code class="hljs">ChannelFuture connect = channelFuture.channel().connect(new InetSocketAddress(&quot;127.0.0.1&quot;, 6666));//一般使用启动器，这种方式不常用</code></pre><p><strong>通过channel获取ChannelPipeline</strong>，并做相关的处理：</p><pre><code class="hljs">//获取ChannelPipeline对象ChannelPipeline pipeline = ctx.channel().pipeline();//往pipeline中添加ChannelHandler处理器，装配流水线pipeline.addLast(new MyServerHandler());</code></pre><h2 id="5-6-Selector"><a href="#5-6-Selector" class="headerlink" title="5.6 Selector"></a>5.6 Selector</h2><p>在NioEventLoop中，有一个成员变量selector，这是nio包的Selector，在之前<a href="https://mp.weixin.qq.com/s/GfV9w2B0mbT7PmeBS45xLw">《NIO入门》</a>中，我已经讲过Selector了。</p><p>Netty中的Selector也和NIO的Selector是一样的，就是用于监听事件，管理注册到Selector中的channel，实现多路复用器。<br><img src="img_12.png"></p><h2 id="5-7-PiPeline与ChannelPipeline"><a href="#5-7-PiPeline与ChannelPipeline" class="headerlink" title="5.7 PiPeline与ChannelPipeline"></a>5.7 PiPeline与ChannelPipeline</h2><p>在前面介绍Channel时，我们知道可以在channel中装配ChannelHandler流水线处理器，那一个channel不可能只有一个channelHandler处理器，肯定是有很多的，既然是很多channelHandler在一个流水线工作，肯定是有顺序的。</p><p>于是pipeline就出现了，pipeline相当于处理器的容器。初始化channel时，把channelHandler按顺序装在pipeline中，就可以实现按序执行channelHandler了。<br><img src="img_13.png"></p><p>在一个Channel中，只有一个ChannelPipeline。该pipeline在Channel被创建的时候创建。ChannelPipeline包含了一个ChannelHander形成的列表，且所有ChannelHandler都会注册到ChannelPipeline中。</p><h2 id="5-8-ChannelHandlerContext"><a href="#5-8-ChannelHandlerContext" class="headerlink" title="5.8 ChannelHandlerContext"></a>5.8 ChannelHandlerContext</h2><p>在Netty中，Handler处理器是有我们定义的，上面讲过通过集成入站处理器或者出站处理器实现。这时如果我们想在Handler中获取pipeline对象，或者channel对象，怎么获取呢。</p><p>于是Netty设计了这个ChannelHandlerContext上下文对象，就可以拿到channel、pipeline等对象，就可以进行读写等操作。<br><img src="img_14.png"></p><p>通过类图，ChannelHandlerContext是一个接口，下面有三个实现类。</p><p>实际上ChannelHandlerContext在pipeline中是一个链表的形式。看一段源码就明白了：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">//ChannelPipeline实现类DefaultChannelPipeline的构造器方法</span><br>protected <span class="hljs-constructor">DefaultChannelPipeline(Channel <span class="hljs-params">channel</span>)</span> &#123;<br>    this.channel = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ObjectUtil</span>.</span></span>check<span class="hljs-constructor">NotNull(<span class="hljs-params">channel</span>, <span class="hljs-string">&quot;channel&quot;</span>)</span>;<br>    succeededFuture = <span class="hljs-keyword">new</span> <span class="hljs-constructor">SucceededChannelFuture(<span class="hljs-params">channel</span>, <span class="hljs-params">null</span>)</span>;<br>    voidPromise =  <span class="hljs-keyword">new</span> <span class="hljs-constructor">VoidChannelPromise(<span class="hljs-params">channel</span>, <span class="hljs-params">true</span>)</span>;<br>    <span class="hljs-comment">//设置头结点head，尾结点tail</span><br>    tail = <span class="hljs-keyword">new</span> <span class="hljs-constructor">TailContext(<span class="hljs-params">this</span>)</span>;<br>    head = <span class="hljs-keyword">new</span> <span class="hljs-constructor">HeadContext(<span class="hljs-params">this</span>)</span>;<br>    <br>    head.next = tail;<br>    tail.prev = head;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我用一张图来表示，会更加清晰一点：<br><img src="img_15.png"><br>5.9 EventLoopGroup</p><hr><p>我们先看一下EventLoopGroup的类图：</p><p><img src="img_16.png"></p><p>其中包括了常用的实现类NioEventLoopGroup。OioEventLoopGroup在前面的例子中也有使用过。</p><p>从Netty的架构图中，可以知道服务器是需要两个线程组进行配合工作的，而这个线程组的接口就是EventLoopGroup。</p><p>每个EventLoopGroup里包括一个或多个EventLoop，每个EventLoop中维护一个Selector实例。</p><h3 id="5-9-1-轮询机制的实现原理"><a href="#5-9-1-轮询机制的实现原理" class="headerlink" title="5.9.1 轮询机制的实现原理"></a>5.9.1 轮询机制的实现原理</h3><p>我们不妨看一段DefaultEventExecutorChooserFactory的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">idx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventExecutor[] executors;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> EventExecutor <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//idx.getAndIncrement()相当于idx++，然后对任务长度取模</span><br>    <span class="hljs-keyword">return</span> executors[idx.getAndIncrement() &amp; executors.length - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码可以确定执行的方式是轮询机制，接下来debug调试一下：</p><p><img src="img_4.png" alt="img_4.png"><br>它这里还有一个判断，如果线程数不是2的N次方，则采用取模算法实现。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_">EventExecutor</span> <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> executors[<span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(idx.<span class="hljs-title function_">getAndIncrement</span>() % executors.<span class="hljs-property">length</span>)];<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzU1OTgzNTAzNQ==&mid=2247483871&idx=1&sn=713a6e11422a815d9f98e1ccf71d19c2">超详细Netty入门，看这篇就够了！</a></li><li><a href="https://jishuin.proginn.com/p/763bfbd35406">一文了解Netty整体流程</a></li><li><a href="https://jishuin.proginn.com/p/763bfbd38161">45 张图深度解析 Netty 架构与原理</a></li><li><a href="https://dongzl.github.io/netty-handbook/#/">Netty 学习手册</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 19 新功能介绍</title>
    <link href="/2022/09/30/java/Java%2019%20%E6%96%B0%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/"/>
    <url>/2022/09/30/java/Java%2019%20%E6%96%B0%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<p><img src="https://wdbyte-img.oss-cn-hangzhou.aliyuncs.com/img/22/20220925114113.png?x-oss-process=style/1000px" alt="Java 19"></p><p><strong>Java 19</strong> 在2022 年 9 月 20 日正式发布，Java 19 不是一个长期支持版本，直到 2023 年 3 月它将被 JDK 20 取代，这次更新共带来 7 个新功能。</p><pre><code class="hljs">➜  bin ./java -versionopenjdk version &quot;19&quot; 2022-09-20OpenJDK Runtime Environment (build 19+36-2238)OpenJDK 64-Bit Server VM (build 19+36-2238, mixed mode, sharing)</code></pre><p>OpenJDK Java 19 下载：<a href="https://jdk.java.net/19/">https://jdk.java.net/19/ (opens new window)</a></p><p>OpenJDK Java 19 文档：<a href="https://openjdk.java.net/projects/jdk/19/">https://openjdk.java.net/projects/jdk/19/ (opens new window)</a></p><blockquote><p>Java 19 新功能介绍是 Java 新特性系列文章中的一部分。</p><p>系列详情可以浏览：<a href="https://www.wdbyte.com/java-feature/">https://www.wdbyte.com/java-feature/ (opens new window)</a></p></blockquote><h1 id="JEP-405-Record-模式匹配（预览）"><a href="#JEP-405-Record-模式匹配（预览）" class="headerlink" title="JEP 405: Record 模式匹配（预览）"></a>JEP 405: Record 模式匹配（预览）</h1><p><code>record</code> 是一种全新的类型，它本质上是一个 <code>final</code> 类，同时所有的属性都是 <code>final</code> 修饰，它会自动编译出 <code>public get</code> <code>hashcode</code> 、<code>equals</code>、<code>toString</code> 等方法，减少了代码编写量。Record 在 Java 14 中被提出，在 Java 15 中二次预览，在 Java 16 中正式发布。</p><p>示例：编写一个 Dog record 类，定义 name 和 age 属性。</p><pre><code class="hljs">package com.wdbyte;public record Dog(String name, Integer age) &#123;&#125;</code></pre><p>Record 的使用。</p><pre><code class="hljs">package com.wdbyte;public class Java14Record &#123;    public static void main(String[] args) &#123;        Dog dog1 = new Dog(&quot;牧羊犬&quot;, 1);        Dog dog2 = new Dog(&quot;田园犬&quot;, 2);        Dog dog3 = new Dog(&quot;哈士奇&quot;, 3);        System.out.println(dog1);        System.out.println(dog2);        System.out.println(dog3);    &#125;&#125;</code></pre><p>输出结果：</p><pre><code class="hljs">Dog[name=牧羊犬, age=1]Dog[name=田园犬, age=2]Dog[name=哈士奇, age=3]</code></pre><p>在 Java 19 中，为 Record 带来了增强的模式匹配，在使用 <code>instanceof</code> 后，可以进行类型转换。</p><pre><code class="hljs">public class RecordTest &#123;    public static void main(String[] args) &#123;        Object dog1 = new Dog(&quot;牧羊犬&quot;, 1);        if(dog1 instanceof Dog dogTemp)&#123;            System.out.println(dogTemp.name());         &#125;    &#125;&#125;record Dog( String name, Integer age )&#123;&#125;// ➜  bin ./java  RecordTest.java// 牧羊犬</code></pre><p>甚至可以在使用 <code>instanceof</code> 时直接得到 <code>Record</code> 中的变量引用。</p><pre><code class="hljs">public class RecordTest2 &#123;    public static void main(String[] args) &#123;        Object dog1 = new Dog(&quot;牧羊犬&quot;, 1);        if(dog1 instanceof Dog(String name,Integer age))&#123;            System.out.println(name+&quot;:&quot;+age);         &#125;    &#125;&#125;record Dog( String name, Integer age )&#123;&#125;//➜  bin ./java --enable-preview --source 19 RecordTest2.java//注: RecordTest2.java 使用 Java SE 19 的预览功能。//注: 有关详细信息，请使用 -Xlint:preview 重新编译。//牧羊犬:1</code></pre><blockquote><p>扩展：</p><p><a href="https://www.wdbyte.com/java/java-14/#_1-jep-305-instanceof-%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD-%E9%A2%84%E8%A7%88">Java 14 instanceof 类型推断 (opens new window)</a></p><p><a href="https://www.wdbyte.com/java/java-16/#_14-jep-395-records">Java 16 Record 介绍 (opens new window)</a></p></blockquote><h1 id="JEP-425-虚拟线程-预览"><a href="#JEP-425-虚拟线程-预览" class="headerlink" title="JEP 425: 虚拟线程 (预览)"></a>JEP 425: 虚拟线程 (预览)</h1><p><strong>很实用</strong>的一个新特性，从 Java 19 开始逐步的引入虚拟线程，虚拟线程是<strong>轻量级的线程</strong>，可以在显著的减少代码的编写，提高可维护性的同时提高系统的<strong>吞吐量</strong>。</p><h3 id="引入的原因"><a href="#引入的原因" class="headerlink" title="引入的原因"></a>引入的原因</h3><p>一直以来，在 Java 并发编程中，Thread 都是十分重要的一部分，Thread 是 Java 中的并发单元，每个 Thread 线程都提供了一个堆栈来存储局部变量和方法调用，以及线程上下文等相关信息。</p><p>但问题是线程和进程一样，都是一项<strong>昂贵的资源</strong>，JDK 将 Thread 线程实现为操作系统线程的包装器，也就是说成本很高，而且数量有限。也因此我们会使用线程池来管理线程，同时限制线程的数量。比如常用的 Tomcat 会<strong>为每次请求单独使用一个线程进行请求处理</strong>，同时限制处理请求的线程数量以防止线程过多而崩溃；这很有可能<strong>在 CPU 或网络连接没有耗尽之前，线程数量已经耗尽</strong>，从而限制了 web 服务的吞吐量。</p><p>看到这里你可能要说了，可以放弃请求和线程一一对应的方式啊，使用异步编程来解决这个问题，把请求处理分段，在组合成顺序管道，通过一套 API 进行管理，这样就可以使用有限的线程来处理超过线程数量的请求。这当然也是可以的，但是随之而来的问题是：</p><ul><li>  需要额外的学习异步编程。</li><li>  代码复杂度增加，等于放弃了语言的基本顺序组合运算。</li><li>  堆栈上下文信息都变得难以追踪。</li><li>  Debug 困难。</li><li>  和 Java 平台本身的编程风格有冲突，Java 并发单元是 Thread，而这时是异步管道。</li></ul><h3 id="虚拟线程"><a href="#虚拟线程" class="headerlink" title="虚拟线程"></a>虚拟线程</h3><p>基于上面的种种原因，Java 19 引入了虚拟线程，在使用体验上和 Thread 没有区别，与之前的 API 互相兼容，但是相比之下虚拟线程资源占用非常少，同时优化了硬件的使用效率，因此非常易用且<strong>不需要被池化</strong>。</p><p>下面是一个示例，<strong>创建 10 万个线程</strong>，然后都休眠 1 秒钟最后打印耗时，如果是开传统的 Thread 线程的方式，资源十分紧张；如果是线程池的方式，必定有部分线程在等待线程释放；但是使用虚拟线程的方式，可以瞬间完成。</p><pre><code class="hljs">import java.util.concurrent.Executors;import java.util.stream.IntStream;public class ThreadTest &#123;    public static void main(String[] args) &#123;        long start = System.currentTimeMillis();        try (var executor = Executors.newVirtualThreadPerTaskExecutor()) &#123;            IntStream.range(0, 100_000).forEach(i -&gt; &#123;                executor.submit(() -&gt; &#123;                    Thread.sleep(1000);                    return i;                &#125;);            &#125;);        &#125; // executor.close() 会被自动调用        // 提交了 10 万个虚拟线程，每个线程休眠 1 秒钟，1秒左右完成        System.out.println(&quot;耗时:&quot; + (System.currentTimeMillis() - start)+&quot;ms&quot;);    &#125;&#125;</code></pre><p>执行后发现 1.3 秒执行完毕，速度惊人。</p><pre><code class="hljs">➜  bin ./java --enable-preview --source 19  ThreadTest.java注: ThreadTest.java 使用 Java SE 19 的预览功能。注: 有关详细信息，请使用 -Xlint:preview 重新编译。耗时:1309ms➜  bin</code></pre><p>注意：虚拟线程只是增加程序的吞吐量，并不能提高程序的处理速度。</p><h1 id="JEP-427-switch-模式匹配-三次预览"><a href="#JEP-427-switch-模式匹配-三次预览" class="headerlink" title="JEP 427: switch 模式匹配 (三次预览)"></a>JEP 427: switch 模式匹配 (三次预览)</h1><hr><p>Switch 模式匹配在 Java 17 中已经引入，在 Java 18 中二次预览，现在在 Java 19 中进行三次预览，功能和在 <a href="https://www.wdbyte.com/java/java-18/#jep-420-switch-%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%BA%8C%E6%AC%A1%E5%AD%B5%E5%8C%96">Java 18 新功能介绍 - Switch (opens new window)</a> 中介绍的一样，改进后的 Switch 模式匹配可以代码更加简洁，逻辑更加清晰，下面是一些使用示例对比。</p><p>下面是几个例子：</p><pre><code class="hljs">// JDK 17 以前static String formatter(Object o) &#123;    String formatted = &quot;unknown&quot;;    if (o instanceof Integer i) &#123;        formatted = String.format(&quot;int %d&quot;, i);    &#125; else if (o instanceof Long l) &#123;        formatted = String.format(&quot;long %d&quot;, l);    &#125; else if (o instanceof Double d) &#123;        formatted = String.format(&quot;double %f&quot;, d);    &#125; else if (o instanceof String s) &#123;        formatted = String.format(&quot;String %s&quot;, s);    &#125;    return formatted;&#125;</code></pre><p>而在 Java 17 之后，可以通过下面的写法进行改进：</p><pre><code class="hljs">// JDK 17 之后static String formatterPatternSwitch(Object o) &#123;    return switch (o) &#123;        case Integer i -&gt; String.format(&quot;int %d&quot;, i);        case Long l    -&gt; String.format(&quot;long %d&quot;, l);        case Double d  -&gt; String.format(&quot;double %f&quot;, d);        case String s  -&gt; String.format(&quot;String %s&quot;, s);        default        -&gt; o.toString();    &#125;;&#125;</code></pre><p>switch 可以和 <code>null</code> 进行结合判断：</p><pre><code class="hljs">static void testFooBar(String s) &#123;    switch (s) &#123;        case null         -&gt; System.out.println(&quot;Oops&quot;);        case &quot;Foo&quot;, &quot;Bar&quot; -&gt; System.out.println(&quot;Great&quot;);        default           -&gt; System.out.println(&quot;Ok&quot;);    &#125;&#125;</code></pre><p>case 时可以加入复杂表达式：</p><pre><code class="hljs">static void testTriangle(Shape s) &#123;    switch (s) &#123;        case Triangle t &amp;&amp; (t.calculateArea() &gt; 100) -&gt;            System.out.println(&quot;Large triangle&quot;);        default -&gt;            System.out.println(&quot;A shape, possibly a small triangle&quot;);    &#125;&#125;</code></pre><p>case 时可以进行类型判断：</p><pre><code class="hljs">sealed interface S permits A, B, C &#123;&#125;final class A implements S &#123;&#125;final class B implements S &#123;&#125;record C(int i) implements S &#123;&#125;  // Implicitly finalstatic int testSealedExhaustive(S s) &#123;    return switch (s) &#123;        case A a -&gt; 1;        case B b -&gt; 2;        case C c -&gt; 3;    &#125;;&#125;</code></pre><p>扩展：<a href="https://www.wdbyte.com/java/java-17/#_7-jep-406-switch-%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%8C%B9%E9%85%8D-%E9%A2%84%E8%A7%88">JEP 406：Switch 的类型匹配（预览） (opens new window)</a></p><h1 id="JEP-422-Linux-RISC-V-Port"><a href="#JEP-422-Linux-RISC-V-Port" class="headerlink" title="JEP 422: Linux/RISC-V Port"></a>JEP 422: Linux/RISC-V Port</h1><p><a href="https://en.wikipedia.org/wiki/RISC-V">RISC-V (opens new window)</a>是一个免费和开源的 RISC 指令集架构 (ISA)，实际上 RISC-V 是一系列相关的 ISA，现在 Java 19 开始对其进行支持。</p><h1 id="JEP-424-外部函数-amp-内存-API-预览"><a href="#JEP-424-外部函数-amp-内存-API-预览" class="headerlink" title="JEP 424: 外部函数 &amp; 内存 API (预览)"></a>JEP 424: 外部函数 &amp; 内存 API (预览)</h1><p>此功能引入的 API 允许 Java 开发者与 JVM 之外的代码和数据进行交互，通过调用外部函数（JVM之外）和安全的访问外部内存（非 JVM 管理），让 Java 程序可以调用本机库并处理本机数据，而不会像 JNI 一样存在很多安全风险。</p><p>这不是一个新功能，自 Java 14 就已经引入，此次对其进行了性能、通用性、安全性、易用性上的优化。</p><p><em>历史</em></p><ul><li>  Java 14 <a href="https://openjdk.java.net/jeps/370">JEP 370 (opens new window)</a> 引入了外部内存访问 API（孵化器）。</li><li>  Java 15 <a href="https://openjdk.java.net/jeps/383">JEP 383 (opens new window)</a>引入了外部内存访问 API（第二孵化器）。</li><li>  Java 16 <a href="https://openjdk.java.net/jeps/389">JEP 389 (opens new window)</a>引入了外部链接器 API（孵化器）。</li><li>  Java 16 <a href="https://openjdk.java.net/jeps/393">JEP 393 (opens new window)</a>引入了外部内存访问 API（第三孵化器）。</li><li>  Java 17 <a href="https://openjdk.java.net/jeps/412">JEP 412 (opens new window)</a>引入了外部函数和内存 API（孵化器）。</li><li>  Java 18 <a href="https://openjdk.java.net/jeps/419">JEP 419 (opens new window)</a>引入了外部函数和内存 API（二次孵化器）。</li></ul><h1 id="其他更新"><a href="#其他更新" class="headerlink" title="其他更新"></a>其他更新</h1><p><strong>JEP 426: Vector API (四次孵化)</strong></p><p>通过将在运行时可靠地编译为支持的 CPU 架构上的向量指令的向量计算表示，与等效的标量计算相比，实现了卓越的性能。此功能已经第四次孵化，在之前 Java 16 ~ Java 18 中都有介绍，这里不做赘述。</p><p><strong>JEP 428: Structured Concurrency (孵化)</strong></p><p>通过简化多线程编程并将在不同线程中运行的多个任务视为单个工作单元，简化错误处理和取消，提高可靠性并增强可观察性。</p><h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><ul><li><a href="https://www.wdbyte.com/java/java-19/">Java 19 新功能介绍</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Feign服务间调用请求头丢失问题</title>
    <link href="/2022/09/29/java/Feign%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%B0%83%E7%94%A8%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/29/java/Feign%E6%9C%8D%E5%8A%A1%E9%97%B4%E8%B0%83%E7%94%A8%E8%AF%B7%E6%B1%82%E5%A4%B4%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>客户端带请求头请求接口–&gt;接口调用其他服务的接口会导致请求头丢失问题</p><p>例子：有两个服务A和B，都加了认证拦截器，客户端调用服务A接口时会携带<code>cookie</code>请求头信息，经过服务A认证拦截器后调用服务B接口，在经过服务B拦截器时会发现请求头<code>cookie</code>丢失问题</p><h1 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h1><p>Feign 远程调用时会生成代理对象，代理对象调用时会经过一些逻辑判断和一系列的拦截器，构造出新的Request对象，Request默认为空，所以导致请求头丢失问题</p><h1 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h1><p>如果生成代理对象后再经过我们定义的拦截器，将请求头加上去再调用远程服务就可以解决这个问题；</p><p><img src="img.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> feign.RequestInterceptor;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.web.context.request.RequestContextHolder;<br><span class="hljs-keyword">import</span> org.springframework.web.context.request.ServletRequestAttributes;<br><br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Feign 配置类，解决Feign调用请求头丢失问题</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FeignConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean(&quot;requestInterceptor&quot;)</span><br>    <span class="hljs-keyword">public</span> RequestInterceptor <span class="hljs-title function_">requestInterceptor</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-type">RequestInterceptor</span> <span class="hljs-variable">requestInterceptor</span> <span class="hljs-operator">=</span> template -&gt; &#123;<br>            <span class="hljs-comment">//1、使用RequestContextHolder拿到刚进来的请求数据（原理：通过ThreadLocal存取）</span><br>            <span class="hljs-type">ServletRequestAttributes</span> <span class="hljs-variable">requestAttributes</span> <span class="hljs-operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();<br><br>            <span class="hljs-keyword">if</span> (requestAttributes != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> requestAttributes.getRequest();<br>                <span class="hljs-comment">//2、同步请求头的数据（例如把cookie放到新的请求头中）</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;token&quot;</span>);<br>                template.header(<span class="hljs-string">&quot;token&quot;</span>, token);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-keyword">return</span> requestInterceptor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><p><img src="img_1.png"></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://codeantenna.com/a/nWgdG0MWx7">Feign服务间调用请求头丢失问题（整理）</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>feign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解 OpenFeign 远程调用的架构原理</title>
    <link href="/2022/09/27/java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20OpenFeign%20%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E7%9A%84%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/"/>
    <url>/2022/09/27/java/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20OpenFeign%20%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E7%9A%84%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6aa8ace980894507aef8610253e4528a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp"></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://juejin.cn/post/7114293942014869540">深入理解 OpenFeign 远程调用的架构原理</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>OpenFeign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大白话聊 Web3——终将到来的时代，会如我们所想吗</title>
    <link href="/2022/09/26/web3/%E5%A4%A7%E7%99%BD%E8%AF%9D%E8%81%8A%20Web3%E2%80%94%E2%80%94%E7%BB%88%E5%B0%86%E5%88%B0%E6%9D%A5%E7%9A%84%E6%97%B6%E4%BB%A3%EF%BC%8C%E4%BC%9A%E5%A6%82%E6%88%91%E4%BB%AC%E6%89%80%E6%83%B3%E5%90%97/"/>
    <url>/2022/09/26/web3/%E5%A4%A7%E7%99%BD%E8%AF%9D%E8%81%8A%20Web3%E2%80%94%E2%80%94%E7%BB%88%E5%B0%86%E5%88%B0%E6%9D%A5%E7%9A%84%E6%97%B6%E4%BB%A3%EF%BC%8C%E4%BC%9A%E5%A6%82%E6%88%91%E4%BB%AC%E6%89%80%E6%83%B3%E5%90%97/</url>
    
    <content type="html"><![CDATA[<ul><li>web和web3之间的关系就是雷锋和雷峰塔之间的关系——也就是没有关系</li><li>web3跟web2比，你会发现方方面面都是退步（比如区块链的传输交易可能需要几十分钟，区块链的存储需要钱还很贵）。这时候八成是你看错了这个东西的本质——你不能拿着皮鞋当筷子用，然后抱怨这个筷子不好用</li><li>互联网是把很多已有网络连起来了，连成了一张全球唯一共同的一张大网络；区块链是一张全球所有人共享的一张数据表，table one（只能append到最后一行，不能删和改）</li><li>web3不是下一代的互联网，它是基于互联网的新东西。比如计算机是基于电力的，互联网是基于计算机的，区块链是基于互联网的</li><li>当一个新技术忽然出现了，很显然是没有（现有）应用场景的。就像互联网出现后大家没头苍蝇一样找各种应用，等浏览器出现后 web才出现。<ul><li>eg1：像微信这种1s发一条信息，在美国1s能收到，这样的需求是不存在的，大家觉得信一天能寄到已经是不可思议了。</li><li>eg2：当有了几乎是无限的带宽后，大家才想着找应用，才有了4k 8k电视这样的探索</li></ul></li><li>没有基础设施的原因是没有需求，没有需求是因为应用做不出来，应用做不出来是因为没有基础设施,这是一个死锁.所以技术的发展要有自己的节奏，需要“左脚走一步，右脚才能走一步，左脚才能再走一步”</li><li>要看一个技术实现了哪些以前没法实现的东西，越底层它可能对世界的影响就越大。（互联网初期：1 bit信息可以几乎0时间0成本传到世界任一角落）区块链创造了人类历史上从没有过的新能力：人类第一次有了一个可以共同相信的东西</li><li>大家的误区是总觉得新世界会取代旧世界。no，区块链只是在现实的世界上面又叠加了一层</li><li>（什么时候适合进入web3）当你适合进入的时候 你自然会知道的，有人告诉你一个东西你觉得挺好用的，就自然而然进入了。这个其实不是你的胜利，是整个web3的胜利，它把你赢得了</li></ul><h1 id="references"><a href="#references" class="headerlink" title="references"></a>references</h1><ul><li><a href="https://www.xiaoyuzhoufm.com/episode/62d93b1cfa15142e17251e05">大白话聊 Web3——终将到来的时代，会如我们所想吗？（Sarah &amp; 王建硕）</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Difference between Subarray, Subsequence, and Subset</title>
    <link href="/2022/09/26/other/Difference%20between%20Subarray,%20Subsequence,%20and%20Subset/"/>
    <url>/2022/09/26/other/Difference%20between%20Subarray,%20Subsequence,%20and%20Subset/</url>
    
    <content type="html"><![CDATA[<p>This post will discuss the difference between a subarray, a substring, a subsequence, and a subset.</p><h1 id="1-Subarray"><a href="#1-Subarray" class="headerlink" title="1. Subarray"></a>1. Subarray</h1><p>A subarray is a slice from a contiguous array (i.e., occupy consecutive positions) and inherently maintains the order of elements. For example, the subarrays of array {1, 2, 3} are {1}, {1, 2}, {1, 2, 3}, {2}, {2, 3}, and {3}.</p><p>Please note that there are precisely n×(n+1)/2 subarrays in an array of size n. Also, there is no such thing as a contiguous subarray. The prefix contiguous is sometimes applied to make the context more clear. So, a contiguous subarray is just another name for a subarray.</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span><br>&#123;<br>    <span class="hljs-comment">// Function to print all subarrays of the specified array</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printAllSubarrays</span><span class="hljs-params">(List&lt;Integer&gt; input)</span><br>    &#123;<br>        <span class="hljs-comment">// consider all subarrays starting from `i`</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; input.size(); i++)<br>        &#123;<br>            <span class="hljs-comment">// consider all subarrays ending at `j`</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; input.size(); j++)<br>            &#123;<br>                <span class="hljs-comment">// Function to print a subarray formed by [i, j]</span><br>                System.out.println(input.subList(i, j + <span class="hljs-number">1</span>));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        List&lt;Integer&gt; input = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>        printAllSubarrays(input);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>Output:</p><p>[1]<br>[1, 2]<br>[1, 2, 3]<br>[1, 2, 3, 4]<br>[1, 2, 3, 4, 5]<br>[2]<br>[2, 3]<br>[2, 3, 4]<br>[2, 3, 4, 5]<br>[3]<br>[3, 4]<br>[3, 4, 5]<br>[4]<br>[4, 5]<br>[5]</p><h1 id="2-Substring"><a href="#2-Substring" class="headerlink" title="2. Substring"></a>2. Substring</h1><p>A substring of a string s is a string s’ that occurs in s. A substring is almost similar to a subarray, but it is in the context of strings.</p><p>For example, the substrings of string ‘apple’ are ‘apple’, ‘appl’, ‘pple’, ‘app’, ‘ppl’, ‘ple’, ‘ap’, ‘pp’, ‘pl’, ‘le’, ‘a’, ‘p’, ‘l’, ‘e’, ‘’.</p><h2 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span><br>&#123;<br>    <span class="hljs-comment">// Function to print all non-empty substrings of the specified string</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printAllSubstrings</span><span class="hljs-params">(String str)</span><br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> str.length();<br> <br>        <span class="hljs-comment">// consider all substrings starting from `i`</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            <span class="hljs-comment">// consider all substrings ending at j</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; n; j++) &#123;<br>                System.out.print(<span class="hljs-string">&quot;&#x27;&quot;</span> + str.substring(i, j + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;&#x27;, &quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;techie&quot;</span>;<br>        printAllSubstrings(str);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Output:</p><p>‘t’, ‘te’, ‘tec’, ‘tech’, ‘techi’, ‘techie’, ‘e’, ‘ec’, ‘ech’, ‘echi’, ‘echie’, ‘c’, ‘ch’, ‘chi’, ‘chie’, ‘h’, ‘hi’, ‘hie’, ‘i’, ‘ie’, ‘e’</p><h1 id="3-Subsequence"><a href="#3-Subsequence" class="headerlink" title="3. Subsequence"></a>3. Subsequence</h1><p>A subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements. For example, {nums, B, D} is a subsequence of sequence {nums, B, C, D, E} obtained after removing {C} and {E}.</p><p>People are often confused between a subarray/substring and a subsequence. A subarray or substring will always be contiguous, but a subsequence need not be contiguous. That is, subsequences are not required to occupy consecutive positions within the original sequences. But we can say that both contiguous subsequence and subarray are the same.</p><p>In other words, the subsequence is a generalization of a substring, or substring is a refinement of the subsequence. For example, {nums, C, E} is a subsequence of {nums, B, C, D, E}, but not a substring, and {nums, B, C} is both a subarray and a subsequence.</p><p>Please note that a subsequence can be in the context of both arrays and strings. Generating all subsequences of an array/string is equivalent to generating a power set of an array/string. For a given set, S, we can find the power set by generating all binary numbers between 0 and 2n-1, where n is the size of the given set. </p><h2 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span><br>&#123;<br>    <span class="hljs-comment">// Function to print all subsequences of the specified string</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">findPowerSet</span><span class="hljs-params">(String str)</span><br>    &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> str.length();<br> <br>        <span class="hljs-comment">// N stores the total number of subsets</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">N</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)Math.pow(<span class="hljs-number">2</span>, n);<br> <br>        List&lt;String&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br> <br>        <span class="hljs-comment">// generate each subset one by one</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++)<br>        &#123;<br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br> <br>            <span class="hljs-comment">// check every bit of `i`</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; n; j++)<br>            &#123;<br>                <span class="hljs-comment">// if j&#x27;th bit of `i` is set, print S[j]</span><br>                <span class="hljs-keyword">if</span> ((i &amp; (<span class="hljs-number">1</span> &lt;&lt; j)) != <span class="hljs-number">0</span>) &#123;<br>                    sb.append(str.charAt(j));<br>                &#125;<br>            &#125;<br>            result.add(<span class="hljs-string">&quot;&#x27;&quot;</span> + sb.toString() + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        &#125;<br> <br>        System.out.println(result);<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span><br>    &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;apple&quot;</span>;<br>        findPowerSet(str);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>Output:</p><p>[‘’, ‘a’, ‘p’, ‘ap’, ‘p’, ‘ap’, ‘pp’, ‘app’, ‘l’, ‘al’, ‘pl’, ‘apl’, ‘pl’, ‘apl’, ‘ppl’, ‘appl’, ‘e’, ‘ae’, ‘pe’, ‘ape’, ‘pe’, ‘ape’, ‘ppe’, ‘appe’, ‘le’, ‘ale’, ‘ple’, ‘aple’, ‘ple’, ‘aple’, ‘pple’, ‘apple’]</p><h1 id="4-Subset"><a href="#4-Subset" class="headerlink" title="4. Subset"></a>4. Subset</h1><p>A subset is any possible combination of the original set. The term subset is often used for subsequence, but that’s not right. A subsequence always maintains the relative order of the array elements (i.e., increasing index), but there is no such restriction on a subset. For example, {3, 1} is a valid subset of {1, 2, 3, 4, 5}, but it is neither a subsequence nor a subarray.</p><p>It is worth noting that all subarrays are subsequences and all subsequences are a subset, but the reverse is not valid. For instance, a subarray {1, 2} of array {1, 2, 3, 4, 5} is also a subsequence and a subset.</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://www.techiedelight.com/difference-between-subarray-subsequence-subset/">Difference between Subarray, Subsequence, and Subset</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring配置属性管理--Environment</title>
    <link href="/2022/09/23/spring/Spring%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E7%AE%A1%E7%90%86--Environment/"/>
    <url>/2022/09/23/spring/Spring%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E7%AE%A1%E7%90%86--Environment/</url>
    
    <content type="html"><![CDATA[<p>在上一篇文章中 Spring配置属性管理—Value注解解析我们从@Value注解入手大致讲解了一下配置属性在Spring项目中应用的基本原理，本文将会围绕Spring的Environment对org.springframework.core.env包中的重要类进行进一步的解析。</p><blockquote><p>The Environment interface is an abstraction integrated in the container that models two key aspects of the application environment: profiles and properties.</p><p>A profile is a named, logical group of bean definitions to be registered with the container only if the given profile is active. Beans may be assigned to a profile whether defined in XML or with annotations. The role of the Environment object with relation to profiles is in determining which profiles (if any) are currently active, and which profiles (if any) should be active by default.</p><p>Properties play an important role in almost all applications and may originate from a variety of sources: properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc Properties objects, Map objects, and so on. The role of the Environment object with relation to properties is to provide the user with a convenient service interface for configuring property sources and resolving properties from them.</p></blockquote><p>在Spring的官方文档中我们可以得知，在Spring框架中Environment主要负责两个Profiles于Properties两个部分。这两个部分对于我们而言基本上是耳熟能详的了，Profiles通常用于应用区分环境（例如测试、预发、正式加载不同的属性配置或者是Bean配置），Properties则是Spring用于管理配置文件属性的重要组件。本文我们重点关注一下Properties相关的原理。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">ApplicationContext ctx = <span class="hljs-keyword">new</span> <span class="hljs-constructor">GenericApplicationContext()</span>;<br>Environment env = ctx.get<span class="hljs-constructor">Environment()</span>;<br>boolean containsMyProperty = env.contains<span class="hljs-constructor">Property(<span class="hljs-string">&quot;my-property&quot;</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;Does my environment contain the &#x27;my-property&#x27; property? &quot;</span> + containsMyProperty);<br></code></pre></td></tr></table></figure><p>除了在上一篇文章中提到的利用@Value注解来获取配置属性以外，我们还可以通过上面的代码片段利用Environment来获取到配置属性（通常在应用中使用的是自动注入的Environment），默认单机应用的情况下在ApplicationContext中的Environment的具体实现类是StandardEnvironment，在其中配置了两个默认的PropertySource(属性数据源)分别是JVM系统数据以及操作系统环境变量属性，在Spring Web应用中则是由StandardServletEnvironment负责具体的实现，增加了Servlet配置相关的数据源。</p><p><img src="img.png"></p><p>我们围绕这张UML类图来分析StandardEnvironment是如何为Spring应用程序提供属性配置的。</p><p>PropertyResolver定义了从属性配置源的获取属性的基本功能接口，主要包含三种类型的接口：获取字符串类型属性、获取指定类型的属性以及利用属性解析字符串中的占位符。</p><p>ConfigurablePropertyResolver进一步完善了属性相关的接口定义，提供了自定义属性解析的相关接口，例如配置属性类型转换器、占位符设置等。</p><p>而在ConfigurableEnvironment中则定义了获取属性源的相关的接口，在这个接口中我们可以注意到，默认情况下Environment一定会存在两个属性，一个是SystemProperties另一个是SystemEnvironment。</p><p>再往下则是AbstractEnvironment，在这个抽象类中实现了大部分的属性相关功能，总的来说可以分为两个部分，也是最重要的两个部分，负责属性存储管理的MutablePropertySources以及负责属性解析的ConfigurablePropertyResolver。</p><p>StandardEnvironment与StandardServletEnvironment实际上并没有实现太多的功能，而是根据自己不同的特性为AbstractEnvironment添加了默认的属性源。</p><h1 id="MutablePropertySources"><a href="#MutablePropertySources" class="headerlink" title="MutablePropertySources"></a>MutablePropertySources</h1><p>MutablePropertySources实现了PropertySources接口，PropertySources定义了属性源PropertySource容器相关的接口（例如遍历属性源、根据名称获取属性源等），PropertySource与Java中常用的Properties类似，不同的是除了定义了查询属性的方法外，每个属性源还包含一个属性源的名称。</p><p>在MutablePropertySources中，使用一个CopyOnWriteArrayList来存储PropertySource，为什么用的不是Map来保存呢？因为不同的属性源是有优先级区别的，高优先级属性会覆盖低优先级的属性（MutablePropertySources提供了addFirst、addLast属性）。那为什么用的不是普通的List而需要用的是CopyOnWriteArrayList呢，因为CopyOnWriteArrayList提供了更加稳定的遍历功能，获取属性源的时候如下所示使用的是遍历的方式，而属性源的变更在应用中通常是低频的。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># org.springframework.core.env.MutablePropertySources.<span class="hljs-keyword">get</span><br><span class="hljs-built_in">public</span> PropertySource&lt;?&gt; <span class="hljs-keyword">get</span>(String <span class="hljs-type">name</span>) &#123;<br><span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = this.propertySourceList.indexOf(PropertySource.named(<span class="hljs-type">name</span>));<br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">index</span> != <span class="hljs-number">-1</span> ? this.propertySourceList.<span class="hljs-keyword">get</span>(<span class="hljs-keyword">index</span>) : <span class="hljs-keyword">null</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在spring-core的env包下提供了两种比较常用的PropertySource的具体实现类，分别是以Properties作为数据源的PropertiesPropertySource、以Map对象作为数据源的MapPropertySource，以存储系统环境变量的SystemEnvironmentPropertySource为例，继承了MapPropertySource，将System.getenv()返回的属性转换为Map作为数据源，默认的属性源的名称是systemEnvironment。</p><p>在前面提到默认的情况下Environment中包含两个JVM系统属性与操作系统属性，那是在什么时候被添加到AbstractEnvironment中的MutablePropertySources的呢，回到StandardEnvironment的customizePropertySources中，这个函数主要是用于不同的Environment来添加自定义的属性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># org.springframework.core.env.StandardEnvironment.customizePropertySources</span><br><br>@<span class="hljs-function">Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-type">void</span> <span class="hljs-title">customizePropertySources</span><span class="hljs-params">(MutablePropertySources propertySources)</span> </span>&#123;<br>propertySources.<span class="hljs-built_in">addLast</span>(<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">PropertiesPropertySource</span>(SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, <span class="hljs-built_in">getSystemProperties</span>()));<br>propertySources.<span class="hljs-built_in">addLast</span>(<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">SystemEnvironmentPropertySource</span>(SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, <span class="hljs-built_in">getSystemEnvironment</span>()));<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="ConfigurablePropertyResolver"><a href="#ConfigurablePropertyResolver" class="headerlink" title="ConfigurablePropertyResolver"></a>ConfigurablePropertyResolver</h1><p>在上一篇文章中我们提到了无论是AbstractEnvironment还是PropertySourcesPlaceholderConfigurer中，真正负责属性解析的都是PropertySourcesPropertyResolver。PropertySourcesPropertyResolver继承自AbstractPropertyResolver，AbstractPropertyResolver实现了属性解析的大部分的功能模版，例如使用PropertyPlaceholderHelper解析占位符，利用ConfigurableConversionService完成属性到目标类型的转换等，而PropertySourcesPropertyResolver负责数据源的存储以及实现属性获取的基本功能。以下面的函数为例，PropertySourcesPropertyResolver在查找属性时，会遍历所有的PropertySource，首先直接通过key获取属性，当属性不存在的时在解析占位符，最后利用ConversionService完成属性转换。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"># org.springframework.core.env.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PropertySourcesPropertyResolver</span>.</span></span>get<span class="hljs-constructor">Property(<span class="hljs-params">java</span>.<span class="hljs-params">lang</span>.String, <span class="hljs-params">java</span>.<span class="hljs-params">lang</span>.Class&lt;T&gt;, <span class="hljs-params">boolean</span>)</span><br><br>@Nullable<br>protected &lt;T&gt; T get<span class="hljs-constructor">Property(String <span class="hljs-params">key</span>, Class&lt;T&gt; <span class="hljs-params">targetValueType</span>, <span class="hljs-params">boolean</span> <span class="hljs-params">resolveNestedPlaceholders</span>)</span> &#123;<br><span class="hljs-keyword">if</span> (this.propertySources != null) &#123;<br><span class="hljs-keyword">for</span> (PropertySource&lt;?&gt; propertySource : this.propertySources) &#123;<br><span class="hljs-keyword">if</span> (logger.is<span class="hljs-constructor">TraceEnabled()</span>) &#123;<br>logger.trace(<span class="hljs-string">&quot;Searching for key &#x27;&quot;</span> + key + <span class="hljs-string">&quot;&#x27; in PropertySource &#x27;&quot;</span> +<br>propertySource.get<span class="hljs-constructor">Name()</span> + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>&#125;<br>Object value = propertySource.get<span class="hljs-constructor">Property(<span class="hljs-params">key</span>)</span>;<br><span class="hljs-keyword">if</span> (value != null) &#123;<br><span class="hljs-keyword">if</span> (resolveNestedPlaceholders<span class="hljs-operator"> &amp;&amp; </span>value instanceof String) &#123;<br>value = resolve<span class="hljs-constructor">NestedPlaceholders((String)</span> value);<br>&#125;<br>log<span class="hljs-constructor">KeyFound(<span class="hljs-params">key</span>, <span class="hljs-params">propertySource</span>, <span class="hljs-params">value</span>)</span>;<br>return convert<span class="hljs-constructor">ValueIfNecessary(<span class="hljs-params">value</span>, <span class="hljs-params">targetValueType</span>)</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (logger.is<span class="hljs-constructor">TraceEnabled()</span>) &#123;<br>logger.trace(<span class="hljs-string">&quot;Could not find key &#x27;&quot;</span> + key + <span class="hljs-string">&quot;&#x27; in any property source&quot;</span>);<br>&#125;<br>return null;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="自定义属性数据源"><a href="#自定义属性数据源" class="headerlink" title="自定义属性数据源"></a>自定义属性数据源</h1><p>在上一篇文章中我们知道通过配置PropertySourcesPlaceholderConfigurer可以自动的加载本地的Resource文件，与Environment中的属性组合成一个新的PropertySources，在BeanFactory注入ValueResolver中来使得自定义属性添加到属性解析的流程中。然而通过这种方式注入的属性是无法直接通过Environment获取的，通过上面的简单分析，我们可以得知如果想要在应用中加入自定义的属性源只需要获取到Environment中的MutablePropertySources，将属性源添加到其中即可。那么注入的时间点就非常的重要，如果应用启动后再去注入自定义的属性源的话，那么初始化过程中的@Value注解等就无法获取到自定义的属性数据源。</p><p>对于纯原生的Spring项目而言，我们可以在创建ApplicationContext时获取到Environment来完成自定义属性源的注入。当然也可以利用BeanPostProcessor结合EnvironmentAware来获取到Environment完成，但这种方式只受益于Bean，对于在其之前执行的BeanPostProcessor则不生肖。</p><p>对于Spring Boot项目而言实际上是有比较明确的注入点的，我们来看下SpringBoot启动的代码片段。首先会根据SPI获取到项目中所有的SpringApplicationRunListeners，然后创建Environment，在prepareEnvironment函数中创建完Environment后会调用listeners.environmentPrepared通过EventPublishingRunListener广播ApplicationEnvironmentPreparedEvent事件，EnvironmentPostProcessorApplicationListener在收到事件后会获取到应用中的EnvironmentPostProcessor调用postProcessEnvironment来自定义处理Environment。在这个监听器中处理自定义数据源的注入是最早的一个注入点（在后续Nacos-spring-boot的项目中我们也会提到）。ConfigDataEnvironmentPostProcessor即是利用了这一机制来完成application.properties配置的加载与注入。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta"># org.springframework.boot.SpringApplication.run(java.lang.String...)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Run the Spring application, creating and refreshing a new</span><br><span class="hljs-comment"> * &#123;@link ApplicationContext&#125;.</span><br><span class="hljs-comment"> * @param args the application arguments (usually passed from a Java main method)</span><br><span class="hljs-comment"> * @return a running &#123;@link ApplicationContext&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> ConfigurableApplicationContext run(<span class="hljs-keyword">String</span>... args) &#123;<br>StopWatch stopWatch = <span class="hljs-keyword">new</span> <span class="hljs-type">StopWatch</span>();<br>stopWatch.start();<br>ConfigurableApplicationContext context = <span class="hljs-literal">null</span>;<br>Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = <span class="hljs-keyword">new</span> <span class="hljs-type">ArrayList</span>&lt;&gt;();<br>configureHeadlessProperty();<br>SpringApplicationRunListeners listeners = getRunListeners(args);<br>listeners.starting();<br><span class="hljs-keyword">try</span> &#123;<br>ApplicationArguments applicationArguments = <span class="hljs-keyword">new</span> <span class="hljs-type">DefaultApplicationArguments</span>(args);<br>ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);<br>configureIgnoreBeanInfo(environment);<br>Banner printedBanner = printBanner(environment);<br>context = createApplicationContext();<br>exceptionReporters = getSpringFactoriesInstances(SpringBootExceptionReporter.class,<br><span class="hljs-keyword">new</span> <span class="hljs-type">Class</span>[] &#123; ConfigurableApplicationContext.<span class="hljs-class"><span class="hljs-keyword">class</span> &#125;, <span class="hljs-title">context</span>);</span><br><span class="hljs-class"><span class="hljs-title">prepareContext</span>(<span class="hljs-title">context</span>, <span class="hljs-title">environment</span>, <span class="hljs-title">listeners</span>, <span class="hljs-title">applicationArguments</span>, <span class="hljs-title">printedBanner</span>);</span><br><span class="hljs-class"><span class="hljs-title">refreshContext</span>(<span class="hljs-title">context</span>);</span><br><span class="hljs-class"><span class="hljs-title">afterRefresh</span>(<span class="hljs-title">context</span>, <span class="hljs-title">applicationArguments</span>);</span><br><span class="hljs-class"><span class="hljs-title">stopWatch</span>.<span class="hljs-title">stop</span>();</span><br><span class="hljs-class"><span class="hljs-title">if</span> (<span class="hljs-title">this</span>.<span class="hljs-title">logStartupInfo</span>) </span>&#123;<br><span class="hljs-keyword">new</span> <span class="hljs-type">StartupInfoLogger</span>(<span class="hljs-built_in">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);<br>&#125;<br>listeners.started(context);<br>callRunners(context, applicationArguments);<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>handleRunFailure(context, ex, exceptionReporters, listeners);<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalStateException</span>(ex);<br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br>listeners.running(context);<br>&#125;<br><span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>handleRunFailure(context, ex, exceptionReporters, <span class="hljs-literal">null</span>);<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">IllegalStateException</span>(ex);<br>&#125;<br><span class="hljs-keyword">return</span> context;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://juejin.cn/post/6992866279061356551/">Spring配置属性管理（二）— Environment</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>Value</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring配置属性管理(一)-Value注解解析</title>
    <link href="/2022/09/23/spring/Spring%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E7%AE%A1%E7%90%86%E2%80%94%20@Value%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/09/23/spring/Spring%E9%85%8D%E7%BD%AE%E5%B1%9E%E6%80%A7%E7%AE%A1%E7%90%86%E2%80%94%20@Value%E6%B3%A8%E8%A7%A3%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>为了能够更好的说明nacos-spring-project的设计原理，我们将首先介绍一下在Spring框架中是如何管理系统属性以及用户的配置属性的。本文将从一个项目中常用的属性使用例子入手，简要的分析属性解析注入的过程，在后续的文章中将从Environment的角度分析Spring是如何进行全局的属性管理的（# Spring配置属性管理（二）— Environment）</p><h1 id="Value注解"><a href="#Value注解" class="headerlink" title="@Value注解"></a>@Value注解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;test&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String test;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在项目中，如上面的代码片段所示，我们通常会在Service Bean中利用@Value注解来注入配置文件（例如application.properties）中的某些自定义配置属性，这些属性实际上都是由Spring Environment负责进行统一管理与解析的，而由AutowiredAnnotationBeanPostProcessor负责在Bean中对@Value注解进行解析注入属性的。</p><p>AutowiredAnnotationBeanPostProcessor实现了SmartInstantiationAwareBeanPostProcessor以及MergedBeanDefinitionPostProcessor接口，在程序初始化时主要完成了两件事：</p><ul><li>在postProcessMergedBeanDefinition接口中解析每个Bean的BeanDefinition，查找Bean中所有被定义的@Value以及@Autowired(本文不作细致分析)，并解析成InjectionMetadata</li><li>在postProcessProperties接口中找到Bean以及对应属性的InjectionMetadata，由InjectionMetadata来负责对PropertyValues进行注入</li></ul><h1 id="postProcessMergedBeanDefinition"><a href="#postProcessMergedBeanDefinition" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h1><p>在postProcessMergedBeanDefinition中最重要的任务就是从BeanDefinition中构造出InjectionMetadata，InjectionMetadata顾名思义即表示了每个Bean注入的元信息。AutowiredAnnotationBeanPostProcessor中的injectionMetadataCache缓存了所有Bean的InjectionMetadata，而InjectionMetadata中每个需要被注入的点都用一个InjectedElement来表示。</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs oxygene"># org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.buildAutowiringMetadata<br><br><span class="hljs-keyword">private</span> InjectionMetadata buildAutowiringMetadata(<span class="hljs-keyword">final</span> <span class="hljs-keyword">Class</span>&lt;?&gt; clazz) <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">if (!AnnotationUtils.isCandidateClass(clazz, this.autowiredAnnotationTypes)) &#123;</span><br><span class="hljs-comment">return InjectionMetadata.EMPTY;</span><br><span class="hljs-comment">&#125;</span><br><br>List&lt;InjectionMetadata.InjectedElement&gt; elements = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;()<span class="hljs-punctuation">;</span><br><span class="hljs-keyword">Class</span>&lt;?&gt; targetClass = clazz<span class="hljs-punctuation">;</span><br><br><span class="hljs-keyword">do</span> <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">final List&lt;InjectionMetadata.InjectedElement&gt; currElements = new ArrayList&lt;&gt;();</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">ReflectionUtils.doWithLocalFields(targetClass, field -&gt; &#123;</span><br><span class="hljs-comment"> //获取Field上的@Value或@Autowired注解</span><br><span class="hljs-comment">MergedAnnotation&lt;?&gt; ann = findAutowiredAnnotation(field);</span><br><span class="hljs-comment">if (ann != null) &#123;</span><br><span class="hljs-comment">//忽略静态属性</span><br><span class="hljs-comment">if (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="hljs-comment">if (logger.isInfoEnabled()) &#123;</span><br><span class="hljs-comment">logger.info(&quot;Autowired annotation is not supported on static fields: &quot; + field);</span><br><span class="hljs-comment">&#125;</span><br>return<span class="hljs-punctuation">;</span><br>&#125;<br>   <span class="hljs-comment">//判断属性上的required参数</span><br>boolean required = determineRequiredStatus(ann)<span class="hljs-punctuation">;</span><br>currElements.add(<span class="hljs-keyword">new</span> AutowiredFieldElement(field, required))<span class="hljs-punctuation">;</span><br>&#125;<br>&#125;)<span class="hljs-punctuation">;</span><br><br>ReflectionUtils.doWithLocalMethods(targetClass, <span class="hljs-keyword">method</span> -&gt; <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="hljs-comment">if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</span><br><span class="hljs-comment">return;</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-title function_">MergedAnnotation</span>&lt;?&gt; <span class="hljs-title function_">ann</span> = <span class="hljs-title function_">findAutowiredAnnotation</span><span class="hljs-params">(bridgedMethod)</span>;<br><span class="hljs-keyword">if</span> (ann != null &amp;&amp; <span class="hljs-keyword">method</span>.equals(ClassUtils.getMostSpecificMethod(<span class="hljs-keyword">method</span>, <span class="hljs-title function_">clazz</span>))) <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">if (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="hljs-comment">if (logger.isInfoEnabled()) &#123;</span><br><span class="hljs-comment">logger.info(&quot;Autowired annotation is not supported on static methods: &quot; + method);</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-title function_">return</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">method</span>.getParameterCount() == <span class="hljs-number">0</span>) <span class="hljs-comment">&#123;</span><br><span class="hljs-comment">if (logger.isInfoEnabled()) &#123;</span><br><span class="hljs-comment">logger.info(&quot;Autowired annotation should only be used on methods with parameters: &quot; +</span><br><span class="hljs-comment">method);</span><br><span class="hljs-comment">&#125;</span><br>&#125;<br>boolean required = determineRequiredStatus(ann)<span class="hljs-punctuation">;</span><br>PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz)<span class="hljs-punctuation">;</span><br>currElements.add(<span class="hljs-keyword">new</span> AutowiredMethodElement(<span class="hljs-keyword">method</span>, <span class="hljs-title function_">required</span>, <span class="hljs-title function_">pd</span>));<br>&#125;<br>&#125;)<span class="hljs-punctuation">;</span><br><br>elements.addAll(<span class="hljs-number">0</span>, currElements)<span class="hljs-punctuation">;</span><br>targetClass = targetClass.getSuperclass()<span class="hljs-punctuation">;</span><br>&#125;<br><span class="hljs-keyword">while</span> (targetClass != null &amp;&amp; targetClass != Object.class)<span class="hljs-punctuation">;</span><br><br>return InjectionMetadata.forElements(elements, clazz)<span class="hljs-punctuation">;</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="postProcessProperties"><a href="#postProcessProperties" class="headerlink" title="postProcessProperties"></a>postProcessProperties</h1><p>在postProcessProperties函数中首先会根据当前的Bean找到解析过的InjectionMetadata，然后利用InjectionMetadata的inject函数完成注入，inject函数中会遍历所有的InjectionElement并调用其Inject方法来完成每个注入点的注入，这里我们以AutowiredFieldElement为例，重点看一下配置属性是如解析并注入到Bean当中的。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"># org.springframework.beans.factory.<span class="hljs-keyword">annotation</span>.AutowiredAnnotationBeanPostProcessor.AutowiredFieldElement.inject<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> void inject(Object bean, <span class="hljs-meta">@Nullable</span> String beanName, <span class="hljs-meta">@Nullable</span> PropertyValues pvs) throws Throwable &#123;<br>Field field = (Field) <span class="hljs-keyword">this</span>.member;<br>Object value;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cached) &#123;<br>value = resolvedCachedArgument(beanName, <span class="hljs-keyword">this</span>.cachedFieldValue);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>DependencyDescriptor desc = new DependencyDescriptor(field, <span class="hljs-keyword">this</span>.required);<br>desc.setContainingClass(bean.getClass());<br>Set&lt;String&gt; autowiredBeanNames = new LinkedHashSet&lt;&gt;(<span class="hljs-number">1</span>);<br>Assert.state(beanFactory != <span class="hljs-literal">null</span>, <span class="hljs-string">&quot;No BeanFactory available&quot;</span>);<br>TypeConverter typeConverter = beanFactory.getTypeConverter();<br><span class="hljs-keyword">try</span> &#123;<br>value = beanFactory.resolveDependency(desc, beanName, autowiredBeanNames, typeConverter);<br>&#125;<br><span class="hljs-keyword">catch</span> (BeansException ex) &#123;<br><span class="hljs-keyword">throw</span> new UnsatisfiedDependencyException(<span class="hljs-literal">null</span>, beanName, new InjectionPoint(field), ex);<br>&#125;<br>synchronized (<span class="hljs-keyword">this</span>) &#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.cached) &#123;<br><span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span> || <span class="hljs-keyword">this</span>.required) &#123;<br><span class="hljs-keyword">this</span>.cachedFieldValue = desc;<br>registerDependentBeans(beanName, autowiredBeanNames);<br><span class="hljs-keyword">if</span> (autowiredBeanNames.size() == <span class="hljs-number">1</span>) &#123;<br>String autowiredBeanName = autowiredBeanNames.iterator().next();<br><span class="hljs-keyword">if</span> (beanFactory.containsBean(autowiredBeanName) &amp;&amp;<br>beanFactory.isTypeMatch(autowiredBeanName, field.getType())) &#123;<br><span class="hljs-keyword">this</span>.cachedFieldValue = new ShortcutDependencyDescriptor(<br>desc, autowiredBeanName, field.getType());<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">this</span>.cachedFieldValue = <span class="hljs-literal">null</span>;<br>&#125;<br><span class="hljs-keyword">this</span>.cached = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (value != <span class="hljs-literal">null</span>) &#123;<br>ReflectionUtils.makeAccessible(field);<br>field.<span class="hljs-keyword">set</span>(bean, value);<br>&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在InjectionElement的inject函数中利用resolveFieldValue来解析出Field当前的值，然后同样是利用反射机制将其注入到Bean中。在resolveFieldValue最终会调用DefaultListableBeanFactory的doResolveDependency来完成属性的解析。</p><p>在doResolveDependency函数中首先会调用 resolveEmbeddedValue 来对@Value注解上的value属性进行解析，如果解析出来是SpEL的表达式的话会利用evaluateBeanDefinitionString函数进行二次解析。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs dart"># org.springframework.beans.<span class="hljs-keyword">factory</span>.support.DefaultListableBeanFactory.doResolveDependency<br><br><span class="hljs-meta">@Nullable</span><br>public <span class="hljs-built_in">Object</span> doResolveDependency(DependencyDescriptor descriptor, <span class="hljs-meta">@Nullable</span> <span class="hljs-built_in">String</span> beanName,<br><span class="hljs-meta">@Nullable</span> <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; autowiredBeanNames, <span class="hljs-meta">@Nullable</span> TypeConverter typeConverter) throws BeansException &#123;<br><br>InjectionPoint previousInjectionPoint = ConstructorResolver.setCurrentInjectionPoint(descriptor);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-built_in">Object</span> shortcut = descriptor.resolveShortcut(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">if</span> (shortcut != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> shortcut;<br>&#125;<br><br>Class&lt;?&gt; type = descriptor.getDependencyType();<br><span class="hljs-built_in">Object</span> value = getAutowireCandidateResolver().getSuggestedValue(descriptor);<br><span class="hljs-keyword">if</span> (value != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">if</span> (value instanceof <span class="hljs-built_in">String</span>) &#123;<br><span class="hljs-built_in">String</span> strVal = resolveEmbeddedValue((<span class="hljs-built_in">String</span>) value);<br>BeanDefinition bd = (beanName != <span class="hljs-keyword">null</span> &amp;&amp; containsBean(beanName) ?<br>getMergedBeanDefinition(beanName) : <span class="hljs-keyword">null</span>);<br>value = evaluateBeanDefinitionString(strVal, bd);<br>&#125;<br>TypeConverter converter = (typeConverter != <span class="hljs-keyword">null</span> ? typeConverter : getTypeConverter());<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">return</span> converter.convertIfNecessary(value, type, descriptor.getTypeDescriptor());<br>&#125;<br><span class="hljs-keyword">catch</span> (UnsupportedOperationException ex) &#123;<br><span class="hljs-comment">// A custom TypeConverter which does not support TypeDescriptor resolution...</span><br><span class="hljs-keyword">return</span> (descriptor.getField() != <span class="hljs-keyword">null</span> ?<br>converter.convertIfNecessary(value, type, descriptor.getField()) :<br>converter.convertIfNecessary(value, type, descriptor.getMethodParameter()));<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">Object</span> multipleBeans = resolveMultipleBeans(descriptor, beanName, autowiredBeanNames, typeConverter);<br><span class="hljs-keyword">if</span> (multipleBeans != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> multipleBeans;<br>&#125;<br><br><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; matchingBeans = findAutowireCandidates(beanName, type, descriptor);<br><span class="hljs-keyword">if</span> (matchingBeans.isEmpty()) &#123;<br><span class="hljs-keyword">if</span> (isRequired(descriptor)) &#123;<br>raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-built_in">String</span> autowiredBeanName;<br><span class="hljs-built_in">Object</span> instanceCandidate;<br><br><span class="hljs-keyword">if</span> (matchingBeans.size() &gt; <span class="hljs-number">1</span>) &#123;<br>autowiredBeanName = determineAutowireCandidate(matchingBeans, descriptor);<br><span class="hljs-keyword">if</span> (autowiredBeanName == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">if</span> (isRequired(descriptor) || !indicatesMultipleBeans(type)) &#123;<br><span class="hljs-keyword">return</span> descriptor.resolveNotUnique(descriptor.getResolvableType(), matchingBeans);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// In case of an optional Collection/Map, silently ignore a non-unique case:</span><br><span class="hljs-comment">// possibly it was meant to be an empty collection of multiple regular beans</span><br><span class="hljs-comment">// (before 4.3 in particular when we didn&#x27;t even look for collection beans).</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125;<br>instanceCandidate = matchingBeans.<span class="hljs-keyword">get</span>(autowiredBeanName);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// We have exactly one match.</span><br><span class="hljs-built_in">Map</span>.Entry&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; entry = matchingBeans.entrySet().iterator().next();<br>autowiredBeanName = entry.getKey();<br>instanceCandidate = entry.getValue();<br>&#125;<br><br><span class="hljs-keyword">if</span> (autowiredBeanNames != <span class="hljs-keyword">null</span>) &#123;<br>autowiredBeanNames.add(autowiredBeanName);<br>&#125;<br><span class="hljs-keyword">if</span> (instanceCandidate instanceof Class) &#123;<br>instanceCandidate = descriptor.resolveCandidate(autowiredBeanName, type, <span class="hljs-keyword">this</span>);<br>&#125;<br><span class="hljs-built_in">Object</span> result = instanceCandidate;<br><span class="hljs-keyword">if</span> (result instanceof NullBean) &#123;<br><span class="hljs-keyword">if</span> (isRequired(descriptor)) &#123;<br>raiseNoMatchingBeanFound(type, descriptor.getResolvableType(), descriptor);<br>&#125;<br>result = <span class="hljs-keyword">null</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (!ClassUtils.isAssignableValue(type, result)) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanNotOfRequiredTypeException(autowiredBeanName, type, instanceCandidate.getClass());<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-keyword">finally</span> &#123;<br>ConstructorResolver.setCurrentInjectionPoint(previousInjectionPoint);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们这里重点关注的是 resolveEmbeddedValue，在这个函数中会遍历所有注册StringValueResolver来对Value注解中的值进行解析。那么StringValueResolver又是在什么地方被添加到BeanFactory中的呢，通过引用关系查找我们不难发现添加StringValueResolver的地方有两处，一处是在PlaceholderConfigurerSupport中，一处则是在AbstractApplicationContext的BeanFactory初始化结束的函数中。</p><p>当AbstractApplicationContext中没有注册StringValueResolver时，才会注入一个默认的StringValueResolver，而这个默认的StringValueResolver则是利用Environment来完成属性的解析（strVal -&gt; getEnvironment().resolvePlaceholders(strVal)）。</p><p>而在Spring Boot项目中通常会自动配置一个PropertySourcesPlaceholderConfigurer的Bean来协助解析占位符，这个Bean的一方面提供了占位符的解析，另一方面对Environment进行了二次封装，加入了用户可配置的自定义属性解析，使得属性解析的数据源更加的丰富。</p><p>实际上这两个对于属性的解析的StringValueResolver最终利用的都是 PropertySourcesPropertyResolver，PropertySourcesPropertyResolver在resolvePlaceholders函数中主要经历两个步骤，首先利用PropertyPlaceholderHelper解析出字符串中所有的占位符（例如${test})，然后使用PropertySourcesPropertyResolver中getPropertyAsRawString解析出占位符中应该被替换的属性（即查找属性源中test属性）进行替换，最后返回该值。</p><p>PropertyPlaceholderHelper是通过遍历字符串的方式递归的解析所有的占位符，逻辑相对比较简单就不做深入的分析。getPropertyAsRawString函数最终的属性查找利用的是PropertySourcesPropertyResolver中的PropertySources属性，PropertySources中包含了多个PropertySource，每个PropertySource就代表一个数据配置源，可以是系统环境变量、JVM变量、配置文件或是自定义配置的本地变量（PropertySourcesPropertyResolver中提供的功能）等等。根据前面的分析我们可以知道，PropertySourcesPropertyResolver在Spring框架的代码中有两处实例化，一个是ApplicationContext在创建Enviroment时创建的默认的PropertySourcesPropertyResolver，其中的PropertySources由Enviroment提供，一个是PropertySourcesPlaceholderConfigurer创建的PropertySourcesPropertyResolver，其中的PropertySources由Enviroment与自定义的本地属性合并而成。</p><p>经过上述过程的跟踪分析，其实我们不难发现，在Spring框架中ApplicationContext中的Environment是Spring默认的属性源管理器，每个属性源都会对应一个PropertySource，属性的获取与解析是最终是通过PropertySourcesPropertyResolver来完成的。想要自定义属性源可以有两种实现方式，一是配置PropertySourcesPlaceholderConfigurer，二是通过Environment来注入新的属性源。</p><p>最后，附上一张关于@Value注解属性解析中关键函数的调用时序图，在下一篇文章中我们将会从Environment的角度来分析Spring-core中org.springframework.core.env包中关于属性加载与解析的部分。<br><img src="img.png"></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://juejin.cn/post/6992792024231444493">Spring配置属性管理（一）— @Value注解解析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>Value</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NacosSpringProject配置管理源码分析(一)</title>
    <link href="/2022/09/22/java/nacos/NacosSpringProject%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901/"/>
    <url>/2022/09/22/java/nacos/NacosSpringProject%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%901/</url>
    
    <content type="html"><![CDATA[<p>Nacos spring project主要是面向仅使用spring框架的项目，主要提供了Nacos-client中的配置管理模块与服务发现模块在spring框架中集成的相关功能。<br>从整个项目上面来看，可以大致的分为以下两个部分，Nacos相关配置Bean的解析与注入以及Nacos相关功能注解的解析与处理。<br>其中配置Bean的解析注入分为XML配置与注解配置两个部分。<br>而Nacos相关功能注解主要包含了@NacosValue、@NacosConfigListener、@NacosInjected等注解的处理，主要是利用了BeanPostProceesor的特性。</p><p>接下来的两篇文章将围绕Nacos spring project中配置管理相关的功能模块进行分析，主要包含了@EnableNacos、@EnableNacosConfig、@NacosInjected、@NacosValue、@NacosPropertySource、@NacosConfigurationProperties与@NacosConfigListener注解的基本使用以及其原理。</p><h1 id="EnableNacos-EnableNacosConfig"><a href="#EnableNacos-EnableNacosConfig" class="headerlink" title="@EnableNacos/@EnableNacosConfig"></a>@EnableNacos/@EnableNacosConfig</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableNacosConfig(globalProperties = @NacosProperties(serverAddr = &quot;127.0.0.1:8848&quot;))</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NacosConfiguration</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>通常在Spring项目中我们可以利用@EnableNacos的注解开启Nacos，或是利用@EnableNacosConfig注解仅开启配置管理功能，又或者可以通过XML配置的方式开启Nacos功能。注解配置或是XML配置的原理是相似的，本文将针对项目中较为常用的注解配置来进行分析。</p><p><img src="img.png"><br><img src="img_1.png"></p><p>@EnableNacos与@EnableNacosConfig实际上都是利用了@Import注解的机制，@Import的作用主要是用于导入其他配置类。<br>被引入的NacosBeanDefinitionRegistrar与NacosConfigBeanDefinitionRegistrar都实现了ImportBeanDefinitionRegistrar接口，在这个接口中完成Bean定义的注入。</p><p>在NacosBeanDefinitionRegistrar中，首先会注册一个PropertySourcesPlaceholderConfigurer，在前面的Spring Environment解析的文章中我们提到过这个类的功能主要是用于属性中占位符的解析随后会注册一个由Nacos全局配置属性构成Properties对象的Bean；接着会注册Nacos注解处理相关的BeanDefinition，@EnableNacosConfig注解不同的地方是只会注册配置管理相关的Bean；最后会手动的调用一次NacosPropertySourcePostProcessor的postProcessBeanFactory方法，保证@NacosPropertySource注解能够被立即处理，获取到的属性能够尽快的参与到后续Spring初始化的过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta"># com.alibaba.nacos.spring.context.annotation.NacosBeanDefinitionRegistrar#registerBeanDefinitions</span><br><br>@<span class="hljs-function">Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata,</span></span><br><span class="hljs-params"><span class="hljs-function">BeanDefinitionRegistry registry)</span> </span>&#123;<br>BeanDefinition annotationProcessor = BeanDefinitionBuilder<br>.<span class="hljs-built_in">genericBeanDefinition</span>(PropertySourcesPlaceholderConfigurer.<span class="hljs-keyword">class</span>)<br>.<span class="hljs-built_in">getBeanDefinition</span>();<br>registry.<span class="hljs-built_in">registerBeanDefinition</span>(<br>PropertySourcesPlaceholderConfigurer.<span class="hljs-keyword">class</span>.<span class="hljs-built_in">getName</span>(),<br>annotationProcessor);<br><br>AnnotationAttributes attributes = AnnotationAttributes<br>.<span class="hljs-built_in">fromMap</span>(importingClassMetadata<br>.<span class="hljs-built_in">getAnnotationAttributes</span>(EnableNacos.<span class="hljs-keyword">class</span>.<span class="hljs-built_in">getName</span>()));<br><br><span class="hljs-comment">// Register Global Nacos Properties Bean</span><br><span class="hljs-built_in">registerGlobalNacosProperties</span>(attributes, registry, environment,<br>GLOBAL_NACOS_PROPERTIES_BEAN_NAME);<br><span class="hljs-comment">// Register Nacos Annotation Beans</span><br><span class="hljs-built_in">registerNacosAnnotationBeans</span>(registry);<br><span class="hljs-comment">// Invoke NacosPropertySourcePostProcessor immediately</span><br><span class="hljs-comment">// in order to enhance the precedence of @NacosPropertySource process</span><br><span class="hljs-built_in">invokeNacosPropertySourcePostProcessor</span>(beanFactory);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以注意到在这一系列的过程中，Nacos采用了两种注入方式，GloableProperties的注入是调用了NacosBeanUtils的registerSingleton方法，利用SingletonBeanRegistry直接注入Bean，而在registerNacosAnnotationBeans方法中注册的大部分都是调用了NacosBeanUtils中的registerInfrastructureBean方法利用BeanDefinitionRegistry注册了BeanDefinition，并且这些BeanDefinition的角色都被定义成了基础设施的Bean，由BeanFactory负责创建Bean。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs smali"><span class="hljs-comment"># com.alibaba.nacos.spring.util.NacosBeanUtils#registerSingleton</span><br><br><span class="hljs-keyword">public</span><span class="hljs-keyword"> static</span> void registerSingleton(BeanDefinitionRegistry registry, String beanName,<br>Object singletonObject) &#123;<br>SingletonBeanRegistry beanRegistry = null;<br><span class="hljs-built_in">if </span>(registry instanceof SingletonBeanRegistry) &#123;<br>beanRegistry = (SingletonBeanRegistry) registry;<br>&#125;<br>else<span class="hljs-built_in"> if </span>(registry instanceof AbstractApplicationContext) &#123;<br>// Maybe AbstractApplicationContext<span class="hljs-built_in"> or </span>its<span class="hljs-built_in"> sub-classes</span><br><span class="hljs-built_in"></span>beanRegistry = ((AbstractApplicationContext) registry).getBeanFactory();<br>&#125;<br>// Register Singleton Object<span class="hljs-built_in"> if </span>possible<br><span class="hljs-built_in">if </span>(beanRegistry != null) &#123;<br>// Determine in advance whether injected with beans<br><span class="hljs-built_in">if </span>(!beanRegistry.containsSingleton(beanName)) &#123;<br>beanRegistry.registerSingleton(beanName, singletonObject);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta"># com.alibaba.nacos.spring.util.NacosBeanUtils#registerInfrastructureBean</span><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">registerInfrastructureBean</span><span class="hljs-params">(BeanDefinitionRegistry registry,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">String</span> beanName, Class&lt;?&gt; beanClass, Object... constructorArgs)</span> </span>&#123;<br><span class="hljs-comment">// Build a BeanDefinition for NacosServiceFactory class</span><br>BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder<br>.<span class="hljs-built_in">rootBeanDefinition</span>(beanClass);<br><span class="hljs-keyword">for</span> (Object constructorArg : constructorArgs) &#123;<br>beanDefinitionBuilder.<span class="hljs-built_in">addConstructorArgValue</span>(constructorArg);<br>&#125;<br><span class="hljs-comment">// ROLE_INFRASTRUCTURE</span><br>beanDefinitionBuilder.<span class="hljs-built_in">setRole</span>(BeanDefinition.ROLE_INFRASTRUCTURE);<br><span class="hljs-comment">// Register</span><br>registry.<span class="hljs-built_in">registerBeanDefinition</span>(beanName,<br>beanDefinitionBuilder.<span class="hljs-built_in">getBeanDefinition</span>());<br>&#125;<br><br></code></pre></td></tr></table></figure><p>接下来我们来关注一下对于配置管理而言，Nacos需要注入哪些Bean来实现Nacos client与Spring框架的结合。Bean的注册主要是来自registerNacosCommonBeans与registerNacosConfigBeans两个方法。</p><p>在registerNacosCommonBeans中注册了配置管理与服务发现的通用的功能Bean，分别是:</p><ul><li>用于存放ApplicationContext的ApplicationContextHolder</li><li>用于处理@NacosInjected注解的AnnotationNacosInjectedBeanPostProcessor</li></ul><p>在registerNacosConfigBeans中注册了配置管理相关功能的Bean，分别是:</p><ul><li>用于处理@NacosConfigurationProperties注解的NacosConfigurationPropertiesBindingPostProcessor</li><li>用于处理@NacosConfigListener注解的NacosConfigListenerMethodProcessor</li><li>用于处理@NacosPropertySource注解的NacosPropertySourcePostProcessor</li><li>提供给NacosPropertySourcePostProcessor用于解析Bean并创建NacosPropertySource的AnnotationNacosPropertySourceBuilder</li><li>用于执行ConfigService监听器的线程池NacosConfigListenerExecutor</li><li>用于处理@NacosValue注解的NacosValueAnnotationBeanPostProcessor</li><li>用于创建ConfigService的ConfigServiceBeanBuilder</li><li>用于接收Nacos事件并记录的日志的LoggingNacosConfigMetadataEventListener</li></ul><p>接下来的小节我们会逐个对这些配置Bean进行解析。</p><h1 id="NacosInjected"><a href="#NacosInjected" class="headerlink" title="@NacosInjected"></a>@NacosInjected</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestServciceImpl</span> &#123;<br><br>    <span class="hljs-meta">@NacosInjected</span><br>    <span class="hljs-keyword">private</span> ConfigService configService;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>在项目开发过程中可以使用@NacosInjected注解来注入ConfigService实例，同时还可以通过@NacosInjected中的properties来指定需要注入的配置属性项。</p><p>上一节我们提到了@NacosInjected注解主要是由AnnotationNacosInjectedBeanPostProcessor来负责处理的，AnnotationNacosInjectedBeanPostProcessor继承自AbstractAnnotationBeanPostProcessor，AbstractAnnotationBeanPostProcessor实现了Bean实例属性上自定义注解处理的基本方法，处理的思路与我们在Spring Environment解析中提到的@Value属性注入的方式类似，都是通过在MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition方法中找到所有Bean定义中的注入点，然后利用InstantiationAwareBeanPostProcessorAdapter中postProcessPropertyValues方法处理需要被注入的属性。</p><p>本文主要关注一下AnnotationNacosInjectedBeanPostProcessor是如何完成属性注入的。</p><p>首先AnnotationNacosInjectedBeanPostProcessor在初始化过程中，会利用BeanFactory找到所有的AbstractNacosServiceBeanBuilder，并且根据AbstractNacosServiceBeanBuilder中的类型存储到nacosServiceBeanBuilderMap中。</p><p>随后AnnotationNacosInjectedBeanPostProcessor实现了doGetInjectedBean方法，这个方法会在postProcessPropertyValues回调函数中被调用，用于查找目标的Bean对象，然后由AbstractAnnotationBeanPostProcessor利用反射功能设置到属性上。<br>在doGetInjectedBean利用了初始化过程中收集到的AbstractNacosServiceBeanBuilder，结合@NacosInjected上的properties注解属性，创建对应的Nacos Service。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dart"># com.alibaba.nacos.spring.beans.<span class="hljs-keyword">factory</span>.annotation.AnnotationNacosInjectedBeanPostProcessor#doGetInjectedBean<br><span class="hljs-meta">@Override</span><br>protected <span class="hljs-built_in">Object</span> doGetInjectedBean(AnnotationAttributes attributes, <span class="hljs-built_in">Object</span> bean,<br>      <span class="hljs-built_in">String</span> beanName, Class&lt;?&gt; injectedType,<br>      InjectionMetadata.InjectedElement injectedElement) throws Exception &#123;<br>   AbstractNacosServiceBeanBuilder serviceBeanBuilder = nacosServiceBeanBuilderMap<br>         .<span class="hljs-keyword">get</span>(injectedType);<br><br>   <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; nacosProperties = getNacosProperties(attributes);<br><br>   <span class="hljs-keyword">return</span> serviceBeanBuilder.build(nacosProperties);<br>&#125;<br></code></pre></td></tr></table></figure><p>以注入ConfigService为例，最终会找到在上一小节中注册的ConfigServiceBeanBuilder，首先会根据注解的属性解析成Properties对象，然后获取到NacosServiceFactory创建对应的ConfigService。</p><p>实际负责创建ConfigService的是CacheableEventPublishingNacosServiceFactory，在CacheableEventPublishingNacosServiceFactory中由ConfigCreateWorker负责创建，首先会根据属性从缓存中查找是否有创建过的ConfigService，如果没有会利用NacosFactory创建一个新的ConfigService，特别的是每个ConfigService被EventPublishingConfigService封装。</p><p>相对于普通的ConfigService，EventPublishingConfigService在每个ConfigService的接口上都增加了一定的事件的推送，例如在获取配置超时时会发送NacosConfigTimeoutEvent。</p><p>在EventPublishingConfigService中，推送消息所使用的ApplicationEventPublisher是DeferredApplicationEventPublisher，不同之处在于DeferredApplicationEventPublisher的消息推送当ApplicationContext处于非运行状态时，会将事件缓存在ConcurrentLinkedQueue中，当ApplicationContext发送ContextRefreshedEvent事件时再将缓存的消息进行延迟推送。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta"># com.alibaba.nacos.spring.factory.CacheableEventPublishingNacosServiceFactory.ConfigCreateWorker#run</span><br><br>@Override<br><span class="hljs-keyword">public</span> ConfigService run(Properties properties, ConfigService service)<br>throws NacosException &#123;<br><span class="hljs-keyword">String</span> cacheKey = identify(properties);<br>ConfigService configService = configServicesCache.<span class="hljs-keyword">get</span>(cacheKey);<br><br><span class="hljs-keyword">if</span> (configService == <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (service == <span class="hljs-literal">null</span>) &#123;<br>service = NacosFactory.createConfigService(properties);<br>&#125;<br>configService = <span class="hljs-keyword">new</span> <span class="hljs-type">EventPublishingConfigService</span>(service, properties,<br>getSingleton().context,<br>getSingleton().nacosConfigListenerExecutor);<br>configServicesCache.put(cacheKey, configService);<br>&#125;<br><span class="hljs-keyword">return</span> configService;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://juejin.cn/post/6995861449394356261">Nacos Spring Project配置管理源码分析（一）</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>华为p40pro安装google服务框架</title>
    <link href="/2022/09/22/other/%E5%8D%8E%E4%B8%BAp40pro%E5%AE%89%E8%A3%85google%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/"/>
    <url>/2022/09/22/other/%E5%8D%8E%E4%B8%BAp40pro%E5%AE%89%E8%A3%85google%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<p>华为p40pro安装google服务框架</p><h1 id="电脑端使用adb命令"><a href="#电脑端使用adb命令" class="headerlink" title="电脑端使用adb命令"></a>电脑端使用adb命令</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd c:/platform-tools                          定位至ADB文件夹<br>adb uninstall com.huawei.localBackup        卸载备份App<br>adb install c:\oldBackup.apk                  安装备份App<br><br>连接设备: .\adb.exe devices<br>禁用应用：adb shell pm disable-user  应用包名<br>开启应用：adb shell pm enable  应用包名<br>卸载应用：adb shell pm uninstall --user 0  应用包名<br>已装应用：adb shell pm list packages<br></code></pre></td></tr></table></figure><h2 id="方法一-使用华谷套件apk安装"><a href="#方法一-使用华谷套件apk安装" class="headerlink" title="方法一:使用华谷套件apk安装"></a>方法一:<a href="https://bishua666.com/huagu2/#/">使用华谷套件apk安装</a></h2><blockquote><p>推荐</p></blockquote><p><img src="1.jpg"></p><h2 id="方法二-单独执行华谷套件里面的每一个步骤-不推荐"><a href="#方法二-单独执行华谷套件里面的每一个步骤-不推荐" class="headerlink" title="方法二:单独执行华谷套件里面的每一个步骤(不推荐)"></a>方法二:单独执行华谷套件里面的每一个步骤(不推荐)</h2><h1 id="常见问题解决"><a href="#常见问题解决" class="headerlink" title="常见问题解决:"></a>常见问题解决:</h1><h2 id="设备未获得Play保护机制认证"><a href="#设备未获得Play保护机制认证" class="headerlink" title="设备未获得Play保护机制认证"></a>设备未获得Play保护机制认证</h2><p>–<br>方法一: 直接在华谷套件里面购买服务按提示操作即可(收费)<br>方法二: </p><ul><li>下载DeviceID.APK，打开APP</li><li>复制GSF框架ID</li><li>进入网址<a href="https://www.google.com/android/uncertified/">https://www.google.com/android/uncertified/</a> 进行设备注册</li><li>注册完成后手机打开飞行模式</li><li>按顺序清除以下app数据和缓存，并停止运行（需要一直点到停止运行按钮变成灰色，再操作下一个app）<ul><li>google框架，google服务，google商店</li></ul></li><li>直接重启手机</li><li>按顺序清除以下app，并停止运行（需要一直点到停止运行按钮变成灰色，再操作下一个app）<ul><li> google服务</li></ul></li><li>直接重启手机</li><li>关闭飞行模式</li><li>正常使用Googel store(如果出现df-dferh-01,等它自行恢复)</li></ul><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://www.youtube.com/watch?v=0bMesV_en3M">华为手机鸿蒙2.0系统HarmonyOS 2.0正式版上安装谷歌服务框架GMS谷歌应用商店Google Play无需降级直接安装谷歌框架华为P50 P40 P30 Mate40 Mate30荣耀v30</a></li><li><a href="https://bit.ly/3atpvpw8">电脑端ADB工具</a></li><li><a href="https://bit.ly/3xrhujf">手机端谷歌框架安装文件</a></li><li><a href="https://www.youtube.com/watch?v=06ATErza81A">2022解决设备未获得Play保护机制认证,华为荣耀手机鸿蒙2.0系统HarmonyOS 2.0安装谷歌服务框架GMS谷歌应用商店Google Play华为P40 Mate40 Mate30荣耀30</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>google框架</tag>
      
      <tag>p40pro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>源码分析清楚AbstractQueuedSynchronizer</title>
    <link href="/2022/09/19/java/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9AAbstractQueuedSynchronizer/"/>
    <url>/2022/09/19/java/%E4%B8%80%E8%A1%8C%E4%B8%80%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E6%B8%85%E6%A5%9AAbstractQueuedSynchronizer/</url>
    
    <content type="html"><![CDATA[<p>在分析 Java 并发包 java.util.concurrent 源码的时候，少不了需要了解 AbstractQueuedSynchronizer（以下简写AQS）这个抽象类，因为它是 Java 并发包的基础工具类，是实现 ReentrantLock、CountDownLatch、Semaphore、FutureTask 等类的基础。</p><p>Google 一下 AbstractQueuedSynchronizer，我们可以找到很多关于 AQS 的介绍，但是很多都没有介绍清楚，因为大部分文章没有把其中的一些关键的细节说清楚。</p><p>本文将从 ReentrantLock 的公平锁源码出发，分析下 AbstractQueuedSynchronizer 这个类是怎么工作的，希望能给大家提供一些简单的帮助。</p><!--more--><p>申明以下几点：</p><ol><li>本文有点长，但还是挺简单，主要面向读者对象为并发编程的初学者，或者想要阅读 Java 并发包源码的开发者。对于新手来说，可能需要花好几个小时才能完全看懂，但是这时间肯定是值得的。</li><li>源码环境 JDK1.7（1.8没啥变化），看到不懂或有疑惑的部分，最好能自己打开源码看看。Doug Lea 大神的代码写得真心不错。</li><li>本文不分析共享模式，这样可以给读者减少很多负担，<a href="/post/AbstractQueuedSynchronizer-3">第三篇文章</a>对共享模式进行了分析。而且也不分析 condition 部分，所以应该说很容易就可以看懂了。</li><li>本文大量使用我们平时用得最多的 ReentrantLock 的概念，本质上来说是不正确的，读者应该清楚，AQS 不仅仅用来实现可重入锁，只是希望读者可以用锁来联想 AQS 的使用场景，降低阅读压力。</li><li>ReentrantLock 的公平锁和非公平锁只有一点点区别，<a href="/post/AbstractQueuedSynchronizer-2">第二篇文章</a>做了介绍。</li><li>评论区有读者反馈本文直接用代码说不友好，应该多配点流程图，这篇文章确实有这个问题。但是作为过来人，我想告诉大家，对于 AQS 来说，形式真的不重要，重要的是把细节说清楚。</li></ol><h2 id="AQS-结构"><a href="#AQS-结构" class="headerlink" title="AQS 结构"></a>AQS 结构</h2><p>先来看看 AQS 有哪些属性，搞清楚这些基本就知道 AQS 是什么套路了，毕竟可以猜嘛！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 头结点，你直接把它当做 当前持有锁的线程 可能是最好理解的</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;<br><br><span class="hljs-comment">// 阻塞的尾节点，每个新的节点进来，都插入到最后，也就形成了一个链表</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;<br><br><span class="hljs-comment">// 这个是最重要的，代表当前锁的状态，0代表没有被占用，大于 0 代表有线程持有当前锁</span><br><span class="hljs-comment">// 这个值可以大于 1，是因为锁可以重入，每次重入都加上 1</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br><br><span class="hljs-comment">// 代表当前持有独占锁的线程，举个最重要的使用例子，因为锁可以重入</span><br><span class="hljs-comment">// reentrantLock.lock()可以嵌套调用多次，所以每次用这个来判断当前线程是否已经拥有了锁</span><br><span class="hljs-comment">// if (currentThread == getExclusiveOwnerThread()) &#123;state++&#125;</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Thread exclusiveOwnerThread; <span class="hljs-comment">//继承自AbstractOwnableSynchronizer</span><br></code></pre></td></tr></table></figure><p>怎么样，看样子应该是很简单的吧，毕竟也就四个属性啊。</p><p>AbstractQueuedSynchronizer 的等待队列示意如下所示，注意了，之后分析过程中所说的 queue，也就是阻塞队列<strong>不包含 head，不包含 head，不包含 head</strong>。</p><p><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-0.png" alt="aqs-0"></p><p>等待队列中每个线程被包装成一个 Node 实例，数据结构是链表，一起看看源码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-comment">// 标识节点当前在共享模式下</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br>    <span class="hljs-comment">// 标识节点当前在独占模式下</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  <br>    <span class="hljs-comment">// ======== 下面的几个int常量是给waitStatus用的 ===========</span><br>    <span class="hljs-comment">/** waitStatus value to indicate thread has cancelled */</span><br>    <span class="hljs-comment">// 代码此线程取消了争抢这个锁</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">/** waitStatus value to indicate successor&#x27;s thread needs unparking */</span><br>    <span class="hljs-comment">// 官方的描述是，其表示当前node的后继节点对应的线程需要被唤醒</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">/** waitStatus value to indicate thread is waiting on condition */</span><br>    <span class="hljs-comment">// 本文不分析condition，所以略过吧，下一篇文章会介绍这个</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * waitStatus value to indicate the next acquireShared should</span><br><span class="hljs-comment">     * unconditionally propagate</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 同样的不分析，略过吧</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;<br>    <span class="hljs-comment">// =====================================================</span><br>  <br>  <br>    <span class="hljs-comment">// 取值为上面的1、-1、-2、-3，或者0(以后会讲到)</span><br>    <span class="hljs-comment">// 这么理解，暂时只需要知道如果这个值 大于0 代表此线程取消了等待，</span><br>    <span class="hljs-comment">//    ps: 半天抢不到锁，不抢了，ReentrantLock是可以指定timeouot的。。。</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;<br>    <span class="hljs-comment">// 前驱节点的引用</span><br>    <span class="hljs-keyword">volatile</span> Node prev;<br>    <span class="hljs-comment">// 后继节点的引用</span><br>    <span class="hljs-keyword">volatile</span> Node next;<br>    <span class="hljs-comment">// 这个就是线程本尊</span><br>    <span class="hljs-keyword">volatile</span> Thread thread;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>Node 的数据结构其实也挺简单的，就是 thread + waitStatus + pre + next 四个属性而已，大家先要有这个概念在心里。</p><p>上面的是基础知识，后面会多次用到，心里要时刻记着它们，心里想着这个结构图就可以了。下面，我们开始说 ReentrantLock 的公平锁。再次强调，我说的阻塞队列不包含 head 节点。</p><p><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-0.png" alt="aqs-0"></p><p>首先，我们先看下 ReentrantLock 的使用方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 我用个web开发中的service概念吧</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-comment">// 使用static，这样每个线程拿到的是同一把锁，当然，spring mvc中service默认就是单例，别纠结这个</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">reentrantLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 比如我们同一时间，只允许一个线程创建订单</span><br>        reentrantLock.lock();<br>        <span class="hljs-comment">// 通常，lock 之后紧跟着 try 语句</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 这块代码同一时间只能有一个线程进来(获取到锁的线程)，</span><br>            <span class="hljs-comment">// 其他的线程在lock()方法上阻塞，等待获取到锁，再进来</span><br>            <span class="hljs-comment">// 执行代码...</span><br>            <span class="hljs-comment">// 执行代码...</span><br>            <span class="hljs-comment">// 执行代码...</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 释放锁</span><br>            reentrantLock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ReentrantLock 在内部用了内部类 Sync 来管理锁，所以真正的获取锁和释放锁是由 Sync 的实现类来控制的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>Sync 有两个实现，分别为 NonfairSync（非公平锁）和 FairSync（公平锁），我们看 FairSync 部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="线程抢锁"><a href="#线程抢锁" class="headerlink" title="线程抢锁"></a>线程抢锁</h2><p>很多人肯定开始嫌弃上面废话太多了，下面跟着代码走，我就不废话了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3000897897090466540L</span>;<br>  <span class="hljs-comment">// 争锁</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>  <span class="hljs-comment">// 来自父类AQS，我直接贴过来这边，下面分析的时候同样会这样做，不会给读者带来阅读压力</span><br>    <span class="hljs-comment">// 我们看到，这个方法，如果tryAcquire(arg) 返回true, 也就结束了。</span><br>    <span class="hljs-comment">// 否则，acquireQueued方法会将线程压到队列中</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123; <span class="hljs-comment">// 此时 arg == 1</span><br>        <span class="hljs-comment">// 首先调用tryAcquire(1)一下，名字上就知道，这个只是试一试</span><br>        <span class="hljs-comment">// 因为有可能直接就成功了呢，也就不需要进队列排队了，</span><br>        <span class="hljs-comment">// 对于公平锁的语义就是：本来就没人持有锁，根本没必要进队列等待(又是挂起，又是等待被唤醒的)</span><br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>            <span class="hljs-comment">// tryAcquire(arg)没有成功，这个时候需要把当前线程挂起，放到阻塞队列中。</span><br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;<br>              selfInterrupt();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Fair version of tryAcquire.  Don&#x27;t grant access unless</span><br><span class="hljs-comment">     * recursive call or no waiters or is first.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 尝试直接获取锁，返回值是boolean，代表是否获取到锁</span><br>    <span class="hljs-comment">// 返回true：1.没有线程在等待锁；2.重入锁，线程本来就持有锁，也就可以理所当然可以直接获取</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-comment">// state == 0 此时此刻没有线程持有锁</span><br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span><br>            <span class="hljs-comment">// 看看有没有别人在队列中等了半天了</span><br>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                <span class="hljs-comment">// 如果没有线程在等待，那就用CAS尝试一下，成功了就获取到锁了，</span><br>                <span class="hljs-comment">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span><br>                <span class="hljs-comment">// 因为刚刚还没人的，我判断过了</span><br>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>              <br>                <span class="hljs-comment">// 到这里就是获取到锁了，标记一下，告诉大家，现在是我占用了锁</span><br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>      <span class="hljs-comment">// 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span><br>        <span class="hljs-comment">// 这里不存在并发问题</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">// 如果到这里，说明前面的if和else if都没有返回true，说明没有获取到锁</span><br>        <span class="hljs-comment">// 回到上面一个外层调用方法继续看:</span><br>        <span class="hljs-comment">// if (!tryAcquire(arg) </span><br>        <span class="hljs-comment">//        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span><br>        <span class="hljs-comment">//     selfInterrupt();</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  <br>    <span class="hljs-comment">// 假设tryAcquire(arg) 返回false，那么代码将执行：</span><br>  <span class="hljs-comment">//acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，</span><br>    <span class="hljs-comment">// 这个方法，首先需要执行：addWaiter(Node.EXCLUSIVE)</span><br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates and enqueues node for current thread and given mode.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mode Node.EXCLUSIVE for exclusive, Node.SHARED for shared</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the new node</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 此方法的作用是把线程包装成node，同时进入到队列中</span><br>    <span class="hljs-comment">// 参数mode此时是Node.EXCLUSIVE，代表独占模式</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>        <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>        <span class="hljs-comment">// 以下几行代码想把当前node加到链表的最后面去，也就是进到阻塞队列的最后</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>      <br>        <span class="hljs-comment">// tail!=null =&gt; 队列不为空(tail==head的时候，其实队列是空的，不过不管这个吧)</span><br>        <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123; <br>            <span class="hljs-comment">// 将当前的队尾节点，设置为自己的前驱 </span><br>            node.prev = pred; <br>            <span class="hljs-comment">// 用CAS把自己设置为队尾, 如果成功后，tail == node 了，这个节点成为阻塞队列新的尾巴</span><br>            <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123; <br>                <span class="hljs-comment">// 进到这里说明设置成功，当前node==tail, 将自己与之前的队尾相连，</span><br>                <span class="hljs-comment">// 上面已经有 node.prev = pred，加上下面这句，也就实现了和之前的尾节点双向连接了</span><br>                pred.next = node;<br>                <span class="hljs-comment">// 线程入队了，可以返回了</span><br>                <span class="hljs-keyword">return</span> node;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 仔细看看上面的代码，如果会到这里，</span><br>        <span class="hljs-comment">// 说明 pred==null(队列是空的) 或者 CAS失败(有线程在竞争入队)</span><br>        <span class="hljs-comment">// 读者一定要跟上思路，如果没有跟上，建议先不要往下读了，往回仔细看，否则会浪费时间的</span><br>        enq(node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Inserts node into queue, initializing if necessary. See picture above.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node the node to insert</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> node&#x27;s predecessor</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 采用自旋的方式入队</span><br>    <span class="hljs-comment">// 之前说过，到这个方法只有两种可能：等待队列为空，或者有线程竞争入队，</span><br>    <span class="hljs-comment">// 自旋在这边的语义是：CAS设置tail过程中，竞争一次竞争不到，我就多次竞争，总会排到的</span><br>    <span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>            <span class="hljs-comment">// 之前说过，队列为空也会进来这里</span><br>            <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br>                <span class="hljs-comment">// 初始化head节点</span><br>                <span class="hljs-comment">// 细心的读者会知道原来 head 和 tail 初始化的时候都是 null 的</span><br>                <span class="hljs-comment">// 还是一步CAS，你懂的，现在可能是很多线程同时进来呢</span><br>                <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                    <span class="hljs-comment">// 给后面用：这个时候head节点的waitStatus==0, 看new Node()构造方法就知道了</span><br>                  <br>                    <span class="hljs-comment">// 这个时候有了head，但是tail还是null，设置一下，</span><br>                    <span class="hljs-comment">// 把tail指向head，放心，马上就有线程要来了，到时候tail就要被抢了</span><br>                    <span class="hljs-comment">// 注意：这里只是设置了tail=head，这里可没return哦，没有return，没有return</span><br>                    <span class="hljs-comment">// 所以，设置完了以后，继续for循环，下次就到下面的else分支了</span><br>                    tail = head;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 下面几行，和上一个方法 addWaiter 是一样的，</span><br>                <span class="hljs-comment">// 只是这个套在无限循环里，反正就是将当前线程排到队尾，有线程竞争的话排不上重复排</span><br>                node.prev = t;<br>                <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                    t.next = node;<br>                    <span class="hljs-keyword">return</span> t;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>  <br>    <span class="hljs-comment">// 现在，又回到这段代码了</span><br>    <span class="hljs-comment">// if (!tryAcquire(arg) </span><br>    <span class="hljs-comment">//        &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) </span><br>    <span class="hljs-comment">//     selfInterrupt();</span><br>    <br>    <span class="hljs-comment">// 下面这个方法，参数node，经过addWaiter(Node.EXCLUSIVE)，此时已经进入阻塞队列</span><br>    <span class="hljs-comment">// 注意一下：如果acquireQueued(addWaiter(Node.EXCLUSIVE), arg))返回true的话，</span><br>    <span class="hljs-comment">// 意味着上面这段代码将进入selfInterrupt()，所以正常情况下，下面应该返回false</span><br>    <span class="hljs-comment">// 这个方法非常重要，应该说真正的线程挂起，然后被唤醒后去获取锁，都在这个方法里了</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-comment">// p == head 说明当前节点虽然进到了阻塞队列，但是是阻塞队列的第一个，因为它的前驱是head</span><br>                <span class="hljs-comment">// 注意，阻塞队列不包含head节点，head一般指的是占有锁的线程，head后面的才称为阻塞队列</span><br>                <span class="hljs-comment">// 所以当前节点可以去试抢一下锁</span><br>                <span class="hljs-comment">// 这里我们说一下，为什么可以去试试：</span><br>                <span class="hljs-comment">// 首先，它是队头，这个是第一个条件，其次，当前的head有可能是刚刚初始化的node，</span><br>                <span class="hljs-comment">// enq(node) 方法里面有提到，head是延时初始化的，而且new Node()的时候没有设置任何线程</span><br>                <span class="hljs-comment">// 也就是说，当前的head不属于任何一个线程，所以作为队头，可以去试一试，</span><br>                <span class="hljs-comment">// tryAcquire已经分析过了, 忘记了请往前看一下，就是简单用CAS试操作一下state</span><br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                    setHead(node);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span> interrupted;<br>                &#125;<br>                <span class="hljs-comment">// 到这里，说明上面的if分支没有成功，要么当前node本来就不是队头，</span><br>                <span class="hljs-comment">// 要么就是tryAcquire(arg)没有抢赢别人，继续往下看</span><br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                    parkAndCheckInterrupt())<br>                    interrupted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 什么时候 failed 会为 true???</span><br>            <span class="hljs-comment">// tryAcquire() 方法抛异常的情况</span><br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br>  <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Checks and updates status for a node that failed to acquire.</span><br><span class="hljs-comment">     * Returns true if thread should block. This is the main signal</span><br><span class="hljs-comment">     * control in all acquire loops.  Requires that pred == node.prev</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pred node&#x27;s predecessor holding status</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node the node</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if thread should block</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 刚刚说过，会到这里就是没有抢到锁呗，这个方法说的是：&quot;当前线程没有抢到锁，是否需要挂起当前线程？&quot;</span><br>    <span class="hljs-comment">// 第一个参数是前驱节点，第二个参数才是代表当前线程的节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>        <span class="hljs-comment">// 前驱节点的 waitStatus == -1 ，说明前驱节点状态正常，当前线程需要挂起，直接可以返回true</span><br>        <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * This node has already set status asking a release</span><br><span class="hljs-comment">             * to signal it, so it can safely park.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <br>        <span class="hljs-comment">// 前驱节点 waitStatus大于0 ，之前说过，大于0 说明前驱节点取消了排队。</span><br>        <span class="hljs-comment">// 这里需要知道这点：进入阻塞队列排队的线程会被挂起，而唤醒的操作是由前驱节点完成的。</span><br>        <span class="hljs-comment">// 所以下面这块代码说的是将当前节点的prev指向waitStatus&lt;=0的节点，</span><br>        <span class="hljs-comment">// 简单说，就是为了找个好爹，因为你还得依赖它来唤醒呢，如果前驱节点取消了排队，</span><br>        <span class="hljs-comment">// 找前驱节点的前驱节点做爹，往前遍历总能找到一个好爹的</span><br>        <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * Predecessor was cancelled. Skip over predecessors and</span><br><span class="hljs-comment">             * indicate retry.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                node.prev = pred = pred.prev;<br>            &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>            pred.next = node;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="hljs-comment">             * need a signal, but don&#x27;t park yet.  Caller will need to</span><br><span class="hljs-comment">             * retry to make sure it cannot acquire before parking.</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-comment">// 仔细想想，如果进入到这个分支意味着什么</span><br>            <span class="hljs-comment">// 前驱节点的waitStatus不等于-1和1，那也就是只可能是0，-2，-3</span><br>            <span class="hljs-comment">// 在我们前面的源码中，都没有看到有设置waitStatus的，所以每个新的node入队时，waitStatu都是0</span><br>            <span class="hljs-comment">// 正常情况下，前驱节点是之前的 tail，那么它的 waitStatus 应该是 0</span><br>            <span class="hljs-comment">// 用CAS将前驱节点的waitStatus设置为Node.SIGNAL(也就是-1)</span><br>            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>        &#125;<br>        <span class="hljs-comment">// 这个方法返回 false，那么会再走一次 for 循序，</span><br>        <span class="hljs-comment">//     然后再次进来此方法，此时会从第一个分支返回 true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>  <br>    <span class="hljs-comment">// private static boolean shouldParkAfterFailedAcquire(Node pred, Node node)</span><br>    <span class="hljs-comment">// 这个方法结束根据返回值我们简单分析下：</span><br>    <span class="hljs-comment">// 如果返回true, 说明前驱节点的waitStatus==-1，是正常情况，那么当前线程需要被挂起，等待以后被唤醒</span><br>    <span class="hljs-comment">//我们也说过，以后是被前驱节点唤醒，就等着前驱节点拿到锁，然后释放锁的时候叫你好了</span><br>    <span class="hljs-comment">// 如果返回false, 说明当前不需要被挂起，为什么呢？往后看</span><br>  <br>    <span class="hljs-comment">// 跳回到前面是这个方法</span><br>    <span class="hljs-comment">// if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br>    <span class="hljs-comment">//                parkAndCheckInterrupt())</span><br>    <span class="hljs-comment">//                interrupted = true;</span><br>    <br>    <span class="hljs-comment">// 1. 如果shouldParkAfterFailedAcquire(p, node)返回true，</span><br>    <span class="hljs-comment">// 那么需要执行parkAndCheckInterrupt():</span><br>  <br>    <span class="hljs-comment">// 这个方法很简单，因为前面返回true，所以需要挂起线程，这个方法就是负责挂起线程的</span><br>    <span class="hljs-comment">// 这里用了LockSupport.park(this)来挂起线程，然后就停在这里了，等待被唤醒=======</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>        LockSupport.park(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">return</span> Thread.interrupted();<br>    &#125;<br>  <br>    <span class="hljs-comment">// 2. 接下来说说如果shouldParkAfterFailedAcquire(p, node)返回false的情况</span><br>  <br>   <span class="hljs-comment">// 仔细看shouldParkAfterFailedAcquire(p, node)，我们可以发现，其实第一次进来的时候，一般都不会返回true的，原因很简单，前驱节点的waitStatus=-1是依赖于后继节点设置的。也就是说，我都还没给前驱设置-1呢，怎么可能是true呢，但是要看到，这个方法是套在循环里的，所以第二次进来的时候状态就是-1了。</span><br>  <br>    <span class="hljs-comment">// 解释下为什么shouldParkAfterFailedAcquire(p, node)返回false的时候不直接挂起线程：</span><br>    <span class="hljs-comment">// =&gt; 是为了应对在经过这个方法后，node已经是head的直接后继节点了。剩下的读者自己想想吧。</span><br>&#125;<br></code></pre></td></tr></table></figure><p>说到这里，也就明白了，多看几遍 <code>final boolean acquireQueued(final Node node, int arg)</code> 这个方法吧。自己推演下各个分支怎么走，哪种情况下会发生什么，走到哪里。</p><h2 id="解锁操作"><a href="#解锁操作" class="headerlink" title="解锁操作"></a>解锁操作</h2><p>最后，就是还需要介绍下唤醒的动作了。我们知道，正常情况下，如果线程没获取到锁，线程会被 <code>LockSupport.park(this);</code> 挂起停止，等待被唤醒。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 唤醒的代码还是比较简单的，你如果上面加锁的都看懂了，下面都不需要看就知道怎么回事了</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    sync.release(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">// 往后看吧</span><br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 回到ReentrantLock看tryRelease方法</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-comment">// 是否完全释放锁</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 其实就是重入的问题，如果c==0，也就是说没有嵌套锁了，可以释放了，否则还不能释放掉</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        free = <span class="hljs-literal">true</span>;<br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>    &#125;<br>    setState(c);<br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Wakes up node&#x27;s successor, if one exists.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node the node</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 唤醒后继节点</span><br><span class="hljs-comment">// 从上面调用处知道，参数node是head头结点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * If status is negative (i.e., possibly needing signal) try</span><br><span class="hljs-comment">     * to clear in anticipation of signalling.  It is OK if this</span><br><span class="hljs-comment">     * fails or if status is changed by waiting thread.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>    <span class="hljs-comment">// 如果head节点当前waitStatus&lt;0, 将其修改为0</span><br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Thread to unpark is held in successor, which is normally</span><br><span class="hljs-comment">     * just the next node.  But if cancelled or apparently null,</span><br><span class="hljs-comment">     * traverse backwards from tail to find the actual</span><br><span class="hljs-comment">     * non-cancelled successor.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">// 下面的代码就是唤醒后继节点，但是有可能后继节点取消了等待（waitStatus==1）</span><br>    <span class="hljs-comment">// 从队尾往前找，找到waitStatus&lt;=0的所有节点中排在最前面的</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>        s = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 从后往前找，仔细看代码，不必担心中间有节点取消(waitStatus==1)的情况</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = t;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// 唤醒线程</span><br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure><p>唤醒线程以后，被唤醒的线程将从以下代码中继续往前走：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    LockSupport.park(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 刚刚线程被挂起在这里了</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br><span class="hljs-comment">// 又回到这个方法了：acquireQueued(final Node node, int arg)，这个时候，node的前驱是head了</span><br></code></pre></td></tr></table></figure><p>好了，后面就不分析源码了，剩下的还有问题自己去仔细看看代码吧。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结一下吧。</p><p>在并发环境下，加锁和解锁需要以下三个部件的协调：</p><ol><li>锁状态。我们要知道锁是不是被别的线程占有了，这个就是 state 的作用，它为 0 的时候代表没有线程占有锁，可以去争抢这个锁，用 CAS 将 state 设为 1，如果 CAS 成功，说明抢到了锁，这样其他线程就抢不到了，如果锁重入的话，state进行 +1 就可以，解锁就是减 1，直到 state 又变为 0，代表释放锁，所以 lock() 和 unlock() 必须要配对啊。然后唤醒等待队列中的第一个线程，让其来占有锁。</li><li>线程的阻塞和解除阻塞。AQS 中采用了 LockSupport.park(thread) 来挂起线程，用 unpark 来唤醒线程。</li><li>阻塞队列。因为争抢锁的线程可能很多，但是只能有一个线程拿到锁，其他的线程都必须等待，这个时候就需要一个 queue 来管理这些线程，AQS 用的是一个 FIFO 的队列，就是一个链表，每个 node 都持有后继节点的引用。AQS 采用了 CLH 锁的变体来实现，感兴趣的读者可以参考这篇文章<a href="http://coderbee.net/index.php/concurrent/20131115/577">关于CLH的介绍</a>，写得简单明了。</li></ol><h2 id="示例图解析"><a href="#示例图解析" class="headerlink" title="示例图解析"></a>示例图解析</h2><p>下面属于回顾环节，用简单的示例来说一遍，如果上面的有些东西没看懂，这里还有一次帮助你理解的机会。</p><p>首先，第一个线程调用 reentrantLock.lock()，翻到最前面可以发现，tryAcquire(1) 直接就返回 true 了，结束。只是设置了 state=1，连 head 都没有初始化，更谈不上什么阻塞队列了。要是线程 1 调用 unlock() 了，才有线程 2 来，那世界就太太太平了，完全没有交集嘛，那我还要 AQS 干嘛。</p><p>如果线程 1 没有调用 unlock() 之前，线程 2 调用了 lock(), 想想会发生什么？</p><p>线程 2 会初始化 head【new Node()】，同时线程 2 也会插入到阻塞队列并挂起 (注意看这里是一个 for 循环，而且设置 head 和 tail 的部分是不 return 的，只有入队成功才会跳出循环)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                tail = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            node.prev = t;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，是线程 2 初始化 head 节点，此时 head==tail, waitStatus==0</p><p><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-1.png" alt="aqs-1"></p><p>然后线程 2 入队：</p><p><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-2.png" alt="aqs-2"></p><p>同时我们也要看此时节点的 waitStatus，我们知道 head 节点是线程 2 初始化的，此时的 waitStatus 没有设置， java 默认会设置为 0，但是到 shouldParkAfterFailedAcquire 这个方法的时候，线程 2 会把前驱节点，也就是 head 的waitStatus设置为 -1。</p><p>那线程 2 节点此时的 waitStatus 是多少呢，由于没有设置，所以是 0；</p><p>如果线程 3 此时再进来，直接插到线程 2 的后面就可以了，此时线程 3 的 waitStatus 是 0，到 shouldParkAfterFailedAcquire 方法的时候把前驱节点线程 2 的 waitStatus 设置为 -1。</p><p><img src="https://www.javadoop.com/blogimages/AbstractQueuedSynchronizer/aqs-3.png" alt="aqs-3"></p><p>这里可以简单说下 waitStatus 中 SIGNAL(-1) 状态的意思，Doug Lea 注释的是：代表后继节点需要被唤醒。也就是说这个 waitStatus 其实代表的不是自己的状态，而是后继节点的状态，我们知道，每个 node 在入队的时候，都会把前驱节点的状态改为 SIGNAL，然后阻塞，等待被前驱唤醒。这里涉及的是两个问题：有线程取消了排队、唤醒操作。其实本质是一样的，读者也可以顺着 “waitStatus代表后继节点的状态” 这种思路去看一遍源码。</p><p>（全文完）</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://javadoop.com/post/AbstractQueuedSynchronizer">一行一行源码分析清楚AbstractQueuedSynchronizer</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>juc</tag>
      
      <tag>AQS</tag>
      
      <tag>ReentrantLock</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GitHubPages+Hexo搭建个人博客网站</title>
    <link href="/2022/09/19/other/GitHubPages+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
    <url>/2022/09/19/other/GitHubPages+Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<p>本文介绍如何使用GitHub Pages + Hexo搭建个人博客网站，完全免费，所有内容本人亲测，绝对可用。</p><h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><h4 id="1-GitHub账号"><a href="#1-GitHub账号" class="headerlink" title="1. GitHub账号"></a>1. GitHub账号</h4><p>需要有一个<code>GitHub</code>账号，没有的话到 <a href="https://github.com/">官网</a> 申请一个。<br>注册很简单，不懂的话可以参考 <a href="https://blog.csdn.net/yaorongke/article/details/119086305">GitHub申请账号</a></p><h4 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2. 安装Git"></a>2. 安装Git</h4><p>在自己电脑上安装好<code>Git</code>，hexo部署到<code>GitHub</code>时要用。<br>网上找篇教程或者参考 <a href="https://blog.csdn.net/yaorongke/article/details/119085413">Git安装(Windows)</a></p><h4 id="3-安装NodeJS"><a href="#3-安装NodeJS" class="headerlink" title="3. 安装NodeJS"></a>3. 安装NodeJS</h4><p>在自己电脑上安装好<code>NodeJS</code>，<code>Hexo</code>是基于<code>NodeJS</code>编写的，所以需要安装<code>NodeJS</code>和<code>npm</code>工具。<br>网上找篇教程或者参考 <a href="https://blog.csdn.net/yaorongke/article/details/119084295">NodeJS安装及配置(Windows)</a></p><h3 id="二、创建仓库"><a href="#二、创建仓库" class="headerlink" title="二、创建仓库"></a>二、创建仓库</h3><p>在<code>GitHub</code>上创建一个新的代码仓库用于保存我们的网页。</p><p>点击<code>Your repositories</code>，进入仓库页面。<br><img src="https://img-blog.csdnimg.cn/e47a4f36fcbb421a8245aefdd184423f.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>点击<code>New</code>按钮，进入仓库创建页面。<br><img src="https://img-blog.csdnimg.cn/d15e47ad718d43cd98c9c4a99970a9d7.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>填写仓库名，格式必须为<code>&lt;用户名&gt;.github.io</code>，然后点击<code>Create repository</code>。<br><img src="https://img-blog.csdnimg.cn/5b7236589dc8430d8b96c512e0989b23.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>点击<code>creating a new file</code>创建一个新文件，作为我们网站的主页。<br><img src="https://img-blog.csdnimg.cn/711a97234d40440aab799969b516e35b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>新文件的名字必须为<code>index.html</code>，内容先随便写一个简单的，内容示例如下，填写之后点击<code>Commit new file</code>提交。</p><pre><code class="hljs">&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;yaorongke&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h1&gt;yaorongke的个人主页&lt;/h1&gt;    &lt;h1&gt;Hello ~&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="https://img-blog.csdnimg.cn/8d314e9dc79c425ab719fc48b90ec229.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>GitHub Pages中找到我们主页的地址为 <a href="https://yaorongke.github.io/">https://yaorongke.github.io/</a><br><img src="https://img-blog.csdnimg.cn/1219bd69dcbd4c5f80e49a891dca1441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>浏览器中访问，展示成功。<br><img src="https://img-blog.csdnimg.cn/1bb0b7dec1334ac88e86b12541eb1cc3.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>这里创建的网页是非常简陋的，只是为了演示下<code>GitHub Pages</code>的使用方式。</p><h3 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h3><p>我们采用<code>Hexo</code>来创建我们的博客网站，<code>Hexo</code> 是一个基于<code>NodeJS</code>的静态博客网站生成器，使用<code>Hexo</code>不需开发，只要进行一些必要的配置即可生成一个个性化的博客网站，非常方便。点击进入 <a href="https://hexo.io/zh-cn/">官网</a>。</p><p>安装 <code>Hexo</code></p><pre><code class="hljs">npm install -g hexo-cli</code></pre><p>查看版本</p><pre><code class="hljs">hexo -v</code></pre><p>创建一个项目 <code>hexo-blog</code> 并初始化</p><pre><code class="hljs">hexo init hexo-blogcd hexo-blognpm install</code></pre><p>本地启动</p><pre><code class="hljs">hexo ghexo server</code></pre><p>浏览器访问 <a href="http://localhost:4000，页面默认主图风格如下">http://localhost:4000，页面默认主图风格如下</a><br><img src="https://img-blog.csdnimg.cn/656bf025f6934a35abc104b16e4dd2fc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p><h3 id="四、更换主题"><a href="#四、更换主题" class="headerlink" title="四、更换主题"></a>四、更换主题</h3><p><code>Hexo</code> 默认的主题不太好看，不过官方提供了数百种主题供用户选择，可以根据个人喜好更换，官网主题点 <a href="https://hexo.io/themes/">这里</a> 查看。这里介绍两个主题的使用方法，<code>Next</code> 和 <code>Fluid</code>，个人比较喜欢<code>Fluid</code>，后面章节的功能也是以 <code>Fluid</code> 为基础进行讲解的。</p><h4 id="1-NexT-主题"><a href="#1-NexT-主题" class="headerlink" title="1. NexT 主题"></a>1. NexT 主题</h4><p><strong>安装主题</strong></p><pre><code class="hljs">cd hexo-bloggit clone https://github.com/iissnan/hexo-theme-next themes/next</code></pre><p><strong>使用 NexT 主题</strong></p><p>打开 _config.yml 文件，该文件为站点配置文件<br><img src="https://img-blog.csdnimg.cn/f5cc3400d5b64a6ca75ce6cedd34ec41.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>将主题修改为 next</p><pre><code class="hljs">theme: next</code></pre><p><strong>本地启动</strong></p><pre><code class="hljs">hexo g -dhexo s</code></pre><h4 id="2-Fluid主题"><a href="#2-Fluid主题" class="headerlink" title="2. Fluid主题"></a>2. Fluid主题</h4><p>以下安装步骤摘自 <a href="https://github.com/fluid-dev/hexo-theme-fluid">Fluid官网</a></p><p><strong>安装主题</strong></p><p>下载 <a href="https://github.com/fluid-dev/hexo-theme-fluid/releases">最新 release 版本</a> 解压到 <code>themes</code> 目录，并将解压出的文件夹重命名为 <code>fluid</code>。</p><p><strong>指定主题</strong></p><p>如下修改 <code>Hexo</code> 博客目录中的 <code>_config.yml</code>：</p><pre><code class="hljs">theme: fluid  # 指定主题language: zh-CN  # 指定语言，会影响主题显示的语言，按需修改</code></pre><p><strong>创建「关于页」</strong></p><p>首次使用主题的「关于页」需要手动创建：</p><pre><code class="hljs">hexo new page about</code></pre><p>创建成功后，编辑博客目录下 <code>/source/about/index.md</code>，添加 <code>layout</code> 属性。</p><p>修改后的文件示例如下：</p><pre><code class="hljs">---title: aboutdate: 2020-02-23 19:20:33layout: about---这里写关于页的正文，支持 Markdown, HTML</code></pre><p><strong>本地启动</strong></p><pre><code class="hljs">hexo g -dhexo s</code></pre><p>浏览器访问 <a href="http://localhost:4000，`Fluid`主题风格页面如下">http://localhost:4000，`Fluid`主题风格页面如下</a><br><img src="https://img-blog.csdnimg.cn/b02a3408a62040bdac07bb71435c710e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p><h3 id="五、创建文章"><a href="#五、创建文章" class="headerlink" title="五、创建文章"></a>五、创建文章</h3><p>如下修改 Hexo 博客目录中的 <code>_config.yml</code>，打开这个配置是为了在生成文章的时候生成一个同名的资源目录用于存放图片文件。</p><pre><code class="hljs">post_asset_folder: true</code></pre><p>执行如下命令创建一篇新文章，名为《测试文章》</p><pre><code class="hljs">hexo new post 测试文章</code></pre><p>执行完成后在<code>source\_posts</code>目录下生成了一个md文件和一个同名的资源目录(用于存放图片)<br><img src="https://img-blog.csdnimg.cn/4d471824356e476e8c8e092caa453f8a.png" alt="请添加图片描述"><br>在资源目录<code>测试文章</code>中放一张图片 <code>test.png</code><br><img src="https://img-blog.csdnimg.cn/96a7534cb7a743438c553298b216b8b0.png" alt="请添加图片描述"><br>在<code>测试文章.md</code>中添加内容如下，演示了图片的三种引用方式。第一种为官方推荐用法，第二种为markdown语法，第三种和前两种图片存放位置不一样，是将图片放在<code>\source\images</code>目录下。这三种写法在md文件中图片是无法显示的，但是在页面上能正常显示。</p><p>图片的引入方式可参考官方文档 <a href="https://hexo.io/zh-cn/docs/asset-folders.html">https://hexo.io/zh-cn/docs/asset-folders.html</a>，有详细介绍。</p><pre><code class="hljs">---title: 测试文章date: 2021-06-10 16:35:20tags:- 原创categories:- Java---这是一篇测试文章&#123;% asset_img test.png 图片引用方法一 %&#125;![图片引用方法二](test.png)![图片引用方法三](/images/test.png)</code></pre><p><strong>本地启动</strong></p><pre><code class="hljs">hexo g -dhexo s</code></pre><p>浏览器访问 <a href="http://localhost:4000，页面如下，文章添加成功">http://localhost:4000，页面如下，文章添加成功</a><br><img src="https://img-blog.csdnimg.cn/69a79d245c854c719696160a4ef409d4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p><h3 id="六、个性化页面展示"><a href="#六、个性化页面展示" class="headerlink" title="六、个性化页面展示"></a>六、个性化页面展示</h3><p>页面的标题等位置显示默认的文字，可以改下显示一些个性化的信息。</p><h4 id="1-浏览器tab页名称"><a href="#1-浏览器tab页名称" class="headerlink" title="1. 浏览器tab页名称"></a>1. 浏览器tab页名称</h4><p>修改根目录下 <code>_config.yml</code> 中的 <code>title</code> 字段。<br><img src="https://img-blog.csdnimg.cn/39ee292aaa8c4c1faeedceb184a3c01c.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p><h4 id="2-博客标题"><a href="#2-博客标题" class="headerlink" title="2. 博客标题"></a>2. 博客标题</h4><p>主题目录 <code>themes\fluid</code> 下 <code>_config.yml</code> 中的 <code>blog_title</code> 字段。</p><p><img src="https://img-blog.csdnimg.cn/42c777e342ed4c8baee84d4d21cb6310.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p><h4 id="3-主页正中间的文字"><a href="#3-主页正中间的文字" class="headerlink" title="3. 主页正中间的文字"></a>3. 主页正中间的文字</h4><p>主题目录 <code>themes\fluid</code> 下 <code>_config.yml</code> 中的 <code>text</code> 字段。<br><img src="https://img-blog.csdnimg.cn/449f76f0e322400abbe136bd8d9bf13d.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>修改好配置后，页面效果如下，可以看到现在显示的内容变成了我们的个人信息。<br><img src="https://img-blog.csdnimg.cn/35f5961e0d744ba69fc00c346ed372c4.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p><h3 id="七、添加阅读量统计"><a href="#七、添加阅读量统计" class="headerlink" title="七、添加阅读量统计"></a>七、添加阅读量统计</h3><p><code>Fluid</code> 主题写好了统计阅读量的代码，但是缺少相应配置所以没有开启，需要借助三方服务来统计阅读量，这里是有 <code>Leancloud</code> 的免费服务来进行统计。</p><h4 id="1-申请LeanCloud账号并创建应用"><a href="#1-申请LeanCloud账号并创建应用" class="headerlink" title="1. 申请LeanCloud账号并创建应用"></a>1. 申请LeanCloud账号并创建应用</h4><p>进入 <a href="https://console.leancloud.cn/">官网</a> 注册账号<br><img src="https://img-blog.csdnimg.cn/688c0b7aca6447db836d7c7ae183b70a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>需实名认证，完成后才能使用各项服务<br><img src="https://img-blog.csdnimg.cn/a79900336e394a9d93d5fd5c590d3c3a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>验证邮箱<br><img src="https://img-blog.csdnimg.cn/ae9d5224f9af41008489b2006c06bbd1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>创建应用，选择<code>开发版</code>即可，免费的<br><img src="https://img-blog.csdnimg.cn/60d49bcc50e34a908fccf4a544e12d03.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>进入该应用的 <code>设置-&gt;应用凭证</code>，找到 <code>AppID</code> 和 <code>AppKey</code>，记录下来后面配置要用<br><img src="https://img-blog.csdnimg.cn/ae58b27419584dc3bd0da78aa7b6a90b.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p><h4 id="2-修改Fluid配置"><a href="#2-修改Fluid配置" class="headerlink" title="2. 修改Fluid配置"></a>2. 修改Fluid配置</h4><p>打开主题目录 <code>themes\fluid</code>下的 <code>_config.yml</code> 文件，修改如下配置</p><h5 id="单篇文章阅读量计数"><a href="#单篇文章阅读量计数" class="headerlink" title="单篇文章阅读量计数"></a>单篇文章阅读量计数</h5><p>打开统计开关<br><img src="https://img-blog.csdnimg.cn/281c1db597dc4751a9fe4be660476045.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>配置 <code>leancloud</code>的 <code>app_id</code> 和 <code>app_key</code><br><img src="https://img-blog.csdnimg.cn/c707838cfa334702803b2ab9fc06501a.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>打开计数功能，统计来源改为 <code>leancloud</code><br><img src="https://img-blog.csdnimg.cn/08292cdb1d754d9b86c0a80416281ec5.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>页面效果<br><img src="https://img-blog.csdnimg.cn/5e8932a5f55b4bbab8659fdb6665e4da.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p><h5 id="页面底部展示网站的-PV、UV-统计数"><a href="#页面底部展示网站的-PV、UV-统计数" class="headerlink" title="页面底部展示网站的 PV、UV 统计数"></a>页面底部展示网站的 PV、UV 统计数</h5><p><img src="https://img-blog.csdnimg.cn/a285eab4997a4b9db2e575b966abb3d1.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>页面效果<br><img src="https://img-blog.csdnimg.cn/2693096de407498fb19d5ed760241191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p><h3 id="八、添加评论功能"><a href="#八、添加评论功能" class="headerlink" title="八、添加评论功能"></a>八、添加评论功能</h3><p>评论功能的代码已经写好了，只不过没有开启，需要修改一些配置</p><p>打开主题目录 <code>themes\fluid</code>下的 <code>_config.yml</code> 文件，修改如下配置</p><p>启用评论插件<br><img src="https://img-blog.csdnimg.cn/1cafa579015843df8e4d5ff2d7b413a6.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>配置 <code>LeanCloud</code> 的 <code>appId</code> 和 <code>appkey</code><br><img src="https://img-blog.csdnimg.cn/ed068b6c0e1a486f8efcd46de70cec24.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>重新部署后，查看页面效果，评论功能已开启<br><img src="https://img-blog.csdnimg.cn/74b51bf3f94e4c9b9f6229733cba2eeb.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>部署在本地时评论无法提交，会报跨域问题，发布到 <code>GitHub Pages</code> 上之后课正常提交评论</p><h3 id="九、发布到GitHub-Pages"><a href="#九、发布到GitHub-Pages" class="headerlink" title="九、发布到GitHub Pages"></a>九、发布到GitHub Pages</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><p>安装hexo-deployer-git</p><pre><code class="hljs">npm install hexo-deployer-git --save</code></pre><p>修改根目录下的 <code>_config.yml</code>，配置 <code>GitHub</code> 相关信息</p><pre><code class="hljs">deploy:  type: git  repo: https://github.com/yaorongke/yaorongke.github.io.git  branch: main  token: ghp_3KakcaPHerunNRyMerofcFd9pblU282FSbsY</code></pre><p>其中 <code>token</code> 为 <code>GitHub</code> 的 <code>Personal access tokens</code>，获取方式如下图<br><img src="https://img-blog.csdnimg.cn/2350558a10d94c8ab4959b04771d2bcc.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"><br>部署到GitHub</p><pre><code class="hljs">hexo g -d</code></pre><p>浏览器访问 <a href="https://yaorongke.github.io/%EF%BC%8C%E9%83%A8%E7%BD%B2%E6%88%90%E5%8A%9F">https://yaorongke.github.io/，部署成功</a><br><img src="https://img-blog.csdnimg.cn/8a1b2c92b27a4026bdb22401a4460902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p><h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><p>直接将 <code>public</code> 目录中的文件和目录推送至 <code>GitHub</code> 仓库和分支中。<br><img src="https://img-blog.csdnimg.cn/efdfd2d6cf5d4551af0eabfa565f4a1e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhb3JvbmdrZQ==,size_16,color_FFFFFF,t_70" alt="请添加图片描述"></p><h3 id="十、发布到自己服务器，Nginx代理"><a href="#十、发布到自己服务器，Nginx代理" class="headerlink" title="十、发布到自己服务器，Nginx代理"></a>十、发布到自己服务器，Nginx代理</h3><p>如果自己有服务器的话，也可以不使用 <code>GitHub Pages</code>，直接部署的自己的服务器上，通过 <code>Nginx</code> 进行代理，我这里有一个阿里云上的 <code>CentOS 7</code> 版的 <code>Linux</code> 服务器，演示下如何部署，步骤如下。</p><p>打开 <code>hexo-blog</code> 根目录下的 <code>_config.yml</code>，增加如下配置，这是因为把网站存放在了子目录中，要和 <code>Nginx</code> 配置中的 <code>location /blog</code> 路径一致。</p><pre><code class="hljs">root: /blog</code></pre><p><code>hexo-blog</code> 根目录下执行打包命令，打包好的文件在 <code>public</code> 目录下</p><pre><code class="hljs">hexo g</code></pre><p>将<code>public</code> 目录下的文件复制到 <code>Linux</code> 服务器上的某个目录下，我的存放目录为</p><pre><code class="hljs">/opt/rkyao/fronted/hexo-blog</code></pre><p>修改 <code>Nginx</code> 配置文件，我的 <code>Nginx</code> 安装路径为 <code>/usr/local</code>，大家根据自己实际情况调整</p><pre><code class="hljs">cd /usr/local/nginx/confvim nginx.conf# server节点下添加如下配置location /blog &#123;    alias  /opt/rkyao/fronted/hexo-blog;    index  index.html index.htm;&#125;</code></pre><p>重启 <code>Nginx</code></p><pre><code class="hljs">cd /usr/local/nginx/sbin./nginx -s reload</code></pre><p>访问博客</p><pre><code class="hljs">http://82.157.70.28/</code></pre><h3 id="十一、最终效果展示"><a href="#十一、最终效果展示" class="headerlink" title="十一、最终效果展示"></a>十一、最终效果展示</h3><p>可访问如下地址查看<br><a href="https://baymax55.github.io/">https://baymax55.github.io/</a></p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://blog.csdn.net/yaorongke/article/details/119089190">GitHub Pages + Hexo搭建个人博客网站，史上最全教程</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitHub Pages</tag>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xxl-Job执行器原理解析</title>
    <link href="/2022/09/19/java/Xxl-Job%E6%89%A7%E8%A1%8C%E5%99%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/09/19/java/Xxl-Job%E6%89%A7%E8%A1%8C%E5%99%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>项目解析源码地址：<a href="https://gitee.com/lidishan/xxl-job-code-analysis">xxl-job</a><br>xxl-job版本：2.3.0<br>Xxl-Job分为执行器、调度器。而我们平时的客户端就属于一个执行器，执行器启动的时候会自动注册到调度器上，然后调度器进行远程调度。</p></blockquote><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b32956275e1a464992be32767fbcdbf3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="image.png"></p><h2 id="执行器初始化过程步骤如下"><a href="#执行器初始化过程步骤如下" class="headerlink" title="执行器初始化过程步骤如下"></a>执行器初始化过程步骤如下</h2><blockquote><p>1 通过加了@Conguration注解的XxlJobConfig初始化，并生成beanName=xxlJobExecutor的Bean<br>2 注册的BeanName=XxlJobConfig，会进行初始化，步骤如下：  </p><blockquote><ul><li>  扫描所有bean，加载加了@XxlJob注解类，并记录在jobHandlerRepository</li><li>  选择工厂类：GlueFactory 或 SpringGlueFactory</li></ul><blockquote><p>-- SpringGlueFactory会拦截当前实例属性 判断是否加了@Resource或@Autowired注解，如果存在就获取当前对应的bean实例，然后通过反射注入成员中</p></blockquote><ul><li>  启动，其步骤如下：</li></ul><blockquote><p>-– 1 初始化存放执行日志目录文件 — 2 初始化执行者，管理客户端 — 3 初始化日志清除线程，一天执行一次，默认清除N天(可配置)前数据 — 4 初始化回调触发器线程，线程执行完会把数据回调调度器接口告诉他结果 — 5 初始化执行服务器，初始化netty服务器，并发客户端信息注册到调度器上</p></blockquote></blockquote></blockquote><hr><h2 id="接下来对各个源码进行一定的解析"><a href="#接下来对各个源码进行一定的解析" class="headerlink" title="接下来对各个源码进行一定的解析"></a>接下来对各个源码进行一定的解析</h2><h3 id="1-通过加了-Conguration注解的XxlJobConfig初始化，并生成beanName-xxlJobExecutor的Bean"><a href="#1-通过加了-Conguration注解的XxlJobConfig初始化，并生成beanName-xxlJobExecutor的Bean" class="headerlink" title="1     通过加了@Conguration注解的XxlJobConfig初始化，并生成beanName=xxlJobExecutor的Bean"></a>1     通过加了@Conguration注解的XxlJobConfig初始化，并生成beanName=xxlJobExecutor的Bean</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XxlJobConfig</span> &#123;<span class="hljs-comment">//     注入XxlJob相关的配置信息，并生成Bean     xxlJobExecutor</span><br>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">&quot;$&#123;xxl.job.admin.addresses&#125;&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> adminAddresses;<br>    <span class="hljs-comment">//省略</span><br>    <span class="hljs-meta">@Bean</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">XxlJobSpringExecutor</span> <span class="hljs-title function_">xxlJobExecutor</span>(<span class="hljs-params"></span>) &#123;<br>        logger.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;</span>);<br>        <span class="hljs-title class_">XxlJobSpringExecutor</span> xxlJobSpringExecutor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XxlJobSpringExecutor</span>();<br>        <span class="hljs-comment">//省略</span><br>        <span class="hljs-keyword">return</span> xxlJobSpringExecutor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-注册的BeanName-XxlJobConfig，会进行初始化，步骤如下"><a href="#2-注册的BeanName-XxlJobConfig，会进行初始化，步骤如下" class="headerlink" title="2     注册的BeanName=XxlJobConfig，会进行初始化，步骤如下"></a>2     注册的BeanName=XxlJobConfig，会进行初始化，步骤如下</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XxlJobSpringExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">XxlJobExecutor</span> <span class="hljs-title">implements</span> <span class="hljs-title">ApplicationContextAware</span>, <span class="hljs-title">SmartInitializingSingleton</span>, <span class="hljs-title">DisposableBean</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> logger = <span class="hljs-type">LoggerFactory</span>.getLogger(<span class="hljs-type">XxlJobSpringExecutor</span>.<span class="hljs-keyword">class</span>);<br><br>    <span class="hljs-comment">// start</span><br>    <span class="hljs-meta">@Override</span><br>    public void afterSingletonsInstantiated() &#123;<br>        <span class="hljs-comment">// init JobHandler Repository</span><br>        <span class="hljs-comment">/*initJobHandlerRepository(applicationContext);*/</span><br>        <span class="hljs-comment">// 扫描所有bean，加载加了@XxlJob注解类，并记录在jobHandlerRepository                init JobHandler Repository (for method)</span><br>        initJobHandlerMethodRepository(applicationContext);<br>        <span class="hljs-comment">// 选择工厂类：GlueFactory 或 SpringGlueFactory               选择工厂类：GlueFactory 或 SpringGlueFactory               refresh GlueFactory</span><br>        <span class="hljs-type">GlueFactory</span>.refreshInstance(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 启动，其步骤如下：</span><br>        <span class="hljs-comment">//--- 1 初始化存放执行日志目录文件</span><br>        <span class="hljs-comment">//--- 2 初始化执行者，管理客户端</span><br>        <span class="hljs-comment">//--- 3 初始化日志清除线程</span><br>        <span class="hljs-comment">//--- 4 初始化回调触发器线程</span><br>        <span class="hljs-comment">//--- 5 初始化执行服务器</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">super</span>.start();<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-type">Exception</span> e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="上面我们对启动super-start-步骤来做具体的分析，其分析代码如下："><a href="#上面我们对启动super-start-步骤来做具体的分析，其分析代码如下：" class="headerlink" title="上面我们对启动super.start()步骤来做具体的分析，其分析代码如下："></a>上面我们对启动super.start()步骤来做具体的分析，其分析代码如下：</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void start<span class="hljs-literal">()</span> throws Exception &#123;<br>    <span class="hljs-comment">// 1 初始化存放执行日志目录文件 init logpath</span><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">XxlJobFileAppender</span>.</span></span>init<span class="hljs-constructor">LogPath(<span class="hljs-params">logPath</span>)</span>;<br>    <span class="hljs-comment">// 2 初始化执行者，管理客户端 init invoker, admin-client</span><br>    init<span class="hljs-constructor">AdminBizList(<span class="hljs-params">adminAddresses</span>, <span class="hljs-params">accessToken</span>)</span>;<br>    <span class="hljs-comment">// 3 初始化日志清除线程 init JobLogFileCleanThread</span><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JobLogFileCleanThread</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.start(logRetentionDays);<br>    <span class="hljs-comment">// 4 初始化回调触发器线程 init TriggerCallbackThread</span><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TriggerCallbackThread</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.start<span class="hljs-literal">()</span>;<br>    <span class="hljs-comment">// 5 初始化执行服务器 init executor-server</span><br>    init<span class="hljs-constructor">EmbedServer(<span class="hljs-params">address</span>, <span class="hljs-params">ip</span>, <span class="hljs-params">port</span>, <span class="hljs-params">appname</span>, <span class="hljs-params">accessToken</span>)</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="启动super-start-gt-初始化存放执行日志目录文件"><a href="#启动super-start-gt-初始化存放执行日志目录文件" class="headerlink" title="启动super.start() -&gt;          初始化存放执行日志目录文件"></a>启动super.start() -&gt;          初始化存放执行日志目录文件</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">String</span> logBasePath = <span class="hljs-string">&quot;/data/applogs/xxl-job/jobhandler&quot;</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">String</span> glueSrcPath = logBasePath.<span class="hljs-built_in">concat</span>(<span class="hljs-string">&quot;/gluesource&quot;</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">initLogPath</span><span class="hljs-params">(<span class="hljs-type">String</span> logPath)</span> </span>&#123;<br>    <span class="hljs-comment">// init 判断有没有自定义目录</span><br>    <span class="hljs-keyword">if</span> (logPath != null &amp;&amp; logPath.<span class="hljs-built_in">trim</span>().<span class="hljs-built_in">length</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>        logBasePath = logPath;<br>    &#125;<br>    <span class="hljs-comment">// mk base dir 如果当前目录为空，就创建一个</span><br>    <span class="hljs-built_in">File</span> logPathDir = <span class="hljs-keyword">new</span> <span class="hljs-built_in">File</span>(logBasePath);<br>    <span class="hljs-keyword">if</span> (!logPathDir.<span class="hljs-built_in">exists</span>()) &#123;<br>        logPathDir.<span class="hljs-built_in">mkdirs</span>();<br>    &#125;<br>    logBasePath = logPathDir.<span class="hljs-built_in">getPath</span>();<span class="hljs-comment">// 获取创建的目录路径</span><br><br>    <span class="hljs-comment">// mk glue dir 创建glue目录路径，没有就创建然后获取</span><br>    <span class="hljs-built_in">File</span> glueBaseDir = <span class="hljs-keyword">new</span> <span class="hljs-built_in">File</span>(logPathDir, <span class="hljs-string">&quot;gluesource&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!glueBaseDir.<span class="hljs-built_in">exists</span>()) &#123;<br>        glueBaseDir.<span class="hljs-built_in">mkdirs</span>();<br>    &#125;<br>    glueSrcPath = glueBaseDir.<span class="hljs-built_in">getPath</span>();<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="启动super-start-gt-初始化执行者，管理客户端"><a href="#启动super-start-gt-初始化执行者，管理客户端" class="headerlink" title="启动super.start() -&gt; 初始化执行者，管理客户端"></a>启动super.start() -&gt; 初始化执行者，管理客户端</h4><blockquote><p>-- 把调度管理器的地址写入adminBizList中<br>-- 启动super.start() -&gt; 初始化日志清除线程</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">long</span> logRetentionDays)</span>&#123;<br><br>    <span class="hljs-comment">// 日志最多也只能清除三天前的 limit min value</span><br>    <span class="hljs-keyword">if</span> (logRetentionDays &lt; <span class="hljs-number">3</span> ) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 启动一个本地线程，用于处理日志清除</span><br>    localThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (!toStop) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 清除日志目录中超过logRetentionDays天的日志文件 clean log dir, over logRetentionDays</span><br>                    File[] childDirs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(XxlJobFileAppender.getLogPath()).listFiles();<br>                    <span class="hljs-keyword">if</span> (childDirs!=<span class="hljs-literal">null</span> &amp;&amp; childDirs.length&gt;<span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// today</span><br>                    <span class="hljs-type">Calendar</span> <span class="hljs-variable">todayCal</span> <span class="hljs-operator">=</span> Calendar.getInstance();<br>                    todayCal.set(Calendar.HOUR_OF_DAY,<span class="hljs-number">0</span>);<br>                    todayCal.set(Calendar.MINUTE,<span class="hljs-number">0</span>);<br>                    todayCal.set(Calendar.SECOND,<span class="hljs-number">0</span>);<br>                    todayCal.set(Calendar.MILLISECOND,<span class="hljs-number">0</span>);<br>                    <span class="hljs-type">Date</span> <span class="hljs-variable">todayDate</span> <span class="hljs-operator">=</span> todayCal.getTime();<br>                    <span class="hljs-keyword">for</span> (File childFile: childDirs) &#123;<br>                        <span class="hljs-comment">// valid</span><br>                        <span class="hljs-keyword">if</span> (!childFile.isDirectory()) &#123;<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (childFile.getName().indexOf(<span class="hljs-string">&quot;-&quot;</span>) == -<span class="hljs-number">1</span>) &#123;<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                        <span class="hljs-comment">// file create date</span><br>                        <span class="hljs-type">Date</span> <span class="hljs-variable">logFileCreateDate</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-comment">// 将日志文件名转为时间</span><br>                            <span class="hljs-type">SimpleDateFormat</span> <span class="hljs-variable">simpleDateFormat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>                            logFileCreateDate = simpleDateFormat.parse(childFile.getName());<br>                        &#125; <span class="hljs-keyword">catch</span> (ParseException e) &#123;<br>                            logger.error(e.getMessage(), e);<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (logFileCreateDate == <span class="hljs-literal">null</span>) &#123;<br>                            <span class="hljs-keyword">continue</span>;<br>                        &#125;<br>                        <span class="hljs-comment">// 如果文件时间超过logRetentionDays天，就进行删除</span><br>                        <span class="hljs-keyword">if</span> ((todayDate.getTime(<br></code></pre></td></tr></table></figure><h4 id="启动super-start-gt-初始化回调触发器线程"><a href="#启动super-start-gt-初始化回调触发器线程" class="headerlink" title="启动super.start() -&gt; 初始化回调触发器线程"></a>启动super.start() -&gt; 初始化回调触发器线程</h4><blockquote><p>回调job执行结果给调度器，告诉调度器已执行完</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 启动执行结果回调线程</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span>()</span> &#123;<br>    <span class="hljs-comment">// 判断是否合法的admin地址 valid</span><br>    <span class="hljs-keyword">if</span> (XxlJobExecutor.getAdminBizList() == <span class="hljs-literal">null</span>) &#123;<br>        logger.warn(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, executor callback config fail, adminAddresses is null.&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 启动回调触发线程 callback</span><br>    triggerCallbackThread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        @Override<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>            <span class="hljs-comment">// 进入回调循环处理中 normal callback</span><br>            <span class="hljs-keyword">while</span>(!toStop)&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 任务执行完，会把执行结果塞入 LinkedBlockingQueue 中，然后LinkedBlockingQueue.tack()是阻塞形的，会阻塞等待执行结果</span><br>                    HandleCallbackParam callback = getInstance().callBackQueue.take();<br>                    <span class="hljs-keyword">if</span> (callback != <span class="hljs-literal">null</span>) &#123;<br><br>                        <span class="hljs-comment">// 把执行结果全部搞出来，然后塞入callbackParamList，然后批量回调处理 callback list param</span><br>                        List&lt;HandleCallbackParam&gt; callbackParamList = <span class="hljs-keyword">new</span> ArrayList&lt;HandleCallbackParam&gt;();<br>                        <span class="hljs-built_in">int</span> drainToNum = getInstance().callBackQueue.drainTo(callbackParamList);<br>                        callbackParamList.<span class="hljs-keyword">add</span>(callback);<br>                        <span class="hljs-comment">// callback, will retry if error</span><br>                        <span class="hljs-keyword">if</span> (callbackParamList!=<span class="hljs-literal">null</span> &amp;&amp; callbackParamList.size()&gt;<span class="hljs-number">0</span>) &#123;<br>                            doCallback(callbackParamList);<span class="hljs-comment">// 回调执行结果，告诉admin，请求的结果是 addressUrl+&quot;api/callback&quot;</span><br>                        &#125;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;......&#125;<br>                    <span class="hljs-comment">// 进行回到后的回归操作 last callback</span><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        List&lt;HandleCallbackParam&gt; callbackParamList = <span class="hljs-keyword">new</span> ArrayList&lt;HandleCallbackParam&gt;();<br>                        <span class="hljs-built_in">int</span> drainToNum = getInstance().callBackQueue.drainTo(callbackParamList);<br>                        <span class="hljs-keyword">if</span> (callbackParamList!=<span class="hljs-literal">null</span> &amp;&amp; callbackParamList.size()&gt;<span class="hljs-number">0</span>) &#123;<br>                            doCallback(callbackParamList);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;..........&#125;<br>                    logger.info(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, executor callback thread destory.&quot;</span>);<br>                &#125;<br></code></pre></td></tr></table></figure><h4 id="启动super-start-gt-初始化执行服务器"><a href="#启动super-start-gt-初始化执行服务器" class="headerlink" title="启动super.start() -&gt;初始化执行服务器"></a>启动super.start() -&gt;初始化执行服务器</h4><blockquote><p>初始化netty服务器，并发客户端信息注册到调度器上</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化执行服务器</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initEmbedServer</span><span class="hljs-params">(String address, String ip, <span class="hljs-type">int</span> port, String appname, String accessToken)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 填充ip和端口号 fill ip port</span><br>    port = port&gt;<span class="hljs-number">0</span>?port: NetUtil.findAvailablePort(<span class="hljs-number">9999</span>);<br>    ip = (ip!=<span class="hljs-literal">null</span>&amp;&amp;ip.trim().length()&gt;<span class="hljs-number">0</span>)?ip: IpUtil.getIp();<br>    <span class="hljs-comment">// 地址为空，就根据ip:port生成新的地址 generate address</span><br>    <span class="hljs-keyword">if</span> (address==<span class="hljs-literal">null</span> || address.trim().length()==<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ip_port_address</span> <span class="hljs-operator">=</span> IpUtil.getIpPort(ip, port); <span class="hljs-comment">// registry-address：default use address to registry , otherwise use         ip:port if address is null</span><br>        address = <span class="hljs-string">&quot;http://&#123;ip_port&#125;/&quot;</span>.replace(<span class="hljs-string">&quot;&#123;ip_port&#125;&quot;</span>, ip_port_address);<br>    &#125;<br>    <span class="hljs-comment">// accessToken</span><br>    <span class="hljs-keyword">if</span> (accessToken==<span class="hljs-literal">null</span> || accessToken.trim().length()==<span class="hljs-number">0</span>) &#123;<br>        logger.warn(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job accessToken is empty. To ensure system security, please set the accessToken.&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 实例化一个网络server start</span><br>    embedServer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmbedServer</span>();<br>    embedServer.start(address, port, appname, accessToken);<span class="hljs-comment">// 启动server，基于netty</span><br>&#125;<br><span class="hljs-comment">// embedServer.start 调用的就是以下方法，启动nettyServer服务器，然后请求注册到调度器上，调度器会通过netty通知来调度job</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String address, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> port, <span class="hljs-keyword">final</span> String appname, <span class="hljs-keyword">final</span> String accessToken)</span> &#123;<br>    executorBiz = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutorBizImpl</span>();<br>    thread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// param</span><br>            <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">bossGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>            <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>            <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">bizThreadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, <span class="hljs-number">200</span>, <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="hljs-number">2000</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>() &#123;xxxxx&#125;);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// start server</span><br>                <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>                bootstrap.group(bossGroup, workerGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    ............省略.................<br>                    .addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">EmbedHttpServerHandler</span>(executorBiz, accessToken, bizThre<br></code></pre></td></tr></table></figure><p>上面启动了nettyServer，并且对应的实现handler为EmbedHttpServerHandler，通过监听，最终调用如下代码：</p><p>-- 路径为：EmbedHttpServerHandler-&gt;channelRead0-&gt;process()-&gt;executorBiz.run(triggerParam)-&gt;ExecutorBizImpl#run()</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 执行job任务最终会调用到这里</span><br><span class="hljs-comment">* @param triggerParam 执行参数</span><br><span class="hljs-comment">*/</span><br>@Override<br><span class="hljs-keyword">public</span> ReturnT&lt;<span class="hljs-keyword">String</span>&gt; run(TriggerParam triggerParam) &#123;<br>    <span class="hljs-comment">// 加载出对应的jobHandler + jobThread load old：jobHandler + jobThread</span><br>    JobThread jobThread = XxlJobExecutor.loadJobThread(triggerParam.getJobId());<br>    IJobHandler jobHandler = jobThread!=<span class="hljs-literal">null</span>?jobThread.getHandler():<span class="hljs-type">null</span>;<br>    <span class="hljs-keyword">String</span> removeOldReason = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// valid：jobHandler + jobThread</span><br>    GlueTypeEnum glueTypeEnum = GlueTypeEnum.match(triggerParam.getGlueType());<br>    <span class="hljs-keyword">if</span> (GlueTypeEnum.BEAN == glueTypeEnum) &#123;<span class="hljs-comment">// bean的方式调用，现在一般都是这个方式，其他方式是怎么处理的就不解析了</span><br>        <span class="hljs-comment">// new jobhandler</span><br>        IJobHandler <span class="hljs-keyword">new</span><span class="hljs-type">JobHandler</span> = XxlJobExecutor.loadJobHandler(triggerParam.getExecutorHandler());<br>        <span class="hljs-comment">// 验证旧的任务处理器，如果不相等，就创建一个新的 valid old jobThread</span><br>        <span class="hljs-keyword">if</span> (jobThread!=<span class="hljs-literal">null</span> &amp;&amp; jobHandler != <span class="hljs-keyword">new</span><span class="hljs-type">JobHandler</span>) &#123;<br>            <span class="hljs-comment">// change handler, need kill old thread</span><br>            removeOldReason = <span class="hljs-string">&quot;change jobhandler or glue type, and terminate the old job thread.&quot;</span>;<br>            jobThread = <span class="hljs-literal">null</span>;<span class="hljs-comment">// 任务线程</span><br>            jobHandler = <span class="hljs-literal">null</span>;<span class="hljs-comment">// 任务处理器</span><br>        &#125;<br>        <span class="hljs-comment">// 验证处理器并再次赋值 valid handler</span><br>        <span class="hljs-keyword">if</span> (jobHandler == <span class="hljs-literal">null</span>) &#123;<br>            jobHandler = <span class="hljs-keyword">new</span><span class="hljs-type">JobHandler</span>;<br>            <span class="hljs-keyword">if</span> (jobHandler == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ReturnT</span>&lt;<span class="hljs-keyword">String</span>&gt;(ReturnT.FAIL_CODE, <span class="hljs-string">&quot;job handler [&quot;</span> + triggerParam.getExecutorHandler() + <span class="hljs-string">&quot;] not found.&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (GlueTypeEnum.GLUE_GROOVY == glueTypeEnum) &#123;......省略多种其他方式......&#125;<br><br>    <span class="hljs-comment">// 执行block策略 executor block strategy</span><br>    <span class="hljs-keyword">if</span> (jobThread != <span class="hljs-literal">null</span>) &#123;<br>        ExecutorBlockStrategyEnum blockStrategy = ExecutorBlockStrategyEnum.match(triggerParam.getExecutorBlockStrategy(), <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> (ExecutorBlockStrategyEnum.DISCARD_LATER == blockStrategy) &#123;<span class="hljs-comment">// 废弃后面来的</span><br>            <span class="hljs-comment">// discard when running</span><br>            <span class="hljs-keyword">if</span> (jobThread.isRunningOrHasQueue()) &#123;<span class="hljs-comment">// 如果有运行中线程，就终止当前调用</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">ReturnT</span>&lt;<span class="hljs-keyword">String</span>&gt;(ReturnT.FAIL_CODE, <span class="hljs-string">&quot;block strategy effect：&quot;</span>+ExecutorBlockStrategyEnum.DISCARD_LATER.getTitle());<br>            &#125;<br>        &#125; <br>        <br></code></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://juejin.cn/post/6987409807430909966">Xxl-Job执行器原理解析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>xxl-job</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Xxl-Job调度器原理解析</title>
    <link href="/2022/09/19/java/Xxl-Job%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/09/19/java/Xxl-Job%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>项目解析源码地址：<a href="https://gitee.com/lidishan/xxl-job-code-analysis">xxl-job</a><br>xxl-job版本：2.3.0<br>Xxl-Job分为执行器、调度器。而我们平时的客户端就属于一个执行器，执行器启动的时候会自动注册到调度器上，然后调度器进行远程调度。</p></blockquote><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da76545841614878a200966fda993018~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.image" alt="image.png"></p><h2 id="调度器初始化过程步骤如下"><a href="#调度器初始化过程步骤如下" class="headerlink" title="调度器初始化过程步骤如下"></a>调度器初始化过程步骤如下</h2><blockquote><p>1 国际化相关  </p><blockquote><p>配置参数： xxl.job.i18n=zh_CN, 这里设置为中文简体  </p></blockquote><p>2 初始化快线程fastTriggerPool、慢线程池slowTriggerPool  </p><blockquote><p>配置参数：xxl.job.triggerpool.fast.max=200, 这里设置为fastTriggerPool的最大线程数=200, 不能小于200<br>xxl.job.triggerpool.slow.max=100, 这里设置为slowTriggerPool的最大线程数=100, 不能小于100  </p></blockquote><p>3 启动注册监听线程  </p><blockquote><p>3.1 初始化registryOrRemoveThreadPool线程池：用于注册或者移除的线程池，客户端调用api/registry或api/registryRemove接口时，会用这个线程池进行注册或注销<br>3.2 启动监听注册的线程registryMonitorThread：清除心跳超过90s的注册信息，并且刷新分组注册信息  </p></blockquote><p>4 启动失败任务监听线程(重试、告警)  </p><blockquote><p>配置参数：spring.mail.from=<a href="https://link.juejin.cn/?target=mailto:xxx@qq.com" title="mailto:xxx@qq.com">[email protected]</a>, 告警邮箱  </p></blockquote><p>5 启动监控线程  </p><blockquote><p>5.1 初始化callbackThreadPool线程池：用于callback回调的线程池，客户端调用api/callback接口时会使用这个线程池<br>5.2 启动监控线monitorThread：调度记录停留在 “运行中” 状态超过10min，且对应执行器心跳注册失败不在线，则将本地调度主动标记失败  </p></blockquote><p>6 启动日志统计和清除线程logrThread  </p><blockquote><p>-- 日志记录刷新，刷新最近三天的日志Report（即统计每天的失败、成功、运行次数等）<br>-- 每天清除一次失效过期的日志数据<br>配置参数：xxl.job.logretentiondays=30, 清除xxl-job数据库日志的过期时间, 小于7天则不清除  </p></blockquote><p>7 启动任务调度（**很重要！！**主要靠这两个线程进行塞数据到时间轮，然后时间轮取数调度任务）  </p><blockquote><p>7.1 scheduleThread线程-取待执行任务数据入时间轮（塞数据）<br>-- 第一步：用select for update 数据库作为分布式锁加锁，避免多个xxl-job admin调度器节点同时执行<br>-- 第二步：预读数据，从数据库中读取当前截止到五秒后内会执行的job信息，并且读取分页大小为preReadCount=6000条数据<br>-— preReadCount = (XxlJobAdminConfig.getAdminConfig().getTriggerPoolFastMax() + XxlJobAdminConfig.getAdminConfig().getTriggerPoolSlowMax()) * 20;<br>-- 第三步：将当前时间与下次调度时间对比，有如下三种情况<br>**** 当前时间 大于 （任务的下一次触发时间 + PRE_READ_MS（5s））：可能是查询太久了，然后下面的代码刷新了任务下次执行时间，导致超过五秒，所以就需要特殊处理<br>-——- 1、匹配过期失效的策略：DO_NOTHING=过期啥也不干，废弃；FIRE_ONCE_NOW=过期立即触发一次<br>-——- 2、刷新上一次触发 和 下一次待触发时间<br>**** 当前时间 大于 任务的下一次触发时间 并且是没有过期的：<br>-——- 1、直接触发任务执行器<br>-——- 2、刷新上一次触发 和 下一次待触发时间<br>-——- 3、如果下一次触发在五秒内，直接放进时间轮里面待调度<br>-————— 1、求当前任务下一次触发时间所处一分钟的第N秒<br>-————— 2、将当前任务ID和ringSecond放进时间轮里面<br>-————— 3、刷新上一次触发 和 下一次待触发时间<br>**** 当前时间 小于 下一次触发时间：<br>-——- 1、求当前任务下一次触发时间所处一分钟的第N秒<br>-——- 2、将当前任务ID和ringSecond放进时间轮里面<br>-——- 3、刷新上一次触发 和 下一次待触发时间<br>-- 第四步：更新数据库执行器信息，如trigger_last_time、trigger_next_time  </p><p>-- 第五步：提交数据库事务，释放数据库select for update排它锁  </p><p>7.2 ringThread线程-根据时间轮执行job任务 （取数据执行）<br>首先时间轮数据格式为：Map&lt;Integer, List&gt; ringData = new ConcurrentHashMap&lt;&gt;()<br>-- 第一步：获取当前所处的一分钟第几秒，然后for两次，第二次是为了重跑前面一个刻度没有被执行的的job list，避免前面的刻度遗漏了<br>-- 第二步：执行触发器<br>-- 第三步：清除当前刻度列表的数据<br>**** 执行的过程中还会选择对应的策略，如下：<br>-——- 阻塞策略：串行、废弃后面、覆盖前面<br>-——- 路由策略：取第一个、取最后一个、最小分发、一致性hash、快速失败、LFU最不常用、LRU最近最少使用、随机、轮询</p></blockquote></blockquote><h2 id="初始化的入口代码为-XxlJobAdminConfig如下"><a href="#初始化的入口代码为-XxlJobAdminConfig如下" class="headerlink" title="初始化的入口代码为 XxlJobAdminConfig如下"></a>初始化的入口代码为 XxlJobAdminConfig如下</h2><pre><code class="hljs">@Componentpublic class XxlJobAdminConfig implements InitializingBean, DisposableBean &#123;    private static XxlJobAdminConfig adminConfig = null;    public static XxlJobAdminConfig getAdminConfig() &#123;        return adminConfig;    &#125;    // ---------------------- XxlJobScheduler ----------------------    private XxlJobScheduler xxlJobScheduler;    @Override    public void afterPropertiesSet() throws Exception &#123;// 生命周期中的属性注入来对xxlJobScheduler初始化        adminConfig = this;        // 初始化xxl-job定时任务        xxlJobScheduler = new XxlJobScheduler();        xxlJobScheduler.init();    &#125;    @Override    public void destroy() throws Exception &#123; // 生命周期中的销毁来对xxlJobScheduler销毁        xxlJobScheduler.destroy();    &#125;    ..............省略..............&#125;     </code></pre><blockquote><p>xxlJobScheduler.init()进行初始化会执行如下过程：</p></blockquote><pre><code class="hljs">public class XxlJobScheduler &#123;    private static final Logger logger = LoggerFactory.getLogger(XxlJobScheduler.class);    public void init() throws Exception &#123;        // 1 国际化相关 init i18n        initI18n();        // 2 初始化快线程池fastTriggerPool、慢线程池slowTriggerPool admin trigger pool start        JobTriggerPoolHelper.toStart();        // 3 启动注册监听线程 admin registry monitor run        JobRegistryHelper.getInstance().start();        // 4 启动失败任务监听线程(重试、告警) admin fail-monitor run        JobFailMonitorHelper.getInstance().start();        // 5 启动监控线程（调度记录停留在 &quot;运行中&quot; 状态超过10min，且对应执行器心跳注册失败不在线，则将本地调度主动标记失败）admin lose-monitor run ( depend on JobTriggerPoolHelper )        JobCompleteHelper.getInstance().start();        // 6 启动日志统计和清除线程（日志记录刷新，刷新最近三天的日志Report（即统计每天的失败、成功、运行次数等）；每天清除一次失效过期的日志数据）admin log report start        JobLogReportHelper.getInstance().start();        // 7 启动任务调度(scheduleThread-取待执行任务数据入时间轮；ringThread-根据时间轮执行job任务) start-schedule ( depend on JobTriggerPoolHelper )        JobScheduleHelper.getInstance().start();        logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin success.&quot;);    &#125;    ................省略........................&#125;     </code></pre><hr><h2 id="上面初始化的7个步骤拆分如下"><a href="#上面初始化的7个步骤拆分如下" class="headerlink" title="上面初始化的7个步骤拆分如下"></a>上面初始化的7个步骤拆分如下</h2><h3 id="1-国际化相关"><a href="#1-国际化相关" class="headerlink" title="1 国际化相关"></a>1 国际化相关</h3><pre><code class="hljs">private void initI18n()&#123;// 根据环境设置title为中文、英文等    for (ExecutorBlockStrategyEnum item:ExecutorBlockStrategyEnum.values()) &#123;        item.setTitle(I18nUtil.getString(&quot;jobconf_block_&quot;.concat(item.name())));    &#125;&#125;     </code></pre><h3 id="2-初始化快线程fastTriggerPool、慢线程池slowTriggerPool"><a href="#2-初始化快线程fastTriggerPool、慢线程池slowTriggerPool" class="headerlink" title="2 初始化快线程fastTriggerPool、慢线程池slowTriggerPool"></a>2 初始化快线程fastTriggerPool、慢线程池slowTriggerPool</h3><blockquote><p>这个步骤初始化了两个线程池fastTriggerPool和slowTriggerPool<br>在触发调度的时候会有一个选择快慢线程池的过程，如果job在一分钟内超过超过10次，就用slowTriggerPool来处理，如下：</p></blockquote><pre><code class="hljs">ThreadPoolExecutor triggerPool_ = fastTriggerPool;AtomicInteger jobTimeoutCount = jobTimeoutCountMap.get(jobId);if (jobTimeoutCount!=null &amp;&amp; jobTimeoutCount.get() &gt; 10) &#123; // job在一分钟内超过超过10次，就用slowTriggerPool来处理 job-timeout 10 times in 1 min    triggerPool_ = slowTriggerPool;&#125;triggerPool_.execute(new Runnable() &#123;.........省略............&#125;     </code></pre><h3 id="3-启动注册监听线程"><a href="#3-启动注册监听线程" class="headerlink" title="3 启动注册监听线程"></a>3 启动注册监听线程</h3><blockquote><p>3.1 初始化registryOrRemoveThreadPool线程池：用于注册或者移除的线程池，客户端调用api/registry或api/registryRemove接口时，会用这个线程池进行注册或注销<br>3.2 启动监听注册的线程registryMonitorThread：清除心跳超过90s的注册信息，并且刷新分组注册信息</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">start</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-comment">// 用于注册或者移除的线程池，客户端调用api/registry或api/registryRemove接口时，会用这个线程池进行注册或注销    for registry or remove</span><br>   registryOrRemoveThreadPool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>         <span class="hljs-number">2</span>,<br>         <span class="hljs-number">10</span>,<br>         30L,<br>         <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">SECONDS</span>,<br>         <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;<span class="hljs-title class_">Runnable</span>&gt;(<span class="hljs-number">2000</span>),<br>         <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-title class_">Thread</span> <span class="hljs-title function_">newThread</span>(<span class="hljs-params">Runnable r</span>) &#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;xxl-job, admin JobRegistryMonitorHelper-registryOrRemoveThreadPool-&quot;</span> + r.<span class="hljs-title function_">hashCode</span>());<br>            &#125;<br>         &#125;,<br>         <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionHandler</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">rejectedExecution</span>(<span class="hljs-params">Runnable r, ThreadPoolExecutor executor</span>) &#123;<br>               r.<span class="hljs-title function_">run</span>();<br>               logger.<span class="hljs-title function_">warn</span>(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, registry or remove too fast, match threadpool rejected handler(run now).&quot;</span>);<br>            &#125;<br>         &#125;);<br><br>   <span class="hljs-comment">// 启动监听注册的线程      for monitor</span><br>   registryMonitorThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) &#123;<br>         <span class="hljs-keyword">while</span> (!toStop) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-comment">// 获取自动注册的执行器组（执行器地址类型：0=自动注册、1=手动录入） auto registry group</span><br>               <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">XxlJobGroup</span>&gt; groupList = <span class="hljs-title class_">XxlJobAdminConfig</span>.<span class="hljs-title function_">getAdminConfig</span>().<span class="hljs-title function_">getXxlJobGroupDao</span>().<span class="hljs-title function_">findByAddressType</span>(<span class="hljs-number">0</span>);<br>               <span class="hljs-keyword">if</span> (groupList!=<span class="hljs-literal">null</span> &amp;&amp; !groupList.<span class="hljs-title function_">isEmpty</span>()) &#123;<span class="hljs-comment">// group组集合不为空</span><br>                  <span class="hljs-comment">// 移除死掉的调用地址（心跳时间超过90秒，就当线程挂掉了。默认是30s做一次心跳）          remove dead address (admin/executor)</span><br>                  <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">Integer</span>&gt; ids = <span class="hljs-title class_">XxlJobAdminConfig</span>.<span class="hljs-title function_">getAdminConfig</span>().<span class="hljs-title function_">getXxlJobRegistryDao</span>().<span class="hljs-title function_">findDead</span>(<span class="hljs-title class_">RegistryConfig</span>.<span class="hljs-property">DEAD_TIMEOUT</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>                  <span class="hljs-keyword">if</span> (ids!=<span class="hljs-literal">null</span> &amp;&amp; ids.<span class="hljs-title function_">size</span>()&gt;<span class="hljs-number">0</span>) &#123;<span class="hljs-comment">// 移除挂掉的注册地址信息</span><br>                     <span class="hljs-title class_">XxlJobAdminConfig</span>.<span class="hljs-title function_">getAdminConfig</span>().<span class="hljs-title function_">getXxlJobRegistryDao</span>().<span class="hljs-title function_">removeDead</span>(ids);<br>                  &#125;<br>   <br>                  <span class="hljs-comment">// fresh online address (admin/executor)</span><br>                  <span class="hljs-title class_">HashMap</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt;&gt; appAddressMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt;&gt;();<br>                  <span class="hljs-comment">// 找出所有正常没死掉的注册地址</span><br>                  <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">XxlJobRegistry</span>&gt; list = <span class="hljs-title class_">XxlJobAdminConfig</span>.<span class="hljs-title function_">getAdminConfig</span>().<span class="hljs-title function_">getXxlJobRegistryDao</span>().<span class="hljs-title function_">findAll</span>(<span class="hljs-title class_">RegistryConfig</span>.<span class="hljs-property">DEAD_TIMEOUT</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>                  <span class="hljs-keyword">if</span> (list != <span class="hljs-literal">null</span>) &#123;<br>                     <span class="hljs-keyword">for</span> (<span class="hljs-title class_">XxlJobRegistry</span> <span class="hljs-attr">item</span>: list) &#123;<br>                        <span class="hljs-comment">// 确保是 EXECUTOR 执行器类型</span><br>                        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">RegistryConfig</span>.<span class="hljs-property">RegistType</span>.<span class="hljs-property">EXECUTOR</span>.<span class="hljs-title function_">name</span>().<span class="hljs-title function_">equals</span>(item.<span class="hljs-title function_">getRegistryGroup</span>())) &#123;<br>                           <span class="hljs-title class_">String</span> appname = item.<span class="hljs-title function_">getRegistryKey</span>();<br>                           <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; registryList = appAddressMap.<span class="hljs-title function_">get</span>(appname);<br>                           <span class="hljs-keyword">if</span> (registryList == <span class="hljs-literal">null</span>) &#123;<br>                              registryList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;<span class="hljs-title class_">String</span>&gt;();<br>                           &#125;<br><br><br>     <br>                           <span class="hljs-keyword">if</span> (!registryList.<span class="hljs-title function_">contains</span>(item.<span class="hljs-title function_">getRegistryValue</span>())) &#123;<br>                              registryList.<span class="hljs-title function_">add</span>(item.<span class="hljs-title function_">getRegistryValue</span>());<br>                           &#125;<br>                           appAddressMap.<span class="hljs-title function_">put</span>(appname, registryList);<br>                        &#125;<br>                     &#125;<br>                  &#125;<br><br><br>     <br>                  <span class="hljs-comment">// 刷新分组注册地址信息  fresh group address</span><br>                  <span class="hljs-keyword">for</span> (<span class="hljs-title class_">XxlJobGroup</span> <span class="hljs-attr">group</span>: groupList) &#123;<br>                     <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; registryList = appAddressMap.<span class="hljs-title function_">get</span>(group.<span class="hljs-title function_">getAppname</span>());<br>                     <span class="hljs-title class_">String</span> addressListStr = <span class="hljs-literal">null</span>;<br>                     <span class="hljs-keyword">if</span> (registryList!=<span class="hljs-literal">null</span> &amp;&amp; !registryList.<span class="hljs-title function_">isEmpty</span>()) &#123;<br>                        <span class="hljs-title class_">Collections</span>.<span class="hljs-title function_">sort</span>(registryList);<br>                        <span class="hljs-title class_">StringBuilder</span> addressListSB = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>                        <span class="hljs-keyword">for</span> (<span class="hljs-title class_">String</span> <span class="hljs-attr">item</span>:registryList) &#123;<br>                           addressListSB.<span class="hljs-title function_">append</span>(item).<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;,&quot;</span>);<br>                        &#125;<br>                        addressListStr = addressListSB.<span class="hljs-title function_">toString</span>();<br>                        addressListStr = addressListStr.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, addressListStr.<span class="hljs-title function_">length</span>()-<span class="hljs-number">1</span>);<br>                     &#125;<br>                     group.<span class="hljs-title function_">setAddressList</span>(addressListStr);<br>                     group.<span class="hljs-title function_">setUpdateTime</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br><br><br><br>                     <span class="hljs-title class_">XxlJobAdminConfig</span>.<span class="hljs-title function_">getAdminConfig</span>().<span class="hljs-title function_">getXxlJobGroupDao</span>().<span class="hljs-title function_">update</span>(group);<br>                  &#125;<br>               &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br>               <span class="hljs-keyword">if</span> (!toStop) &#123;<br>                  logger.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job registry monitor thread error:&#123;&#125;&quot;</span>, e);<br>               &#125;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">SECONDS</span>.<span class="hljs-title function_">sleep</span>(<span class="hljs-title class_">RegistryConfig</span>.<span class="hljs-property">BEAT_TIMEOUT</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">InterruptedException</span> e) &#123;<br>               <span class="hljs-keyword">if</span> (!toStop) &#123;<br>                  logger.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job registry monitor thread error:&#123;&#125;&quot;</span>, e);<br>               &#125;<br>            &#125;<br>         &#125;<br>         logger.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, job registry monitor thread stop&quot;</span>);<br>      &#125;     <br>   &#125;);<br>   registryMonitorThread.<span class="hljs-title function_">setDaemon</span>(<span class="hljs-literal">true</span>);<br>   registryMonitorThread.<span class="hljs-title function_">setName</span>(<span class="hljs-string">&quot;xxl-job, admin JobRegistryMonitorHelper-registryMonitorThread&quot;</span>);<br>   registryMonitorThread.<span class="hljs-title function_">start</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-启动失败任务监听线程-重试、告警"><a href="#4-启动失败任务监听线程-重试、告警" class="headerlink" title="4 启动失败任务监听线程(重试、告警)"></a>4 启动失败任务监听线程(重试、告警)</h3><blockquote><p>这部分逻辑比较简单，就是重试 + 告警，核心代码如下</p></blockquote><pre><code class="hljs">// 获取执行失败的job信息List&lt;Long&gt; failLogIds = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().findFailJobLogIds(1000);if (failLogIds!=null &amp;&amp; !failLogIds.isEmpty()) &#123;   for (long failLogId: failLogIds) &#123;      // lock log      int lockRet = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateAlarmStatus(failLogId, 0, -1);      if (lockRet &lt; 1) &#123;         continue;      &#125;      XxlJobLog log = XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().load(failLogId);      XxlJobInfo info = XxlJobAdminConfig.getAdminConfig().getXxlJobInfoDao().loadById(log.getJobId());      // 1、失败塞回重试       fail retry monitor      if (log.getExecutorFailRetryCount() &gt; 0) &#123;         JobTriggerPoolHelper.trigger(log.getJobId(), TriggerTypeEnum.RETRY, (log.getExecutorFailRetryCount()-1), log.getExecutorShardingParam(), log.getExecutorParam(), null);         String retryMsg = &quot;&lt;span style=\&quot;color:#F39C12;\&quot; &gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;+ I18nUtil.getString(&quot;jobconf_trigger_type_retry&quot;) +&quot;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; &lt;/span&gt;&quot;;         log.setTriggerMsg(log.getTriggerMsg() + retryMsg);         XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateTriggerInfo(log);      &#125;      // 2、进行失败告警       fail alarm monitor      int newAlarmStatus = 0;       // 告警状态：0-默认、-1=锁定状态、1-无需告警、2-告警成功、3-告警失败      if (info!=null &amp;&amp; info.getAlarmEmail()!=null &amp;&amp; info.getAlarmEmail().trim().length()&gt;0) &#123;         boolean alarmResult = XxlJobAdminConfig.getAdminConfig().getJobAlarmer().alarm(info, log);         newAlarmStatus = alarmResult?2:3;      &#125; else &#123;         newAlarmStatus = 1;      &#125;      XxlJobAdminConfig.getAdminConfig().getXxlJobLogDao().updateAlarmStatus(failLogId, -1, newAlarmStatus);   &#125;&#125;     </code></pre><h3 id="5-启动监控线程"><a href="#5-启动监控线程" class="headerlink" title="5 启动监控线程"></a>5 启动监控线程</h3><blockquote><p>5.1 初始化callbackThreadPool线程池：用于callback回调的线程池，客户端调用api/callback接口时会使用这个线程池<br>5.2 启动监控线monitorThread：调度记录停留在 “运行中” 状态超过10min，且对应执行器心跳注册失败不在线，则将本地调度主动标记失败</p></blockquote><h3 id="6-启动日志统计和清除线程logrThread"><a href="#6-启动日志统计和清除线程logrThread" class="headerlink" title="6 启动日志统计和清除线程logrThread"></a>6 启动日志统计和清除线程logrThread</h3><blockquote><p>-- 日志记录刷新，刷新最近三天的日志Report（即统计每天的失败、成功、运行次数等）<br>-- 每天清除一次失效过期的日志数据<br>配置参数：xxl.job.logretentiondays=30, 清除xxl-job数据库日志的过期时间, 小于7天则不清除</p></blockquote><h3 id="7-启动任务调度（重点！！）"><a href="#7-启动任务调度（重点！！）" class="headerlink" title="7 启动任务调度（重点！！）"></a>7 启动任务调度（<strong>重点！！</strong>）</h3><blockquote><p>7.1 scheduleThread线程-取待执行任务数据入时间轮（塞数据）<br>-- 第一步：用select for update 数据库作为分布式锁加锁，避免多个xxl-job admin调度器节点同时执行<br>-- 第二步：预读数据，从数据库中读取当前截止到五秒后内会执行的job信息，并且读取分页大小为preReadCount=6000条数据<br>-— preReadCount = (XxlJobAdminConfig.getAdminConfig().getTriggerPoolFastMax() + XxlJobAdminConfig.getAdminConfig().getTriggerPoolSlowMax()) * 20;<br>-- 第三步：将当前时间与下次调度时间对比，有如下三种情况<br>**** 当前时间 大于 （任务的下一次触发时间 + PRE_READ_MS（5s））：可能是查询太久了，然后下面的代码刷新了任务下次执行时间，导致超过五秒，所以就需要特殊处理<br>-——- 1、匹配过期失效的策略：DO_NOTHING=过期啥也不干，废弃；FIRE_ONCE_NOW=过期立即触发一次<br>-——- 2、刷新上一次触发 和 下一次待触发时间<br>**** 当前时间 大于 任务的下一次触发时间 并且是没有过期的：<br>-——- 1、直接触发任务执行器<br>-——- 2、刷新上一次触发 和 下一次待触发时间<br>-——- 3、如果下一次触发在五秒内，直接放进时间轮里面待调度<br>-————— 1、求当前任务下一次触发时间所处一分钟的第N秒<br>-————— 2、将当前任务ID和ringSecond放进时间轮里面<br>-————— 3、刷新上一次触发 和 下一次待触发时间<br>**** 当前时间 小于 下一次触发时间：<br>-——- 1、求当前任务下一次触发时间所处一分钟的第N秒<br>-——- 2、将当前任务ID和ringSecond放进时间轮里面<br>-——- 3、刷新上一次触发 和 下一次待触发时间<br>-- 第四步：更新数据库执行器信息，如trigger_last_time、trigger_next_time  </p><p>-- 第五步：提交数据库事务，释放数据库select for update排它锁  </p><p>7.2 ringThread线程-根据时间轮执行job任务 （取数据执行）<br>首先时间轮数据格式为：Map&lt;Integer, List&gt; ringData = new ConcurrentHashMap&lt;&gt;()<br>-- 第一步：获取当前所处的一分钟第几秒，然后for两次，第二次是为了重跑前面一个刻度没有被执行的的job list，避免前面的刻度遗漏了<br>-- 第二步：执行触发器<br>-- 第三步：清除当前刻度列表的数据<br>**** 执行的过程中还会选择对应的策略，如下：<br>-——- 阻塞策略：串行、废弃后面、覆盖前面<br>-——- 路由策略：取第一个、取最后一个、最小分发、一致性hash、快速失败、LFU最不常用、LRU最近最少使用、随机、轮询</p></blockquote><ul><li>  启动两个线程解析的核心源码如下：<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void start<span class="hljs-literal">()</span>&#123;<br><br>    <span class="hljs-comment">// 启动调度线程，这些线程是用来取数据的 schedule thread</span><br>    scheduleThread = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(<span class="hljs-params">new</span> Runnable()</span> &#123;<br>    @Override<br>    public void run<span class="hljs-literal">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<span class="hljs-comment">// 不知道为啥要休眠 4-5秒 时间，然后再启动</span><br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TimeUnit</span>.</span><span class="hljs-module"><span class="hljs-identifier">MILLISECONDS</span>.</span></span>sleep(<span class="hljs-number">5000</span> - <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>%<span class="hljs-number">1000</span> );<br>    &#125; catch (InterruptedException e) &#123;<br>        <span class="hljs-keyword">if</span> (!scheduleThreadToStop) &#123;<br>            logger.error(e.get<span class="hljs-constructor">Message()</span>, e);<br>        &#125;<br>    &#125;<br>    logger.info(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; init xxl-job admin scheduler success.&quot;</span>);<br>    <br>    <span class="hljs-comment">// 这里是预读数量 pre-read count: treadpool-size * trigger-qps (each trigger cost 50ms, qps = 1000/50 = 20)</span><br>    <span class="hljs-built_in">int</span> preReadCount = (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">XxlJobAdminConfig</span>.</span></span>get<span class="hljs-constructor">AdminConfig()</span>.get<span class="hljs-constructor">TriggerPoolFastMax()</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">XxlJobAdminConfig</span>.</span></span>get<span class="hljs-constructor">AdminConfig()</span>.get<span class="hljs-constructor">TriggerPoolSlowMax()</span>)<span class="hljs-operator"> * </span><span class="hljs-number">20</span>;<br>    <br>    <span class="hljs-keyword">while</span> (!scheduleThreadToStop) &#123;<br>    <span class="hljs-comment">// 扫描任务 Scan Job</span><br>    long start = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;<br>    Connection conn = null;<br>    Boolean connAutoCommit = null;<br>    PreparedStatement preparedStatement = null<br>    boolean preReadSuc = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        conn = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">XxlJobAdminConfig</span>.</span></span>get<span class="hljs-constructor">AdminConfig()</span>.get<span class="hljs-constructor">DataSource()</span>.get<span class="hljs-constructor">Connection()</span>;<br>        connAutoCommit = conn.get<span class="hljs-constructor">AutoCommit()</span>;<br>        conn.set<span class="hljs-constructor">AutoCommit(<span class="hljs-params">false</span>)</span>;<br>        <span class="hljs-comment">// 采用select for update，是排它锁。说白了xxl-job用一张数据库表来当分布式锁了，确保多个xxl-job admin节点下，依旧只能同时执行一个调度线程任务</span><br>        preparedStatement = conn.prepare<span class="hljs-constructor">Statement( <span class="hljs-string">&quot;select * from xxl_job_lock where lock_name = &#x27;schedule_lock&#x27; for update&quot;</span> )</span>;<br>        preparedStatement.execute<span class="hljs-literal">()</span>;<br>    <br>        <span class="hljs-comment">// tx start</span><br>    <br>        <span class="hljs-comment">// 1、预读数据 pre read</span><br>        long nowTime = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>;<br>        <span class="hljs-comment">// -- 从数据库中读取截止到五秒后未执行的job，并且读取preReadCount=6000条</span><br>        List&lt;XxlJobInfo&gt; scheduleList = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">XxlJobAdminConfig</span>.</span></span>get<span class="hljs-constructor">AdminConfig()</span>.get<span class="hljs-constructor">XxlJobInfoDao()</span>.schedule<span class="hljs-constructor">JobQuery(<span class="hljs-params">nowTime</span> + PRE_READ_MS, <span class="hljs-params">preReadCount</span>)</span>;<br>        <span class="hljs-keyword">if</span> (scheduleList!=null<span class="hljs-operator"> &amp;&amp; </span>scheduleList.size<span class="hljs-literal">()</span>&gt;<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 2、push压进 时间轮 push time-ring</span><br>            <span class="hljs-keyword">for</span> (XxlJobInfo jobInfo: scheduleList) &#123;<br>    <br>                <span class="hljs-comment">// time-ring jump</span><br>                <span class="hljs-keyword">if</span> (nowTime &gt; jobInfo.get<span class="hljs-constructor">TriggerNextTime()</span> + PRE_READ_MS) &#123;<br>                    <span class="hljs-comment">// 当前时间 大于 （任务的下一次触发时间 + PRE_READ_MS（5s））,可能是查询太久了，然后下面的代码刷新了任务下次执行时间，导致超过五秒，所以就需要特殊处理</span><br>                    <span class="hljs-comment">// 2.1、trigger-expire &gt; 5s：pass &amp;&amp; make next-trigger-time</span><br>                    logger.warn(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, schedule misfire, jobId = &quot;</span> + jobInfo.get<span class="hljs-constructor">Id()</span>);<br>                    <span class="hljs-comment">// 1、匹配过期失效的策略：DO_NOTHING=过期啥也不干，废弃；FIRE_ONCE_NOW=过期立即触发一次 misfire match</span><br>                    MisfireStrategyEnum misfireStrategyEnum = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MisfireStrategyEnum</span>.</span></span><span class="hljs-keyword">match</span>(jobInfo.get<span class="hljs-constructor">MisfireStrategy()</span>, MisfireStrategyEnum.DO_NOTHING);<br>                    <span class="hljs-keyword">if</span> (MisfireStrategyEnum.FIRE_ONCE_NOW<span class="hljs-operator"> == </span>misfireStrategyEnum) &#123;<br>                        <span class="hljs-comment">// FIRE_ONCE_NOW 》 trigger</span><br>                        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JobTriggerPoolHelper</span>.</span></span>trigger(jobInfo.get<span class="hljs-constructor">Id()</span>, TriggerTypeEnum.MISFIRE, -<span class="hljs-number">1</span>, null, null, null);<br>                        logger.debug(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, schedule push trigger : jobId = &quot;</span> + jobInfo.get<span class="hljs-constructor">Id()</span> );<br>                    &#125;<br>                    <span class="hljs-comment">// 2、刷新上一次触发 和 下一次待触发时间 fresh next</span><br>                    refresh<span class="hljs-constructor">NextValidTime(<span class="hljs-params">jobInfo</span>, <span class="hljs-params">new</span> Date()</span>);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nowTime &gt; jobInfo.get<span class="hljs-constructor">TriggerNextTime()</span>) &#123;<br>                    <span class="hljs-comment">// 当前时间 大于 任务的下一次触发时间 并且是没有过期的</span><br>                    <span class="hljs-comment">// 2.2、trigger-expire &lt; 5s：direct-trigger &amp;&amp; make next-trigger-time</span><br>                    <span class="hljs-comment">// 1、直接触发任务执行器 trigger</span><br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JobTriggerPoolHelper</span>.</span></span>trigger(jobInfo.get<span class="hljs-constructor">Id()</span>, TriggerTypeEnum.CRON, -<span class="hljs-number">1</span>, null, null, null);<br>                    logger.debug(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, schedule push trigger : jobId = &quot;</span> + jobInfo.get<span class="hljs-constructor">Id()</span> );<br>                    <span class="hljs-comment">// 2、刷新上一次触发 和 下一次待触发时间 fresh next</span><br>                    refresh<span class="hljs-constructor">NextValidTime(<span class="hljs-params">jobInfo</span>, <span class="hljs-params">new</span> Date()</span>);<br>    <br>                    <span class="hljs-comment">// 如果下一次触发在五秒内，直接放进时间轮里面待调度 next-trigger-time in 5s, pre-read again</span><br>                    <span class="hljs-keyword">if</span> (jobInfo.get<span class="hljs-constructor">TriggerStatus()</span>==<span class="hljs-number">1</span><span class="hljs-operator"> &amp;&amp; </span>nowTime + PRE_READ_MS &gt; jobInfo.get<span class="hljs-constructor">TriggerNextTime()</span>) &#123;<br>                        <span class="hljs-comment">// 1、求当前任务下一次触发时间所处一分钟的第N秒 make ring second</span><br>                        <span class="hljs-built_in">int</span> ringSecond = (<span class="hljs-built_in">int</span>)((jobInfo.get<span class="hljs-constructor">TriggerNextTime()</span>/<span class="hljs-number">1000</span>)%<span class="hljs-number">60</span>);<br>                        <span class="hljs-comment">// 2、将当前任务ID和ringSecond放进时间轮里面 push time ring</span><br>                        push<span class="hljs-constructor">TimeRing(<span class="hljs-params">ringSecond</span>, <span class="hljs-params">jobInfo</span>.<span class="hljs-params">getId</span>()</span>);<br>                        <span class="hljs-comment">// 3、刷新上一次触发 和 下一次待触发时间 fresh next</span><br>                        refresh<span class="hljs-constructor">NextValidTime(<span class="hljs-params">jobInfo</span>, <span class="hljs-params">new</span> Date(<span class="hljs-params">jobInfo</span>.<span class="hljs-params">getTriggerNextTime</span>()</span>));<br>                    &#125;<br>    <br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 当前时间 小于 下一次触发时间</span><br>                    <span class="hljs-comment">// 2.3、trigger-pre-read：time-ring trigger &amp;&amp; make next-trigger-time</span><br>                    <span class="hljs-comment">// 1、求当前任务下一次触发时间所处一分钟的第N秒 make ring second</span><br>                    <span class="hljs-built_in">int</span> ringSecond = (<span class="hljs-built_in">int</span>)((jobInfo.get<span class="hljs-constructor">TriggerNextTime()</span>/<span class="hljs-number">1000</span>)%<span class="hljs-number">60</span>);<br>                    <span class="hljs-comment">// 2、将当前任务ID和ringSecond放进时间轮里面 push time ring</span><br>                    push<span class="hljs-constructor">TimeRing(<span class="hljs-params">ringSecond</span>, <span class="hljs-params">jobInfo</span>.<span class="hljs-params">getId</span>()</span>);<br>                    <span class="hljs-comment">// 3、刷新上一次触发 和 下一次待触发时间 fresh next</span><br>                    refresh<span class="hljs-constructor">NextValidTime(<span class="hljs-params">jobInfo</span>, <span class="hljs-params">new</span> Date(<span class="hljs-params">jobInfo</span>.<span class="hljs-params">getTriggerNextTime</span>()</span>));<br>                &#125;<br>            &#125;<br>    <br>            <span class="hljs-comment">// 3、更新数据库执行器信息，如trigger_last_time、trigger_next_time update trigger info</span><br>            <span class="hljs-keyword">for</span> (XxlJobInfo jobInfo: scheduleList) &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">XxlJobAdminConfig</span>.</span></span>get<span class="hljs-constructor">AdminConfig()</span>.get<span class="hljs-constructor">XxlJobInfoDao()</span>.schedule<span class="hljs-constructor">Update(<span class="hljs-params">jobInfo</span>)</span>;<br>            &#125;<br>    <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            preReadSuc = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// tx stop</span><br>    &#125; catch (Exception e) &#123;<br>        <span class="hljs-keyword">if</span> (!scheduleThreadToStop) &#123;<br>            logger.error(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, JobScheduleHelper#scheduleThread error:&#123;&#125;&quot;</span>, e);<br>        &#125;<br>    &#125; finally &#123;<br>        <span class="hljs-comment">// 提交事务，释放数据库select for update的锁 commit</span><br>        .......................省略.............   <br>    &#125;<br>    long cost = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>-start;<br>    <br>    <span class="hljs-comment">// 如果执行太快了，就稍微sleep等待一下 Wait seconds, align second</span><br>    <span class="hljs-keyword">if</span> (cost &lt; <span class="hljs-number">1000</span>) &#123; <span class="hljs-comment">// scan-overtime, not wait</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// pre-read period: success &gt; scan each second; fail &gt; skip this period;</span><br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TimeUnit</span>.</span><span class="hljs-module"><span class="hljs-identifier">MILLISECONDS</span>.</span></span>sleep((preReadSuc?<span class="hljs-number">1000</span>:PRE_READ_MS) - <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span>%<span class="hljs-number">1000</span>);<br>        &#125; catch (InterruptedException e) &#123;<br>            <span class="hljs-keyword">if</span> (!scheduleThreadToStop) &#123;<br>                logger.error(e.get<span class="hljs-constructor">Message()</span>, e);<br>            &#125;<br>        &#125;<br>    &#125;);<br>    scheduleThread.set<span class="hljs-constructor">Daemon(<span class="hljs-params">true</span>)</span>;<br>    scheduleThread.set<span class="hljs-constructor">Name(<span class="hljs-string">&quot;xxl-job, admin JobScheduleHelper#scheduleThread&quot;</span>)</span>;<br>    scheduleThread.start<span class="hljs-literal">()</span>;<br><br><br>    <span class="hljs-comment">// 时间轮线程，用于取出每秒的数据，然后处理 ring thread</span><br>    ringThread = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Thread(<span class="hljs-params">new</span> Runnable()</span> &#123;<br>        @Override<br>        public void run<span class="hljs-literal">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (!ringThreadToStop) &#123;<br>                <span class="hljs-comment">// align second</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">TimeUnit</span>.</span><span class="hljs-module"><span class="hljs-identifier">MILLISECONDS</span>.</span></span>sleep(<span class="hljs-number">1000</span> - <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>current<span class="hljs-constructor">TimeMillis()</span> % <span class="hljs-number">1000</span>);<br>                &#125; catch (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">if</span> (!ringThreadToStop) &#123;<br>                        logger.error(e.get<span class="hljs-constructor">Message()</span>, e);<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// second data</span><br>                    List&lt;Integer&gt; ringItemData = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<br>                    <span class="hljs-comment">// 获取当前所处的一分钟第几秒，然后for两次，第二次是为了重跑前面一个刻度没有被执行的的job list，避免前面的刻度遗漏了</span><br>                    <span class="hljs-built_in">int</span> nowSecond = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Calendar</span>.</span></span>get<span class="hljs-constructor">Instance()</span>.get(Calendar.SECOND); <span class="hljs-comment">// 避免处理耗时太长，跨过刻度，向前校验一个刻度；</span><br>                    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>                        List&lt;Integer&gt; tmpData = ringData.remove( (nowSecond+<span class="hljs-number">60</span>-i)%<span class="hljs-number">60</span> );<br>                        <span class="hljs-keyword">if</span> (tmpData != null) &#123;<br>                            ringItemData.add<span class="hljs-constructor">All(<span class="hljs-params">tmpData</span>)</span>;<br>                        &#125;<br>                    &#125;<br>    <br>                    <span class="hljs-comment">// ring trigger</span><br>                    logger.debug(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, time-ring beat : &quot;</span> + nowSecond + <span class="hljs-string">&quot; = &quot;</span> + <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Arrays</span>.</span></span><span class="hljs-keyword">as</span><span class="hljs-constructor">List(<span class="hljs-params">ringItemData</span>)</span> );<br>                    <span class="hljs-keyword">if</span> (ringItemData.size<span class="hljs-literal">()</span> &gt; <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// do trigger</span><br>                        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> jobId: ringItemData) &#123;<br>                            <span class="hljs-comment">// 执行触发器 do trigger</span><br>                            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JobTriggerPoolHelper</span>.</span></span>trigger(jobId, TriggerTypeEnum.CRON, -<span class="hljs-number">1</span>, null, null, null);<br>                        &#125;<br>                        <span class="hljs-comment">// 清除当前刻度列表的数据 clear</span><br>                        ringItemData.clear<span class="hljs-literal">()</span>;<br>                    &#125;<br>                &#125; catch (Exception e) &#123;<br>                    <span class="hljs-keyword">if</span> (!ringThreadToStop) &#123;<br>                        logger.error(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, JobScheduleHelper#ringThread error:&#123;&#125;&quot;</span>, e);<br>                    &#125;<br>                &#125;<br>            &#125;<br>            logger.info(<span class="hljs-string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job, JobScheduleHelper#ringThread stop&quot;</span>);<br>        &#125;<br>    &#125;);<br>    ringThread.set<span class="hljs-constructor">Daemon(<span class="hljs-params">true</span>)</span>;<br>    ringThread.set<span class="hljs-constructor">Name(<span class="hljs-string">&quot;xxl-job, admin JobScheduleHelper#ringThread&quot;</span>)</span>;<br>    ringThread.start<span class="hljs-literal">()</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2></li></ul><ul><li><a href="https://juejin.cn/post/6987415823690235934">Xxl-Job调度器原理解析</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>xxl-job</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>modified subpath configmap mount fails when container restarts</title>
    <link href="/2022/09/13/k8s/modified%20subpath%20configmap%20mount%20fails%20when%20container%20restarts/"/>
    <url>/2022/09/13/k8s/modified%20subpath%20configmap%20mount%20fails%20when%20container%20restarts/</url>
    
    <content type="html"><![CDATA[<p>k8s 1.20 以下版本使用subpath会出现此问题</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://github.com/kubernetes/kubernetes/issues/68211">modified subpath configmap mount fails when container restarts</a></li><li><a href="https://www.cnblogs.com/cmt/p/14333247.html">【故障公告】K8s CofigMap 挂载问题引发网站故障</a></li><li><a href="https://github.com/moby/moby/issues/37083">docker run –mount creates a directory owned by root if directory is removed at a wrong time</a></li><li><a href="https://github.com/kubernetes/kubernetes/issues/96240">OCI runtime create failed: container_linux.go:349: starting container process caused “process_linux.go:449</a></li><li><a href="https://github.com/kubernetes/kubernetes/issues/68211">modified subpath configmap mount fails when container restarts </a></li><li><a href="https://github.com/kubernetes/kubernetes/pull/89629">Modified subpath configmap mount fails when container restarts </a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>configmap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>plantuml杂记</title>
    <link href="/2022/09/13/plantuml%E6%9D%82%E8%AE%B0/"/>
    <url>/2022/09/13/plantuml%E6%9D%82%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="活动图"><a href="#活动图" class="headerlink" title="活动图"></a>活动图</h2><p>活动图(activity diagram)是工作流的图形化表示。活动图主要由活动和动作构成，也可以支持分支选择、迭代、并行。在 UML 中，活动图主要用于为计算性和组织性过程(即工作流)建模，相关活动之间的数据流也在其覆盖范围之内。活动图主要是用来说明控制流，不过也可以显示数据在各数据存储之间的流动。</p><h3 id="示例图"><a href="#示例图" class="headerlink" title="示例图"></a>示例图</h3><p><img src="http://www.plantuml.com/plantuml/svg/PL5BRi8m4Dtx5BCa6mwGB8g4rAex12Umd1UmC7Ow7XTn-yOsZb1PPJBlepVFkoYQ9TsSAeFgzywQwmdywo3RY_QZmn4_2L4stQ1wZplD-en1sOasXsNQ1d-2IMpbiR_0N3kI2pnjX1CwHTG_IT_U5WkYhBJnC_1Ty_ZH-3vaTkPpC8YHJF32mSKigQAyiJw1vagn_lmc9ueIvZB2ZtPIgzh6GuYo2Xw8JT4YPhn698ABQAwld2-ibEh_2XwN5RZY5Qqsaru-dQghqjmOY35QXdbBr3UWdJaKbmLv2gVQtFib_RDJulfYW_f_HryJbYSamMrsMh2cRG5BWxlb9ztS7m00"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://zh.wikipedia.org/wiki/%E6%B4%BB%E5%8A%A8%E5%9B%BE">活动图</a></li><li><a href="https://plantuml.com/">plantuml</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>plantuml</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之设计原则</title>
    <link href="/2022/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <url>/2022/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>应该有且仅有一个原因引起类的变更</p><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>类的复杂性降低</li><li>可读性提高，复杂性降低</li><li>可维护性提高，可读性提高</li><li>变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否优良，但是“职责”和“变化原因”都是不可度量的，因项目而异，因环境而异。</p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li>第一种定义，也是最正宗的定义：If for each object o1 of type S there is an object o2 of type T such that for all programs P defined in terms of T,the behavior of P is unchanged when o1 is substituted for o2 then S is a subtype of T.（如果对每一个类型为S的对象o1，都有类型为T的对 象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变 化，那么类型S是类型T的子类型。）</li><li>第二种定义：Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.（所有引用基类的地方必须能透明地使用其子类的 对象。）</li></ul><p>第二个定义是最清晰明确的，通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但 是，反过来就不行了，有子类出现的地方，父类未必就能适应。</p><p>里氏替换原则为良好的继承定义了一个规范，一句简单的定义包含了4层含义。</p><ul><li>1.子类必须完全实现父类的方法</li><li>2.子类可以有自己的个性</li><li>3.覆盖或实现父类的方法时输入参数可以被放大</li><li>4.覆写或实现父类的方法时输出结果可以被缩小</li></ul><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>采用里氏替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性。即使增加子类，原有的子类还可以继续运行。在实际项目中，每个子类对应不同的业务 含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑，非常完美！</p><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.</p><p>翻译过来，包含三层含义:</p><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象</li><li>抽象不应该依赖细节</li><li>细节应该依赖抽象</li></ul><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。</p><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>设计是否具备稳定性，只要适当地“松松土”，观察“设计的蓝图”是否还可以茁壮地成长就可以得出结论，稳定性较高的设计，在周围环境频繁变化的时候，依然可以做到“我自岿然不动”。</p><h4 id="依赖的三种写法"><a href="#依赖的三种写法" class="headerlink" title="依赖的三种写法"></a>依赖的三种写法</h4><p>依赖是可以传递的，A对象依赖B对象，B又依赖C，C又依赖D……生生不息，依赖不止，记住一点：只要做到抽象依赖，即使是多层的依赖传递也无所畏惧！</p><p>对象的依赖关系有三种方式来传递</p><ul><li>1.构造函数传递依赖对象</li><li>2.Setter方法传递依赖对象</li><li>3.接口声明依赖对象</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合，我们怎么在项目中使用这个规则呢？只要遵循以下的几个规则就可以:</p><ul><li>每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备</li><li>变量的表面类型尽量是接口或者是抽象类</li><li>任何类都不应该从具体类派生</li><li>尽量不要覆写基类的方法</li><li>结合里氏替换原则使用</li></ul><p>依赖倒置原则是6个设计原则中最难以实现的原则，它是实现开闭原则的重要途径，依赖倒置原则没有实现，就别想实现对扩展开放，对修改关闭。在项目中，大家只要记住是“面向接口编程”就基本上抓住了依赖倒置原则的核心</p><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><ul><li>Clients should not be forced to depend upon interfaces that they don’t use.（客户端不应该依赖它不需要的接口。）</li><li>or The dependency of one class to another one should depend on the smallest possible interface. （类间的依赖关系应该建立在最小的接口上。）</li></ul><h4 id="接口隔离原则是对接口进行规范约束，其包含以下4层含义"><a href="#接口隔离原则是对接口进行规范约束，其包含以下4层含义" class="headerlink" title="接口隔离原则是对接口进行规范约束，其包含以下4层含义"></a>接口隔离原则是对接口进行规范约束，其包含以下4层含义</h4><ul><li>接口要尽量小</li><li>接口要高内聚<ul><li>什么是高内聚？高内聚就是提高接口、类、模块的处理能力，减少对外的交互。比如你告诉下属“到奥巴马的办公室偷一个×××文件”，然后听到下属用坚定的口吻回答你：“是，保证完成任务！”一个月后，你的下属还真的把×××文件放到你的办公桌上了，这种不讲任何条件、立刻完成任务的行为就是高内聚的表现。具体到接口隔离原则就是，要求在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越少，同时也有利于降低成本。</li></ul></li><li>定制服务</li><li>接口设计是有限度的</li></ul><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>接口隔离原则是对接口的定义，同时也是对类的定义，接口和类尽量使用原子接口或原子类来组装。但是，这个原子该怎么划分是设计模式中的一大难题，在实践中可以根据以下几个规则来衡量:</p><ul><li>一个接口只服务于一个子模块或业务逻辑</li><li>通过业务逻辑压缩接口中的public方法，接口时常去回顾，尽量让接口达到“满身筋骨肉”，而不是“肥嘟嘟”的一大堆方法</li><li>已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理</li><li>了解环境，拒绝盲从。每个项目或产品都有特定的环境因素，别看到大师是这样做的你就照抄。千万别，环境不同，接口拆分的标准就不同。深入了解业务逻辑，最好的接口设计就出自你的手中！</li></ul><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least KnowledgePrinciple，LKP），虽然名字不同，但描述的是同一个规则：一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public方法，我就调用这么多，其他的我一概不关心<br>朋友类:<br>出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类</p><h4 id="迪米特法则对类的低耦合提出了明确的要求，其包含以下4层含义"><a href="#迪米特法则对类的低耦合提出了明确的要求，其包含以下4层含义" class="headerlink" title="迪米特法则对类的低耦合提出了明确的要求，其包含以下4层含义"></a>迪米特法则对类的低耦合提出了明确的要求，其包含以下4层含义</h4><ul><li>1.只和朋友交流</li><li>2.朋友间也是有距离的</li><li>3.是自己的就是自己的</li><li>4.谨慎使用Serializable</li></ul><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p>Software entities like classes,modules and functions should be open for extension but closed for modifications.（一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。）</p><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><p>开闭原则是一个终极目标，任何人包括大师级人物都无法百分之百做到，但朝这个方向努力，可以非常显著地改善一个系统的架构，真正做到“拥抱变化”。</p><h3 id="合成复用原则"><a href="#合成复用原则" class="headerlink" title="合成复用原则"></a>合成复用原则</h3><p>原则是尽量使用合成/聚合的方式，而不是使用继承。</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li>设计模式之禅（第2版）</li><li><a href="https://java-design-patterns.com/patterns/">Java Design Patterns</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>设计原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Template method</title>
    <link href="/2022/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/TemplateMethod/"/>
    <url>/2022/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/TemplateMethod/</url>
    
    <content type="html"><![CDATA[<p>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</p><p><img src="/img/design-patterns/img_2.png"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://java-design-patterns.com/patterns/template-method/"> Template method</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Adapter</title>
    <link href="/2022/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/adapter/"/>
    <url>/2022/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/adapter/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/design-patterns/img_1.png"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://java-design-patterns.com/patterns/adapter/">adapter</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Principles</title>
    <link href="/2022/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Principles/"/>
    <url>/2022/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Principles/</url>
    
    <content type="html"><![CDATA[<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://java-design-patterns.com/principles/">principles</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>设计原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Strategy</title>
    <link href="/2022/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Strategy/"/>
    <url>/2022/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Strategy/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/design-patterns/img.png"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://java-design-patterns.com/patterns/strategy/">Strategy</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Factory Method</title>
    <link href="/2022/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/FactoryMethod/"/>
    <url>/2022/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/FactoryMethod/</url>
    
    <content type="html"><![CDATA[<p>Define an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.</p><p><img src="/img/design-patterns/img_3.png"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://java-design-patterns.com/patterns/factory-method/">Factory Method</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bean与Component同时作用同一个类</title>
    <link href="/2022/09/13/spring/%E6%B3%A8%E8%A7%A3Bean%E4%B8%8E%E6%B3%A8%E8%A7%A3Component%E5%90%8C%E6%97%B6%E4%BD%9C%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E7%B1%BB,%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7/"/>
    <url>/2022/09/13/spring/%E6%B3%A8%E8%A7%A3Bean%E4%B8%8E%E6%B3%A8%E8%A7%A3Component%E5%90%8C%E6%97%B6%E4%BD%9C%E7%94%A8%E5%90%8C%E4%B8%80%E4%B8%AA%E7%B1%BB,%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7/</url>
    
    <content type="html"><![CDATA[<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.cnblogs.com/youzhibing/p/15354706.html">关于 Spring Boot 中创建对象的疑虑 → @Bean 与 @Component 同时作用同一个类，会怎么样？ </a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring事务常见错误</title>
    <link href="/2022/09/13/spring/Spring%E4%BA%8B%E5%8A%A1%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/"/>
    <url>/2022/09/13/spring/Spring%E4%BA%8B%E5%8A%A1%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<h2 id="unchecked异常与事务回滚"><a href="#unchecked异常与事务回滚" class="headerlink" title="unchecked异常与事务回滚"></a>unchecked异常与事务回滚</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StudentMapper studentMapper;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveStudent</span><span class="hljs-params">(String realName)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        student.setRealname(realname);<br>        studentMapper.saveStudent(student);<br>        <span class="hljs-keyword">if</span> (student.getRealName().equals(<span class="hljs-string">&quot;小明&quot;</span>)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;该学生已存在&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们通过 debug 沿着 saveStudent 继续往下跟，得到了一个这样的调用栈:<br><img src="img.png"></p><p>从这个调用栈中我们看到了熟悉的 CglibAopProxy，另外事务本质上也是一种特殊的切面，在创建的过程中，被 CglibAopProxy 代理。事务处理的拦截器是TransactionInterceptor，它支撑着整个事务功能的架构，我们来分析下这个拦截器是如何实现事务特性的。</p><p>首先，TransactionInterceptor 继承类 TransactionAspectSupport，实现了接口MethodInterceptor。当执行代理类的目标方法时，会触发 invoke()。由于我们的关注重点是在异常处理上，所以直奔主题，跳到异常处理相关的部分。当它 catch 到异常时，会调用 completeTransactionAfterThrowing 方法做进一步处理。<br><img src="img_1.png"></p><p>在 completeTransactionAfterThrowing 的代码中，有这样一个方法 rollbackOn()，这是事务的回滚的关键判断条件。当这个条件满足时，会触发 rollback 操作，事务回滚。<br><img src="img_2.png"></p><p>rollbackOn() 其实包括了两个层级，具体可参考如下代码：<br><img src="img_3.png"></p><p>1.RuleBasedTransactionAttribute 自身的 rollbackOn()</p><p>当我们在 @Transactional 中配置了 rollbackFor，这个方法就会用捕获到的异常和rollbackFor 中配置的异常做比较。如果捕获到的异常是 rollbackFor 配置的异常或其子类，就会直接 rollback。在我们的案例中，由于在事务的注解中没有加任何规则，所以这段逻辑处理其实找不到规则（即 winner == null），进而走到下一步。</p><p>2.RuleBasedTransactionAttribute 父类 DefaultTransactionAttribute 的 rollbackOn()</p><p>如果没有在 @Transactional 中配置 rollback 属性，或是捕获到的异常和所配置异常的类型不一致，就会继续调用父类的 rollbackOn() 进行处理。</p><p>而在父类的 rollbackOn() 中，我们发现了一个重要的线索，只有在异常类型为RuntimeException 或者 Error 的时候才会返回 true，此时，会触发completeTransactionAfterThrowing 方法中的 rollback 操作，事务被回滚。<br><img src="img_4.png"></p><p>查到这里，真相大白，Spring 处理事务的时候，如果没有在 @Transactional 中配置rollback 属性，那么只有捕获到 RuntimeException 或者 Error 的时候才会触发回滚操作。而我们案例抛出的异常是 Exception，又没有指定与之匹配的回滚规则，所以我们不能触发回滚。</p><h2 id="试图给private方法添加事务"><a href="#试图给private方法添加事务" class="headerlink" title="试图给private方法添加事务"></a>试图给private方法添加事务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudentService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StudentMapper studentMapper;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StudentService studentService;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">saveStudent</span><span class="hljs-params">(String realName)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        student.setRealname(realName);<br>        studentService.doSaveStudent(student);<br>    &#125;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSaveStudent</span><span class="hljs-params">(Student student)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        studentMapper.saveStudent(student);<br>        <span class="hljs-keyword">if</span> (student.getRealname().equals(<span class="hljs-string">&quot;小明&quot;</span>)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;该用户已存在&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>通过debug，我们一步步寻找到了问题的根源，得到了以下调用栈。我们通过 Spring的源码来解析一下完整的过程。</p><p><img src="https://static001.geekbang.org/resource/image/d8/ce/d87ef9769456803c6d9db35c8d7503ce.png"></p><p>前一段是 Spring 创建 Bean 的过程。当 Bean 初始化之后，开始尝试代理操作，这个过程是从 AbstractAutoProxyCreator 里的 postProcessAfterInitialization 方法开始处理的：</p><p><img src="img_6.png"></p><p>我们一路往下找，暂且略过那些非关键要素的代码，直到到了 AopUtils 的 canApply 方法。这个方法就是针对切面定义里的条件，确定这个方法是否可以被应用创建成代理。其中有一段 methodMatcher.matches(method, targetClass) 是用来判断这个方法是否符合这样的条件：</p><p><img src="img_7.png"></p><p>从 matches() 调用到了 AbstractFallbackTransactionAttributeSource的getTransactionAttribute：<br><img src="img_8.png"></p><p>其中，getTransactionAttribute 这个方法是用来获取注解中的事务属性，根据属性确定事务采用什么样的策略。<br><img src="img_9.png"></p><p>接着调用到 computeTransactionAttribute 这个方法，其主要功能是根据方法和类的类型确定是否返回事务属性，执行代码如下：<br><img src="img_10.png"></p><p>这里有这样一个判断 allowPublicMethodsOnly() &amp;&amp;!Modifier.isPublic(method.getModifiers()) ，当这个判断结果为 true 的时候返回 null，也就意味着这个方法不会被代理，从而导致事务的注解不会生效。那此处的判断值到底是不是 true 呢？我们可以分别看一下。</p><h3 id="条件-1：allowPublicMethodsOnly"><a href="#条件-1：allowPublicMethodsOnly" class="headerlink" title="条件 1：allowPublicMethodsOnly()"></a>条件 1：allowPublicMethodsOnly()</h3><p>allowPublicMethodsOnly 返回了 AnnotationTransactionAttributeSource的publicMethodsOnly 属性。</p><p><img src="img_11.png"></p><blockquote><p>springframework:5.2.5.RELEASE,不同版本默认值不同</p></blockquote><p>这个publicMethodsOnly 属性是通过 AnnotationTransactionAttributeSource 的构造方法初始化的，默认为 false。</p><h3 id="条件-2：Modifier-isPublic"><a href="#条件-2：Modifier-isPublic" class="headerlink" title="条件 2：Modifier.isPublic()"></a>条件 2：Modifier.isPublic()</h3><p>这个方法根据传入的 method.getModifiers() 获取方法的修饰符。该修饰符是java.lang.reflect.Modifier 的静态属性，对应的几类修饰符分别是：PUBLIC: 1，PRIVATE: 2，PROTECTED: 4。这里面做了一个位运算，只有当传入的方法修饰符是public 类型的时候，才返回 true。<br><img src="img_12.png"></p><p>综合上述两个条件，你会发现，只有当注解为事务的方法被声明为 public 的时候，才会被Spring 处理。</p><h3 id="问题修正"><a href="#问题修正" class="headerlink" title="问题修正"></a>问题修正</h3><p>了解了问题的根源以后，解决它就变得很简单了，我们只需要把它的修饰符从 private 改成 public 就可以了。不过需要额外补充的是，我们调用这个加了事务注解的方法，必须是调用被 Spring AOP代理过的方法，也就是不能通过类的内部调用或者通过 this 的方式调用。<br>所以我们的案例的 StudentService，它含有一个自动装配（Autowired）了自身（StudentService）的实例来完成代理方法的调用。这个问题我们在之前 Spring AOP 的代码解析中重点强调过，此处就不再详述了。</p><h2 id="嵌套事务回滚错误"><a href="#嵌套事务回滚错误" class="headerlink" title="嵌套事务回滚错误"></a>嵌套事务回滚错误</h2><p>我们增加了一个新的业务类 CourseService，用于实现相关业务逻辑。分别调用了两个方法来保存学生与课程的关联关系，并给课程注册人数+1。最后，别忘了给这个方法加上事务注解。<br><img src="img_13.png"></p><p>我们在之前的 StudentService.saveStudent() 中调用了 regCourse()，实现了完整的业务逻辑。为了避免注册课程的业务异常导致学生信息无法保存，在这里 catch 了注册课程方法中抛出的异常。我们希望的结果是，当注册课程发生错误时，只回滚注册课程部分，保证学生信息依然正常。<br><img src="img_14.png"></p><p>为了验证异常是否符合预期，我们在 regCourse() 里抛出了一个注册失败的异常：<br><img src="img_15.png"></p><p>运行一下这段代码，在控制台里我们看到了以下提示信息：<br><img src="img_16.png"></p><p>运行一下这段代码，在控制台里我们看到了以下提示信息：其中，注册失败部分的异常符合预期，但是后面又多了一个这样的错误提示：Transaction rolled back because it has been marked as rollback-only。</p><p>最后的结果是，学生和选课的信息都被回滚了，显然这并不符合我们的预期。我们期待的结果是即便内部事务 regCourse() 发生异常，外部事务 saveStudent() 俘获该异常后，内部事务应自行回滚，不影响外部事务。那么这是什么原因造成的呢？我们需要研究一下Spring 的源码，来找找答案。</p><h3 id="案例解析"><a href="#案例解析" class="headerlink" title="案例解析"></a>案例解析</h3><p>在做进一步地解析之前，我们可以先通过伪代码把整个事务的结构梳理一下：<br><img src="img_17.png"><br>可以看出来，整个业务是包含了2层事务，外层的saveStudent()的事务和内层的regCourse() 事务。</p><p>在 Spring 声明式的事务处理中，有一个属性 propagation，表示打算对这些方法怎么使用事务，即一个带事务的方法调用了另一个带事务的方法，被调用的方法它怎么处理自己事务和调用方法事务之间的关系。</p><p>其中 propagation 有 7 种配置：REQUIRED、SUPPORTS、MANDATORY、REQUIRES_NEW、NOT_SUPPORTED、NEVER、NESTED。默认是 REQUIRED，它的含<br>义是：如果本来有事务，则加入该事务，如果没有事务，则创建新的事务。</p><p>结合我们的伪代码示例，因为在 saveStudent() 上声明了一个外部的事务，就已经存在一个事务了，在 propagation 值为默认的 REQUIRED 的情况下， regCourse() 就会加入到已有的事务中，两个方法共用一个事务。</p><p>我们再来看下 Spring 事务处理的核心，其关键实现参考<br>TransactionAspectSupport.invokeWithinTransaction()：<br><img src="img_18.png"><br>整个方法完成了事务的一整套处理逻辑，如下：<br>1.检查是否需要创建事务；<br>2.调用具体的业务方法进行处理；<br>3.提交事务；<br>4.处理异常。</p><p><img src="img_19.png"></p><p>这里要格外注意的是，当前案例是两个事务嵌套的场景，外层事务 doSaveStudent() 和内层事务 regCourse()，每个事务都会调用到这个方法。所以，这个方法会被调用两次。下面我们来具体来看下内层事务对异常的处理。</p><p>当捕获了异常，会调用TransactionAspectSupport.completeTransactionAfterThrowing() 进行异常处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><br># org.springframework.transaction.interceptor.TransactionAspectSupport.completeTransactionAfterThrowing<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">completeTransactionAfterThrowing</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TransactionInfo txInfo, Throwable ex)</span> &#123;<br>        <span class="hljs-keyword">if</span> (txInfo != <span class="hljs-literal">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isTraceEnabled()) &#123;<br>                <span class="hljs-built_in">this</span>.logger.trace(<span class="hljs-string">&quot;Completing transaction for [&quot;</span> + txInfo.getJoinpointIdentification() + <span class="hljs-string">&quot;] after exception: &quot;</span> + ex);<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (txInfo.transactionAttribute != <span class="hljs-literal">null</span> &amp;&amp; txInfo.transactionAttribute.rollbackOn(ex)) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    txInfo.getTransactionManager().rollback(txInfo.getTransactionStatus());<br>                &#125; <span class="hljs-keyword">catch</span> (TransactionSystemException var6) &#123;<br>                    <span class="hljs-built_in">this</span>.logger.error(<span class="hljs-string">&quot;Application exception overridden by rollback exception&quot;</span>, ex);<br>                    var6.initApplicationException(ex);<br>                    <span class="hljs-keyword">throw</span> var6;<br>                &#125; <span class="hljs-keyword">catch</span> (Error | RuntimeException var7) &#123;<br>                    <span class="hljs-built_in">this</span>.logger.error(<span class="hljs-string">&quot;Application exception overridden by rollback exception&quot;</span>, ex);<br>                    <span class="hljs-keyword">throw</span> var7;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());<br>                &#125; <span class="hljs-keyword">catch</span> (TransactionSystemException var4) &#123;<br>                    <span class="hljs-built_in">this</span>.logger.error(<span class="hljs-string">&quot;Application exception overridden by commit exception&quot;</span>, ex);<br>                    var4.initApplicationException(ex);<br>                    <span class="hljs-keyword">throw</span> var4;<br>                &#125; <span class="hljs-keyword">catch</span> (Error | RuntimeException var5) &#123;<br>                    <span class="hljs-built_in">this</span>.logger.error(<span class="hljs-string">&quot;Application exception overridden by commit exception&quot;</span>, ex);<br>                    <span class="hljs-keyword">throw</span> var5;<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>在这个方法里，我们对异常类型做了一些检查，当符合声明中的定义后，执行了具体的rollback 操作，这个操作是通过 TransactionManager.rollback() 完成的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"># org.springframework.transaction.support.AbstractPlatformTransactionManager.rollback<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">(TransactionStatus status)</span> <span class="hljs-keyword">throws</span> TransactionException &#123;<br>        <span class="hljs-keyword">if</span> (status.isCompleted()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalTransactionStateException</span>(<span class="hljs-string">&quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">DefaultTransactionStatus</span> <span class="hljs-variable">defStatus</span> <span class="hljs-operator">=</span> (DefaultTransactionStatus)status;<br>            <span class="hljs-built_in">this</span>.processRollback(defStatus, <span class="hljs-literal">false</span>);<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>而 rollback() 是在 AbstractPlatformTransactionManager 中实现的，继续调用了processRollback()：<br><img src="img_20.png"></p><p>这个方法里区分了三种不同类型的情况：<br>1.是否有保存点；<br>2.是否为一个新的事务；<br>3.是否处于一个更大的事务中。</p><p>在这里，因为我们用的是默认的传播类型 REQUIRED，嵌套的事务并没有开启一个新的事务，所以在这种情况下，当前事务是处于一个更大的事务中，所以会走到情况3分支1的代码块下。</p><p>这里有两个判断条件来确定是否设置为仅回滚：<br>if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure())</p><p>满足任何一个，都会执行 doSetRollbackOnly() 操作。isLocalRollbackOnly 在当前的情 况下是 false，所以是否分设置为仅回滚就由 isGlobalRollbackOnParticipationFailure()这个方法来决定了，其默认值为 true， 即是否回滚交由外层事务统一决定 。</p><p>显然这里的条件得到了满足，从而执行 doSetRollbackOnly：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"># org.springframework.jdbc.datasource.DataSourceTransactionManager.doSetRollbackOnly<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSetRollbackOnly</span><span class="hljs-params">(DefaultTransactionStatus status)</span> &#123;<br>        <span class="hljs-type">DataSourceTransactionObject</span> <span class="hljs-variable">txObject</span> <span class="hljs-operator">=</span> (DataSourceTransactionObject)status.getTransaction();<br>        <span class="hljs-keyword">if</span> (status.isDebug()) &#123;<br>            <span class="hljs-built_in">this</span>.logger.debug(<span class="hljs-string">&quot;Setting JDBC transaction [&quot;</span> + txObject.getConnectionHolder().getConnection() + <span class="hljs-string">&quot;] rollback-only&quot;</span>);<br>        &#125;<br><br>        txObject.setRollbackOnly();<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>以及最终调用到的 DataSourceTransactionObject 中的 setRollbackOnly()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"># org.springframework.jdbc.datasource.DataSourceTransactionManager.DataSourceTransactionObject.setRollbackOnly<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRollbackOnly</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-built_in">this</span>.getConnectionHolder().setRollbackOnly();<br>        &#125;<br></code></pre></td></tr></table></figure><p>到这一步，内层事务的操作基本执行完毕，它处理了异常，并最终调用到了DataSourceTransactionObject 中的 setRollbackOnly() 。</p><p>接下来，我们来看外层事务。因为在外层事务中，我们自己的代码捕获了内层抛出来的异常，所以这个异常不会继续往上抛，最后的事务会在 TransactionAspectSupport.invokeWithinTransaction() 中的 commitTransactionAfterReturning() 中进行处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">#org.springframework.transaction.interceptor.TransactionAspectSupport.commitTransactionAfterReturning<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commitTransactionAfterReturning</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TransactionInfo txInfo)</span> &#123;<br>        <span class="hljs-keyword">if</span> (txInfo != <span class="hljs-literal">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isTraceEnabled()) &#123;<br>                <span class="hljs-built_in">this</span>.logger.trace(<span class="hljs-string">&quot;Completing transaction for [&quot;</span> + txInfo.getJoinpointIdentification() + <span class="hljs-string">&quot;]&quot;</span>);<br>            &#125;<br><br>            txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure><p>在这个方法里我们执行了 commit 操作，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"># org.springframework.transaction.support.AbstractPlatformTransactionManager.commit<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(TransactionStatus status)</span> <span class="hljs-keyword">throws</span> TransactionException &#123;<br>        <span class="hljs-keyword">if</span> (status.isCompleted()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalTransactionStateException</span>(<span class="hljs-string">&quot;Transaction is already completed - do not call commit or rollback more than once per transaction&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">DefaultTransactionStatus</span> <span class="hljs-variable">defStatus</span> <span class="hljs-operator">=</span> (DefaultTransactionStatus)status;<br>            <span class="hljs-keyword">if</span> (defStatus.isLocalRollbackOnly()) &#123;<br>                <span class="hljs-keyword">if</span> (defStatus.isDebug()) &#123;<br>                    <span class="hljs-built_in">this</span>.logger.debug(<span class="hljs-string">&quot;Transactional code has requested rollback&quot;</span>);<br>                &#125;<br><br>                <span class="hljs-built_in">this</span>.processRollback(defStatus, <span class="hljs-literal">false</span>);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.shouldCommitOnGlobalRollbackOnly() &amp;&amp; defStatus.isGlobalRollbackOnly()) &#123;<br>                <span class="hljs-keyword">if</span> (defStatus.isDebug()) &#123;<br>                    <span class="hljs-built_in">this</span>.logger.debug(<span class="hljs-string">&quot;Global transaction is marked as rollback-only but transactional code requested commit&quot;</span>);<br>                &#125;<br><br>                <span class="hljs-built_in">this</span>.processRollback(defStatus, <span class="hljs-literal">true</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">this</span>.processCommit(defStatus);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在 AbstractPlatformTransactionManager.commit() 中，当满足了shouldCommitOnGlobalRollbackOnly() 和 defStatus.isGlobalRollbackOnly()，就会回<br>滚，否则会继续提交事务。其中 shouldCommitOnGlobalRollbackOnly() 的作用为，如果发现了事务被标记了全局回滚，并且在发生了全局回滚的情况下，判断是否应该提交事务，这个方法的默认实现是返回了 false，这里我们不需要关注它，继续查看isGlobalRollbackOnly() 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"># org.springframework.transaction.support.DefaultTransactionStatus.isGlobalRollbackOnly<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isGlobalRollbackOnly</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.transaction <span class="hljs-keyword">instanceof</span> SmartTransactionObject &amp;&amp; ((SmartTransactionObject)<span class="hljs-built_in">this</span>.transaction).isRollbackOnly();<br>    &#125;<br></code></pre></td></tr></table></figure><p>这个方法最终进入了 DataSourceTransactionObject 类中的 isRollbackOnly()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"># org.springframework.jdbc.datasource.DataSourceTransactionManager.DataSourceTransactionObject.isRollbackOnly<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isRollbackOnly</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.getConnectionHolder().isRollbackOnly();<br>        &#125;<br></code></pre></td></tr></table></figure><p>现在让我们再次回顾一下之前的内部事务处理结果，其最终调用到的是DataSourceTransactionObject 中的 setRollbackOnly()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"># org.springframework.jdbc.datasource.DataSourceTransactionManager.DataSourceTransactionObject.setRollbackOnly<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRollbackOnly</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-built_in">this</span>.getConnectionHolder().setRollbackOnly();<br>        &#125;<br></code></pre></td></tr></table></figure><p>isRollbackOnly() 和 setRollbackOnly() 这两个方法的执行本质都是对ConnectionHolder 中 rollbackOnly 属性标志位的存取，而 ConnectionHolder 则存在于 DefaultTransactionStatus 类实例的 transaction 属性之中。</p><p>至此，答案基本浮出水面了，我们把整个逻辑串在一起就是：外层事务是否回滚的关键，最终取决于 <strong>DataSourceTransactionObject 类中的 isRollbackOnly()，而该方法的返回值，正是我们在内层异常的时候设置的</strong>。</p><p>所以最终外层事务也被回滚了，从而在控制台中打印出异常信息：”Transaction rolled back because it has been marked as rollback-only”。</p><p>所以到这里，问题也就清楚了，Spring 默认的事务传播属性为 REQUIRED，如我们之前介绍的，它的含义是：如果本来有事务，则加入该事务，如果没有事务，则创建新的事务，因而内外两层事务都处于同一个事务中。所以，当我们在 regCourse() 中抛出异常，并触发了回滚操作时，这个回滚会进一步传播，从而把 saveStudent() 也回滚了。最终导致整个事务都被回滚了。</p><h3 id="问题修正-1"><a href="#问题修正-1" class="headerlink" title="问题修正"></a>问题修正</h3><p>从上述案例解析中，我们了解到，Spring 在处理事务过程中，有个默认的传播属性REQUIRED，在整个事务的调用链上，任何一个环节抛出的异常都会导致全局回滚。</p><p>知道了这个结论，修改方法也就很简单了，我们只需要对传播属性进行修改，把类型改成REQUIRES_NEW 就可以了。于是这部分代码就修改成这样：<br><img src="img_21.png"></p><p>运行一下看看：<br><img src="img_22.png"><br>异常正常抛出，注册课程部分的数据没有保存，但是学生还是正常注册成功。这意味着此时 Spring 只对注册课程这部分的数据进行了回滚，并没有传播到上一级。</p><p>这里我简单解释下这个过程：</p><ul><li>当子事务声明为 Propagation.REQUIRES_NEW 时，在TransactionAspectSupport.invokeWithinTransaction() 中调用createTransactionIfNecessary() 就会创建一个新的事务，独立于外层事务。</li><li>而在 AbstractPlatformTransactionManager.processRollback() 进行 rollback 处理时，因为 status.isNewTransaction() 会因为它处于一个新的事务中而返回 true，所以它走入到了另一个分支，执行了 doRollback() 操作，让这个子事务单独回滚，不会影响到主事务。</li></ul><p>至此，这个问题得到了很好的解决。</p><h2 id="多数据源间切换之谜"><a href="#多数据源间切换之谜" class="headerlink" title="多数据源间切换之谜"></a>多数据源间切换之谜</h2><h3 id="案例解析-1"><a href="#案例解析-1" class="headerlink" title="案例解析"></a>案例解析</h3><p>这是一个相对常见的需求，学生注册和发卡都要在一个事务里完成，但是我们都默认只会连一个数据源，之前我们一直连的都是学生信息这个数据源，在这里，我们还需要对校园卡的数据源进行操作。于是，我们需要在一个事务里完成对两个数据源的操作，该如何实现这样的功能呢？</p><p>我们继续从 Spring 的源码中寻找答案。在 Spring 里有这样一个抽象类AbstractRoutingDataSource，这个类相当于 DataSource 的路由中介，在运行时根据某种key 值来动态切换到所需的 DataSource 上。通过实现这个类就可以实现我们期望的动态数据源切换。</p><p>这里强调一下，这个类里有这么几个关键属性：</p><ul><li>targetDataSources 保存了 key 和数据库连接的映射关系；</li><li>defaultTargetDataSource 标识默认的连接；</li><li>resolvedDataSources 存储数据库标识和数据源的映射关系。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">#org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractRoutingDataSource</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractDataSource</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">private</span> Map&lt;Object, Object&gt; targetDataSources;<br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">private</span> Object defaultTargetDataSource;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">lenientFallback</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">DataSourceLookup</span> <span class="hljs-variable">dataSourceLookup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JndiDataSourceLookup</span>();<br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">private</span> Map&lt;Object, DataSource&gt; resolvedDataSources;<br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-keyword">private</span> DataSource resolvedDefaultDataSource;<br>    <span class="hljs-comment">//省略非关键代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>AbstractRoutingDataSource 实现了 InitializingBean 接口，并覆写了afterPropertiesSet()。该方法会在初始化 Bean 的时候执行，将多个 DataSource 初始化到 resolvedDataSources。这里的 targetDataSources 属性存储了将要切换的多数据源Bean 信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">#org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource.afterPropertiesSet<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.targetDataSources == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Property &#x27;targetDataSources&#x27; is required&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.resolvedDataSources = CollectionUtils.newHashMap(<span class="hljs-built_in">this</span>.targetDataSources.size());<br>            <span class="hljs-built_in">this</span>.targetDataSources.forEach((key, value) -&gt; &#123;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">lookupKey</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.resolveSpecifiedLookupKey(key);<br>                <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.resolveSpecifiedDataSource(value);<br>                <span class="hljs-built_in">this</span>.resolvedDataSources.put(lookupKey, dataSource);<br>            &#125;);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.defaultTargetDataSource != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-built_in">this</span>.resolvedDefaultDataSource = <span class="hljs-built_in">this</span>.resolveSpecifiedDataSource(<span class="hljs-built_in">this</span>.defaultTargetDataSource);<br>            &#125;<br><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>获取数据库连接的是 getConnection()，它调用了 determineTargetDataSource() 来创建连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"># org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource.getConnection()<br><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.determineTargetDataSource().getConnection();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">(String username, String password)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.determineTargetDataSource().getConnection(username, password);<br>    &#125;<br></code></pre></td></tr></table></figure><p>determineTargetDataSource() 是整个部分的核心，它的作用就是动态切换数据源。有多少个数据源，就存多少个数据源在 targetDataSources 中。</p><p>targetDataSources 是一个 Map 类型的属性，key 表示每个数据源的名字，value 对应的是每个数据源 DataSource。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">#org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource.determineTargetDataSource<br>    <span class="hljs-keyword">protected</span> DataSource <span class="hljs-title function_">determineTargetDataSource</span><span class="hljs-params">()</span> &#123;<br>        Assert.notNull(<span class="hljs-built_in">this</span>.resolvedDataSources, <span class="hljs-string">&quot;DataSource router not initialized&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">lookupKey</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.determineCurrentLookupKey();<br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> (DataSource)<span class="hljs-built_in">this</span>.resolvedDataSources.get(lookupKey);<br>        <span class="hljs-keyword">if</span> (dataSource == <span class="hljs-literal">null</span> &amp;&amp; (<span class="hljs-built_in">this</span>.lenientFallback || lookupKey == <span class="hljs-literal">null</span>)) &#123;<br>            dataSource = <span class="hljs-built_in">this</span>.resolvedDefaultDataSource;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (dataSource == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Cannot determine target DataSource for lookup key [&quot;</span> + lookupKey + <span class="hljs-string">&quot;]&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> dataSource;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>而选择哪个数据源又是由 determineCurrentLookupKey() 来决定的，此方法是抽象方法，需要我们继承 AbstractRoutingDataSource 抽象类来重写此方法。该方法返回一个key，该 key 是 Bean 中的 beanName，并赋值给 lookupKey，由此 key 可以通过resolvedDataSources 属性的键来获取对应的 DataSource 值，从而达到数据源切换的效果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Object <span class="hljs-title function_">determineCurrentLookupKey</span><span class="hljs-params">()</span>;<br><br></code></pre></td></tr></table></figure><p>这样看来，这个方法的实现就得由我们完成了。接下来我们将会完成一系列相关的代码，解决这个问题。</p><h3 id="问题修正-2"><a href="#问题修正-2" class="headerlink" title="问题修正"></a>问题修正</h3><p>首先，我们创建一个 MyDataSource 类，继承了 AbstractRoutingDataSource，并覆写了 determineCurrentLookupKey()：<br><img src="img_23.png"></p><p>其次，我们需要修改 JdbcConfig。这里我新写了一个 dataSource，将原来的dataSource 改成 dataSourceCore，再将新定义的 dataSourceCore 和 dataSourceCard放进一个 Map，对应的 key 分别是 core 和 card，并把 Map 赋值给setTargetDataSources</p><p><img src="img_24.png"><br><img src="img_25.png"></p><p>最后还剩下一个问题，setDataSource 这个方法什么时候执行呢？</p><p>我们可以用 Spring AOP 来设置，把配置的数据源类型都设置成注解标签， Service 层中在切换数据源的方法上加上注解标签，就会调用相应的方法切换数据源。</p><p>我们定义了一个新的注解 @DataSource，可以直接加在 Service() 上，实现数据库切换：<br><img src="img_26.png"></p><p>声明方法如下：<br><img src="img_27.png"></p><p>另外，我们还需要写一个 Spring AOP 来对相应的服务方法进行拦截，完成数据源的切换操作。特别要注意的是，这里要加上一个 @Order(1) 标记它的初始化顺序。这个 Order值一定要比事务的 AOP 切面的值小，这样可以获得更高的优先级，否则自动切换数据源将会失效。<br><img src="img_28.png"></p><p>最后，我们实现了 Card 的发卡逻辑，在方法前声明了切换数据库：<br><img src="img_29.png"></p><p>并在 saveStudent() 里调用了发卡逻辑：<br><img src="img_30.png"></p><p>执行一下，一切正常，两个库的数据都可以正常保存了。<br>最后我们来看一下整个过程的调用栈，重新过一遍流程（这里我略去了不重要的部分）。<br>在创建了事务以后，会通过 DataSourceTransactionManager.doBegin() 获取相应的数据库连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBegin</span><span class="hljs-params">(Object transaction, TransactionDefinition definition)</span> &#123;<br>    <span class="hljs-type">DataSourceTransactionObject</span> <span class="hljs-variable">txObject</span> <span class="hljs-operator">=</span> (DataSourceTransactionObject)transaction;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">con</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (!txObject.hasConnectionHolder() || txObject.getConnectionHolder().isSynchronizedWithTransaction()) &#123;<br>            <span class="hljs-type">Connection</span> <span class="hljs-variable">newCon</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.obtainDataSource().getConnection();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isDebugEnabled()) &#123;<br>                <span class="hljs-built_in">this</span>.logger.debug(<span class="hljs-string">&quot;Acquired Connection [&quot;</span> + newCon + <span class="hljs-string">&quot;] for JDBC transaction&quot;</span>);<br>            &#125;<br><br>            txObject.setConnectionHolder(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectionHolder</span>(newCon), <span class="hljs-literal">true</span>);<br>        &#125;<br>        <span class="hljs-comment">//省略非关键代码</span><br>        &#125;<br>    <br>    &#125;<br></code></pre></td></tr></table></figure><p>这里的 obtainDataSource().getConnection() 调用到了AbstractRoutingDataSource.getConnection()，这就与我们实现的功能顺利会师了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.determineTargetDataSource().getConnection();<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="http://90.84.47.13/188-Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B%EF%BC%88%E5%AE%8C%E7%BB%93%EF%BC%89/04-Spring%E8%A1%A5%E5%85%85%E7%AF%87%287%E8%AE%B2%29/19%E4%B8%A8Spring%E4%BA%8B%E5%8A%A1%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%EF%BC%88%E4%B8%8A%EF%BC%89.html">19 | Spring 事务常见错误（上）</a></li><li><a href="http://90.84.47.13/188-Spring%E7%BC%96%E7%A8%8B%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF50%E4%BE%8B%EF%BC%88%E5%AE%8C%E7%BB%93%EF%BC%89/04-Spring%E8%A1%A5%E5%85%85%E7%AF%87%287%E8%AE%B2%29/20%E4%B8%A8Spring%E4%BA%8B%E5%8A%A1%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%EF%BC%88%E4%B8%8B%EF%BC%89.html">20 | Spring 事务常见错误（下）</a></li><li><a href="https://github.com/baymax55/springissue">code</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Use Kali Linux NetHunter on Android</title>
    <link href="/2022/09/13/other/Kali-Linux-NetHunter-Android-install-in-5-minutes/"/>
    <url>/2022/09/13/other/Kali-Linux-NetHunter-Android-install-in-5-minutes/</url>
    
    <content type="html"><![CDATA[<h1 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h1><ol><li>A Physical Android Phone. You can do this install on an Android 12 phone,but a phone running on a version before Android 12 is recommended. See the link to the article below on GitHub on how Android monitors and kills forked child processes of apps when they use too much of the CPU. <a href="https://github.com/termux/terethutmux-app/issues/2366">https://github.com/termux/terethutmux-app/issues/2366</a></li></ol><ol><li>You will need to install Termux. You can get Termux from the F-Droid store or from their<br>GitHub repo using one of the following links (In the demo we use GitHub):<ul><li><a href="https://f-droid.org/packages/com.termux/">https://f-droid.org/packages/com.termux/</a></li><li><a href="https://github.com/termux/termux-app/releases">https://github.com/termux/termux-app/releases</a><br>Take note that the official Termux Wiki and TermuxGitHub pages indicates that you<br>should not install the outdated version hosted on the Google Play Store.</li></ul></li><li>Download the latest Termux version at the time of writing it is termux-app_v0.118.0+github-debug_arm64-v8a.apk from the github link above.</li></ol><ol start="3"><li>Open and Install the downloaded APK file. Press on Install and then Open.</li></ol><h2 id="apt-update-and-apt-upgrade"><a href="#apt-update-and-apt-upgrade" class="headerlink" title="apt update and apt upgrade"></a>apt update and apt upgrade</h2><p>Debian Linux and many of its derivatives use <strong>APT (Advanced Package Tool)</strong> to install tools. We need to run <strong>apt update</strong> to get the package source information from the configured resources in the <strong>/etc/apt/sources.list</strong> file. This is how the system knows which files needs to be updated and where they can be downloaded from.</p><p><strong>apt upgrade</strong> will then use the information to upgrade all the installed packages to their latest versions.</p><ol start="4"><li>Enter the following command: apt update</li></ol><ol start="5"><li>Enter the following command: apt upgrade</li></ol><ol start="6"><li>When you get asked to “Do you want to continue” press Y and Enter.</li></ol><ol start="7"><li>When prompted for an action press <strong>Y</strong> and <strong><Enter></strong> so you install the package maintainer’s version.</li></ol><ol start="8"><li>Enter the following command:<br>You want to do this, so you get the <strong>wget</strong> package information.</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">apt update</span><br></code></pre></td></tr></table></figure><ol start="9"><li>Install wget and when you’re asked Do you want to continue, press Y and Enter.</li></ol><p>apt install wget</p><ol start="10"><li>When you get asked to “Do you want to continue” press Y and Enter.</li></ol><ol start="11"><li>Download the NetHunter install file.</li></ol><p>wget -O install-nethunter-termux <a href="https://offs.ec/2MceZWr">https://offs.ec/2MceZWr</a><br><img src="11.png"><br>12. Change the permissions so that you can execute the file:</p><p>chmod +x install-nethunter-termux<br><img src="12.png"></p><ol start="13"><li>Type the following command to execute the downloaded install file:</li></ol><p>./install-nethunter-termux<br><img src="13.png"></p><ol start="14"><li><p>The installation will take a while, when asked to delete rootfs, enter N.</p></li><li><p>To start Kali NetHunter you can use the following commands:</p><ul><li>To start the CLI :nethunter</li><li>To setup the NetHunter KeX password :nethunter kex passwd</li><li>To start NetHunter KeX (Password will ve set on first startup) :nethunter kex</li><li>To stop the NetHunter KeX GUI :nethunter kex stop</li><li>To run NetHunter as root : nethunter -r</li><li>You replace nethunter with nh in all these commands. :nh<br><img src="15.png"></li></ul></li><li><p>Once you run nh you are now in the Kali NetHunter CLI.</p></li></ol><ol start="17"><li>You can exit the NetHunter CLI by entering exit.</li></ol><ol start="18"><li>Set the password for KeX VNC by running nh kex for the first time. You’ll use the password again in Step 26 so remember it.</li></ol><ol start="19"><li>Remember the port number. You will use it in Step 26.</li></ol><ol start="20"><li>Set the password for KeX VNC by running nh kex for the first time. Say no to entering a view-only password.</li></ol><ol start="21"><li>Go to the Kali NetHunter App Store website: <a href="https://store.nethunter.com/en/">https://store.nethunter.com/en/</a></li></ol><ol start="22"><li>Download the NetHunter App Store.</li></ol><ol start="23"><li>Press on the Hamburger button of your browser, go to downloads and install NetHunterStore.apk</li></ol><ol start="24"><li>Press on the search button and enter KeX. Press to download NetHunter KeX.</li></ol><ol start="25"><li>Press on the search button and enter KeX. Press to download and install KeX.</li></ol><ol start="26"><li>You will get a popup window. You click on Settings, and then toggle Allow from this source. Then press Install.</li></ol><ol start="27"><li>Press on Allow to allow NetHunterKeX access to your files on the device.</li></ol><ol start="28"><li>Enter the port number from step 19, username as kali, and your password from step 14. Press on Connect.</li></ol><ol start="29"><li>You now should have Rootless Kali NetHunter GUI on your Android Phone!</li></ol><h2 id="Using-the-SSH-server"><a href="#Using-the-SSH-server" class="headerlink" title="Using the SSH server"></a>Using the SSH server</h2><p>in termux</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">pkg update<br>pkg upgrade<br>pkg install openssh<br>sshd # start openssh server<br>passwd # set password<br><br>netstat # get sshd port number<br><br>ssh -p 8022 192.168.5.115 # connect in terminal<br></code></pre></td></tr></table></figure><p><img src="end.png"></p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul><li><a href="https://www.youtube.com/watch?v=KxOGyuGq0Ts">Kali Linux NetHunter Android install in 5 minutes (rootless)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>android</tag>
      
      <tag>kail</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>以windows服务的方式运行FRP</title>
    <link href="/2022/09/13/network/%E4%BB%A5windows%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%90%E8%A1%8CFRP/"/>
    <url>/2022/09/13/network/%E4%BB%A5windows%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%90%E8%A1%8CFRP/</url>
    
    <content type="html"><![CDATA[<p>前几天看见有人在frp提<a href="https://github.com/fatedier/frp/issues/1901">工单</a>问是否可以支持windows服务,正好有解决类似问题的经验，于是给作者提了一个PR，不过作者表示：</p><ol><li> 类似脚本打算放到专门的仓库中维护</li><li> 那个专门仓库目前无人维护</li></ol><p>那就是没法了，只能记在自己的小本子上了。</p><p>效果演示</p><p><img src="1.png"></p><h2 id="English"><a href="#English" class="headerlink" title="English:"></a>English:</h2><h2 id="Run-frp-as-Windows-service"><a href="#Run-frp-as-Windows-service" class="headerlink" title="Run frp as Windows service"></a><a href="#Run-frp-as-Windows-service" title="Run frp as Windows service"></a>Run <code>frp</code> as Windows service</h2><ol><li> Download <a href="https://github.com/winsw/winsw/releases">winsw</a> Rename it to <code>frpc-service.exe</code> or <code>frps-service.exe</code> .</li><li> Put <code>frpc-service.xml</code> and <code>frpc-service.xml</code> to same directory as <code>frpc-service.exe</code> or <code>frps-service.exe</code>  .</li><li> Default location of frp is <code>C:\frp</code>, you can edit the xml config file.</li></ol><p>install service</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">for</span> frp client</span>  <br>frpc-service.exe install   <br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">for</span> frp server</span>  <br>frps-service.exe install <br></code></pre></td></tr></table></figure><blockquote><p>You will see frp service in windows service manager</p></blockquote><p>uninstall service</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">for</span> frp client</span>  <br>frpc-service.exe uninstall   <br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">for</span> frp server</span>  <br>frps-service.exe uninstall  <br></code></pre></td></tr></table></figure><h2 id="中文"><a href="#中文" class="headerlink" title="中文:"></a>中文:</h2><h2 id="以Windows服务的方式运行frp"><a href="#以Windows服务的方式运行frp" class="headerlink" title="以Windows服务的方式运行frp"></a><a href="#%E4%BB%A5Windows%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%90%E8%A1%8Cfrp" title="以Windows服务的方式运行frp"></a>以Windows服务的方式运行<code>frp</code></h2><ol><li> 下载<a href="https://github.com/winsw/winsw/releases">winsw</a>然后将其分别重命名为两个文件: <code>frpc-service.exe</code> 或 <code>frps-service.exe</code> .</li><li> 将<code>frpc-service.xml</code> 和 <code>frpc-service.xml</code> 放到 <code>frpc-service.exe</code> 或 <code>frps-service.exe</code>  相同的目录下.</li><li> 默认的frp安装目录是 <code>C:\frp</code>, 你可以在xml配置文件中修改。</li></ol><p>创建服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">for</span> frp client</span>  <br>frpc-service.exe install   <br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">for</span> frp server</span>  <br>frps-service.exe install  <br></code></pre></td></tr></table></figure><blockquote><p>服务创建后你在Windows的服务管理器里面就能看见frp服务了</p></blockquote><p>服务卸载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">for</span> frp client</span>  <br>frpc-service.exe uninstall   <br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-keyword">for</span> frp server</span>  <br>frps-service.exe uninstall  <br></code></pre></td></tr></table></figure><h2 id="脚本-scripts"><a href="#脚本-scripts" class="headerlink" title="脚本(scripts)"></a><a href="#%E8%84%9A%E6%9C%AC-scripts" title="脚本(scripts)"></a>脚本(scripts)</h2><h3 id="frps-service-xml"><a href="#frps-service-xml" class="headerlink" title="frps-service.xml"></a><a href="#frps-service-xml" title="frps-service.xml"></a>frps-service.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">service</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- ID of the service. It should be unique across the Windows system--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>frpc<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Display name of the service --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>frp client <span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Service description --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>service for frp client<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- frp install dir --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">workingdirectory</span>&gt;</span>C:\frp<span class="hljs-tag">&lt;/<span class="hljs-name">workingdirectory</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- frpc.exe --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">executable</span>&gt;</span>C:\frp\frpc.exe<span class="hljs-tag">&lt;/<span class="hljs-name">executable</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- args --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">startarguments</span>&gt;</span>-c frpc.ini<span class="hljs-tag">&lt;/<span class="hljs-name">startarguments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">priority</span>&gt;</span>High<span class="hljs-tag">&lt;/<span class="hljs-name">priority</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">startmode</span>&gt;</span>Automatic<span class="hljs-tag">&lt;/<span class="hljs-name">startmode</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="frps-service-xml-1"><a href="#frps-service-xml-1" class="headerlink" title="frps-service.xml"></a><a href="#frps-service-xml-1" title="frps-service.xml"></a>frps-service.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">service</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- ID of the service. It should be unique across the Windows system--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>frps<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Display name of the service --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>frp server <span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Service description --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>service for frp server<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- frp install dir --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">workingdirectory</span>&gt;</span>C:\frp<span class="hljs-tag">&lt;/<span class="hljs-name">workingdirectory</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- frpc.exe --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">executable</span>&gt;</span>C:\frp\frps.exe<span class="hljs-tag">&lt;/<span class="hljs-name">executable</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- args --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">startarguments</span>&gt;</span>-c frps.ini<span class="hljs-tag">&lt;/<span class="hljs-name">startarguments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">priority</span>&gt;</span>High<span class="hljs-tag">&lt;/<span class="hljs-name">priority</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">startmode</span>&gt;</span>Automatic<span class="hljs-tag">&lt;/<span class="hljs-name">startmode</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="screenshot"><a href="#screenshot" class="headerlink" title="screenshot"></a><a href="#screenshot" title="screenshot"></a>screenshot</h2><p>frp install dir</p><p><img src="2.png"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="http://note.eta.pub/2020/07/21/frp-windows-service/">以windows服务的方式运行FRP</a></li><li><a href="https://github.com/winsw/winsw/releases">winsw</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>frp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Network</title>
    <link href="/2022/09/13/network/network/"/>
    <url>/2022/09/13/network/network/</url>
    
    <content type="html"><![CDATA[<h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li><a href="https://github.com/bregman-arie/devops-exercises#Network">Network</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在黑群晖内安装虚拟机</title>
    <link href="/2022/09/13/nas/%E9%BB%91%E7%BE%A4%E6%99%96%E5%86%85%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/2022/09/13/nas/%E9%BB%91%E7%BE%A4%E6%99%96%E5%86%85%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>主要是安装 Virtual Machine Manager,在套件中心直接搜索安装即可</p><h2 id="安装注意点"><a href="#安装注意点" class="headerlink" title="安装注意点"></a>安装注意点</h2><ul><li>nas 内存至少4g+</li><li>磁盘格式必须为btrfs</li><li>貌似不需要安装官方映像文件,后续直接下载对于镜像进行安装即可</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://post.smzdm.com/p/apz37e79/">群晖中用VMM（Virtual Machine Manager）再虚拟安装一台群晖保姆教程</a></li><li><a href="https://archive.synology.com/download/Os/DSM">官方映像文件</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nas</tag>
      
      <tag>群晖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黑群晖系统安装</title>
    <link href="/2022/09/13/nas/%E9%BB%91%E7%BE%A4%E6%99%96%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/"/>
    <url>/2022/09/13/nas/%E9%BB%91%E7%BE%A4%E6%99%96%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>使用u盘作为引导盘,后续要一直插着,拔掉后会无法进行系统</p><ol><li>插入u盘,打开rufus软件,待识别u盘后,选择img镜像文件成功写入u盘</li><li>将u盘插入闲置主机,启动电脑并调试bios第一启动项为U盘</li><li>待出现如下图后,在另一设备操作<br><img src="1.png"></li><li>在浏览器打开 闲置主机的ip:5000 等待响应 </li><li>按浏览器提示操作即可,中间会提示选择系统,安装.pat文件即可</li></ol><h3 id="安装注意点"><a href="#安装注意点" class="headerlink" title="安装注意点"></a>安装注意点</h3><ol><li>我这边使用u盘作为引导盘,使用ssd作为引导时会报错(Failed to format the disk. (35))</li><li>修改bios设置第一启动项为u盘启动(否则每次手动选择启动项很烦)</li><li>安装其他群晖系统时无法进入系统,我这边只能适合ds3617_6.1版本</li><li>一定要设置u盘为默认的第一启动项(即电脑开机后默认选择u盘进入),否则系统安装完,需要重启,会出现无法进行系统问题</li></ol><h3 id="其他nas系统"><a href="#其他nas系统" class="headerlink" title="其他nas系统"></a>其他nas系统</h3><ol><li>TrueNAS</li><li>Unraid</li></ol><h3 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h3><p>用到的工具及系统文件下载地址:<br><a href="https://pan.baidu.com/share/init?surl=EqJ8s2YedADjV9zCX_LwRQ">https://pan.baidu.com/share/init?surl=EqJ8s2YedADjV9zCX_LwRQ</a><br>提取码: ifb5</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://post.smzdm.com/p/aqx07xmk/">文菌装NAS 篇五：手把手教您安装黑群晖918+ 6.2保姆级教程，这应该是装黑群晖NAS最详细的教程了，含群晖设置</a></li><li><a href="https://new.qq.com/omn/20210129/20210129A0C4S900.html">如何通过bios设置u盘启动项实现U盘启动</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nas</tag>
      
      <tag>群晖</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>虚拟机安装OpenWrt软路由</title>
    <link href="/2022/09/13/nas/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85OpenWrt%E8%BD%AF%E8%B7%AF%E7%94%B1/"/>
    <url>/2022/09/13/nas/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85OpenWrt%E8%BD%AF%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<p>虚拟机安装OpenWrt软路由,并实现局域网内所以设备自动科学上网,广告过滤等</p><h2 id="安装注意点"><a href="#安装注意点" class="headerlink" title="安装注意点"></a>安装注意点</h2><ul><li>安装后的OpenWrt需要手动设置ip地址</li></ul><h2 id="使局域网设备自动科学上网方式"><a href="#使局域网设备自动科学上网方式" class="headerlink" title="使局域网设备自动科学上网方式"></a>使局域网设备自动科学上网方式</h2><p>设置网口网关地址和dns为软路由ip<br><img src="1.png"></p><p>忽略该接口,并保存并应用<br><img src="2.png"></p><p>情况说明:我有俩个路由器,一级路由器负责拨号，二级路由器挂在一级路由器下面设置为固定ip范围获取,主要工作路由为二级路由</p><p>由于软路由处于在一级路由下，二级路由和软路由位于同一层，因此我设置二级路由的WAN口连接类型为固定ip获取,并将网关和dns设置为软路由IP.自此,我直接连上二级路由实现自动科学上网<br><img src="3.png"></p><h2 id="OpenWrt-开启openClash-服务后，WireGuard无法接收流量问题"><a href="#OpenWrt-开启openClash-服务后，WireGuard无法接收流量问题" class="headerlink" title="OpenWrt 开启openClash 服务后，WireGuard无法接收流量问题"></a>OpenWrt 开启openClash 服务后，WireGuard无法接收流量问题</h2><p>openClash-&gt; 全局设置-&gt; 模式设置 -&gt; 实验性：绕过中国大陆IP 功能 启用<br><strong>我的WireGuard server ip 为国内</strong>,可能被代理了<br><img src="4.png"></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://post.smzdm.com/p/a5dn78pl/">群晖虚拟机安装 Openwrt 做旁路由的设置教程</a></li><li><a href="https://openwrt.club/dl">OpenWrt固件下载</a></li><li><a href="https://www.youtube.com/watch?v=OCF8KgoctfU">OpenWrt设置旁路由</a></li><li><a href="https://supes.top/">下载或定制适用于您设备的OpenWrt固件</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>折腾</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OpenWrt</tag>
      
      <tag>设置旁路由</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树,平衡二叉树,B-Tree,B+Tree</title>
    <link href="/2022/09/13/mysql/%E4%BA%8C%E5%8F%89%E6%A0%91,%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91,B-Tree,B+Tree/"/>
    <url>/2022/09/13/mysql/%E4%BA%8C%E5%8F%89%E6%A0%91,%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91,B-Tree,B+Tree/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>一般说MySQL的索引，都清楚其索引主要以B+树为主，此外还有Hash、RTree、FullText。本文简要说明一下MySQL的B+Tree索引，以及和其相关的二叉树、平衡二叉树、B-Tree</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="二叉查找树（BST）"><a href="#二叉查找树（BST）" class="headerlink" title="二叉查找树（BST）"></a>二叉查找树（BST）</h3><ul><li><p><strong>概念</strong><br>二叉查找树是基于二分查找法来提高数据查找速度的二叉树的数据结构；关于二分查找法的时间复杂度可以看 <a href="https://juejin.im/entry/6844903481191432206">时间复杂度 O(log n) 意味着什么？</a>。</p></li><li><p><strong>特点</strong><br>二叉查找树是采用二分查找法把数据按规则组装成一个树形结构的数据，减少无关数据的检索，提升了数据检索的速度；二叉树的数据结构有以下规则：</p><p>1.非叶子节点只能允许最多两个子节点存在。<br>2.每一个非叶子节点数据分布规则为左边的子节点小当前节点的值，右边的子节点大于当前节点的值；<br>即二叉查找树的特点就是任何节点的左子节点的键值都小于当前节点的键值，右子节点的键值都大于当前节点的键值。 顶端的节点称为根节点，没有子节点的节点我们称之为叶节点。以下图中的圆为二叉查找树的节点，<strong>节点中存储了键(key)和数据(<br>data)</strong><br><img src="1.png"></p><p>查找结点值的方法就是二分查找法：查找次数就是树的高度。二叉查找树可以任意地构造 如果向一方倾斜的二叉树是不平衡的，查询效率就低了，二叉查找树变成了一个链表。如下图：</p><p><img src="2.png"><br>在上面的2张图中，查找键值为17的数据，第一张图里需要3次IO，第2张图里需要7次IO。原因是二叉查找树变得不平衡了，也就是高度太高了，从而导致查找效率的不稳定。为了解决这个问题，需要保证二叉查找树一直保持平衡，就需要用到平衡二叉树了。</p></li></ul><h3 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h3><p>在满足二叉查找树特性的基础上，如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。 类似于：</p><p><img src="3.png"></p><p>关于平衡二叉树的可以看 <a href="https://zhuanlan.zhihu.com/p/56066942">什么是平衡二叉树（AVL）</a> 该文章说明，平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。 <strong>需要注意的是平衡二叉树是每个节点只存储一个键值和数据的。</strong></p><h3 id="B树-B-Tree"><a href="#B树-B-Tree" class="headerlink" title="B树(B-Tree)"></a>B树(B-Tree)</h3><ul><li><p><strong>概念</strong><br>B树和平衡二叉树不同，B树属于多叉树又名<strong>平衡多路查找树</strong>（查找路径不只两个），数据库索引里大量使用者B-Tree和B+Tree的数据结构。</p></li><li><p><strong>特点</strong></p><p>1.方式：所有节点关键字是按递增次序排列，并遵循左小右大原则；</p><p>2.子节点数：非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2，空树除外（注：M阶代表一个树节点最多有多少个查找路径，M=M路，当M=2则是2叉树,M=3则是3叉）；</p><p>3.关键字数：枝节点的关键字数量大于等于ceil(M/2)-1个且小于等于M-1个（注：ceil()是个朝正无穷方向取整的函数 如ceil(1.1)结果为2);</p><p>4.所有叶子节点均在同一层、叶子节点除了包含了关键字还包含了数据;</p><p>最后我们用一个图和一个实际的例子来理解B树（这里为了理解方便我就直接用实际字母的大小来排列C&gt;B&gt;A）</p><p><img src="4.png"><br>图中可以看到BTree的单个节点可以存储多个键值和数据的平衡树。和平衡二叉树相比：<br>比如要存储海量的数据，因为（平衡）<strong>二叉树的每个节点只存储一个键值和数据的</strong>，二叉树的节点将会非常多，高度也会及其高，当查找数据时也会进行很多次磁盘IO，查找的效率将会极低，大致的二叉树结构如下：<br><img src="5.png"><br>为了解决平衡二叉树的这个弊端，需要一种<strong>单个节点可以存储多个键值和数据的平衡树（BTree）</strong>：<br><img src="6.png"><br>从上图可以看出，<strong>B树相对于平衡二叉树，每个节点存储了更多的键值(key)和数据(data)，并且每个节点拥有更多的子节点</strong>，子节点的个数一般称为阶，上述图中的B树为3阶B树，高度也会很低。<br>基于这个特性，B树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。</p><p>假如我们要查找id=28的用户信息，那么我们在上图B树中查找的流程如下：</p><ol><li>先找到根节点也就是页1，判断28在键值17和35之间，我们那么我们根据页1中的指针p2找到页3。</li><li>将28和页3中的键值相比较，28在26和30之间，我们根据页3中的指针p2找到页8。</li><li>将28和页8中的键值相比较，发现有匹配的键值28，键值28对应的用户信息为(28,bv)。</li></ol><p><strong>区别:</strong><br>B树相对于平衡二叉树的不同是：每个节点包含的关键字增多了，特别是在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度。<br><strong>相同数量的key在B-Tree中生成的节点要远远少于二叉树中的节点，相差的节点数量就等同于磁盘IO的次数。这样到达一定数量后，性能的差异就显现出来了。</strong></p></li></ul><h3 id="B-树（B-Tree）"><a href="#B-树（B-Tree）" class="headerlink" title="B+树（B+Tree）"></a>B+树（B+Tree）</h3><ul><li><p><strong>概念</strong><br>B+树是B树的一个进化，相对于B树来说B+树更充分的利用了节点的空间，让查询速度更加稳定，其速度完全接近于二分法查找。结构如下：<br><img src="7.png"><br>为什么说B+树查找的效率要比B树更高、更稳定；我们先看看两者的区别：</p><p>（1）<strong>B+树的非叶子节点不保存数据，只进行数据索引（</strong>关键字记录的指针<strong>），这样使得B+树每个非叶子节点所能保存的关键字大大增加；</strong></p><p>（2）<strong>B+树叶子节点保存了父节点的所有关键字记录的指针，所有数据地址必须要到叶子节点才能获取到。所以每次数据查询的次数都一样；</strong></p><p>（3）<strong>B+树叶子节点的关键字从小到大有序排列，左边结尾数据都会保存右边节点开始数据的指针；</strong></p><p>（4）<strong>B+树非叶子节点的子节点数=关键字数;</strong></p></li><li><p><strong>特点</strong></p><p>1、B+树的层级更少：相较于B树，B+每个非叶子节点存储的关键字数更多，树的层级更少所以查询数据更快；</p><p>2、B+树查询速度更稳定：B+所有关键字数据地址都存在叶子节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</p><p>3、B+树天然具备排序功能：B+树所有的叶子节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</p><p>4、B+树全节点遍历更快：B+树遍历整棵树只需要遍历所有的叶子节点即可，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</p><p>B树相对于B+树的优点是：如果经常访问的数据离根节点很近，而B树的非叶子节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比B+树快。</p></li></ul><p><strong>根据上图我们来看下B+树和B树有什么不同：</strong>  </p><ol><li><p><strong>B+Tree 非叶子节点上是不存储数据的，仅存储键值，数据存储在同一层的叶节点，而B-Tree节点中不仅存储键值，也会存储数据</strong>。之所以这么做是因为在数据库中页的大小是固定的，innodb中页的默认大小是16KB。如果不存储数据，那么就会存储更多的键值，相应的树的阶数(节点的子节点树)就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。另外，B+Tree的阶数是等于键值的数量的，如果B+Tree一个节点可以存储1000个键值，那么3层B+树可以存储1000×1000×1000=10亿个数据。一般根节点是常驻内存的，所以一般我们查找10亿数据，只需要2次磁盘IO**。  </p></li><li><p>因为B+Tree索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而B-Tree 因为数据分散在各个节点，要实现这一点是很不容易的。</p><p> B+Tree 中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。</p><p> 其实上面的B-Tree也可以对各个节点加上链表。其实这些不是它们之前的区别，是因为在mysql的innodb存储引擎中，索引就是这样存储的。也就是说上图中的B+Tree索引就是innodb中B+Tree索引真正的实现方式，准确的说应该是聚集索引。</p><p> 通过上图可以看到，<strong>在innodb中，数据页之间通过双向链表连接以及叶子节点中数据之间通过单向链表连接的方式可以找到表中所有的数据。</strong></p><p> 注意：MyISAM中的B+树索引实现与innodb中的略有不同。在MyISAM中，B+树索引的叶子节点并不存储数据，而是存储数据的文件地址。 </p></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>B+Tree 结构是从二叉查找树，平衡二叉树和B-Tree这三种数据结构演化来的，他们之前的区别上面已经介绍过，现在大致的总结下，如下：</p><ul><li><p>1.二叉查找树是基于二分查找法来提高数据查找速度的二叉树的数据结构，减少无关数据的检索，提升了数据检索的速度。非叶子节点只能允许最多两个子节点存在，每一个非叶子节点数据分布规则为左边的子节点小当前节点的值，右边的子节点大于当前节点的值，<strong>每个节点只存储一个键值和数据的。</strong></p></li><li><p>2.平衡二叉树满足二叉查找树特性的基础上，如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。</p></li><li><p>3.B-TreeB和平衡二叉树不同，B-Tree属于多叉树又名<strong>平衡多路查找树，</strong> <strong><strong>B-Tree相对于平衡二叉树，每个节点存储了更多的键值(key)和数据(data)，并且每个节点拥有更多的子节点。</strong></strong></p></li><li><p>4.B+Tree和B-Tree不同，<strong>B+Tree在非叶子节点上，不保存数据，只存储键指针</strong>，能存储更多的键值，相应的树的阶数(节点的子节点树)就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数有会再次减少，数据查询的效率也会更快。并且B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。那么B+Tree使得范围查找，排序查找，分组查找以及去重查找变得异常简单。</p></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.cnblogs.com/zhoujinyi/p/13900554.html">二叉树、平衡二叉树、B-Tree、B+Tree 说明</a></li><li><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualizations</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>B+Tree</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql分库分表方案</title>
    <link href="/2022/09/13/mysql/mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%88/"/>
    <url>/2022/09/13/mysql/mysql%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://shardingsphere.apache.org/">ShardingSphere</a></li><li><a href="https://github.com/baymax55/sharding-jdbc-example">sharding-jdbc-example</a></li><li><a href="https://bbs.huaweicloud.com/blogs/323521">ShardingSphere(1)—主从篇</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>ShardingSphere</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tldr命令</title>
    <link href="/2022/09/13/linux/tldr/"/>
    <url>/2022/09/13/linux/tldr/</url>
    
    <content type="html"><![CDATA[<p>The tldr pages are a community effort to simplify the beloved man pages with practical examples.</p><h2 id="类似命令"><a href="#类似命令" class="headerlink" title="类似命令"></a>类似命令</h2><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><h3 id="cheat"><a href="#cheat" class="headerlink" title="cheat"></a>cheat</h3><p>Linux cheat 命令是一个实用程序，可以用来搜索和显示你想要使用的命令的使用示例</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://tldr.sh/">tldr</a></li><li><a href="https://linux.cn/article-14961-1.html">“作弊”：只需要知道这一个 Linux 命令就够了</a></li><li><a href="https://github.com/cheat/cheat">cheat</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux command</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rabbitMQ实现延迟消息队列</title>
    <link href="/2022/09/13/mq/rabbitMQ%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <url>/2022/09/13/mq/rabbitMQ%E5%AE%9E%E7%8E%B0%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h3 id="延迟消息实现的两种方式"><a href="#延迟消息实现的两种方式" class="headerlink" title="延迟消息实现的两种方式"></a>延迟消息实现的两种方式</h3><ul><li>通过Rabbitmq本身队列的特性来实现，需要使用Rabbitmq的死信交换机（Exchange）和消息的存活时间TTL</li><li>通过插件（rabbitmq-delayed-message-exchange）来实现</li></ul><h3 id="消息的TTL"><a href="#消息的TTL" class="headerlink" title="消息的TTL"></a>消息的TTL</h3><p>RabbitMQ可以针对Queue和Message设置 x-message-tt，来控制消息的生存时间，如果超时，则消息变为dead letter</p><h4 id="针对队列的过期时间"><a href="#针对队列的过期时间" class="headerlink" title="针对队列的过期时间"></a>针对队列的过期时间</h4><p>通过队列属性设置，队列中所有消息都有相同的过期时间。</p><h4 id="针对消息的过期时间"><a href="#针对消息的过期时间" class="headerlink" title="针对消息的过期时间"></a>针对消息的过期时间</h4><p>对消息进行单独设置，每条消息TTL可以不同。</p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>如果同时使用，则消息的过期时间以两者之间TTL较小的那个数值为准。消息在队列的生存时间一旦超过设置的TTL值，就成为dead letter</p><h3 id="DLX-Dead-Letter-Exchange"><a href="#DLX-Dead-Letter-Exchange" class="headerlink" title="DLX (Dead-Letter-Exchange)"></a>DLX (Dead-Letter-Exchange)</h3><p>Queue可以配置x-dead-letter-exchange 和x-dead-letter-routing-key（可选）两个参数，如果队列内出现了dead letter，则按照这两个参数重新路由</p><p>x-dead-letter-exchange: 出现dead letter之后将dead letter重新发送到指定exchange<br>x-dead-letter-routing-key:指定routing-key发送</p><h3 id="队列出现dead-letter的情况"><a href="#队列出现dead-letter的情况" class="headerlink" title="队列出现dead letter的情况"></a>队列出现dead letter的情况</h3><ul><li>消息或者队列的TTL过期</li><li>队列达到最大长度</li><li>消息被消费端拒绝（basic.reject or basic.nack）并且requeue=false</li></ul><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><ul><li><a href="https://cloud.tencent.com/developer/article/1877502">rabbitmq 怎么实现延迟消息队列？</a></li><li>RabbitMQ实战指南</li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rabbitmq</tag>
      
      <tag>延迟队列</tag>
      
      <tag>mq</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k3s安装与部署</title>
    <link href="/2022/09/13/k8s/k3s%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/"/>
    <url>/2022/09/13/k8s/k3s%E5%AE%89%E8%A3%85%E4%B8%8E%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>k3s是经过CNCF认证的由Rancher公司开发维护的一个轻量级的 Kubernetes 发行版，内核机制还是和 k8s 一样，但是剔除了很多外部依赖以及 K8s 的 alpha、beta 特性，同时改变了部署方式和运行方式，目的是轻量化 K8s，简单来说，K3s 就是阉割版 K8s，消耗资源极少。它主要用于边缘计算、物联网等场景。</p><h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><h3 id="k3s安装Dashboard无法外面访问时-修改kubernetes-dashboard-svc-type-为NodePort"><a href="#k3s安装Dashboard无法外面访问时-修改kubernetes-dashboard-svc-type-为NodePort" class="headerlink" title="k3s安装Dashboard无法外面访问时,修改kubernetes-dashboard svc type 为NodePort"></a>k3s安装Dashboard无法外面访问时,修改kubernetes-dashboard svc type 为NodePort</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">creationTimestamp:</span> <span class="hljs-string">&quot;2022-08-22T03:45:00Z&quot;</span><br>  <span class="hljs-attr">labels:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">kubernetes-dashboard</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">kubernetes-dashboard</span><br>  <span class="hljs-attr">namespace:</span> <span class="hljs-string">kubernetes-dashboard</span><br>  <span class="hljs-attr">resourceVersion:</span> <span class="hljs-string">&quot;12356&quot;</span><br>  <span class="hljs-attr">uid:</span> <span class="hljs-string">2b77a6f5-97fe-4f04-beac-a4503db1b402</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">clusterIP:</span> <span class="hljs-number">10.43</span><span class="hljs-number">.217</span><span class="hljs-number">.53</span><br>  <span class="hljs-attr">clusterIPs:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">10.43</span><span class="hljs-number">.217</span><span class="hljs-number">.53</span><br>  <span class="hljs-attr">externalTrafficPolicy:</span> <span class="hljs-string">Cluster</span><br>  <span class="hljs-attr">internalTrafficPolicy:</span> <span class="hljs-string">Cluster</span><br>  <span class="hljs-attr">ipFamilies:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">IPv4</span><br>  <span class="hljs-attr">ipFamilyPolicy:</span> <span class="hljs-string">SingleStack</span><br>  <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">nodePort:</span> <span class="hljs-number">30619</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">443</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span><br>      <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8443</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">k8s-app:</span> <span class="hljs-string">kubernetes-dashboard</span><br>  <span class="hljs-attr">sessionAffinity:</span> <span class="hljs-string">None</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span><br><span class="hljs-attr">status:</span><br>  <span class="hljs-attr">loadBalancer:</span> &#123;&#125; <br></code></pre></td></tr></table></figure><h3 id="Kubernetes-cluster-unreachable-with-helm-3-0"><a href="#Kubernetes-cluster-unreachable-with-helm-3-0" class="headerlink" title="Kubernetes cluster unreachable with helm 3.0"></a>Kubernetes cluster unreachable with helm 3.0</h3><p>Try setting the KUBECONFIG environment variable.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">export KUBECONFIG=/etc/rancher/k3s/k3s.yaml<br></code></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.cnblogs.com/hujinzhong/p/15014487.html">k3s安装与部署</a></li><li><a href="https://docs.rancher.cn/docs/k3s/installation/install-options/_index#%E4%BD%BF%E7%94%A8%E8%84%9A%E6%9C%AC%E5%AE%89%E8%A3%85%E7%9A%84%E9%80%89%E9%A1%B9">使用脚本安装的选项</a></li><li><a href="https://rancher.com/docs/k3s/latest/en/installation/kube-dashboard/">k3s install Kubernetes Dashboard</a></li><li><a href="https://opensource.com/article/20/5/helm-charts">How to make a Helm chart in 10 minutes</a></li><li><a href="https://github.com/ohmyzsh/ohmyzsh/blob/master/plugins/kubectl/README.md">ohmyzsh/plugins/kubectl/README.md</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>How to fix OOMKilled Kubernetes error</title>
    <link href="/2022/09/13/k8s/how-to-fix-OOMKilled-kubernetes-error/"/>
    <url>/2022/09/13/k8s/how-to-fix-OOMKilled-kubernetes-error/</url>
    
    <content type="html"><![CDATA[<h2 id="What-is-OOMKilled-exit-code-137"><a href="#What-is-OOMKilled-exit-code-137" class="headerlink" title="What is OOMKilled (exit code 137)"></a>What is OOMKilled (exit code 137)</h2><p>The <code>OOMKilled</code> error, also indicated by exit code 137, means that a container or pod was terminated because they used more memory than allowed. OOM stands for “Out Of Memory”.</p><p>Kubernetes allows pods to limit the resources their containers are allowed to utilize on the host machine. A pod can specify a <strong>memory limit</strong> – the maximum amount of memory the container is allowed to use, and a <strong>memory request</strong> – the minimum memory the container is expected to use.</p><p>If a container uses more memory than its memory limit, it is terminated with an <code>OOMKilled</code> status. Similarly, if overall memory usage on all containers, or all pods on the node, exceeds the defined limit, one or more pods may be terminated.</p><p>You can identify the error by running the <code>kubectl get pods command</code>—the pod status will appear as <code>Terminating</code>.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">NAME</span>        <span class="hljs-string">READY</span>    <span class="hljs-string">STATUS</span>       <span class="hljs-string">RESTARTS</span>    <span class="hljs-string">AGE</span><br><span class="hljs-string">my-pod-1</span>    <span class="hljs-number">0</span><span class="hljs-string">/1</span>      <span class="hljs-string">OOMKilled</span>    <span class="hljs-number">0</span>           <span class="hljs-string">3m12s</span><br></code></pre></td></tr></table></figure><p>We’ll provide a general process for identifying and resolving <code>OOMKilled</code>. More complex cases will require advanced diagnosis and troubleshooting, which is beyond the scope of this article.</p><h2 id="How-Does-the-OOM-Killer-Mechanism-Work"><a href="#How-Does-the-OOM-Killer-Mechanism-Work" class="headerlink" title="How Does the OOM Killer Mechanism Work?"></a>How Does the OOM Killer Mechanism Work?</h2><p><code>OOMKilled</code> is actually not native to Kubernetes—it is a feature of the Linux Kernel, known as the <code>OOM Killer</code>, which Kubernetes uses to manage container lifecycles. The <code>OOM Killer</code> mechanism monitors node memory and selects processes that are taking up too much memory, and should be killed. It is important to realize that <code>OOM Killer</code> may kill a process even if there is free memory on the node.</p><p>The Linux kernel maintains an <code>oom_score</code> for each process running on the host. The higher this score, the greater the chance that the process will be killed. Another value, called <code>oom_score_adj</code>, allows users to customize the OOM process and define when processes should be terminated.</p><p>Kubernetes uses the <code>oom_score_adj</code> value when defining a Quality of Service (QoS) class for a pod. There are three QoS classes that may be assigned to a pod:</p><ul><li>  Guaranteed</li><li>  Burstable</li><li>  BestEffort</li></ul><p>Each QoS class has a matching value for <code>oom_score_adj</code>:</p><table><thead><tr><th>Quality of Service</th><th>oom_score_adj</th></tr></thead><tbody><tr><td>Guaranteed</td><td>-997</td></tr><tr><td>BestEffort</td><td>1000</td></tr><tr><td>Burstable</td><td>min(max(2, 1000—(1000 * memoryRequestBytes) / machineMemoryCapacityBytes), 999)</td></tr></tbody></table><p>Because “Guaranteed” pods have a lower value, they are the last to be killed on a node that is running out of memory. “BestEffort” pods are the first to be killed.</p><p>A pod that is killed due to a memory issue is not necessarily evicted from a node—if the restart policy on the node is set to “Always”, it will try to restart the pod.</p><p>To see the QoS class of a pod, run the following command:</p><p><code>Kubectl get pod -o jsonpath=’&#123;.status.qosClass&#125;’</code></p><p>To see the <code>oom_score</code> of a pod:</p><ol><li> Run <code>kubectl exec -it /bin/bash</code></li><li> To see the <code>oom_score</code>, run <code>cat/proc//oom_score</code></li><li> To see the <code>oom_score_adj</code>, <code>run cat/proc//oom_score_adj</code></li></ol><p>The pod with the lowest <code>oom_score</code> is the first to be killed when the node runs out of memory.</p><h2 id="OOMKilled-Common-Causes"><a href="#OOMKilled-Common-Causes" class="headerlink" title="OOMKilled: Common Causes"></a>OOMKilled: Common Causes</h2><p>The following table shows the common causes of this error and how to resolve it. However, note there are many more causes of OOMKilled errors, and many cases are difficult to diagnose and troubleshoot.</p><table><thead><tr><th>Cause</th><th>Resolution</th></tr></thead><tbody><tr><td>Container memory limit was reached, and the application is experiencing higher load than normal</td><td>Increase memory limit in pod specifications</td></tr><tr><td>Container memory limit was reached, and application is experiencing a memory leak</td><td>Debug the application and resolve the memory leak</td></tr><tr><td>Node is overcommitted—this means the total memory used by pods is greater than node memory</td><td>Adjust memory requests (minimal threshold) and memory limits (maximal threshold) in your containers</td></tr></tbody></table><h2 id="OOMKilled-Diagnosis-and-Resolution"><a href="#OOMKilled-Diagnosis-and-Resolution" class="headerlink" title="OOMKilled: Diagnosis and Resolution"></a>OOMKilled: Diagnosis and Resolution</h2><h3 id="Step-1-Gather-Information"><a href="#Step-1-Gather-Information" class="headerlink" title="Step 1: Gather Information"></a>Step 1: Gather Information</h3><p>Run <code>kubectl describe pod [name]</code> and save the content to a text file for future reference:</p><p><code>kubectl describe pod [name] /tmp/troubleshooting_describe_pod.txt</code></p><h3 id="Step-2-Check-Pod-Events-Output-for-Exit-Code-137"><a href="#Step-2-Check-Pod-Events-Output-for-Exit-Code-137" class="headerlink" title="Step 2: Check Pod Events Output for Exit Code 137"></a>Step 2: Check Pod Events Output for Exit Code 137</h3><p>Check the Events section of the describe pod text file, and look for the following message:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">State:</span>          <span class="hljs-string">Running</span><br>       <span class="hljs-attr">Started:</span>      <span class="hljs-string">Thu,</span> <span class="hljs-number">10</span> <span class="hljs-string">Oct</span> <span class="hljs-number">2019 11:14:13</span> <span class="hljs-string">+0200</span><br>       <span class="hljs-attr">Last State:</span>   <span class="hljs-string">Terminated</span><br>       <span class="hljs-attr">Reason:</span>       <span class="hljs-string">OOMKilled</span><br>       <span class="hljs-attr">Exit Code:</span>    <span class="hljs-number">137</span><br>       <span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>Exit code 137 indicates that the container was terminated due to an out of memory issue. Now look through the events in the pod’s recent history, and try to determine what caused the <code>OOMKilled</code> error:</p><ul><li>  The pod was terminated because a container limit was reached.</li><li>  The pod was terminated because the node was “overcommitted”—pods were scheduled to the node that, put together, request more memory than is available on the node.</li></ul><h3 id="Step-3-Troubleshooting"><a href="#Step-3-Troubleshooting" class="headerlink" title="Step 3: Troubleshooting"></a>Step 3: Troubleshooting</h3><p>If the pod was terminated because <strong>container limit was reached</strong>:</p><ul><li>  Determine if your application really needs more memory. For example, if the application is a website that is experiencing additional load, it may need more memory than originally specified. In this case, to resolve the error, increase the memory limit for the container in the pod specification.</li><li>  If memory use suddenly increases, and does not seem to be related to application loads, the application may be experiencing a memory leak. Debug the application and resolve the memory leak. In this case you should not increase the memory limit, because this will cause the application to use up too many resources on the nodes.</li></ul><p>If the pod was terminated because of <strong>overcommit on the node</strong>:</p><ul><li>  Overcommit on a node can occur because pods are allowed to schedule on a node if their memory requests value—the minimal memory value—is less than the memory available on the node.</li><li>  For example, Kubernetes may run 10 containers with a memory request value of 1 GB on a node with 10 GB memory. However, if these containers have a memory limit of 1.5 GB, some of the pods may use more than the minimum memory, and then the node will run out of memory and need to kill some of the pods.</li><li>  You need to determine why Kubernetes decided to terminate the pod with the <code>OOMKilled</code> error, and adjust memory requests and limit values to ensure that the node is not overcommitted.</li></ul><p>When adjusting memory requests and limits, keep in mind that when a node is overcommitted, Kubernetes kills nodes according to the following priority order:</p><ol><li> Pods that do not have requests or limits</li><li> Pods that have requests, but not limits</li><li> Pods that are using more than their memory request value—minimal memory specified—but under their memory limit</li><li> Pods that are using more than their memory limit</li></ol><p>To fully diagnose and resolve Kubernetes memory issues, you’ll need to monitor your environment, understand the memory behavior of pods and containers compared to the limits, and fine tune your settings. This can be a complex, unwieldy process without the right tooling.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://komodor.com/learn/how-to-fix-oomkilled-exit-code-137/">How to fix OOMKilled Kubernetes error (exit code 137)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>OOMKilled</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes网络模型的基础知识</title>
    <link href="/2022/09/13/k8s/Kubernetes%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2022/09/13/k8s/Kubernetes%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>Kubernetes 是为运行分布式集群而建立的，分布式系统的本质使得网络成为 Kubernetes 的核心和必要组成部分，了解 Kubernetes 网络模型可以使你能够正确运行、监控和排查应用程序故障。</p><p>网络所涉及的内容很多，拥有许多成熟的技术。对于不熟悉的人来说可能会非常痛苦，因为大多数人对网络都有先入为主的观念，并且有很多新旧概念需要理解并组合成一个连贯的整体。所说的网络可能包括网络命名空间、虚拟接口、IP 转发和网络地址转换等技术。本指南旨在通过讨论每种 Kubernetes 相关技术以及如何使用这些技术来启用 Kubernetes 网络模型的描述来揭开 Kubernetes 网络的神秘面纱。</p><p>本指南相当长，分为几个部分。我们首先讨论一些基本的 Kubernetes 术语，以确保在整个指南中正确使用术语，然后讨论 Kubernetes 网络模型以及它强加的设计和实施决策。接下来是本指南中最长且最有趣的部分：</p><p>深入讨论如何使用几个不同的用例展示在Kubernetes内是如何进行通信的。</p><p>文章大纲如下：<br><img src="./%E6%96%87%E7%AB%A0%E5%A4%A7%E7%BA%B2.png"></p><h2 id="1、Kubernetes基础知识"><a href="#1、Kubernetes基础知识" class="headerlink" title="1、Kubernetes基础知识"></a>1、Kubernetes基础知识</h2><p>Kubernetes 由几个核心概念构建而成，这些概念组合成越来越强大的功能。本节列出了这些概念中的每一个，并提供了一个简短的概述，以帮助促进讨论。Kubernetes 的内容远不止此，这里仅仅简要阐述一些基础知识。如果您已经熟悉 Kubernetes，请随意跳过本节。</p><h3 id="1-1、Kubernetes-API-server"><a href="#1-1、Kubernetes-API-server" class="headerlink" title="1.1、Kubernetes API server"></a>1.1、Kubernetes API server</h3><p>在 Kubernetes 中，一切都是由 Kubernetes API 服务器（kube-apiserver）提供的 API 调用。API 服务器是 etcd 数据存储的网关，它维护应用程序集群的所需状态。要更新 Kubernetes 集群的状态，您可以对描述所需状态的 API 服务器进行 API 调用。</p><h3 id="1-2、Controllers"><a href="#1-2、Controllers" class="headerlink" title="1.2、Controllers"></a>1.2、Controllers</h3><p>控制器是用于构建 Kubernetes 的核心抽象。一旦您使用 API 服务器声明了集群的所需状态，控制器就会通过持续观察 API 服务器的状态并对任何更改做出反应来确保集群的当前状态与所需状态相匹配。控制器内部实现了一个循环，该循环不断检查集群的当前状态与集群的期望状态。如果有任何差异，控制器将执行任务以使当前状态与所需状态匹配。在伪代码中：</p><p><img src="1.2%E4%BC%AA%E4%BB%A3%E7%A0%81.png"></p><p>例如，当您使用 API 服务器创建新 Pod 时，Kubernetes 调度程序（控制器）会注意到更改并决定将 Pod 放置在集群中的哪个位置。然后它使用 API 服务器（由 etcd 支持）写入状态更改。kubelet（一个控制器）然后会注意到新的变化并设置所需的网络功能以使 Pod 在集群内可访问。在这里，两个独立的控制器对两个独立的状态变化做出反应，以使集群的现实与用户的意图相匹配。</p><h3 id="1-3、Pods"><a href="#1-3、Pods" class="headerlink" title="1.3、Pods"></a>1.3、Pods</h3><p>Pod 是 Kubernetes 的原子——用于构建应用程序的最小可部署对象。单个 Pod 代表集群中正在运行的工作负载，并封装了一个或多个 Docker 容器、任何所需的存储和唯一的 IP 地址，组成 pod 的容器被设计为在同一台机器上共同定位和调度。</p><h3 id="1-4、Nodes"><a href="#1-4、Nodes" class="headerlink" title="1.4、Nodes"></a>1.4、Nodes</h3><p>节点是运行 Kubernetes 集群的机器。这些可以是裸机、虚拟机或其他任何东西。主机一词通常与节点互换使用。我将尝试一致地使用术语节点，但有时会根据上下文使用虚拟机这个词来指代节点。</p><h2 id="2、Kubernetes网络模型"><a href="#2、Kubernetes网络模型" class="headerlink" title="2、Kubernetes网络模型"></a>2、Kubernetes网络模型</h2><p>Kubernetes 对 Pod 的联网方式做出了自以为是的选择。特别是，Kubernetes 对任何网络实现都规定了以下要求：</p><ul><li>所有 Pod 都可以在不使用网络地址转换 (NAT) 的情况下与所有其他 Pod 通信。</li><li>所有节点都可以在没有 NAT 的情况下与所有 Pod 通信。</li><li>Pod 认为自己的 IP 与其他人认为的 IP 相同。</li></ul><p>鉴于这些限制，我们需要解决四个不同的网络问题：</p><ul><li>容器到容器网络</li><li>Pod 到 Pod 网络</li><li>Pod 到服务网络</li><li>Internet 到服务网络</li></ul><p>本指南的其余部分将讨论这些问题中的每一个 以及他们的解决方案。</p><h2 id="3、容器和容器之间网络通信"><a href="#3、容器和容器之间网络通信" class="headerlink" title="3、容器和容器之间网络通信"></a>3、容器和容器之间网络通信</h2><p>通常，我们将虚拟机中的网络通信视为直接与以太网设备交互，如图 1 所示。<br><img src="3.1.png"></p><p>实际上，情况比这更微妙。在 Linux 中，每个正在运行的进程都在一个网络命名空间内进行通信，该命名空间为逻辑网络堆栈提供了自己的路由、防火墙规则和网络设备。本质上，网络命名空间为命名空间内的所有进程提供了一个全新的网络堆栈。作为 Linux 用户，可以使用 ip 命令创建网络命名空间。例如，以下命令将创建一个名为 ns1 的新网络命名空间。<br><img src="3.2.png"></p><p>创建命名空间时，会在 /var/run/netns 下为其创建一个挂载点，即使没有附加任何进程，命名空间也可以保留。<br>您可以通过列出 /var/run/netns 下的所有挂载点或使用 ip 命令来列出可用的命名空间。<br><img src="3.3.png"></p><p>默认情况下，Linux 将每个进程分配给根网络命名空间以提供对外部世界的访问，如图 2 所示。<br><img src="3.4.png"></p><p>就 Docker 结构而言，Pod 被建模为一组共享网络命名空间的 Docker 容器。Pod 中的容器都具有相同的 IP 地址和端口空间，这些 IP 地址和端口空间是通过分配给 Pod 的网络命名空间分配的，并且可以通过 localhost 找到彼此，因为它们位于同一个命名空间中。我们可以为虚拟机上的每个 Pod 创建一个网络命名空间。这是使用 Docker 作为“Pod 容器”实现的，它保持网络命名空间打开，而“应用容器”（用户指定的东西）通过 Docker 的 –net=container: 函数加入该命名空间。图 3 显示了每个 Pod 如何由共享命名空间内的多个 Docker 容器 (ctr*) 组成。<br><img src="3.5.png"></p><p>Pod 中的应用程序还可以访问共享卷，这些卷被定义为 Pod 的一部分，并且可以挂载到每个应用程序的文件系统中。</p><h2 id="4、Pod和Pod之间网络通信"><a href="#4、Pod和Pod之间网络通信" class="headerlink" title="4、Pod和Pod之间网络通信"></a>4、Pod和Pod之间网络通信</h2><p>在 Kubernetes 中，每个 Pod 都有一个真实的 IP 地址，并且每个 Pod 都使用该 IP 地址与其他 Pod 通信。现在任务是了解 Kubernetes 如何使用真实 IP 实现 Pod 到 Pod 的通信，无论 Pod 部署在集群中的同一个物理节点还是不同的节点上。我们通过考虑驻留在同一台机器上的 Pod 来开始这个讨论，以避免通过内部网络跨节点通信的复杂性。</p><p>从 Pod 的角度来看，它存在于自己的以太网命名空间中，需要与同一节点上的其他网络命名空间进行通信。值得庆幸的是，可以使用 Linux 虚拟以太网设备或由两个虚拟接口组成的 veth 对连接命名空间，这些虚拟接口可以分布在多个命名空间上。要连接 Pod 命名空间，我们可以将 veth 对的一侧分配给根网络命名空间，将另一侧分配给 Pod 的网络命名空间。每对 veth 对的工作方式就像一根跳线，连接两侧并允许流量在它们之间流动。这个设置可以复制到机器上的尽可能多的 Pod。图 4 显示了将 VM 上的每个 Pod 连接到根命名空间的 veth 对。<br><img src="4.1.png"></p><p>此时，我们已将 Pod 设置为每个都有自己的网络命名空间，以便它们相信自己拥有自己的以太网设备和 IP 地址，并且它们连接到节点的根命名空间。现在，我们希望 Pod 通过根命名空间相互通信，为此我们使用网桥。</p><p>Linux 以太网网桥是一个虚拟的第 2 层网络设备，用于联合两个或多个网段，透明地工作以将两个网络连接在一起。网桥通过检查通过它的数据包的目的地并决定是否将数据包传递到连接到网桥的其他网段来维护源和目标之间的转发表来运行。桥接代码通过查看网络中每个以太网设备的唯一 MAC 地址来决定是桥接数据还是丢弃数据。</p><p>网桥实现 ARP 协议以发现与给定 IP 地址关联的链路层 MAC 地址。当网桥接收到数据帧时，网桥将帧广播到所有连接的设备（原始发送者除外），响应该帧的设备存储在查找表中。具有相同 IP 地址的未来流量使用查找表来发现将数据包转发到的正确 MAC 地址。<br><img src="4.2.png"><br>图5. 使用桥接连接网络</p><h3 id="4-1、同节点Pod通信"><a href="#4-1、同节点Pod通信" class="headerlink" title="4.1、同节点Pod通信"></a>4.1、同节点Pod通信</h3><p>给定将每个 Pod 与自己的网络堆栈隔离的网络命名空间、将每个命名空间连接到根命名空间的虚拟以太网设备以及将命名空间连接在一起的网桥，我们终于准备好在同一节点上的 Pod 之间进行通信。这如图 6 所示。<br><img src="https://images.elecfans.top/uploads/20220719/3fc2516c-076d-11ed-ba43-dac502259ad0.gif"></p><p>在图 6 中，Pod 1 将数据包发送到它自己的以太网设备 eth0，该设备可用作 Pod 的默认设备。对于 Pod 1，eth0 通过虚拟以太网设备连接到根命名空间 veth0 (1)。网桥 cbr0 配置有 veth0 连接到它的网段。一旦数据包到达网桥，网桥会解析正确的网段以使用 ARP 协议将数据包发送到 veth1 (3)。当数据包到达虚拟设备 veth1 时，它被直接转发到 Pod 2 的命名空间和该命名空间内的 eth0 设备 (4)。在整个流量流中，每个 Pod 仅与 localhost 上的 eth0 通信，并且流量被路由到正确的 Pod。使用网络的开发体验是开发人员所期望的默认行为。</p><p>Kubernetes 的网络模型规定 Pod 必须可以通过其 IP 地址跨节点访问。也就是说，一个 Pod 的 IP 地址始终对网络中的其他 Pod 可见，每个 Pod 看待自己的 IP 地址的方式与其他 Pod 看待它的方式相同。我们现在转向不同节点上的 Pod 之间如何进行通信的问题。</p><h3 id="4-2、跨节点Pod通信"><a href="#4-2、跨节点Pod通信" class="headerlink" title="4.2、跨节点Pod通信"></a>4.2、跨节点Pod通信</h3><p>在研究了如何在同一节点上的 Pod 之间如何进行通信之后，我们继续研究在不同节点上的 Pod 如何进行通信。Kubernetes 网络模型要求 Pod IP 可以通过网络访问，但它没有指定必须如何完成。</p><p>通常，集群中的每个节点都分配有一个 CIDR 块，指定该节点上运行的 Pod 可用的 IP 地址。一旦流向 CIDR 块的流量到达节点，节点就有责任将流量转发到正确的 Pod。图 7 说明了两个节点之间的流量流，假设网络可以将 CIDR 块中的流量路由到正确的节点。<br><img src="https://images.elecfans.top/uploads/20220719/3fd4d332-076d-11ed-ba43-dac502259ad0.gif"></p><p>图 7 以与图 6 相同的请求开始，但这次，目标 Pod（以绿色突出显示）与源 Pod（以蓝色突出显示）位于不同的节点上。数据包首先通过 Pod 1 的以太网设备发送，该设备与根命名空间 (1) 中的虚拟以太网设备配对。最终，数据包最终到达根命名空间的网桥 (2)。ARP 将在网桥上失败，因为没有设备连接到网桥并具有正确的数据包 MAC 地址。失败时，网桥将数据包发送到默认路由——根命名空间的 eth0 设备。此时路由离开节点并进入网络 (3)。我们现在假设网络可以根据分配给节点的 CIDR 块将数据包路由到正确的节点 (4)。数据包进入目标节点的根命名空间（VM 2 上的 eth0），在那里它通过网桥路由到正确的虚拟以太网设备 (5)。最后，路由通过位于 Pod 4 的命名空间 (6) 中的虚拟以太网设备对来完成。一般来说，每个节点都知道如何将数据包传递给在其中运行的 Pod。一旦数据包到达目标节点，数据包的流动方式与在同一节点上的 Pod 之间路由流量的方式相同。</p><p>我们轻松地避开了如何配置网络以将 Pod IP 的流量转发到负责这些 IP 的正确节点。这是特定于网络的，但查看特定示例将提供对所涉及问题的一些见解。例如，借助 AWS，Amazon 为 Kubernetes 维护了一个容器网络插件，允许节点到节点网络使用 [容器网络接口 (CNI) 插件] (<a href="https://github.com/aws/amazon">https://github.com/aws/amazon</a>) 在 Amazon VPC 环境中运行-vpc-cni-k8s）。</p><p>容器网络接口 (CNI) 提供了一个通用 API，用于将容器连接到外部网络。作为开发人员，我们想知道 Pod 可以使用 IP 地址与网络通信，并且我们希望此操作的机制是透明的。AWS 开发的 CNI 插件试图满足这些需求，同时通过 AWS 提供的现有 VPC、IAM 和安全组功能提供安全和可管理的环境，解决方案是使用弹性网络接口。</p><p>在 EC2 中，每个实例都绑定到一个弹性网络接口 (ENI)，并且所有 ENI 都连接在一个 VPC 内——ENI 无需额外努力即可相互访问。默认情况下，每个 EC2 实例部署一个 ENI，但您可以自由创建多个 ENI 并将它们部署到您认为合适的 EC2 实例。适用于 Kubernetes 的 AWS CNI 插件通过为部署到节点的每个 Pod 创建一个新的 ENI 来利用这种灵活性。因为 VPC 中的 ENI 已经连接到现有 AWS 基础设施中，所以这允许每个 Pod 的 IP 地址在 VPC 中本地可寻址。当 CNI 插件部署到集群时，每个节点（EC2 实例）都会创建多个弹性网络接口并为这些实例分配 IP 地址，从而为每个节点形成一个 CIDR 块。部署 Pod 时，作为 DaemonSet 部署到 Kubernetes 集群的小型二进制文件会从 Nodes 本地 kubelet 进程接收任何将 Pod 添加到网络的请求。这个二进制文件从节点的可用 ENI 池中选择一个可用的 IP 地址，并通过在 Linux 内核中连接虚拟以太网设备和网桥将其分配给 Pod，如在同一节点内联网 Pod 时所述。有了这个，Pod 流量就可以跨集群内的节点路由。</p><h2 id="5、Pod和Service之间网络通信"><a href="#5、Pod和Service之间网络通信" class="headerlink" title="5、Pod和Service之间网络通信"></a>5、Pod和Service之间网络通信</h2><p>我们已经展示了如何在 Pod 及其关联的 IP 地址之间路由转发。在我们需要应对变化之前，这很有效。Pod IP 地址不是持久的，并且会随着扩展或缩减、应用程序崩溃或节点重启而出现和消失。这些事件中的每一个都可以使 Pod IP 地址在没有警告的情况下更改。Service被内置到 Kubernetes 中来解决这个问题。</p><p>Kubernetes Service 管理一组 Pod 的状态，允许您跟踪一组随时间动态变化的 Pod IP 地址。Service充当对 Pod 的抽象，并将单个虚拟 IP 地址分配给一组 Pod IP 地址。任何发往 Service 虚拟 IP 的流量都将被转发到与虚拟 IP 关联的 Pod 集。这允许与 Service 关联的 Pod 集随时更改——客户端只需要知道 Service 的虚拟 IP即可，它不会更改。</p><p>创建新的 Kubernetes Service时，会为您创建一个新的虚拟 IP（也称为集群 IP）。在集群中的任何地方，发往虚拟 IP 的流量都将负载均衡到与服务关联的一组支持 Pod。实际上，Kubernetes 会自动创建并维护一个分布式集群内负载均衡器，将流量分配到服务相关联的健康 Pod。让我们仔细看看它是如何工作的。</p><h3 id="5-1、netfilter-和-iptables"><a href="#5-1、netfilter-和-iptables" class="headerlink" title="5.1、netfilter 和 iptables"></a>5.1、netfilter 和 iptables</h3><p>为了在集群中执行负载平衡，Kubernetes 依赖于 Linux 内置的网络框架——netfilter。Netfilter 是 Linux 提供的一个框架，它允许以自定义处理程序的形式实现各种与网络相关的操作。Netfilter 为数据包过滤、网络地址转换和端口转换提供了各种功能和操作，它们提供了引导数据包通过网络所需的功能，以及提供禁止数据包到达计算机网络中敏感位置的能力。</p><p>iptables 是一个用户空间程序，它提供了一个基于表的系统，用于定义使用 netfilter 框架操作和转换数据包的规则。在 Kubernetes 中，iptables 规则由 kube-proxy 控制器配置，该控制器监视 Kubernetes API 服务器的更改。当对 Service 或 Pod 的更改更新 Service 的虚拟 IP 地址或 Pod 的 IP 地址时，iptables 规则会更新以正确地将指向 Service 的流量转发到正确的Pod。iptables 规则监视发往 Service 的虚拟 IP 的流量，并且在匹配时，从可用 Pod 集中选择一个随机 Pod IP 地址，并且 iptables 规则将数据包的目标 IP 地址从 Service 的虚拟 IP 更改为选定的 Pod。当 Pod 启动或关闭时，iptables 规则集会更新以反映集群不断变化的状态。换句话说，iptables 已经在机器上进行了负载平衡，以将定向到服务 IP 的流量转移到实际 pod 的 IP。</p><p>在返回路径上，IP 地址来自目标 Pod。在这种情况下，iptables 再次重写 IP 标头以将 Pod IP 替换为 Service 的 IP，以便 Pod 认为它一直只与 Service 的 IP 通信。</p><h3 id="5-2、IPVS"><a href="#5-2、IPVS" class="headerlink" title="5.2、IPVS"></a>5.2、IPVS</h3><p>Kubernetes 的最新版本 (1.11) 包括用于集群内负载平衡的第二个选项：IPVS。IPVS（IP 虚拟服务器）也构建在 netfilter 之上，并将传输层负载平衡作为 Linux 内核的一部分实现。IPVS 被合并到 LVS（Linux 虚拟服务器）中，它在主机上运行并充当真实服务器集群前面的负载平衡器。IPVS 可以将基于 TCP 和 UDP 的服务的请求定向到真实服务器，并使真实服务器的服务在单个 IP 地址上表现为虚拟服务。这使得 IPVS 非常适合 Kubernetes 服务。</p><p>声明 Kubernetes Service时，您可以指定是否希望使用 iptables 或 IPVS 完成集群内负载平衡。IPVS 专为负载平衡而设计，并使用更高效的数据结构（哈希表），与 iptables 相比允许几乎无限的规模。在使用 IPVS 创建负载均衡的 Service 时，会发生三件事：在 Node 上创建一个虚拟 IPVS 接口，将 Service 的 IP 地址绑定到虚拟 IPVS 接口，并为每个 Service IP 地址创建 IPVS 服务器。</p><p>未来，IPVS 有望成为集群内负载均衡的默认方法。此更改仅影响集群内负载平衡，并且在本指南的其余部分中，您可以安全地将 iptables 替换为 IPVS 以实现集群内负载平衡，而不会影响其余讨论。现在让我们看看通过集群内负载平衡服务的数据包的生命周期。</p><h3 id="5-3、Pod和Service通信"><a href="#5-3、Pod和Service通信" class="headerlink" title="5.3、Pod和Service通信"></a>5.3、Pod和Service通信</h3><p><img src="https://images.elecfans.top/uploads/20220719/4003ef64-076d-11ed-ba43-dac502259ad0.gif"></p><p>在 Pod 和 Service 之间路由数据包时，与以前相同的方式开始。数据包首先通过连接到 Pod 的网络命名空间 (1) 的 eth0 接口离开 Pod。然后它通过虚拟以太网设备到达网桥 (2)。网桥上运行的 ARP 协议不知道 Service，因此它通过默认路由 eth0 (3) 将数据包传输出去。在这里，发生了一些不同的事情。在 eth0 接受之前，数据包会通过 iptables 过滤。iptables 收到数据包后，使用 kube-proxy 安装在 Node 上的规则响应 Service 或 Pod 事件，将数据包的目的地从 Service IP 重写为特定的 Pod IP（4）。数据包现在注定要到达 Pod 4，而不是服务的虚拟 IP。iptables 利用 Linux 内核的 conntrack 实用程序来记住所做的 Pod 选择，以便将来的流量路由到同一个 Pod（除非发生任何扩展事件）。本质上，iptables 直接在 Node 上做了集群内负载均衡。然后流量使用我们已经检查过的 Pod 到 Pod 路由流向 Pod (5)。</p><h3 id="5-4、Service和Pod通信"><a href="#5-4、Service和Pod通信" class="headerlink" title="5.4、Service和Pod通信"></a>5.4、Service和Pod通信</h3><p><img src="https://images.elecfans.top/uploads/20220719/4019bb0a-076d-11ed-ba43-dac502259ad0.gif"><br>收到此数据包的 Pod 将响应，将源 IP 识别为自己的 IP，将目标 IP 识别为最初发送数据包的 Pod (1)。进入节点后，数据包流经 iptables，它使用 conntrack 记住它之前所做的选择，并将数据包的源重写为服务的 IP 而不是 Pod 的 IP (2)。从这里开始，数据包通过网桥流向与 Pod 的命名空间配对的虚拟以太网设备 (3)，然后流向我们之前看到的 Pod 的以太网设备 (4)。</p><h3 id="5-5、使用DNS"><a href="#5-5、使用DNS" class="headerlink" title="5.5、使用DNS"></a>5.5、使用DNS</h3><p>Kubernetes 可以选择使用 DNS 来避免将服务的集群 IP 地址硬编码到您的应用程序中。Kubernetes DNS 作为在集群上调度的常规 Kubernetes 服务运行。它配置在每个节点上运行的 kubelet，以便容器使用 DNS 服务的 IP 来解析 DNS 名称。集群中定义的每个服务（包括 DNS 服务器本身）都被分配了一个 DNS 名称。DNS 记录将 DNS 名称解析为服务的集群 IP 或 POD 的 IP，具体取决于您的需要。SRV 记录用于指定运行服务的特定命名端口。</p><p>DNS Pod 由三个独立的容器组成：</p><ul><li>kubedns：监视 Kubernetes 主服务器的服务和端点变化，并维护内存中的查找结构以服务 DNS 请求。</li><li>dnsmasq：添加 DNS 缓存以提高性能。</li><li>sidecar：提供一个单一的健康检查端点来执行 dnsmasq 和 kubedns 的健康检查。</li></ul><p>DNS Pod 本身作为 Kubernetes 服务公开，具有静态集群 IP，该 IP 在启动时传递给每个正在运行的容器，以便每个容器都可以解析 DNS 条目。DNS 条目通过维护内存中 DNS 表示的 kubedns 系统解析。etcd 是集群状态的后端存储系统，kubedns 使用一个库将 etcd 键值存储转换为 DNS 整体，以便在必要时重建内存中 DNS 查找结构的状态。</p><p>CoreDNS 与 kubedns 的工作方式类似，但使用插件架构构建，使其更加灵活。从 Kubernetes 1.11 开始，CoreDNS 是 Kubernetes 的默认 DNS 实现。</p><h2 id="6、Internet和Service之间网络通信"><a href="#6、Internet和Service之间网络通信" class="headerlink" title="6、Internet和Service之间网络通信"></a>6、Internet和Service之间网络通信</h2><p>到目前为止，我们已经了解了 Kubernetes 集群内的流量是如何转发的。这一切都很好，但不幸的是，将您的应用程序与外界隔离无助于实现任何销售目标——在某些时候，您可能希望将您的服务暴露给外部流量。这种需求突出了两个相关的问题：</p><ul><li>1）从 Kubernetes 服务获取流量到 Internet。</li><li>2）从 Internet 获取流量到您的 Kubernetes 服务。</li></ul><h3 id="6-1、Egress-将Kubernetes流量转发到Internet"><a href="#6-1、Egress-将Kubernetes流量转发到Internet" class="headerlink" title="6.1、Egress-将Kubernetes流量转发到Internet"></a>6.1、Egress-将Kubernetes流量转发到Internet</h3><p>从节点到公共 Internet 的流量转发是特定于网络的，并且实际上取决于您的网络如何配置以发布流量。为了使本节更加具体，我将使用 AWS VPC 来讨论任何具体细节。</p><p>在 AWS 中，Kubernetes 集群在 VPC 中运行，其中每个节点都分配有一个私有 IP 地址，该地址可从 Kubernetes 集群内访问。要从集群外部访问流量，您需要将 Internet 网关连接到您的 VPC。Internet 网关有两个用途：在您的 VPC 路由表中为可路由到 Internet 的流量提供目标，以及为已分配公共 IP 地址的任何实例执行网络地址转换 (NAT)。NAT 转换负责将集群专用的节点内部 IP 地址更改为公共 Internet 中可用的外部 IP 地址。</p><p>有了 Internet 网关，VM 就可以自由地将流量路由到 Internet。不幸的是，有一个小问题。Pod 有自己的 IP 地址，与托管 Pod 的节点的 IP 地址不同，并且 Internet 网关的 NAT 转换仅适用于 VM IP 地址，因为它不知道 Pod 正在运行什么哪些虚拟机——网关不支持容器。让我们看看 Kubernetes 如何使用 iptables 解决这个问题（再次）。</p><h4 id="6-1-1、Node和Internet通信"><a href="#6-1-1、Node和Internet通信" class="headerlink" title="6.1.1、Node和Internet通信"></a>6.1.1、Node和Internet通信</h4><p>在下图中，数据包源自 Pod 的命名空间 (1)，并经过连接到根命名空间 (2) 的 veth 对。一旦进入根命名空间，数据包就会从网桥移动到默认设备，因为数据包上的 IP 与连接到网桥的任何网段都不匹配。在到达根命名空间的以太网设备 (3) 之前，iptables 会破坏数据包 (3)。在这种情况下，数据包的源 IP 地址是 Pod，如果我们将源保留为 Pod，Internet 网关将拒绝它，因为网关 NAT 只了解连接到 VM 的 IP 地址。解决方案是让 iptables 执行源 NAT——更改数据包源——使数据包看起来来自 VM 而不是 Pod。有了正确的源 IP，数据包现在可以离开 VM (4) 并到达 Internet 网关 (5)。Internet 网关将执行另一个 NAT，将源 IP 从 VM 内部 IP 重写为外部 IP。最后，数据包将到达公共 Internet (6)。在返回的路上，数据包遵循相同的路径，并且任何源 IP 修改都被撤消，以便系统的每一层都接收到它理解的 IP 地址：节点或 VM 级别的 VM 内部，以及 Pod 内的 Pod IP命名空间。<br><img src="https://images.elecfans.top/uploads/20220719/402ccfa6-076d-11ed-ba43-dac502259ad0.gif"></p><h3 id="6-2、Ingress-将Internet流量转发到Kubernetes"><a href="#6-2、Ingress-将Internet流量转发到Kubernetes" class="headerlink" title="6.2、Ingress-将Internet流量转发到Kubernetes"></a>6.2、Ingress-将Internet流量转发到Kubernetes</h3><p>入口——让流量进入你的集群——是一个非常难以解决的问题。同样，这是特定于您正在运行的网络的，但一般来说，Ingress 分为两种解决方案，适用于网络堆栈的不同部分：(</p><ul><li><ol><li>服务负载平衡器和 </li></ol></li><li><ol start="2"><li>入口控制器<h4 id="6-2-1、四层转发-Loadbalancer"><a href="#6-2-1、四层转发-Loadbalancer" class="headerlink" title="6.2.1、四层转发-Loadbalancer"></a>6.2.1、四层转发-Loadbalancer</h4>当你创建一个 Kubernetes 服务时，你可以选择指定一个 LoadBalancer 来配合它。LoadBalancer 的实现由知道如何为您的服务创建负载均衡器的云控制器提供。创建服务后，它将公布负载均衡器的 IP 地址。作为最终用户，您可以开始将流量引导到负载均衡器以开始与您的服务通信。</li></ol></li></ul><p>借助 AWS，负载均衡器可以了解其目标组中的节点，并将平衡集群中所有节点的流量。一旦流量到达一个节点，之前为您的服务在整个集群中安装的 iptables 规则将确保流量到达您感兴趣的服务的 Pod。</p><h4 id="6-2-2、Loadbalancer和Service通信"><a href="#6-2-2、Loadbalancer和Service通信" class="headerlink" title="6.2.2、Loadbalancer和Service通信"></a>6.2.2、Loadbalancer和Service通信</h4><p>让我们看看这在实践中是如何工作的。部署服务后，您正在使用的云提供商将为您创建一个新的负载均衡器 (1)。因为负载均衡器不支持容器，所以一旦流量到达负载均衡器，它就会分布在组成集群的所有虚拟机中 (2)。每个 VM 上的 iptables 规则会将来自负载均衡器的传入流量引导到正确的 Pod (3) — 这些是在服务创建期间实施并在前面讨论过的相同 IP 表规则。Pod 到客户端的响应将返回 Pod 的 IP，但客户端需要有负载均衡器的 IP 地址。正如我们之前看到的，iptables 和 conntrack 用于在返回路径上正确重写 IP。</p><p>下图显示了托管 Pod 的三个 VM 前面的网络负载均衡器。传入流量 (1) 指向您的服务的负载均衡器。一旦负载均衡器收到数据包 (2)，它就会随机选择一个 VM。在这种情况下，我们病态地选择了没有运行 Pod 的 VM：VM 2 (3)。在这里，运行在 VM 上的 iptables 规则将使用 kube-proxy 安装到集群中的内部负载平衡规则将数据包定向到正确的 Pod。iptables 执行正确的 NAT 并将数据包转发到正确的 Pod (4)。<br><img src="https://images.elecfans.top/uploads/20220719/40442c46-076d-11ed-ba43-dac502259ad0.gif"></p><h4 id="6-2-3、七层转发-Ingress-Controller"><a href="#6-2-3、七层转发-Ingress-Controller" class="headerlink" title="6.2.3、七层转发-Ingress Controller"></a>6.2.3、七层转发-Ingress Controller</h4><p>第 7 层网络 Ingress 在网络堆栈的 HTTP/HTTPS 协议范围内运行，并构建在 Services 之上。启用 Ingress 的第一步是使用 Kubernetes 中的 NodePort 服务类型在您的服务上打开一个端口。如果将 Service 的 type 字段设置为 NodePort，Kubernetes master 将从您指定的范围内分配一个端口，并且每个 Node 都会将该端口（每个 Node 上的相同端口号）代理到您的 Service 中。也就是说，任何指向节点端口的流量都将使用 iptables 规则转发到服务。这个 Service 到 Pod 的路由遵循我们在将流量从 Service 路由到 Pod 时已经讨论过的相同的内部集群负载平衡模式。</p><p>要向 Internet 公开节点的端口，您需要使用 Ingress 对象。Ingress 是一个更高级别的 HTTP 负载均衡器，它将 HTTP 请求映射到 Kubernetes 服务。Ingress 方法将根据 Kubernetes 云提供商控制器的实现方式而有所不同。HTTP 负载均衡器，如第 4 层网络负载均衡器，仅了解节点 IP（而不是 Pod IP），因此流量路由同样利用由 kube-proxy 安装在每个节点上的 iptables 规则提供的内部负载均衡。</p><p>在 AWS 环境中，ALB 入口控制器使用 Amazon 的第 7 层应用程序负载均衡器提供 Kubernetes 入口。下图详细介绍了此控制器创建的 AWS 组件。它还演示了 Ingress 流量从 ALB 到 Kubernetes 集群的路由。<br><img src="6.2.3.png"></p><p>创建后，(1) Ingress Controller 监视来自 Kubernetes API 服务器的 Ingress 事件。当它找到满足其要求的 Ingress 资源时，它会开始创建 AWS 资源。AWS 将 Application Load Balancer (ALB) (2) 用于 Ingress 资源。负载均衡器与用于将请求路由到一个或多个注册节点的目标组一起工作。(3) 在 AWS 中为 Ingress 资源描述的每个唯一 Kubernetes 服务创建目标组。(4) Listener 是一个 ALB 进程，它使用您配置的协议和端口检查连接请求。侦听器由 Ingress 控制器为您的 Ingress 资源注释中详述的每个端口创建。最后，为 Ingress 资源中指定的每个路径创建目标组规则。这确保了到特定路径的流量被路由到正确的 Kubernetes 服务 (5)。</p><h4 id="6-2-4、Ingress和Service通信"><a href="#6-2-4、Ingress和Service通信" class="headerlink" title="6.2.4、Ingress和Service通信"></a>6.2.4、Ingress和Service通信</h4><p>流经 Ingress 的数据包的生命周期与 LoadBalancer 的生命周期非常相似。主要区别在于 Ingress 知道 URL 的路径（允许并可以根据路径将流量路由到服务），并且 Ingress 和 Node 之间的初始连接是通过 Node 上为每个服务公开的端口。</p><p>让我们看看这在实践中是如何工作的。部署服务后，您正在使用的云提供商将为您创建一个新的 Ingress 负载均衡器 (1)。由于负载均衡器不支持容器，因此一旦流量到达负载均衡器，它就会通过为您的服务提供的广告端口分布在组成集群 (2) 的整个 VM 中。每个 VM 上的 iptables 规则会将来自负载均衡器的传入流量引导到正确的 Pod (3) — 正如我们之前所见。Pod 到客户端的响应将返回 Pod 的 IP，但客户端需要有负载均衡器的 IP 地址。正如我们之前看到的，iptables 和 conntrack 用于在返回路径上正确重写 IP。<br><img src="https://images.elecfans.top/uploads/20220719/40866d90-076d-11ed-ba43-dac502259ad0.gif"></p><p>第 7 层负载均衡器的一个好处是它们可以识别 HTTP，因此它们知道 URL 和路径。这使您可以按 URL 路径对服务流量进行分段。它们通常还在 HTTP 请求的 X-Forwarded-For 标头中提供原始客户端的 IP 地址。</p><h2 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h2><p>本指南为理解 Kubernetes 网络模型以及它如何支持常见的网络任务奠定了基础。网络领域既广泛又深入，不可能在这里涵盖所有内容。本指南应为您提供深入了解您感兴趣并想了解更多主题的起点。每当您遇到困难时，请利用 Kubernetes 文档和 Kubernetes 社区来帮助您找到自己的方式。</p><h2 id="8、网络术语"><a href="#8、网络术语" class="headerlink" title="8、网络术语"></a>8、网络术语</h2><p>Kubernetes 依赖于几种现有技术来构建一个正常运行的集群。全面探索这些技术中的每一个超出了本指南的范围，但本节将详细描述这些技术中的每一个，以便进行讨论。如果您感到困惑或需要复习，您可以随意略读本节，完全跳过它，或者根据需要参考它。</p><h3 id="二层网络"><a href="#二层网络" class="headerlink" title="二层网络"></a>二层网络</h3><p>第 2 层是提供节点到节点数据传输的数据链路层。它定义了在两个物理连接的设备之间建立和终止连接的协议。它还定义了它们之间的流量控制协议。</p><h3 id="四层网络"><a href="#四层网络" class="headerlink" title="四层网络"></a>四层网络</h3><p>传输层通过流量控制控制给定链路的可靠性。在 TCP/IP 中，这一层是指用于在不可靠网络上交换数据的 TCP 协议。</p><h3 id="七层网络"><a href="#七层网络" class="headerlink" title="七层网络"></a>七层网络</h3><p>应用层是最接近最终用户的层，这意味着应用层和用户都直接与软件应用程序交互。该层与实现通信组件的软件应用程序交互。通常，第 7 层网络是指 HTTP。</p><h3 id="Nat网络地址转换"><a href="#Nat网络地址转换" class="headerlink" title="Nat网络地址转换"></a>Nat网络地址转换</h3><p>NAT 或网络地址转换是将一个地址空间重新映射到另一个地址空间的 IP 级别。映射通过在数据包通过流量路由设备传输时修改数据包的 IP 标头中的网络地址信息来实现。</p><p>基本 NAT 是从一个 IP 地址到另一个 IP 地址的简单映射。更常见的是，NAT 用于将多个私有 IP 地址映射到一个公开的 IP 地址。通常，本地网络使用私有 IP 地址空间，并且该网络上的路由器在该空间中被赋予私有地址。然后路由器使用公共 IP 地址连接到 Internet。当流量从本地网络传递到 Internet 时，每个数据包的源地址都从私有地址转换为公共地址，这使得请求看起来好像直接来自路由器。路由器维护连接跟踪，以将回复转发到本地网络上的正确专用 IP。</p><p>NAT 提供了一个额外的好处，即允许大型专用网络使用单个公共 IP 地址连接到 Internet，从而节省公共使用的 IP 地址的数量。</p><h4 id="snat-源地址转换"><a href="#snat-源地址转换" class="headerlink" title="snat-源地址转换"></a>snat-源地址转换</h4><p>SNAT 只是指修改 IP 数据包源地址的 NAT 过程。这是上述 NAT 的典型行为。</p><h4 id="dnat-目标地址转换"><a href="#dnat-目标地址转换" class="headerlink" title="dnat-目标地址转换"></a>dnat-目标地址转换</h4><p>DNAT 是指修改 IP 数据包的目的地址的 NAT 过程。DNAT 用于将位于专用网络中的服务发布到可公开寻址的 IP 地址。</p><h3 id="网络名称空间"><a href="#网络名称空间" class="headerlink" title="网络名称空间"></a>网络名称空间</h3><p>在网络中，每台机器（真实的或虚拟的）都有一个以太网设备（我们将其称为 eth0）。所有流入和流出机器的流量都与该设备相关联。事实上，Linux 将每个以太网设备与一个网络命名空间相关联——整个网络堆栈的逻辑副本，以及它自己的路由、防火墙规则和网络设备。最初，所有进程共享来自 init 进程的相同默认网络命名空间，称为根命名空间。默认情况下，进程从其父进程继承其网络命名空间，因此，如果您不进行任何更改，所有网络流量都会流经为根网络命名空间指定的以太网设备。</p><h3 id="veth虚拟网卡对"><a href="#veth虚拟网卡对" class="headerlink" title="veth虚拟网卡对"></a>veth虚拟网卡对</h3><p>计算机系统通常由一个或多个网络设备（eth0、eth1 等）组成，这些设备与负责将数据包放置到物理线路上的物理网络适配器相关联。Veth 设备是虚拟网络设备，始终以互连的对创建。它们可以充当网络命名空间之间的隧道，以创建到另一个命名空间中的物理网络设备的桥接，但也可以用作独立的网络设备。您可以将 veth 设备视为设备之间的虚拟跳线——一端连接的设备将连接另一端。</p><h3 id="网络桥接"><a href="#网络桥接" class="headerlink" title="网络桥接"></a>网络桥接</h3><p>网桥是从多个通信网络或网段创建单个聚合网络的设备。桥接连接两个独立的网络，就好像它们是一个网络一样。桥接使用内部数据结构来记录每个数据包发送到的位置，以作为性能优化。</p><h3 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h3><p>CIDR 是一种分配 IP 地址和执行 IP 路由的方法。对于 CIDR，IP 地址由两组组成：网络前缀（标识整个网络或子网）和主机标识符（指定该网络或子网上的主机的特定接口）。CIDR 使用 CIDR 表示法表示 IP 地址，其中地址或路由前缀写有表示前缀位数的后缀，例如 IPv4 的 192.0.2.0/24。IP 地址是 CIDR 块的一部分，如果地址的初始 n 位和 CIDR 前缀相同，则称其属于 CIDR 块。</p><h3 id="CNI"><a href="#CNI" class="headerlink" title="CNI"></a>CNI</h3><p>CNI（容器网络接口）是一个云原生计算基金会项目，由规范和库组成，用于编写插件以在 Linux 容器中配置网络接口。CNI 只关心容器的网络连接以及在容器被删除时移除分配的资源。</p><h3 id="VIP地址"><a href="#VIP地址" class="headerlink" title="VIP地址"></a>VIP地址</h3><p>虚拟 IP 地址或 VIP 是软件定义的 IP 地址，与实际的物理网络接口不对应。</p><h3 id="netfilter"><a href="#netfilter" class="headerlink" title="netfilter"></a>netfilter</h3><p>netfilter 是 Linux 中的包过滤框架。实现此框架的软件负责数据包过滤、网络地址转换 (NAT) 和其他数据包处理。</p><p>netfilter、ip_tables、连接跟踪（ip_conntrack、nf_conntrack）和NAT子系统共同构建了框架的主要部分。</p><h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a>iptables</h3><p>iptables 是一个允许 Linux 系统管理员配置 netfilter 及其存储的链和规则的程序。IP 表中的每条规则都由许多分类器（iptables 匹配）和一个连接的操作（iptables 目标）组成。</p><h3 id="conntrack"><a href="#conntrack" class="headerlink" title="conntrack"></a>conntrack</h3><p>conntrack 是建立在 Netfilter 框架之上的用于处理连接跟踪的工具。连接跟踪允许内核跟踪所有逻辑网络连接或会话，并将每个连接或会话的数据包定向到正确的发送者或接收者。NAT 依靠此信息以相同的方式翻译所有相关数据包，并且 iptables 可以使用此信息充当状态防火墙。</p><h3 id="IPVS"><a href="#IPVS" class="headerlink" title="IPVS"></a>IPVS</h3><p>IPVS 将传输层负载平衡作为 Linux 内核的一部分来实现。</p><p>IPVS 是一个类似于 iptables 的工具。它基于 Linux 内核的 netfilter 钩子函数，但使用哈希表作为底层数据结构。这意味着，与 iptables 相比，IPVS 重定向流量更快，在同步代理规则时具有更好的性能，并提供更多的负载平衡算法。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>域名系统 (DNS) 是一个分散的命名系统，用于将系统名称与 IP 地址相关联。它将域名转换为用于定位计算机服务的数字 IP 地址。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://m.elecfans.com/article/1863588.html">Kubernetes网络模型的基础知识</a></li><li><a href="https://sookocheff.com/post/kubernetes/understanding-kubernetes-networking-model/">A Guide to the Kubernetes Networking Model</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用的创建对象方式及存在问题</title>
    <link href="/2022/09/13/java/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98/"/>
    <url>/2022/09/13/java/%E5%B8%B8%E7%94%A8%E7%9A%84%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%AD%98%E5%9C%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="使用构造方法"><a href="#使用构造方法" class="headerlink" title="使用构造方法"></a>使用构造方法</h2><p>成员变量很多的时候，构造方法就没方便了.<br>举例:NutritionFacts是食品包装外面显示的营养成分标签，这里面有的营养成分是必须的：每一份的含量、每一罐的含量，其他的可选</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NutritionFacts</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> servingSize;  <span class="hljs-comment">// (mL)            required</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> servings;     <span class="hljs-comment">// (per container) required</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> calories;     <span class="hljs-comment">//                 optional</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> fat;          <span class="hljs-comment">// (g)             optional</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> sodium;       <span class="hljs-comment">// (mg)            optional</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> carbohydrate; <span class="hljs-comment">// (g)             optional</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">(<span class="hljs-type">int</span> servingSize, <span class="hljs-type">int</span> servings)</span> &#123;<br>        <span class="hljs-built_in">this</span>(servingSize, servings, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">(<span class="hljs-type">int</span> servingSize, <span class="hljs-type">int</span> servings,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> calories)</span> &#123;<br>        <span class="hljs-built_in">this</span>(servingSize, servings, calories, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">(<span class="hljs-type">int</span> servingSize, <span class="hljs-type">int</span> servings,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> calories, <span class="hljs-type">int</span> fat)</span> &#123;<br>        <span class="hljs-built_in">this</span>(servingSize, servings, calories, fat, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">(<span class="hljs-type">int</span> servingSize, <span class="hljs-type">int</span> servings,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> calories, <span class="hljs-type">int</span> fat, <span class="hljs-type">int</span> sodium)</span> &#123;<br>        <span class="hljs-built_in">this</span>(servingSize, servings, calories, fat, sodium, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">(<span class="hljs-type">int</span> servingSize, <span class="hljs-type">int</span> servings,</span><br><span class="hljs-params">           <span class="hljs-type">int</span> calories, <span class="hljs-type">int</span> fat, <span class="hljs-type">int</span> sodium, <span class="hljs-type">int</span> carbohydrate)</span> &#123;<br>        <span class="hljs-built_in">this</span>.servingSize  = servingSize;<br>        <span class="hljs-built_in">this</span>.servings     = servings;<br>        <span class="hljs-built_in">this</span>.calories     = calories;<br>        <span class="hljs-built_in">this</span>.fat          = fat;<br>        <span class="hljs-built_in">this</span>.sodium       = sodium;<br>        <span class="hljs-built_in">this</span>.carbohydrate = carbohydrate;<br>    &#125;<br>&#125;<br><br><br><br></code></pre></td></tr></table></figure><p>从上面的代码可见，为了尽量满足用户需要，NutritionFacts提供了多个构造方法给用户使用,以后要是加字段就麻烦了</p><p>缓解上述问题的一种方法是使用JavaBeans模式，用无参构造方法，然后按照调用setXXX设置每个所需字段，示例如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">NutritionFacts</span> <span class="hljs-variable">cocaCola</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NutritionFacts</span>();<br>cocaCola.setServingSize(<span class="hljs-number">240</span>);<br>cocaCola.setServings(<span class="hljs-number">8</span>);<br>cocaCola.setCalories(<span class="hljs-number">100</span>);<br>cocaCola.setSodium(<span class="hljs-number">35</span>);<br>cocaCola.setCarbohydrate(<span class="hljs-number">27</span>);<br><br></code></pre></td></tr></table></figure><h3 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h3><ol><li>首先，直观的看，这种做法违背了不可变对象的定义，创建出对象后，又用setXXX方法改变了成员变量</li><li>《Effective Java》的原话是在构造过程中JavaBean可能处于不一致的中的状态</li></ol><h2 id="使用静态工厂方法"><a href="#使用静态工厂方法" class="headerlink" title="使用静态工厂方法"></a>使用静态工厂方法</h2><p>相比静态工厂方法，构造方法存在以下五个典型问题</p><ol><li>随着入参的不同，构造方法可以有多个，如下所示，然而都是同名的，这会给用户造成困惑，此刻用静态工厂方法，可以自由设置方法名（例如createWithName或者createWithAge），让用户更方便的选择合适的方法</li><li>使用构造方法意味着创建对象，而有时候我们只想使用，并不在乎对象本身是否是新建的</li><li>以动物类Animal.class为例，Animal类的构造方法创建的对象Animal的实例，而静态工厂方法的返回值声明虽然是Animal，但实际返回的实例可以是Animal的子类，例如Dog</li><li>静态工厂方法内部可以有灵活的逻辑来决定返回那种子类的实例</li><li>静态工厂方法还有一个优势：方法返回对象所属的类，在编写此静态方法时可以不存在，这句话有点晦涩，可以回想一下JDBC的获取connection的API，在编写此API的时候，并不需要知道MySQL的driver实现</li></ol><h3 id="存在问题-1"><a href="#存在问题-1" class="headerlink" title="存在问题"></a>存在问题</h3><ol><li>当您开发一个类时，如果决定对外提供静态工厂方法，那么将构造方法设为私有，就可以让用户只能选择静态工厂方法了，代码如下所示，然而，这样的Student类就无法被继承<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">Student</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Student <span class="hljs-title function_">newInstance</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">student</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        student.setName(name);<br><br>        <span class="hljs-keyword">return</span> student;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li>一个类的代码中，可能已有一些静态方法，再加入静态工厂方法，一堆静态方法混杂在一起，用户从中找出静态工厂方法怕是不容易</li></ol><h2 id="使用builder"><a href="#使用builder" class="headerlink" title="使用builder"></a>使用builder</h2><p>builder pattern，《Effective Java》中文版译作建造者模式，用builder对象来创建真正的对象实例，前面提到的构造方法和静态工厂的不足，在builder pattern这里都得到了改善</p><p>来看代码吧，以刚才的NutritionFacts为例，使用builder pattern后的代码如下，新增一个静态成员类Builder，可以设置Builder的每个成员变量，最后调用其build方法的时候，才真正创建NutritionFacts对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NutritionFacts</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> servingSize;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> servings;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> calories;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> fat;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> sodium;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> carbohydrate;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Builder</span> &#123;<br>        <span class="hljs-comment">// Required parameters</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> servingSize;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> servings;<br><br>        <span class="hljs-comment">// Optional parameters - initialized to default values</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">calories</span>      <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">fat</span>           <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">carbohydrate</span>  <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">sodium</span>        <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Builder</span><span class="hljs-params">(<span class="hljs-type">int</span> servingSize, <span class="hljs-type">int</span> servings)</span> &#123;<br>            <span class="hljs-built_in">this</span>.servingSize = servingSize;<br>            <span class="hljs-built_in">this</span>.servings    = servings;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">calories</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span><br>            &#123; calories = val;      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>; &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">fat</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span><br>            &#123; fat = val;           <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>; &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">carbohydrate</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span><br>            &#123; carbohydrate = val;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>; &#125;<br>        <span class="hljs-keyword">public</span> Builder <span class="hljs-title function_">sodium</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span><br>            &#123; sodium = val;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>; &#125;<br><br>        <span class="hljs-keyword">public</span> NutritionFacts <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NutritionFacts</span>(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">NutritionFacts</span><span class="hljs-params">(Builder builder)</span> &#123;<br>        servingSize  = builder.servingSize;<br>        servings     = builder.servings;<br>        calories     = builder.calories;<br>        fat          = builder.fat;<br>        sodium       = builder.sodium;<br>        carbohydrate = builder.carbohydrate;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>以一个使用者的视角来看如何创建NutritionFacts对象，如下所示，流畅的写法，那些字段被设置以及具体的值都一目了然，最终build方法才会创建NutritionFacts对象，而且这是个不可变对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-type">NutritionFacts</span> <span class="hljs-variable">cocaCola</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NutritionFacts</span>.Builder(<span class="hljs-number">240</span>, <span class="hljs-number">8</span>)<br>                              .calories(<span class="hljs-number">100</span>)<br>                              .sodium(<span class="hljs-number">35</span>)<br>                              .carbohydrate(<span class="hljs-number">27</span>)<br>                              .build();<br><br></code></pre></td></tr></table></figure><h3 id="存在问题-2"><a href="#存在问题-2" class="headerlink" title="存在问题"></a>存在问题</h3><ol><li>即便能解决构造方法和静态工厂自身的一些问题，builder pattern也不是万能的，缺点很明显：创建对象之前，先要创建builder对象，这在一些性能要求高、资源限制苛刻的场景中就不适合了</li><li>另外builder pattern适合的场景是成员变量多的时候，而这个所谓的多究竟如何理解呢？这可能是个小马过河的问题吧：见惯了几十个成员变量的类，再去看十几个成员变量的类，可能会有种很清爽的感觉，呃，扯远了，其实《Effective Java》的说法是四个或者更多个参数，就适合用builder apttern了</li></ol><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><a href="https://xinchen.blog.csdn.net/article/details/125324863">java与es8实战之一：以builder pattern开篇</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JsonTypeInfo annotation usage</title>
    <link href="/2022/09/13/java/Using%20@JsonTypeInfo%20annotation%20to%20handle%20polymorphic%20types/"/>
    <url>/2022/09/13/java/Using%20@JsonTypeInfo%20annotation%20to%20handle%20polymorphic%20types/</url>
    
    <content type="html"><![CDATA[<p>In cases where polymorphic types are persisted to JSON, there’s no way for Jackson to figure out the right type during deserialization. Let’s understand that with an example.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> w;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> h;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Shape</span> &#123;<br>  <span class="hljs-type">int</span> radius;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">View</span> &#123;<br>  <span class="hljs-keyword">private</span> List&lt;Shape&gt; shapes;<br>&#125;<br></code></pre></td></tr></table></figure><p>Let’s serialize and then deserialize a View object:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleMain</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>      <span class="hljs-type">View</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>();<br>      v.setShapes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(List.of(Rectangle.of(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>), Circle.of(<span class="hljs-number">5</span>))));<br><br>      System.out.println(<span class="hljs-string">&quot;-- serializing --&quot;</span>);<br>      <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>      <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> om.writeValueAsString(v);<br>      System.out.println(s);<br><br>      System.out.println(<span class="hljs-string">&quot;-- deserializing --&quot;</span>);<br>      <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> om.readValue(s, View.class);<br>      System.out.println(view);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">--</span> <span class="hljs-string">serializing</span> <span class="hljs-string">--</span><br>&#123;<span class="hljs-string">&quot;shapes&quot;</span><span class="hljs-string">:</span>[&#123;<span class="hljs-string">&quot;w&quot;</span><span class="hljs-string">:3</span>,<span class="hljs-string">&quot;h&quot;</span><span class="hljs-string">:6</span>&#125;,&#123;<span class="hljs-string">&quot;radius&quot;</span><span class="hljs-string">:5</span>&#125;]&#125;<br><span class="hljs-string">--</span> <span class="hljs-string">deserializing</span> <span class="hljs-string">--</span><br><span class="hljs-string">Exception</span> <span class="hljs-string">in</span> <span class="hljs-string">thread</span> <span class="hljs-string">&quot;main&quot;</span> <span class="hljs-attr">com.fasterxml.jackson.databind.exc.InvalidDefinitionException:</span> <span class="hljs-string">Cannot</span> <span class="hljs-string">construct</span> <span class="hljs-string">instance</span> <span class="hljs-string">of</span> <span class="hljs-string">`com.logicbig.example.Shape`</span> <span class="hljs-string">(no</span> <span class="hljs-string">Creators,</span> <span class="hljs-string">like</span> <span class="hljs-string">default</span> <span class="hljs-string">construct,</span> <span class="hljs-string">exist):</span> <span class="hljs-string">abstract</span> <span class="hljs-string">types</span> <span class="hljs-string">either</span> <span class="hljs-string">need</span> <span class="hljs-string">to</span> <span class="hljs-string">be</span> <span class="hljs-string">mapped</span> <span class="hljs-string">to</span> <span class="hljs-string">concrete</span> <span class="hljs-string">types,</span> <span class="hljs-string">have</span> <span class="hljs-string">custom</span> <span class="hljs-string">deserializer,</span> <span class="hljs-string">or</span> <span class="hljs-string">contain</span> <span class="hljs-string">additional</span> <span class="hljs-string">type</span> <span class="hljs-string">information</span><br> <span class="hljs-string">at</span> [<span class="hljs-attr">Source:</span> <span class="hljs-string">(String)&quot;</span>&#123;<span class="hljs-string">&quot;shapes&quot;</span><span class="hljs-string">:</span>[&#123;<span class="hljs-string">&quot;w&quot;</span><span class="hljs-string">:3</span>,<span class="hljs-string">&quot;h&quot;</span><span class="hljs-string">:6</span>&#125;,&#123;<span class="hljs-string">&quot;radius&quot;</span><span class="hljs-string">:5</span>&#125;]&#125;<span class="hljs-string">&quot;; line: 1, column: 12] (through reference chain: com.logicbig.example.View[&quot;</span><span class="hljs-string">shapes&quot;</span>]<span class="hljs-string">-&gt;java.util.ArrayList[0])</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.fasterxml.jackson.databind.exc.InvalidDefinitionException.from(InvalidDefinitionException.java:67)</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.fasterxml.jackson.databind.DeserializationContext.reportBadDefinition(DeserializationContext.java:1451)</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.fasterxml.jackson.databind.DeserializationContext.handleMissingInstantiator(DeserializationContext.java:1027)</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.fasterxml.jackson.databind.deser.AbstractDeserializer.deserialize(AbstractDeserializer.java:265)</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:286)</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:245)</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:27)</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.fasterxml.jackson.databind.deser.impl.MethodProperty.deserializeAndSet(MethodProperty.java:127)</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.fasterxml.jackson.databind.deser.BeanDeserializer.vanillaDeserialize(BeanDeserializer.java:288)</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:151)</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4013)</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3004)</span><br><span class="hljs-string">at</span> <span class="hljs-string">com.logicbig.example.ExampleMain.main(ExampleMain.java:18)</span><br></code></pre></td></tr></table></figure><h2 id="Using-JsonTypeInfo"><a href="#Using-JsonTypeInfo" class="headerlink" title="Using @JsonTypeInfo"></a>Using @JsonTypeInfo</h2><p>This annotation is used to serialize information about actual class of polymorphic instances, so that Jackson can know what subtype is to be deserialized. Let’s fix about exception by using this annotation:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = &quot;className&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>Above configuration specifies that the qualified class name should be used (use = JsonTypeInfo.Id.CLASS) and persist that as JSON property (include = JsonTypeInfo.As.PROPERTY). The property name should be ‘className’.<br>Let’s run our main method again:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">--</span> <span class="hljs-string">serializing</span> <span class="hljs-string">--</span><br>&#123;<span class="hljs-string">&quot;shapes&quot;</span><span class="hljs-string">:</span>[&#123;<span class="hljs-string">&quot;className&quot;</span><span class="hljs-string">:&quot;com.logicbig.example.Rectangle&quot;</span>,<span class="hljs-string">&quot;w&quot;</span><span class="hljs-string">:3</span>,<span class="hljs-string">&quot;h&quot;</span><span class="hljs-string">:6</span>&#125;,&#123;<span class="hljs-string">&quot;className&quot;</span><span class="hljs-string">:&quot;com.logicbig.example.Circle&quot;</span>,<span class="hljs-string">&quot;radius&quot;</span><span class="hljs-string">:5</span>&#125;]&#125;<br><span class="hljs-string">--</span> <span class="hljs-string">deserializing</span> <span class="hljs-string">--</span><br><span class="hljs-string">View&#123;shapes=[Rectangle&#123;w=3,</span> <span class="hljs-string">h=6&#125;,</span> <span class="hljs-string">Circle&#123;radius=5&#125;]&#125;</span><br></code></pre></td></tr></table></figure><p>In above configuration if we skip optional elements, ‘include’ and ‘property’, then defaults will be used. The default ‘include’ is also JsonTypeInfo.As.PROPERTY and default ‘property’ is @class. So our example will be:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>which will be serialized as:</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml">&#123;<span class="hljs-string">&quot;shapes&quot;</span><span class="hljs-string">:</span>[&#123;<span class="hljs-string">&quot;@class&quot;</span><span class="hljs-string">:&quot;com.logicbig.example.Rectangle&quot;</span>,<span class="hljs-string">&quot;w&quot;</span><span class="hljs-string">:3</span>,<span class="hljs-string">&quot;h&quot;</span><span class="hljs-string">:6</span>&#125;,&#123;<span class="hljs-string">&quot;@class&quot;</span><span class="hljs-string">:&quot;com.logicbig.example.Circle&quot;</span>,<span class="hljs-string">&quot;radius&quot;</span><span class="hljs-string">:5</span>&#125;]&#125;<br><br></code></pre></td></tr></table></figure><h2 id="Using-JsonTypeInfo-on-properties"><a href="#Using-JsonTypeInfo-on-properties" class="headerlink" title="Using @JsonTypeInfo on properties"></a>Using @JsonTypeInfo on properties</h2><p>@JsonTypeInfo annotation can be used both on classes (above example) and properties. In our example using the annotation on ‘shapes’ property:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">View</span> &#123;<br>    <span class="hljs-meta">@JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY, property = &quot;className&quot;)</span><br>    <span class="hljs-keyword">private</span> List&lt;Shape&gt; shapes;<br>    <br>&#125; <br></code></pre></td></tr></table></figure><p>If this annotation exists on both class and property, then the one on property has precedence, as it is considered more specific.</p><p>When used on properties (fields, methods), this annotation applies to values. That means when used on collection types (Collection, Map, arrays) it will apply to the elements, not the collection itself. For non-collection types there is no difference. In above snippet when we used it on ‘shapes’ list, it is applied on each element (Shape) of the List rather than List type itself.</p><h2 id="Using-JsonTypeInfo-Id-MINIMAL-CLASS"><a href="#Using-JsonTypeInfo-Id-MINIMAL-CLASS" class="headerlink" title="Using JsonTypeInfo.Id.MINIMAL_CLASS"></a>Using JsonTypeInfo.Id.MINIMAL_CLASS</h2><p>use = JsonTypeInfo.Id.MINIMAL_CLASS option will serialize minimal relative package path. Check out complete example <a href="https://www.logicbig.com/examples/jackson/jackson-json-type-info-annotation-with-minimal-class.html">here</a>.</p><h2 id="Using-ObjectMapper-enableDefaultTyping"><a href="#Using-ObjectMapper-enableDefaultTyping" class="headerlink" title="Using ObjectMapper.enableDefaultTyping()"></a>Using ObjectMapper.enableDefaultTyping()</h2><p>This method can be used to enable global automatic inclusion of type information in cases where polymorphic types are used.</p><p>Let’s use this method in our example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExampleMain2</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>      <span class="hljs-type">View</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>();<br>      v.setShapes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(List.of(Rectangle.of(<span class="hljs-number">3</span>, <span class="hljs-number">6</span>), Circle.of(<span class="hljs-number">5</span>))));<br><br>      System.out.println(<span class="hljs-string">&quot;-- serializing --&quot;</span>);<br>      <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">om</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>      om.enableDefaultTyping(ObjectMapper.DefaultTyping.OBJECT_AND_NON_CONCRETE, JsonTypeInfo.As.PROPERTY);<br><br>      <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> om.writeValueAsString(v);<br>      System.out.println(s);<br><br>      System.out.println(<span class="hljs-string">&quot;-- deserializing --&quot;</span>);<br>      <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> om.readValue(s, View.class);<br>      System.out.println(view);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">--</span> <span class="hljs-string">serializing</span> <span class="hljs-string">--</span><br>&#123;<span class="hljs-string">&quot;shapes&quot;</span><span class="hljs-string">:</span>[<span class="hljs-string">&quot;java.util.ArrayList&quot;</span>,[&#123;<span class="hljs-string">&quot;@class&quot;</span><span class="hljs-string">:&quot;com.logicbig.example.Rectangle&quot;</span>,<span class="hljs-string">&quot;w&quot;</span><span class="hljs-string">:3</span>,<span class="hljs-string">&quot;h&quot;</span><span class="hljs-string">:6</span>&#125;,&#123;<span class="hljs-string">&quot;@class&quot;</span><span class="hljs-string">:&quot;com.logicbig.example.Circle&quot;</span>,<span class="hljs-string">&quot;radius&quot;</span><span class="hljs-string">:5</span>&#125;]]&#125;<br><span class="hljs-string">--</span> <span class="hljs-string">deserializing</span> <span class="hljs-string">--</span><br><span class="hljs-string">View&#123;shapes=[Rectangle&#123;w=3,</span> <span class="hljs-string">h=6&#125;,</span> <span class="hljs-string">Circle&#123;radius=5&#125;]&#125;</span><br></code></pre></td></tr></table></figure><p>In above example DefaultTyping.OBJECT_AND_NON_CONCRETE specifies that default typing will be used for properties with declared type of java.lang.Object or an abstract type (abstract class or interface, Shape in our example).</p><p>Note that in above output the actual type of List<Shape> is also persisted as ArrayList. That’s because List is also a non-concrete type.</p><h2 id="Example-Project"><a href="#Example-Project" class="headerlink" title="Example Project"></a>Example Project</h2><p>Dependencies and Technologies Used:</p><ul><li>ackson-databind 2.9.6: General data-binding functionality for Jackson: works on core streaming API.</li><li>JDK 10 </li><li>Maven 3.3.9</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.logicbig.com/tutorials/misc/jackson/jackson-json-type-info-annotation.html">Jackson JSON - Using @JsonTypeInfo annotation to handle polymorphic types</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>Jackson</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java ThreadLocal</title>
    <link href="/2022/09/13/java/threadlocal/"/>
    <url>/2022/09/13/java/threadlocal/</url>
    
    <content type="html"><![CDATA[<p>The <em>Java</em> <em>ThreadLocal</em> class enables you to create variables that can only be read and written by the same thread. Thus, even if two threads are executing the same code, and the code has a reference to the same <code>ThreadLocal</code> variable, the two threads cannot see each other’s <code>ThreadLocal</code> variables. Thus, the Java ThreadLocal class provides a simple way to make code <a href="http://tutorials.jenkov.com/java-concurrency/thread-safety.html">thread safe</a> that would not otherwise be so.</p><h2 id="Java-ThreadLocal-Tutorial-Video"><a href="#Java-ThreadLocal-Tutorial-Video" class="headerlink" title="Java ThreadLocal Tutorial Video"></a>Java ThreadLocal Tutorial Video</h2><p>If you prefer video, I have a video version of this Java ThreadLocal tutorial here:<br><a href="https://www.youtube.com/watch?v=a_BoqsnVR2U&list=PLL8woMHwr36EDxjUoCzboZjedsnhLP1j4&index=9" title="Java ThreadLocal Tutorial Video">Java ThreadLocal Tutorial</a></p><h2 id="Creating-a-ThreadLocal"><a href="#Creating-a-ThreadLocal" class="headerlink" title="Creating a ThreadLocal"></a>Creating a ThreadLocal</h2><p>You create a <code>ThreadLocal</code> instance just like you create any other Java object - via the <code>new</code> operator. Here is an example that shows how to create a <code>ThreadLocal</code> variable:</p><p>private ThreadLocal threadLocal = new ThreadLocal();</p><p>This only needs to be done once per thread. Multiple threads can now get and set values inside this <code>ThreadLocal</code>, and each thread will only see the value it set itself.</p><h2 id="Set-ThreadLocal-Value"><a href="#Set-ThreadLocal-Value" class="headerlink" title="Set ThreadLocal Value"></a>Set ThreadLocal Value</h2><p>Once a <code>ThreadLocal</code> has been created you can set the value to be stored in it using its <code>set()</code> method.</p><p>threadLocal.set(“A thread local value”);</p><h2 id="Get-ThreadLocal-Value"><a href="#Get-ThreadLocal-Value" class="headerlink" title="Get ThreadLocal Value"></a>Get ThreadLocal Value</h2><p>You read the value stored in a <code>ThreadLocal</code> using its <code>get()</code> method. Here is an example obtaining the value stored inside a Java <code>ThreadLocal</code>:</p><p>String threadLocalValue = (String) threadLocal.get();</p><h2 id="Remove-ThreadLocal-Value"><a href="#Remove-ThreadLocal-Value" class="headerlink" title="Remove ThreadLocal Value"></a>Remove ThreadLocal Value</h2><p>It is possible to remove a value set in a ThreadLocal variable. You remove a value by calling the <code>ThreadLocal</code> <code>remove()</code> method. Here is an example of removing the value set on a Java <code>ThreadLocal</code>:</p><p>threadLocal.remove();</p><h2 id="Generic-ThreadLocal"><a href="#Generic-ThreadLocal" class="headerlink" title="Generic ThreadLocal"></a>Generic ThreadLocal</h2><p>You can create a <code>ThreadLocal</code> with a generic type. Using a generic type only objects of the generic type can be set as value on the <code>ThreadLocal</code>. Additionally, you do not have to typecast the value returned by <code>get()</code>. Here is a generic <code>ThreadLocal</code> example:</p><p>private ThreadLocal<String> myThreadLocal = new ThreadLocal<String>();</p><p>Now you can only store strings in the <code>ThreadLocal</code> instance. Additionally, you do not need to typecast the value obtained from the <code>ThreadLocal</code>:</p><p>myThreadLocal.set(“Hello ThreadLocal”);</p><p>String threadLocalValue = myThreadLocal.get();</p><h2 id="Initial-ThreadLocal-Value"><a href="#Initial-ThreadLocal-Value" class="headerlink" title="Initial ThreadLocal Value"></a>Initial ThreadLocal Value</h2><p>It is possible to set an initial value for a Java <code>ThreadLocal</code> which will get used the first time <code>get()</code> is called - before <code>set()</code> has been called with a new value. You have two options for specifying an initial value for a ThreadLocal:</p><ul><li>  Create a ThreadLocal subclass that overrides the <code>initialValue()</code> method.</li><li>  Create a ThreadLocal with a <code>Supplier</code> interface implementation.</li></ul><p>I will show you both options in the following sections.</p><h3 id="Override-initialValue"><a href="#Override-initialValue" class="headerlink" title="Override initialValue()"></a>Override initialValue()</h3><p>The first way to specify an initial value for a Java <code>ThreadLocal</code> variable is to create a subclass of <code>ThreadLocal</code> which overrides its <code>initialValue()</code> method. The easiest way to create a subclass of <code>ThreadLocal</code> is to simply create an anonymous subclass, right where you create the <code>ThreadLocal</code> variable. Here is an example of creating an anonymous subclass of <code>ThreadLocal</code> which overrides the <code>initialValue()</code> method:</p><p>private ThreadLocal myThreadLocal = new ThreadLocal<String>() {<br>    @Override protected String initialValue() {<br>        return String.valueOf(System.currentTimeMillis());<br>    }<br>};    </p><p>Note, that different threads will still see different initial values. Each thread will create its own initial value. Only if you return the exact same object from the <code>initialValue()</code> method, will all threads see the same object. However, the whole point of using a <code>ThreadLocal</code> in the first place is to avoid the different threads seeing the same instance.</p><h3 id="Provide-a-Supplier-Implementation"><a href="#Provide-a-Supplier-Implementation" class="headerlink" title="Provide a Supplier Implementation"></a>Provide a Supplier Implementation</h3><p>The second method for specifying an initial value for a Java <code>ThreadLocal</code> variable is to use its static factory method <code>withInitial(Supplier)</code> passing a <code>Supplier</code> interface implementation as parameter. This <code>Supplier</code> implementation supplies the initial value for the <code>ThreadLocal</code>. Here is an example of creating a <code>ThreadLocal</code> using its <code>withInitial()</code> static factory method, passing a simple <code>Supplier</code> implementation as parameter:</p><p>ThreadLocal<String> threadLocal = ThreadLocal.withInitial(new Supplier<String>() {<br>    @Override<br>    public String get() {<br>        return String.valueOf(System.currentTimeMillis());<br>    }<br>});</p><p>Since <code>Supplier</code> is a <a href="http://tutorials.jenkov.com/java-functional-programming/functional-interfaces.html">functional interface</a>, it an be implemented using a <a href="http://tutorials.jenkov.com/java/lambda-expressions.html">Java Lambda Expression</a>. Here is how providing a <code>Supplier</code> implementation as a lambda expression to <code>withInitial()</code> looks:</p><p>ThreadLocal threadLocal = ThreadLocal.withInitial(<br>        () -&gt; { return String.valueOf(System.currentTimeMillis()); } );</p><p>As you can see, this is somewhat shorter than the previous example. But it can be made even a bit shorter yet, using the most dense syntax of lambda expressions:</p><p>ThreadLocal threadLocal3 = ThreadLocal.withInitial(<br>        () -&gt; String.valueOf(System.currentTimeMillis()) );</p><h2 id="Lazy-Setting-of-ThreadLocal-Value"><a href="#Lazy-Setting-of-ThreadLocal-Value" class="headerlink" title="Lazy Setting of ThreadLocal Value"></a>Lazy Setting of ThreadLocal Value</h2><p>In some situations you cannot use the standard ways of setting an initial value. For instance, perhaps you need some configuration information which is not available at the time you create the ThreadLocal variable. In that case you can set the initial value lazily. Here is an example of how setting an initial value lazily on a Java ThreadLocal:</p><p>public class MyDateFormatter {</p><pre><code class="hljs">private ThreadLocal&lt;SimpleDateFormat&gt; simpleDateFormatThreadLocal = new ThreadLocal&lt;&gt;();public String format(Date date) &#123;    SimpleDateFormat simpleDateFormat = getThreadLocalSimpleDateFormat();    return simpleDateFormat.format(date);&#125;</code></pre><p>​<br>​    private SimpleDateFormat getThreadLocalSimpleDateFormat() {<br>​        SimpleDateFormat simpleDateFormat = simpleDateFormatThreadLocal.get();<br>​        if(simpleDateFormat == null) {<br>​            simpleDateFormat = new SimpleDateFormat(“yyyy-MM-dd HH:mm:ss”);<br>​            simpleDateFormatThreadLocal.set(simpleDateFormat);<br>​        }<br>​        return simpleDateFormat;<br>​    }<br>}</p><p>Notice how the <code>format()</code> method calls the <code>getThreadLocalSimpleDateFormat()</code> method to obtain a <a href="http://tutorials.jenkov.com/java-internationalization/simpledateformat.html">Java SimpleDatFormat</a> instance. If a <code>SimpleDateFormat</code> instance has not been set in the <code>ThreadLocal</code>, a new <code>SimpleDateFormat</code> is created and set in the <code>ThreadLocal</code> variable. Once a thread has set its own <code>SimpleDateFormat</code> in the <code>ThreadLocal</code> variable, the same <code>SimpleDateFormat</code> object is used for that thread going forward. But only for that thread. Each thread creates its own <code>SimpleDateFormat</code> instance, as they cannot see each others instances set on the <code>ThreadLocal</code> variable.</p><p>The <code>SimpleDateFormat</code> class is not thread safe, so multiple threads cannot use it at the same time. To solve this problem, the <code>MyDateFormatter</code> class above creates a <code>SimpleDateFormat</code> per thread, so each thread calling the <code>format()</code> method will use its own <code>SimpleDateFormat</code> instance.</p><h2 id="Using-a-ThreadLocal-with-a-Thread-Pool-or-ExecutorService"><a href="#Using-a-ThreadLocal-with-a-Thread-Pool-or-ExecutorService" class="headerlink" title="Using a ThreadLocal with a Thread Pool or ExecutorService"></a>Using a ThreadLocal with a Thread Pool or ExecutorService</h2><p>If you plan to use a Java <code>ThreadLocal</code> from inside a task passed to a <a href="http://tutorials.jenkov.com/java-concurrency/thread-pools.html">Java Thread Pool</a> or a <a href="http://tutorials.jenkov.com/java-util-concurrent/executorservice.html">Java ExecutorService</a>, keep in mind that you do not have any guarantees which thread will execute your task. However, if all you need is to make sure that each thread uses its own instance of some object, this is not a problem. Then you can use a Java ThreadLocal with a thread pool or <code>ExecutorService</code> just fine.</p><h2 id="Full-ThreadLocal-Example"><a href="#Full-ThreadLocal-Example" class="headerlink" title="Full ThreadLocal Example"></a>Full ThreadLocal Example</h2><p>Here is a fully runnable Java <code>ThreadLocal</code> example:</p><p>public class ThreadLocalExample {</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String\[\] args)</span> &#123;<br>    <span class="hljs-type">MyRunnable</span> <span class="hljs-variable">sharedRunnableInstance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(sharedRunnableInstance);<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(sharedRunnableInstance);<br><br>    thread1.start();<br>    thread2.start();<br><br>    thread1.join(); <span class="hljs-comment">//wait for thread 1 to terminate</span><br>    thread2.join(); <span class="hljs-comment">//wait for thread 2 to terminate</span><br>&#125;<br></code></pre></td></tr></table></figure><p>}</p><p>public class MyRunnable implements Runnable {</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Integer&gt;();<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    threadLocal.set( (<span class="hljs-type">int</span>) (Math.random() \* <span class="hljs-number">100D</span>) );<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">2000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    &#125;<br><br>    System.out.println(threadLocal.get());<br>&#125;<br></code></pre></td></tr></table></figure><p>}</p><p>This example creates a single <code>MyRunnable</code> instance which is passed to two different threads. Both threads execute the <code>run()</code> method, and thus sets different values on the <code>ThreadLocal</code> instance. If the access to the <code>set()</code> call had been synchronized, and it had <em>not</em> been a <code>ThreadLocal</code> object, the second thread would have overridden the value set by the first thread.</p><p>However, since it <em>is</em> a <code>ThreadLocal</code> object then the two threads cannot see each other’s values. Thus, they set and get different values.</p><h2 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h2><p>The <code>InheritableThreadLocal</code> class is a subclass of <code>ThreadLocal</code>. Instead of each thread having its own value inside a <code>ThreadLocal</code>, the <code>InheritableThreadLocal</code> grants access to values to a thread and all child threads created by that thread. Here is a full Java <code>InheritableThreadLocal</code> example:</p><p>public class InheritableThreadLocalBasicExample {</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String\[\] args)</span> &#123;<br><br>    ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;&gt;();<br>    InheritableThreadLocal&lt;String&gt; inheritableThreadLocal =<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;&gt;();<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;===== Thread 1 =====&quot;</span>);<br>        threadLocal.set(<span class="hljs-string">&quot;Thread 1 - ThreadLocal&quot;</span>);<br>        inheritableThreadLocal.set(<span class="hljs-string">&quot;Thread 1 - InheritableThreadLocal&quot;</span>);<br><br>        System.out.println(threadLocal.get());<br>        System.out.println(inheritableThreadLocal.get());<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">childThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>( () -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;===== ChildThread =====&quot;</span>);<br>            System.out.println(threadLocal.get());<br>            System.out.println(inheritableThreadLocal.get());<br>        &#125;);<br>        childThread.start();<br>    &#125;);<br><br>    thread1.start();<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;===== Thread2 =====&quot;</span>);<br>        System.out.println(threadLocal.get());<br>        System.out.println(inheritableThreadLocal.get());<br>    &#125;);<br>    thread2.start();<br>&#125;<br></code></pre></td></tr></table></figure><p>}</p><p>This example creates a normal Java ThreadLocal and a Java InheritableThreadLocal. Then the example creates one thread which sets the value of the ThreadLocal and InheritableThreadLocal - and then creates a child thread which accesses the values of the ThreadLocal and InheritableThreadLocal. Only the value of the InheritableThreadLocal is visible to the child thread.</p><p>Finally the example creates a third thread which also tries to access both the ThreadLocal and InheritableThreadLocal - but which does not see any of the values stored by the first thread.</p><p>The output printed from running this example would look like this:</p><p>===== Thread 1 =====<br>Thread 1 - ThreadLocal<br>Thread 1 - InheritableThreadLocal<br>===== ChildThread =====<br>null<br>Thread 1 - InheritableThreadLocal<br>===== Thread2 =====<br>null<br>null</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://jenkov.com/tutorials/java-concurrency/threadlocal.html">Java ThreadLocal</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>ThreadLocal</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程之LockSupport</title>
    <link href="/2022/09/13/java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BLockSupport/"/>
    <url>/2022/09/13/java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BLockSupport/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>LockSupport是一个工具类，提供了基本的线程阻塞和唤醒功能</strong>，它是创建锁和其他同步组件的基础工具，内部是使用sun.misc.Unsafe类实现的。</p><p>LockSupport和使用它的线程都会关联一个许可，park方法表示消耗一个许可，调用park方法时，如果许可可用则park方法返回，如果没有许可则一直阻塞直到许可可用。unpark方法表示增加一个许可，多次调用并不会积累许可，因为许可数最大值为1。</p><h2 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h2><p><strong>park()：</strong> 阻塞当前线程，直到unpark方法被调用或当前线程被中断，park方法才会返回。</p><p><strong>park(Object blocker)：</strong> 同park()方法，多了一个阻塞对象blocker参数。</p><p><strong>parkNanos(long nanos)：</strong> 同park方法，nanos表示最长阻塞超时时间，超时后park方法将自动返回。</p><p><strong>parkNanos(Object blocker, long nanos)：</strong> 同parkNanos(long nanos)方法，多了一个阻塞对象blocker参数。</p><p><strong>parkUntil(long deadline)：</strong> 同park()方法，deadline参数表示最长阻塞到某一个时间点，当到达这个时间点，park方法将自动返回。（该时间为从1970年到现在某一个时间点的毫秒数）</p><p><strong>parkUntil(Object blocker, long deadline)：</strong> 同parkUntil(long deadline)方法，多了一个阻塞对象blocker参数。</p><p><strong>unpark(Thread thread)：</strong> 唤醒处于阻塞状态的线程thread。</p><h2 id="阻塞和唤醒实例"><a href="#阻塞和唤醒实例" class="headerlink" title="阻塞和唤醒实例"></a>阻塞和唤醒实例</h2><p>子线程执行LockSupport.park()，由于没有许可，进入阻塞状态。主线程3秒后调用unpark方法给子线程增加了一个许可，park方法返回，子线程被唤醒继续执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;do something start&quot;</span>);<br>            LockSupport.park();<br>            System.out.println(<span class="hljs-string">&quot;do something end&quot;</span>);<br>        &#125;);<br><br>        thread.start();<br>        Thread.sleep(<span class="hljs-number">3000</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;给子线程thread增加一个许可&quot;</span>);<br>        LockSupport.unpark(thread);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 输出结果：</span><br><span class="hljs-comment"> * do something start</span><br><span class="hljs-comment"> * 给子线程thread增加一个许可</span><br><span class="hljs-comment"> * do something end</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>先unpark增加许可，后park消费许可也是可以的。unpark会给thread增加一个许可，此时调用park方法，由于许可是可用的，所以park方法直接返回了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;do something start&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;子线程thread给自己增加一个许可&quot;</span>);<br>            LockSupport.unpark(Thread.currentThread());<br>            LockSupport.park();<br>            System.out.println(<span class="hljs-string">&quot;do something end&quot;</span>);<br>        &#125;);<br><br>        thread.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 输出结果：</span><br><span class="hljs-comment"> * do something start</span><br><span class="hljs-comment"> * 子线程thread给自己增加一个许可</span><br><span class="hljs-comment"> * do something end</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p>连续调用unpark不会累计许可，许可最大值为1，第一次park就已经消耗了许可，所以第二次park一直阻塞。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;do something start&quot;</span>);<br><br>            LockSupport.unpark(Thread.currentThread());<br>            System.out.println(<span class="hljs-string">&quot;unpark 1&quot;</span>);<br>            LockSupport.unpark(Thread.currentThread());<br>            System.out.println(<span class="hljs-string">&quot;unpark 2&quot;</span>);<br><br>            LockSupport.park();<br>            System.out.println(<span class="hljs-string">&quot;park 1&quot;</span>);<br>            LockSupport.park();<br>            System.out.println(<span class="hljs-string">&quot;park 2&quot;</span>);<br><br>            System.out.println(<span class="hljs-string">&quot;do something end&quot;</span>);<br>        &#125;);<br><br>        thread.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 输出结果：</span><br><span class="hljs-comment"> * do something start</span><br><span class="hljs-comment"> * unpark 1</span><br><span class="hljs-comment"> * unpark 2</span><br><span class="hljs-comment"> * park 1</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><h2 id="阻塞对象blocker的作用"><a href="#阻塞对象blocker的作用" class="headerlink" title="阻塞对象blocker的作用"></a>阻塞对象blocker的作用</h2><p>通过前面方法介绍可以看到，park、parkNanos、parkUntil方法都有对应的带阻塞对象blocker参数的重载方法。Thread类有一个变量为parkBlocker，对应的就是LockSupport的park等方法设置进去的阻塞对象。</p><p><strong>该参数主要用于问题排查和系统监控，在线程dump中会显示该参数的信息，有利于问题定位。</strong></p><p>分别调用park()和park(Object blocker)，然后使用jstack查看线程堆栈信息，对比发现后者会多输出一条阻塞对象的信息：</p><p>park():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        LockSupport.park();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="1.png"></p><p>park(Object blocker):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        LockSupport.park(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Demo</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="2.png"></p><h2 id="和显式锁、隐式锁等待唤醒的区别"><a href="#和显式锁、隐式锁等待唤醒的区别" class="headerlink" title="和显式锁、隐式锁等待唤醒的区别"></a>和显式锁、隐式锁等待唤醒的区别</h2><ol><li> park和unpark方法的调用不需要获取锁。</li><li> 先调用unpark方法后调用park方法依然可以唤醒。</li><li> park方法响应中断，线程被中断后park方法直接返回，但是不会InterruptedException异常。</li><li> unpark方法是直接唤醒指定的线程。</li></ol><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.cnblogs.com/seve/p/14555740.html">Java并发编程之LockSupport</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程之Condition</title>
    <link href="/2022/09/13/java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCondition/"/>
    <url>/2022/09/13/java/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BCondition/</url>
    
    <content type="html"><![CDATA[<p>Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作</p><p>相比使用Object的wait()、notify()，使用Condition的await()、signal()这种方式实现线程间协作更加安全和高效。</p><p>因此通常来说，线程通信的实现比较推荐使用Condition</p><ul><li>  Condition是个接口，基本的方法就是await()和signal()方法；</li><li>  Condition依赖于Lock接口，生成一个Condition的基本代码是<strong>lock.newCondition()</strong></li><li>  <strong>调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用，因为内部会做释放锁的操作，如果不是在lock和unlock之间使用，会报错<code>java.lang.IllegalMonitorStateException</code></strong></li></ul><p><strong>Conditon中的await()对应Object的wait()；</strong></p><p><strong>Condition中的signal()对应Object的notify()；</strong></p><p><strong>Condition中的signalAll()对应Object的notifyAll()。</strong></p><h2 id="简单demo"><a href="#简单demo" class="headerlink" title="简单demo"></a>简单demo</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionTest</span> &#123;<br><br>    <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">conditionTest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>::conditionWait).start();<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>::conditionSignal).start();<br><br>    &#125;<br><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">conditionWait</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            condition.await();<br>            System.out.println(<span class="hljs-string">&quot;awaiting&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">conditionSignal</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            condition.signal();<br>            System.out.println(<span class="hljs-string">&quot;signal&quot;</span>);<br><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一般都会将Condition对象作为成员变量。当调用await()方法后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的signal()方法，通知当前线程后，当前线程才从await()方法返回，并且在返回前已经获取了锁。</p><h2 id="深入理解demo"><a href="#深入理解demo" class="headerlink" title="深入理解demo"></a>深入理解demo</h2><p>获取一个Condition必须通过Lock的newCondition()方法。下面通过一个有界队列的示例来深入了解Condition的使用方式。</p><p>有界队列是一种特殊的队列，当队列为空时，队列的获取操作将会阻塞获取线程，直到队列中有新增元素，当队列已满时，队列的插入操作将会阻塞插入线程，直到队列出现“空位”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionTest</span> &#123;<br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">boundedQueueTest</span><span class="hljs-params">()</span> &#123;<br><br>        BoundedQueue&lt;Integer&gt; boundedQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BoundedQueue</span>&lt;&gt;(<span class="hljs-number">10</span>);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>                boundedQueue.add(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>                boundedQueue.remove();<br>            &#125;<br>        &#125;).start();<br><br>        Thread.currentThread().join();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BoundedQueue</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object[] items;<br><br>    <span class="hljs-comment">// 添加的下标，删除的下标和数组当前数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> addIndex, removeIndex, count;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BoundedQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span> &#123;<br>        items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[size];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加一个元素，如果数组满，则添加线程进入等待状态，直到有&quot;空位&quot;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(T t)</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (count == items.length) &#123;<br>                System.out.println(<span class="hljs-string">&quot;items is full&quot;</span>);<br>                notFull.await();<br>            &#125;<br>            items[addIndex] = t;<br>            <span class="hljs-keyword">if</span> (++addIndex == items.length)<br>                addIndex = <span class="hljs-number">0</span>;<br>            ++count;<br>            notEmpty.signal();<br>            System.out.println(<span class="hljs-string">&quot;add success&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 由头部删除一个元素，如果数组空，则删除线程进入等待状态，直到有新添加元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>                System.out.println(<span class="hljs-string">&quot;items length is 0&quot;</span>);<br>            notEmpty.await();<br>            <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> items[removeIndex];<br>            <span class="hljs-keyword">if</span> (++removeIndex == items.length)<br>                removeIndex = <span class="hljs-number">0</span>;<br>            --count;<br>            notFull.signal();<br>            System.out.println(<span class="hljs-string">&quot;remove success&quot;</span>);<br>            <span class="hljs-keyword">return</span> (T) x;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先需要获得锁，目的是确保数组修改的可见性和排他性。当数组数量等于数组长度时，表示数组已满，则调用notFull.await()，当前线程随之释放锁并进入等待状态。如果数组数量不等于数组长度，表示数组未满，则添加元素到数组中，同时通知等待在notEmpty上的线程，数组中已经有新元素可以获取。在添加和删除方法中使用while循环而非if判断，目的是防止过早或意外的通知，只有条件符合才能够退出循环。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h3><p>等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态一个Condition包含一个等待队列，Condition拥有首节点（firstWaiter）和尾节点（lastWaiter）。当前线程调用Condition.await()方法，将会以当前线程构造节点，并将节点从尾部加入等待队列，等待队列的基本结构如下图所示</p><p><img src="await_queue.png"></p><p>如图所示，Condition拥有首尾节点的引用，而新增节点只需要将原有的尾节点nextWaiter指向它，并且更新尾节点即可。上述节点引用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是由锁来保证线程安全的。在Object的监视器模型上，一个对象拥有一个同步队列和等待队列，而并发包中的Lock（更确切地说是同步器）拥有一个同步队列和多个等待队列，其对应关系如下图所示</p><p><img src="1.png"></p><h3 id="await"><a href="#await" class="headerlink" title="await"></a>await</h3><p>调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中</p><pre><code class="hljs">public final void await() throws InterruptedException &#123;        if (Thread.interrupted())            throw new InterruptedException();        // 当前线程加入等待队列        Node node = addConditionWaiter();        // 释放同步状态，也就是释放锁        int savedState = fullyRelease(node);        int interruptMode = 0;        while (!isOnSyncQueue(node)) &#123;            LockSupport.park(this);            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)                break;        &#125;        if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)            interruptMode = REINTERRUPT;        if (node.nextWaiter != null)            unlinkCancelledWaiters();        if (interruptMode != 0)            reportInterruptAfterWait(interruptMode);    &#125;</code></pre><p>调用该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。当等待队列中的节点被唤醒，则唤醒节点的线程开始尝试获取同步状态。如果不是通过其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException</p><h3 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h3><p>调用Condition的signal()方法，将会唤醒在等待队列中等待时间最长的节点（首节点），在唤醒节点之前，会将节点移到同步队列中</p><p><img src="2.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br>        <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>            doSignal(first);<br>    &#125;<br></code></pre></td></tr></table></figure><p>调用该方法的前置条件是当前线程必须获取了锁，可以看到signal()方法进行了isHeldExclusively()检查，也就是当前线程必须是获取了锁的线程。接着获取等待队列的首节点，将其移动到同步队列并使用LockSupport唤醒节点中的线程节点从等待队列移动到同步队列的过程如下图所示</p><p><img src="3.png"></p><p>通过调用同步器的enq(Node node)方法，等待队列中的头节点线程安全地移动到同步队列。当节点移动到同步队列后，当前线程再使用LockSupport唤醒该节点的线程。被唤醒后的线程，将从await()方法中的while循环中退出（isOnSyncQueue(Node node)方法返回true，节点已经在同步队列中），进而调用同步器的acquireQueued()方法加入到获取同步状态的竞争中。成功获取同步状态（或者说锁）之后，被唤醒的线程将从先前调用的await()方法返回，此时该线程已经成功地获取了锁。</p><p>Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法（<strong>注意是这个Condition对应的等待队列</strong>），效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://segmentfault.com/a/1190000039075214">Java中的condition类</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>juc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java新特性教程</title>
    <link href="/2022/09/13/java/Java%20%E6%96%B0%E7%89%B9%E6%80%A7%E6%95%99%E7%A8%8B/"/>
    <url>/2022/09/13/java/Java%20%E6%96%B0%E7%89%B9%E6%80%A7%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li><a href="https://www.wdbyte.com/java-feature/">Java 新特性教程</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java中field和property的区别</title>
    <link href="/2022/09/13/java/Java%E4%B8%ADfield%E5%92%8Cproperty%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2022/09/13/java/Java%E4%B8%ADfield%E5%92%8Cproperty%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>field和property中文的翻译差不多，实际上是两个不同的概念。</p><blockquote><p>field: A data member of a class. Unless specified otherwise, a field is not static.</p><p>property: Characteristics of an object that users can set, such as the color of a window.</p><p>摘自：<a href="https://docs.oracle.com/javase/tutorial/information/glossary.html#P">Glossary of Terms</a></p></blockquote><p>我的理解是，field指那些在类的内部，未通过getter/setter访问的成员变量。而property指的是通过getter/setter访问的成员变量</p><p><img src="img.png"></p><p>如上图所示我们新建一个Demo类，在没有设置getter/setter方法时，filed1,filed2,filed3,filed4都是field，然后我给property1和property2添加getter/setter方法后，getProperty1(), setProperty1()和property1就变成了一个property。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://xinxingastro.github.io/2018/07/21/Java/Java%E4%B8%ADfield%E5%92%8Cproperty%E7%9A%84%E5%8C%BA%E5%88%AB/">Java中field和property的区别</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java TreeMap vs HashMap</title>
    <link href="/2022/09/13/java/Java%20TreeMap%20vs%20HashMap/"/>
    <url>/2022/09/13/java/Java%20TreeMap%20vs%20HashMap/</url>
    
    <content type="html"><![CDATA[<p>In this tutorial, we are going to focus on the core <strong>differences between the <em>TreeMap</em> and the <em>HashMap</em>.</strong></p><p><em>TreeMap</em> and <em>HashMap</em> are quite similar, both are collections that implement the <em>Map</em> interface. But they also have some differences that make one better than the other in some situations. Let’s look at those differences.</p><p>Table Of Contents</p><ol><li><a href="#1-Differences-between-HashMap-and-TreeMap">1. Differences between HashMap and TreeMap</a><ul><li>  <a href="#1-1-Class-Hierarchy">1.1. Class Hierarchy</a></li><li>  <a href="#1-2-Internal-Implementations">1.2. Internal Implementations</a></li><li>  <a href="#1-3-Null-Keys-and-Values">1.3. Null Keys and Values</a></li><li>  <a href="#1-4-Functionality">1.4. Functionality</a></li><li>  <a href="#1-5-Element-Ordering">1.5. Element Ordering</a></li><li>  <a href="#1-6-Performance-Comparison">1.6. Performance Comparison</a></li><li>  <a href="#1-7-Memory-Usage">1.7. Memory Usage</a></li><li>  <a href="#1-8-Key-Searches">1.8. Key Searches</a></li></ul></li><li> <a href="#2-When-to-use-HashMap-and-TreeMap">2. When to use HashMap and TreeMap</a></li><li> <a href="#3-Conclusion">3. Conclusion</a></li><li> <a href="#4-References">4. References</a></li></ol><h2 id="1-Differences-between-HashMap-and-TreeMap"><a href="#1-Differences-between-HashMap-and-TreeMap" class="headerlink" title="1.Differences between HashMap and TreeMap"></a>1.Differences between HashMap and TreeMap</h2><p>Let’s discuss some of the main differences between the two maps.</p><h3 id="1-1-Class-Hierarchy"><a href="#1-1-Class-Hierarchy" class="headerlink" title="1.1. Class Hierarchy"></a>1.1. Class Hierarchy</h3><p><em><a href="https://howtodoinjava.com/java-hashmap/">HashMap</a></em> class extends <em>AbstractMap</em> class and <strong>implements <em>Map</em> interface</strong> whereas <em><a href="https://howtodoinjava.com/java/collections/treemap-class/">TreeMap</a></em> class extends <em>AbstractMap</em> class and <strong>implements</strong> _<strong>NavigableMap</strong>_ <strong>interface</strong>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// HashMap class declaration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span>&lt;K, V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K, V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K, V&gt;, Cloneable, Serializable<br><br><span class="hljs-comment">// TreeMap class declaration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeMap</span>&lt;K, V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K, V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NavigableMap</span>&lt;K, V&gt;, Cloneable, Serializable<br></code></pre></td></tr></table></figure><p><img src="img.png"></p><p><img src="img_1.png"></p><h3 id="1-2-Internal-Implementations"><a href="#1-2-Internal-Implementations" class="headerlink" title="1.2. Internal Implementations"></a>1.2. Internal Implementations</h3><ul><li>  <em>HashMap</em> internally uses <em><a href="https://howtodoinjava.com/java/collections/hashtable-class/">HashTable</a></em> and works on the principle of <strong>Hashing</strong>. It contains the buckets in the form of a <em><a href="https://howtodoinjava.com/java/collections/java-linkedlist-class/">LinkedList</a>,</em> and when there are more than 8 entries in the bucket, then the <em>LinkedList</em> transforms into a <em>Balanced Tree</em> (TreeNodes).</li><li>  <em>TreeMap</em> internally uses <strong><em>Red-Black Tree</em>,</strong> a self-balancing <em>Binary Search Tree.</em></li></ul><h3 id="1-3-Null-Keys-and-Values"><a href="#1-3-Null-Keys-and-Values" class="headerlink" title="1.3. Null Keys and Values"></a>1.3. Null Keys and Values</h3><p><strong><em>TreeMap</em> doesn’t allow a <em>null</em> key</strong> but may contain any number of <em>null</em> values<code>.</code></p><p><strong><em>HashMap</em></strong> <strong>allows one null key</strong> (for other <em>null</em> keys, the existing value will simply be overwritten with a new value) and any number of <em>null</em> values.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Putting null key in TreeMap</span><br>TreeMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br><br>map.put(<span class="hljs-literal">null</span>, <span class="hljs-string">&quot;value&quot;</span>);    <span class="hljs-comment">//Exception in thread &quot;main&quot; java.lang.NullPointerException</span><br></code></pre></td></tr></table></figure><p><em>TreeMap</em> internally uses <code>compareTo</code>() or <code>compare</code>() method from <em><a href="https://howtodoinjava.com/java/collections/java-comparable-interface/">Comparable</a></em> &amp; <em><a href="https://howtodoinjava.com/java/collections/java-comparator/">Comparator</a></em> Interfaces respectively to maintain the order of elements in the map based on the keys and in case of <em>null</em> key, these method throws <strong>‘</strong><em><a href="https://howtodoinjava.com/java/exception-handling/how-to-effectively-handle-nullpointerexception-in-java/">NullPointerException</a></em><strong>‘.</strong></p><h3 id="1-4-Functionality"><a href="#1-4-Functionality" class="headerlink" title="1.4. Functionality"></a>1.4. Functionality</h3><p><strong><em>TreeMap</em> is richer in functionality as compared with <em>HashMap</em>.</strong> Along with the normal methods <code>(get(), put(), remove())</code> of <em>Map</em> Interface, it contains methods from <em>NavigableMap</em> interface as well like <code>pollFirstEntry(), pollLastEntry(), tailMap(), firstKey(), lastKey()</code>, etc. which the <em>HashMap</em> class doesn’t have.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Creating TreeMap</span><br>TreeMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br><br><span class="hljs-comment">// Putting values in TreeMap</span><br>map.put(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>map.put(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>map.put(<span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-string">&quot;value3&quot;</span>);<br><br><span class="hljs-comment">// Printing map</span><br>System.out.println(map);                       <span class="hljs-comment">// Prints &#123;key1=value1, key2=value2, key3=value3&#125;</span><br><br><span class="hljs-comment">// Getting first key from map</span><br>System.out.println(map.firstKey());              <span class="hljs-comment">// Prints key1</span><br><span class="hljs-comment">// Getting last key from map</span><br>System.out.println(map.lastKey());             <span class="hljs-comment">// Prints key3</span><br><br><span class="hljs-comment">// Getting first entry from map</span><br>System.out.println(map.firstEntry());         <span class="hljs-comment">// Prints key1=value1</span><br><span class="hljs-comment">// Polling last entry from map</span><br>System.out.println(map.pollLastEntry());       <span class="hljs-comment">// Prints key3=value3</span><br><br><span class="hljs-comment">// Printing map again</span><br>System.out.println(map);                           <span class="hljs-comment">// Prints &#123;key1=value1, key2=value2&#125;</span><br></code></pre></td></tr></table></figure><h3 id="1-5-Element-Ordering"><a href="#1-5-Element-Ordering" class="headerlink" title="1.5. Element Ordering"></a>1.5. Element Ordering</h3><p><strong><em>HashMap</em> does not maintain any order</strong> for its elements i.e. it won’t provide any guarantee that the element inserted first in the map will print first during the iteration of the map.</p><p><strong><em>TreeMap</em> stores the elements in the sorting order of their keys.</strong> The sorting can be default natural sorting order (ascending order for numbers &amp; alphabetical order for strings) or customized sorting based on the <a href="https://howtodoinjava.com/java/collections/java-comparator/"><em>Comparator</em></a> object specified during the map creation.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Creating HashMap</span><br>HashMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br><span class="hljs-comment">// Putting values in the map</span><br>map.put(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>map.put(<span class="hljs-number">13</span>, <span class="hljs-string">&quot;value3&quot;</span>);<br>map.put(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;value4&quot;</span>);<br>map.put(<span class="hljs-number">25</span>, <span class="hljs-string">&quot;value5&quot;</span>);<br><br><span class="hljs-comment">// Printing map</span><br>System.out.println(map);   <span class="hljs-comment">//&#123;2=value2, 5=value4, 25=value5, 10=value1, 13=value3&#125;  - No ordering</span><br><br><span class="hljs-comment">// Creating TreeMap using normal TreeMap() constructor which sorts the elements </span><br><span class="hljs-comment">// based on natural sorting order of keys</span><br>TreeMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br><br><span class="hljs-comment">// Putting values in map</span><br>map.put(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>map.put(<span class="hljs-number">13</span>, <span class="hljs-string">&quot;value3&quot;</span>);<br>map.put(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;value4&quot;</span>);<br>map.put(<span class="hljs-number">25</span>, <span class="hljs-string">&quot;value5&quot;</span>);<br><br><span class="hljs-comment">// Printing map</span><br>System.out.println(map);  <span class="hljs-comment">//&#123;2=value2, 5=value4, 10=value1, 13=value3, 25=value5&#125;</span><br></code></pre></td></tr></table></figure><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Creating TreeMap using TreeMap(Comparator) constructor by specifying Comparator object </span><br><span class="hljs-comment">// as Lambda expression which sorts the elements according to customized sorting of keys</span><br>map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;Integer,String&gt;((I1,I2) -&gt; (I1&lt;I2) ? <span class="hljs-number">1</span> : (I1&gt;I2) ? -<span class="hljs-number">1</span> : <span class="hljs-number">0</span>); <br><br><span class="hljs-comment">// Putting values in map</span><br>map.put(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>map.put(<span class="hljs-number">13</span>, <span class="hljs-string">&quot;value3&quot;</span>);<br>map.put(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;value4&quot;</span>);<br>map.put(<span class="hljs-number">25</span>, <span class="hljs-string">&quot;value5&quot;</span>);<br><br><span class="hljs-comment">// Printing map</span><br>System.out.println(map);  <span class="hljs-comment">//&#123;25=value5, 13=value3, 10=value1, 5=value4, 2=value2&#125;</span><br></code></pre></td></tr></table></figure><h3 id="1-6-Performance-Comparison"><a href="#1-6-Performance-Comparison" class="headerlink" title="1.6. Performance Comparison"></a>1.6. Performance Comparison</h3><ul><li>  <strong><em>HashMap</em> is faster than <em>TreeMap</em></strong> and provides constant time performance <strong>O(1)</strong> for the most basic operations like <code>get(), put(), contains() &amp; remove()</code> in the best case scenario without hash collisions.</li><li>  In case of <strong>hash collisions</strong> (two keys are having the same hashcode), <em>HashMap</em> handles it by using a <em>LinkedList</em> to store the collided elements and hence the performance reduces up to <strong>O(n)</strong> in this case.</li><li>  To improve <em>HashMap’s</em> performance during collisions, <em>LinkedList</em> transforms into a <em>Balanced Tree</em> in case the number of entries in a bucket are more than 8 so that it improves the worst-case performance from <strong>O(n) to O(log(n)).</strong></li></ul><p>On the other hand, <em>TreeMap</em> provides a performance of <strong><em>O(log(n))</em></strong> for most basic operations like <code>get(), put(), contains() &amp; remove()</code>.</p><h3 id="1-7-Memory-Usage"><a href="#1-7-Memory-Usage" class="headerlink" title="1.7. Memory Usage"></a>1.7. Memory Usage</h3><p><strong><em>TreeMap</em> has better performance in memory management as it does not maintain an array internally</strong> to store key-value pairs.</p><p>In <em>HashMap</em>, the array size is determined while initialization or resizing which is often more than needed at the time. It wastes memory. There is no such problem with <em>TreeMap</em>.</p><h3 id="1-8-Key-Searches"><a href="#1-8-Key-Searches" class="headerlink" title="1.8. Key Searches"></a>1.8. Key Searches</h3><p><em>HashMap</em> uses <code>hashCode()</code> and <code>equals()</code> method while comparing the keys of the map while <em>TreeMap</em> uses <code>compareTo()</code> or <code>compare()</code> methods during key comparison.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Creating HashMap</span><br>HashMap&lt;Integer, String&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br><span class="hljs-comment">// Putting values in map</span><br>hashMap.put(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>hashMap.put(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;HashMap: &quot;</span> + hashMap);<br><br><span class="hljs-comment">// Creating TreeMap</span><br>TreeMap&lt;Integer, String&gt; treeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br><br><span class="hljs-comment">// Putting values in map</span><br>treeMap.put(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>treeMap.put(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;TreeMap: &quot;</span> + treeMap);<br></code></pre></td></tr></table></figure><p>Notice the program output. Even though the output is same for both cases, internally <em>HashMap</em> uses <strong><em>equals()</em> while comparing the keys</strong> and rejects the second key as it is a duplicate. Whereas, <em>TreeMap</em> uses <strong><em>compareTo()</em> while comparing keys</strong> and thus rejects the second key.</p><p>Also, both the maps update the previous entry, and a single entry is there on the <em>Map</em>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap: &#123;<span class="hljs-number">10</span>=value2&#125;<br>TreeMap: &#123;<span class="hljs-number">10</span>=value2&#125;<br></code></pre></td></tr></table></figure><h2 id="2-When-to-use-HashMap-and-TreeMap"><a href="#2-When-to-use-HashMap-and-TreeMap" class="headerlink" title="2. When to use HashMap and TreeMap"></a><strong>2</strong>. When to use HashMap and TreeMap</h2><p>We should use <em>TreeMap</em> if we need to add elements (key-value pairs) in sorted order. Let’s take an example of creating a <strong>Dictionary</strong> where the words sort in alphabetical order. So we can easily implement this using a <em>TreeMap</em>.</p><p>A <em>TreeMap</em> is more <strong>memory efficient,</strong> so it is a good map implementation for us in case we are not sure of the number of elements to be stored in the memory.</p><p><em><a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">HashMap</a></em> is more of a general purpose map implementation and can be used where we don’t want any kind of sorting for our data, and the entries can be maintained in any order or sequence. In high-performance applications, we can prefer using <em>HashMap</em> over <em>TreeMap</em> as it performs better as compared to <em><a href="https://docs.oracle.com/javase/8/docs/api/java/util/TreeMap.html">TreeMap</a></em>.</p><h2 id="3-Conclusion"><a href="#3-Conclusion" class="headerlink" title="3. Conclusion"></a>3. Conclusion</h2><p>In this post, we have seen some of the key differences between <em>HashMap</em> and <em>TreeMap</em> and on which factors we can decide between the two while using them in our code.</p><p>Happy Learning !!</p><h2 id="4-References"><a href="#4-References" class="headerlink" title="4.References"></a>4.References</h2><ul><li><a href="https://howtodoinjava.com/java/collections/java-treemap-vs-hashmap/">Java TreeMap vs HashMap</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Integer.toString() vs String.valueOf()</title>
    <link href="/2022/09/13/java/Integer.toString()vsString.valueOf()/"/>
    <url>/2022/09/13/java/Integer.toString()vsString.valueOf()/</url>
    
    <content type="html"><![CDATA[<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.baeldung.com/java-tostring-valueof">Integer.toString() vs String.valueOf() in Java</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JMH - Java 代码性能基准测试</title>
    <link href="/2022/09/13/java/JMH-Java%20%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/"/>
    <url>/2022/09/13/java/JMH-Java%20%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="Java-性能测试难题"><a href="#Java-性能测试难题" class="headerlink" title="Java 性能测试难题"></a>Java 性能测试难题</h2><p>现在的 JVM 已经越来越为智能，它可以在编译阶段、加载阶段、运行阶段对代码进行优化。比如你写了一段不怎么聪明的代码，到了 JVM 这里，它发现几处可以优化的地方，就顺手帮你优化了一把。这对程序的运行固然美妙，却让开发者不能准确了解程序的运行情况。在需要进行性能测试时，如果不知道 JVM 优化细节，可能会导致你的测试结果差之毫厘，失之千里，同样的，Java 诞生之初就有一次编译、随处运行的口号，JVM 提供了底层支持，也提供了内存管理机制，这些机制都会对我们的性能测试结果造成不可预测的影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><span class="hljs-comment">// ....</span><br><span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>System.out.println(end - start);<br></code></pre></td></tr></table></figure><p>上面可能就是你最常见的性能测试了，这样的测试结果真的准确吗？答案是否定的，它有下面几个问题。</p><ol><li> 时间精度问题，本身获取到的时间戳就是存在<strong>误差</strong>的，它和操作系统有关。</li><li> JVM 在运行时会进行<strong>代码预热</strong>，说白了就是<strong>越跑越快</strong>。因为类需要装载、需要准备操作。</li><li> JVM 会在各个阶段都有可能对你的代码进行<strong>优化处理</strong>。</li><li> <strong>资源回收</strong>的不确定性，可能运行很快，回收很慢。</li></ol><p>带着这些问题，突然发现进行一次严格的基准测试的难度大大增加。那么如何才能进行一次严格的基准测试呢？</p><h2 id="JMH-介绍"><a href="#JMH-介绍" class="headerlink" title="JMH 介绍"></a>JMH 介绍</h2><p>那么如何对 Java 程序进行一次精准的性能测试呢？难道需要掌握很多 JVM 优化细节吗？难道要研究如何避免，并进行正确编码才能进行严格的性能测试吗？显然不是，如果是这样的话，未免过于困难了，好在有一款一款官方的微基准测试工具 - <strong>JMH</strong>.</p><p><strong>JMH</strong> 的全名是 Java Microbenchmark Harness，它是由 <strong>Java 虚拟机团队</strong>开发的一款用于 Java <strong>微基准测试工具</strong>。用自己开发的工具测试自己开发的另一款工具，以子之矛，攻子之盾果真手到擒来，如臂使指。使用 <strong>JMH</strong> 可以让你方便快速的进行一次严格的代码基准测试，并且有多种测试模式，多种测试维度可供选择；而且使用简单、增加注解便可启动测试。</p><h2 id="JMH-使用"><a href="#JMH-使用" class="headerlink" title="JMH 使用"></a>JMH 使用</h2><p>JMH 的使用首先引入 maven 所需依赖，当前最新版 为 1.23 版本。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--jmh 基准测试 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jmh<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jmh-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.35<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jmh<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.35<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="快速测试"><a href="#快速测试" class="headerlink" title="快速测试"></a>快速测试</h3><p>下面使用注解的方式指定测试参数，通过一个例子展示 JMH 基准测试的具体用法，先看一次运行效果，然后再了解每个注解的具体含义。</p><p>这个例子是使用 JMH 测试，使用加号拼接字符串和使用 <code>StringBuilder</code> 的 <code>append</code> 方法拼接字符串时的速度如何，每次拼接1000个数字进行平均速度比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.*;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.Runner;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.RunnerException;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.options.Options;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * JMH 基准测试入门</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> niujinpeng</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2020/8/21 1:13</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@BenchmarkMode(Mode.AverageTime)</span><br><span class="hljs-meta">@State(Scope.Thread)</span><br><span class="hljs-meta">@Fork(1)</span><br><span class="hljs-meta">@OutputTimeUnit(TimeUnit.MILLISECONDS)</span><br><span class="hljs-meta">@Warmup(iterations = 3)</span><br><span class="hljs-meta">@Measurement(iterations = 5)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JmhHello</span> &#123;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">stringBuilder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">stringAdd</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            string = string + i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> string;<br>    &#125;<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">stringBuilderAppend</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            stringBuilder.append(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> stringBuilder.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RunnerException &#123;<br>        <span class="hljs-type">Options</span> <span class="hljs-variable">opt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptionsBuilder</span>()<br>            .include(JmhHello.class.getSimpleName())<br>            .build();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runner</span>(opt).run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码很简单，不做解释，<code>stringAdd</code> 使用加号拼接字符串 1000次，<code>stringBuilderAppend</code> 使用 <code>append</code> 拼接字符串 1000次。直接运行 main 方法，稍等片刻后可以得到详细的运行输出结果。</p><h4 id="java8测试结果"><a href="#java8测试结果" class="headerlink" title="java8测试结果"></a>java8测试结果</h4><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-comment">// 开始测试 stringAdd 方法</span><br><span class="hljs-meta"># JMH version: 1.23</span><br><span class="hljs-meta"># VM version: JDK 1.8.0_181, Java HotSpot(TM) 64-Bit Server VM, 25.181-b13</span><br><span class="hljs-meta"># VM invoker: D:\develop\Java\jdk8_181\jre\bin\java.exe</span><br><span class="hljs-meta"># VM options: -javaagent:C:\ideaIU-2020.1.3.win\lib\idea_rt.jar=50363:C:\ideaIU-2020.1.3.win\bin -Dfile.encoding=UTF-8</span><br><span class="hljs-meta"># Warmup: 3 iterations, 10 s each  <span class="hljs-comment">// 预热运行三次</span></span><br><span class="hljs-meta"># Measurement: 5 iterations, 10 s each <span class="hljs-comment">// 性能测试5次 </span></span><br><span class="hljs-meta"># Timeout: 10 min per iteration  <span class="hljs-comment">// 超时时间10分钟</span></span><br><span class="hljs-meta"># Threads: 1 thread, will synchronize iterations  <span class="hljs-comment">// 线程数量为1</span></span><br><span class="hljs-meta"># Benchmark mode: Average time, time/op  <span class="hljs-comment">// 统计方法调用一次的平均时间</span></span><br><span class="hljs-meta"># Benchmark: net.codingme.jmh.JmhHello.stringAdd <span class="hljs-comment">// 本次执行的方法</span></span><br><br><span class="hljs-meta"># Run progress: 0.00% complete, ETA 00:02:40</span><br><span class="hljs-meta"># Fork: 1 of 1</span><br><span class="hljs-meta"># Warmup Iteration   1: 95.153 ms/op  <span class="hljs-comment">// 第一次预热，耗时95ms</span></span><br><span class="hljs-meta"># Warmup Iteration   2: 108.927 ms/op <span class="hljs-comment">// 第二次预热，耗时108ms</span></span><br><span class="hljs-meta"># Warmup Iteration   3: 167.760 ms/op <span class="hljs-comment">// 第三次预热，耗时167ms</span></span><br>Iteration   <span class="hljs-number">1</span>: <span class="hljs-number">198.897</span> ms/op  <span class="hljs-comment">// 执行五次耗时度量</span><br>Iteration   <span class="hljs-number">2</span>: <span class="hljs-number">243.437</span> ms/op<br>Iteration   <span class="hljs-number">3</span>: <span class="hljs-number">271.171</span> ms/op<br>Iteration   <span class="hljs-number">4</span>: <span class="hljs-number">295.636</span> ms/op<br>Iteration   <span class="hljs-number">5</span>: <span class="hljs-number">327.822</span> ms/op<br><br>Result <span class="hljs-string">&quot;net.codingme.jmh.JmhHello.stringAdd&quot;</span>:<br><span class="hljs-number">267.393</span> ±(<span class="hljs-number">99.9</span>%) <span class="hljs-number">189.907</span> ms/op [Average]<br>(<span class="hljs-built_in">min</span>, avg, <span class="hljs-built_in">max</span>) = (<span class="hljs-number">198.897</span>, <span class="hljs-number">267.393</span>, <span class="hljs-number">327.822</span>), stdev = <span class="hljs-number">49.318</span>  <span class="hljs-comment">// 执行的最小、平均、最大、误差值</span><br>CI (<span class="hljs-number">99.9</span>%): [<span class="hljs-number">77.486</span>, <span class="hljs-number">457.299</span>] (assumes normal distribution)<br></code></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">//</span> <span class="hljs-string">开始测试</span> <span class="hljs-string">stringBuilderAppend</span> <span class="hljs-string">方法</span><br><span class="hljs-comment"># Benchmark: net.codingme.jmh.JmhHello.stringBuilderAppend</span><br><br><span class="hljs-comment"># Run progress: 50.00% complete, ETA 00:01:21</span><br><span class="hljs-comment"># Fork: 1 of 1</span><br><span class="hljs-comment"># Warmup Iteration   1: 1.872 ms/op</span><br><span class="hljs-comment"># Warmup Iteration   2: 4.491 ms/op</span><br><span class="hljs-comment"># Warmup Iteration   3: 5.866 ms/op</span><br><span class="hljs-attr">Iteration   1:</span> <span class="hljs-number">6.936</span> <span class="hljs-string">ms/op</span><br><span class="hljs-attr">Iteration   2:</span> <span class="hljs-number">8.465</span> <span class="hljs-string">ms/op</span><br><span class="hljs-attr">Iteration   3:</span> <span class="hljs-number">8.925</span> <span class="hljs-string">ms/op</span><br><span class="hljs-attr">Iteration   4:</span> <span class="hljs-number">9.766</span> <span class="hljs-string">ms/op</span><br><span class="hljs-attr">Iteration   5:</span> <span class="hljs-number">10.143</span> <span class="hljs-string">ms/op</span><br><br><span class="hljs-string">Result</span> <span class="hljs-attr">&quot;net.codingme.jmh.JmhHello.stringBuilderAppend&quot;:</span><br><span class="hljs-number">8.847</span> <span class="hljs-string">±(99.9%)</span> <span class="hljs-number">4.844</span> <span class="hljs-string">ms/op</span> [<span class="hljs-string">Average</span>]<br><span class="hljs-string">(min,</span> <span class="hljs-string">avg,</span> <span class="hljs-string">max)</span> <span class="hljs-string">=</span> <span class="hljs-string">(6.936,</span> <span class="hljs-number">8.847</span><span class="hljs-string">,</span> <span class="hljs-number">10.143</span><span class="hljs-string">),</span> <span class="hljs-string">stdev</span> <span class="hljs-string">=</span> <span class="hljs-number">1.258</span><br><span class="hljs-string">CI</span> <span class="hljs-string">(99.9%):</span> [<span class="hljs-number">4.003</span>, <span class="hljs-number">13.691</span>] <span class="hljs-string">(assumes</span> <span class="hljs-string">normal</span> <span class="hljs-string">distribution)</span><br></code></pre></td></tr></table></figure><pre><code class="hljs"># Run complete. Total time: 00:02:42REMEMBER: The numbers below are just data. To gain reusable insights, you need to follow up onwhy the numbers are the way they are. Use profilers (see -prof, -lprof), design factorialexperiments, perform baseline and negative tests that provide experimental control, make surethe benchmarking environment is safe on JVM/OS/HW level, ask for reviews from the domain experts.Do not assume the numbers tell you what you want them to tell.// 测试结果对比Benchmark                     Mode  Cnt    Score     Error  UnitsJmhHello.stringAdd            avgt    5  267.393 ± 189.907  ms/opJmhHello.stringBuilderAppend  avgt    5    8.847 ±   4.844  ms/op</code></pre><p>上面日志里的 <code>//</code> 注释是我手动增加上去的，其实我们只需要看下面的最终结果就可以了，可以看到 <code>stringAdd</code> 方法平均耗时 267.393ms，而 <code>stringBuilderAppend</code> 方法平均耗时只有 8.847ms，可见 <code>StringBuilder</code> 的 <code>append</code> 方法进行字符串拼接速度快的多，这也是我们推荐使用<code>append</code> 进行字符串拼接的原因。</p><h4 id="java17"><a href="#java17" class="headerlink" title="java17"></a>java17</h4><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># JMH version: 1.35</span><br><span class="hljs-comment"># VM version: JDK 17, Java HotSpot(TM) 64-Bit Server VM, 17+35-LTS-2724</span><br><span class="hljs-comment"># VM invoker: D:\devPrograms\jdk\jdk-17_windows-x64_bin\jdk-17\bin\java.exe</span><br><span class="hljs-comment"># VM options: -javaagent:D:\devPrograms\JetBrains\ideaIU-2022.1.3.win\lib\idea_rt.jar=50503:D:\devPrograms\JetBrains\ideaIU-2022.1.3.win\bin -Dfile.encoding=UTF-8</span><br><span class="hljs-comment"># Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)</span><br><span class="hljs-comment"># Warmup: 3 iterations, 10 s each</span><br><span class="hljs-comment"># Measurement: 5 iterations, 10 s each</span><br><span class="hljs-comment"># Timeout: 10 min per iteration</span><br><span class="hljs-comment"># Threads: 1 thread, will synchronize iterations</span><br><span class="hljs-comment"># Benchmark mode: Average time, time/op</span><br><span class="hljs-comment"># Benchmark: jmh.JmhHello.stringAdd</span><br><br><span class="hljs-comment"># Run progress: 0.00% complete, ETA 00:02:40</span><br><span class="hljs-comment"># Fork: 1 of 1</span><br><span class="hljs-comment"># Warmup Iteration   1: 37.778 ms/op</span><br><span class="hljs-comment"># Warmup Iteration   2: 91.377 ms/op</span><br><span class="hljs-comment"># Warmup Iteration   3: 122.324 ms/op</span><br>Iteration   <span class="hljs-number">1</span>: <span class="hljs-number">131.892</span> ms/op<br>Iteration   <span class="hljs-number">2</span>: <span class="hljs-number">174.695</span> ms/op<br>Iteration   <span class="hljs-number">3</span>: <span class="hljs-number">172.821</span> ms/op<br>Iteration   <span class="hljs-number">4</span>: <span class="hljs-number">177.970</span> ms/op<br>Iteration   <span class="hljs-number">5</span>: <span class="hljs-number">209.361</span> ms/op<br><br><br>Result <span class="hljs-string">&quot;jmh.JmhHello.stringAdd&quot;</span>:<br>  <span class="hljs-number">173.348</span> ±(<span class="hljs-number">99.9</span>%) <span class="hljs-number">106.138</span> ms/op [Average]<br>  (<span class="hljs-built_in">min</span>, <span class="hljs-built_in">avg</span>, <span class="hljs-built_in">max</span>) = (<span class="hljs-number">131.892</span>, <span class="hljs-number">173.348</span>, <span class="hljs-number">209.361</span>), stdev = <span class="hljs-number">27.564</span><br>  CI (<span class="hljs-number">99.9</span>%): [<span class="hljs-number">67.210</span>, <span class="hljs-number">279.486</span>] (assumes <span class="hljs-keyword">normal</span> distribution)<br><br><br><span class="hljs-comment"># JMH version: 1.35</span><br><span class="hljs-comment"># VM version: JDK 17, Java HotSpot(TM) 64-Bit Server VM, 17+35-LTS-2724</span><br><span class="hljs-comment"># VM invoker: D:\devPrograms\jdk\jdk-17_windows-x64_bin\jdk-17\bin\java.exe</span><br><span class="hljs-comment"># VM options: -javaagent:D:\devPrograms\JetBrains\ideaIU-2022.1.3.win\lib\idea_rt.jar=50503:D:\devPrograms\JetBrains\ideaIU-2022.1.3.win\bin -Dfile.encoding=UTF-8</span><br><span class="hljs-comment"># Blackhole mode: compiler (auto-detected, use -Djmh.blackhole.autoDetect=false to disable)</span><br><span class="hljs-comment"># Warmup: 3 iterations, 10 s each</span><br><span class="hljs-comment"># Measurement: 5 iterations, 10 s each</span><br><span class="hljs-comment"># Timeout: 10 min per iteration</span><br><span class="hljs-comment"># Threads: 1 thread, will synchronize iterations</span><br><span class="hljs-comment"># Benchmark mode: Average time, time/op</span><br><span class="hljs-comment"># Benchmark: jmh.JmhHello.stringBuilderAppend</span><br><br><span class="hljs-comment"># Run progress: 50.00% complete, ETA 00:01:21</span><br><span class="hljs-comment"># Fork: 1 of 1</span><br><span class="hljs-comment"># Warmup Iteration   1: 1.426 ms/op</span><br><span class="hljs-comment"># Warmup Iteration   2: 3.321 ms/op</span><br><span class="hljs-comment"># Warmup Iteration   3: 4.922 ms/op</span><br>Iteration   <span class="hljs-number">1</span>: <span class="hljs-number">5.732</span> ms/op<br>Iteration   <span class="hljs-number">2</span>: <span class="hljs-number">6.849</span> ms/op<br>Iteration   <span class="hljs-number">3</span>: <span class="hljs-number">6.621</span> ms/op<br>Iteration   <span class="hljs-number">4</span>: <span class="hljs-number">6.950</span> ms/op<br>Iteration   <span class="hljs-number">5</span>: <span class="hljs-number">8.269</span> ms/op<br><br><br>Result <span class="hljs-string">&quot;jmh.JmhHello.stringBuilderAppend&quot;</span>:<br>  <span class="hljs-number">6.884</span> ±(<span class="hljs-number">99.9</span>%) <span class="hljs-number">3.508</span> ms/op [Average]<br>  (<span class="hljs-built_in">min</span>, <span class="hljs-built_in">avg</span>, <span class="hljs-built_in">max</span>) = (<span class="hljs-number">5.732</span>, <span class="hljs-number">6.884</span>, <span class="hljs-number">8.269</span>), stdev = <span class="hljs-number">0.911</span><br>  CI (<span class="hljs-number">99.9</span>%): [<span class="hljs-number">3.376</span>, <span class="hljs-number">10.392</span>] (assumes <span class="hljs-keyword">normal</span> distribution)<br><br><br><span class="hljs-comment"># Run complete. Total time: 00:02:42</span><br><br>REMEMBER: The numbers below are just data. To gain reusable insights, you need <span class="hljs-built_in">to</span> follow up <span class="hljs-keyword">on</span><br>why <span class="hljs-keyword">the</span> numbers are <span class="hljs-keyword">the</span> way they are. Use profilers (see -prof, -lprof), design factorial<br>experiments, perform baseline <span class="hljs-keyword">and</span> negative tests that provide experimental control, make sure<br><span class="hljs-keyword">the</span> benchmarking environment is safe <span class="hljs-keyword">on</span> <span class="hljs-title">JVM</span>/<span class="hljs-title">OS</span>/<span class="hljs-title">HW</span> <span class="hljs-title">level</span>, <span class="hljs-title">ask</span> <span class="hljs-title">for</span> <span class="hljs-title">reviews</span> <span class="hljs-title">from</span> <span class="hljs-title">the</span> <span class="hljs-title">domain</span> <span class="hljs-title">experts</span>.<br>Do <span class="hljs-keyword">not</span> assume <span class="hljs-keyword">the</span> numbers tell you what you want them <span class="hljs-built_in">to</span> tell.<br><br>NOTE: Current JVM experimentally supports Compiler Blackholes, <span class="hljs-keyword">and</span> they are <span class="hljs-keyword">in</span> use. Please exercise<br>extra caution when trusting <span class="hljs-keyword">the</span> results, look <span class="hljs-keyword">into</span> <span class="hljs-keyword">the</span> generated code <span class="hljs-built_in">to</span> check <span class="hljs-keyword">the</span> benchmark still<br>works, <span class="hljs-keyword">and</span> factor <span class="hljs-keyword">in</span> <span class="hljs-keyword">a</span> small probability <span class="hljs-keyword">of</span> <span class="hljs-built_in">new</span> VM bugs. Additionally, <span class="hljs-keyword">while</span> comparisons between<br>different JVMs are already problematic, <span class="hljs-keyword">the</span> performance <span class="hljs-built_in">difference</span> caused <span class="hljs-keyword">by</span> different Blackhole<br>modes can be very significant. Please make sure you use <span class="hljs-keyword">the</span> consistent Blackhole mode <span class="hljs-keyword">for</span> comparisons.<br><br>Benchmark                     Mode  Cnt    Score     Error  Units<br>JmhHello.stringAdd            avgt    <span class="hljs-number">5</span>  <span class="hljs-number">173.348</span> ± <span class="hljs-number">106.138</span>  ms/op<br>JmhHello.stringBuilderAppend  avgt    <span class="hljs-number">5</span>    <span class="hljs-number">6.884</span> ±   <span class="hljs-number">3.508</span>  ms/op<br></code></pre></td></tr></table></figure><h3 id="注解说明"><a href="#注解说明" class="headerlink" title="注解说明"></a>注解说明</h3><p>经过上面的示例，想必你也可以快速的使用 JMH 进行基准测试了，不过上面的诸多注解你可能还有疑惑，下面一一介绍。</p><p><strong>类上</strong>使用了六个注解。</p><pre><code class="hljs">@BenchmarkMode(Mode.AverageTime)@State(Scope.Thread)@Fork(1)@OutputTimeUnit(TimeUnit.MILLISECONDS)@Warmup(iterations = 3)@Measurement(iterations = 5)</code></pre><p><strong>@BenchmarkMode(Mode.AverageTime)</strong> 表示统计平均响应时间，不仅可以用在类上，也可用在<strong>测试方法</strong>上。</p><p>除此之外还可以取值：</p><ul><li>  Throughput：统计单位时间内可以对方法测试多少次。</li><li>  SampleTime：统计每个响应时间范围内的响应次数，比如 0-1ms，3次；1-2ms，5次。</li><li>  SingleShotTime：跳过预热阶段，直接进行<strong>一次微基准</strong>测试。</li></ul><p>@State(Scope.Thread)：每个进行基准测试的线程都会独享一个对象示例。</p><p>除此之外还能取值：</p><ul><li>  Benchmark：多线程共享一个示例。</li><li>  Group：线程组共享一个示例，在测试方法上使用 @Group 设置线程组。</li></ul><p>@Fork(1)：表示开启一个线程进行测试。</p><p>@OutputTimeUnit(TimeUnit.MILLISECONDS)：输出的时间单位，这里写的是毫秒。</p><p>@Warmup(iterations = 3)：微基准测试前进行三次预热执行，也可用在<strong>测试方法</strong>上。</p><p>@Measurement(iterations = 5)：进行 5 次微基准测试，也可用在<strong>测试方法</strong>上。</p><p>在两个测试方法上只使用了一个注解 <strong>@Benchmark</strong>，这个注解表示这个方法是要进行基准测试的方法，它类似于 Junit 中的 <strong>@Test</strong> 注解。上面还提到某些注解还可以用到测试方法上，也就是使用了 <strong>@Benchmark</strong> 的方法之上，如果类上和测试方法同时存在注解，会以<strong>方法上的注解</strong>为准。</p><p>其实 JMH 也可以把这些参数直接在 main 方法中指定，这时 main 方法中指定的级别最高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RunnerException &#123;<br>    <span class="hljs-type">Options</span> <span class="hljs-variable">opt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptionsBuilder</span>()<br>            .include(JmhHello.class.getSimpleName())<br>            .forks(<span class="hljs-number">1</span>)<br>            .warmupIterations(<span class="hljs-number">5</span>)<br>            .measurementIterations(<span class="hljs-number">10</span>)<br>            .build();<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runner</span>(opt).run();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="正确的微基准测试"><a href="#正确的微基准测试" class="headerlink" title="正确的微基准测试"></a>正确的微基准测试</h2><p>如果编写的代码本身就存在着诸多问题，那么即使使用正确的测试方法，也不可能得到正确的测试结果。这些测试代码中的问题应该由我们进行主动避免，那么有哪些常见问题呢？下面介绍两种最常见的情况。</p><h3 id="无用代码消除-（-Dead-Code-Elimination-）"><a href="#无用代码消除-（-Dead-Code-Elimination-）" class="headerlink" title="无用代码消除 （ Dead Code Elimination ）"></a>无用代码消除 （ Dead Code Elimination ）</h3><p>也有网友形象的翻译成<strong>死代码</strong>，死代码是指那些 JVM 经过检查发现的根本不会使用到的代码。比如下面这个代码片段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.*;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.Runner;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.RunnerException;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.options.Options;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 测试死代码消除</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> niujinpeng</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2020/8/21 8:04</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@BenchmarkMode(Mode.AverageTime)</span><br><span class="hljs-meta">@State(Scope.Thread)</span><br><span class="hljs-meta">@Fork(1)</span><br><span class="hljs-meta">@OutputTimeUnit(TimeUnit.MICROSECONDS)</span><br><span class="hljs-meta">@Warmup(iterations = 3, time = 3)</span><br><span class="hljs-meta">@Measurement(iterations = 5, time = 3)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JmhDCE</span> &#123;<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.log(Math.PI);<br>    &#125;<br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Math.log(Math.PI);<br>        result = Math.log(result);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RunnerException &#123;<br>        <span class="hljs-type">Options</span> <span class="hljs-variable">opt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptionsBuilder</span>()<br>                .include(JmhDCE.class.getSimpleName())<br>                .build();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runner</span>(opt).run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个代码片段里里，<code>test1</code> 方法对圆周率进行对数计算，并返回计算结果；而 <code>test2</code> 中不仅对圆周率进行对数计算，还对计算的结果再次对数计算，看起来复杂一些，但是因为没有用到计算结果，所以 JVM 会自动消除这段代码， 因为它没有任何意义。</p><pre><code class="hljs">Benchmark     Mode  Cnt   Score    Error  UnitsJmhDCE.test1  avgt    5   0.002 ±  0.001  us/opJmhDCE.test2  avgt    5  ≈ 10⁻⁴           us/op</code></pre><p>测试结果里也可以看到 <code>test</code> 平均耗时 0.0004 微秒，而 <code>test1</code> 平均耗时 0.002 微秒。</p><h3 id="常量折叠-（Constant-Folding）"><a href="#常量折叠-（Constant-Folding）" class="headerlink" title="常量折叠 （Constant Folding）"></a>常量折叠 （Constant Folding）</h3><p>在对 Java 源文件编译的过程中，编译器通过语法分析，可以发现某些能直接得到计算结果而不会再次更改的代码，然后会将计算结果记录下来，这样在执行的过程中就不需要再次运算了。比如这段代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.annotations.*;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.Runner;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.RunnerException;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.options.Options;<br><span class="hljs-keyword">import</span> org.openjdk.jmh.runner.options.OptionsBuilder;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * 测试常量折叠</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> niujinpeng</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span> 2020/8/21 8:23</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@BenchmarkMode(Mode.AverageTime)</span><br><span class="hljs-meta">@State(Scope.Thread)</span><br><span class="hljs-meta">@Fork(1)</span><br><span class="hljs-meta">@OutputTimeUnit(TimeUnit.MICROSECONDS)</span><br><span class="hljs-meta">@Warmup(iterations = 3, time = 3)</span><br><span class="hljs-meta">@Measurement(iterations = 5, time = 3)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JmhConstantFolding</span> &#123;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">PI1</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14159265358979323846</span>;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">PI2</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14159265358979323846</span>;<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.log(PI1) * Math.log(PI1);<br>    &#125;<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> Math.log(PI2) * Math.log(PI2);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RunnerException &#123;<br>        <span class="hljs-type">Options</span> <span class="hljs-variable">opt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptionsBuilder</span>().include(JmhConstantFolding.class.getSimpleName()).build();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runner</span>(opt).run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>test</code>1 中使用 <code>final</code> 修饰的 PI1 进行对象计算，因为 PI1 不能再次更改，所以 <code>test1</code> 的计算结果必定是不会更改的，所以 JVM 会进行常量折叠优化，而 <code>test2</code> 使用的 <code>PI2</code> 可能会被修改，所以只能每次进行计算。</p><pre><code class="hljs">Benchmark                 Mode  Cnt  Score    Error  UnitsJmhConstantFolding.test1  avgt    5  0.002 ±  0.001  us/opJmhConstantFolding.test2  avgt    5  0.019 ±  0.001  us/op</code></pre><p>可以看到 <code>test2</code> 耗时要多的多，达到了 0.019 微秒。</p><p>其实 JVM 做的优化操作远不止上面这些，还有比如常量传播（Constant Propagation）、循环展开（Loop Unwinding）、循环表达式外提（Loop Expression Hoisting）、消除公共子表达式（Common Subexpression Elimination）、本块重排序（Basic Block Reordering）、范围检查消除（Range Check Elimination）等。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>JMH 进行基准测试的使用过程并不复杂，同为 Java 虚拟机团队开发，准确性毋容置疑。但是在进行基准测试时还是要注意自己的代码问题，如果编写的要进行测试的代码本身存在问题，那么测试的结果必定是不准的。掌握了 JMH 基准测试之后，可以尝试测试一些常用的工具或者框架的性能如何，看看哪个工具的性能最好，比如 FastJSON 真的比 GSON 在进行 JSON 转换时更 Fast 吗？</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.wdbyte.com/2020/08/develop/tool-jmh/">JMH - Java 代码性能基准测试</a></li><li><a href="http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/">http://hg.openjdk.java.net/code-tools/jmh/file/tip/jmh-samples/src/main/java/org/openjdk/jmh/samples/</a></li><li><a href="https://github.com/openjdk/jmh">https://github.com/openjdk/jmh</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>JMH</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java Enum</title>
    <link href="/2022/09/13/java/Java%20Enum/"/>
    <url>/2022/09/13/java/Java%20Enum/</url>
    
    <content type="html"><![CDATA[<h2 id="Notes"><a href="#Notes" class="headerlink" title="Notes"></a>Notes</h2><ul><li><a href="https://github.com/dromara/hutool/issues/2075">序列化JSON时, 当字段类型为枚举且枚举类存在静态方法时, 反序列化结果与预期不符.</a></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.baeldung.com/java-enum-values">Attaching Values to Java Enum</a></li><li><a href="https://www.baeldung.com/a-guide-to-java-enums">A Guide to Java Enums</a></li><li><a href="https://www.baeldung.com/java-enum-iteration">Iterating over Enum Values in Java</a></li><li><a href="https://www.runoob.com/java/java-enum.html">Java 枚举(enum)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Generic Constructors</title>
    <link href="/2022/09/13/java/GenericConstructors/"/>
    <url>/2022/09/13/java/GenericConstructors/</url>
    
    <content type="html"><![CDATA[<p>In this blog post I will give you a quick overview of generic constructors.</p><h2 id="Generic-constructors-are-rarely-used-in-the-JDK"><a href="#Generic-constructors-are-rarely-used-in-the-JDK" class="headerlink" title="Generic constructors are rarely used (in the JDK)"></a>Generic constructors are rarely used (in the JDK)</h2><p>As I have never seen generic constructors before I wanted to know how “real-world” code uses them. So I wrote a <a href="https://github.com/objectos/blog-examples/blob/master/p011-generic-constructors/src/main/java/shared/JdkSearch.java">program</a> that parses the Java files in the JDK source code. It uses the <a href="https://github.com/javaparser/javaparser">JavaParser</a> open-source library. Since its README file mentions Java 15, I ran the program on tag <a href="https://github.com/openjdk/jdk/tree/jdk-15+36/src">jdk-15+36</a> of the <a href="https://github.com/openjdk/jdk/tree/jdk-15+36">JDK source code</a>.</p><p>I found seven classes having generic constructors. They are all in the <code>java.management</code> module. Four classes are exported (and therefore have Javadocs):</p><ul><li>  <a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.management/javax/management/StandardEmitterMBean.html">javax.management.StandardEmitterMBean</a></li><li>  <a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.management/javax/management/StandardMBean.html">javax.management.StandardMBean</a></li><li>  <a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.management/javax/management/openmbean/OpenMBeanAttributeInfoSupport.html">javax.management.openmbean.OpenMBeanAttributeInfoSupport</a></li><li>  <a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.management/javax/management/openmbean/OpenMBeanParameterInfoSupport.html">javax.management.openmbean.OpenMBeanParameterInfoSupport</a></li></ul><p>While three of the classes are internal:</p><ul><li>  <a href="https://github.com/openjdk/jdk/blob/jdk-15%2B36/src/java.management/share/classes/com/sun/jmx/mbeanserver/MXBeanSupport.java">com.sun.jmx.mbeanserver.MXBeanSupport</a></li><li>  <a href="https://github.com/openjdk/jdk/blob/jdk-15%2B36/src/java.management/share/classes/com/sun/jmx/mbeanserver/MBeanSupport.java">com.sun.jmx.mbeanserver.MBeanSupport</a></li><li>  <a href="https://github.com/openjdk/jdk/blob/jdk-15%2B36/src/java.management/share/classes/com/sun/jmx/mbeanserver/StandardMBeanSupport.java">com.sun.jmx.mbeanserver.StandardMBeanSupport</a></li></ul><p>Therefore one can safely say generic constructors are rarely used. At least in the JDK source code.</p><h2 id="Still…-it-gives-a-glimpse-on-how-to-use-them"><a href="#Still…-it-gives-a-glimpse-on-how-to-use-them" class="headerlink" title="Still… it gives a glimpse on how to use them"></a>Still… it gives a glimpse on how to use them</h2><p>Let’s study the signature of one of those constructors. For example, let’s take this one from the <a href="https://docs.oracle.com/en/java/javase/18/docs/api/java.management/javax/management/openmbean/OpenMBeanParameterInfoSupport.html#%3Cinit%3E(java.lang.String,java.lang.String,javax.management.openmbean.OpenType,T)"><code>OpenMBeanAttributeInfoSupport</code></a> class. Its signature is:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; OpenMBeanParameterInfoSupport(String name, String description,OpenType&lt;T&gt; openType,<br>                                         T defaultValue) <span class="hljs-keyword">throws</span> OpenDataException<br></code></pre></td></tr></table></figure><p>The Javadocs for the type parameter <code>&lt;T&gt;</code> says:</p><blockquote><p>T - allows the compiler to check that the defaultValue, if non-null, has the correct Java type for the given openType.</p></blockquote><p>So the type parameter in the constructor prevents mixing incompatible types. In other words, the following code to compiles:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">OpenType&lt;Foo&gt; openType = getOpenType();<br><span class="hljs-type">Foo</span> <span class="hljs-variable">foo</span> <span class="hljs-operator">=</span> getFoo();<br><span class="hljs-type">var</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenMBeanParameterInfoSupport</span>(<span class="hljs-string">&quot;A Name&quot;</span>, <span class="hljs-string">&quot;Some description&quot;</span>, openType, foo);<br></code></pre></td></tr></table></figure><p>As <code>OpenType&lt;Foo&gt;</code> is compatible with <code>Foo</code>. However, the following code fails to compile:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">OpenType&lt;Foo&gt; openType = getOpenType();<br><span class="hljs-type">Bar</span> <span class="hljs-variable">bar</span> <span class="hljs-operator">=</span> getBar();<br><span class="hljs-type">var</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OpenMBeanParameterInfoSupport</span>(<span class="hljs-string">&quot;A Name&quot;</span>, <span class="hljs-string">&quot;Some description&quot;</span>, openType, bar);<br><span class="hljs-comment">// compilation error                                                              ^^^</span><br></code></pre></td></tr></table></figure><p>As <code>OpenType&lt;Foo&gt;</code> is <strong>not</strong> compatible with <code>Bar</code>.</p><p>Great, let’s try to create an example using same idea. It should make things clearer.</p><h2 id="A-simple-example"><a href="#A-simple-example" class="headerlink" title="A simple example"></a>A simple example</h2><p>Suppose we have a <code>Payload</code> class that represents arbitrary data to be sent over the wire. For example, It could be JSON data to be sent over HTTPS. To keep our example simple, we will model the data as a <code>String</code> value. Additionally, since our data is immutable, we will use a Java record:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">Payload</span><span class="hljs-params">(String data)</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>So, if we were to send a “Hello world!” message over the wire, we could invoke a hypothetical <code>send</code> method like so:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Payload</span>(<span class="hljs-string">&quot;Hello world!&quot;</span>));<br></code></pre></td></tr></table></figure><p>The actual JSON payload sent by our hypothetical service is not important for our example. But, for completeness sake, let’s suppose the JSON data sent in our previous example was:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;data&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Hello world!&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>That’s great. Next, let’s add a little complexity to our data.j</p><h3 id="Sending-other-data-types"><a href="#Sending-other-data-types" class="headerlink" title="Sending other data types"></a>Sending other data types</h3><p>Suppose now we want to send data that is both structured and more complex than our previous “Hello world!” message. For example, we want to send a simplified log message represented by the following Java record:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">Log</span><span class="hljs-params">(<span class="hljs-type">long</span> millis, Level level, String msg)</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>This data is structured in the sense that its JSON format is defined by the following converter:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogConverter</span> &#123;<br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">convert</span><span class="hljs-params">(Log log)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">      &quot;millis&quot;: %d,</span><br><span class="hljs-string">      &quot;level&quot;: &quot;%s&quot;,</span><br><span class="hljs-string">      &quot;msg&quot;: &quot;%s&quot;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    &quot;&quot;&quot;</span>.formatted(log.millis(), log.level(), log.msg());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>To send our log record we could just:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">var</span> <span class="hljs-variable">converter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LogConverter</span>();<br><span class="hljs-type">var</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Log</span>(<span class="hljs-number">12345L</span>, Level.INFO, <span class="hljs-string">&quot;A message&quot;</span>);<br><span class="hljs-type">var</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> converter.convert(log);<br>send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Payload</span>(data));<br></code></pre></td></tr></table></figure><p>But we expect more data types each with its own structure. That is, each data type will bring its own converter. So, let’s refactor our <code>Payload</code> record.</p><h3 id="Enter-the-generic-constructor"><a href="#Enter-the-generic-constructor" class="headerlink" title="Enter the generic constructor"></a>Enter the generic constructor</h3><p>Since each data type will have its own converter there is a chance to use a generic constructor like so:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">Payload</span><span class="hljs-params">(String data)</span> &#123;<br>  <span class="hljs-keyword">public</span> &lt;T&gt; Payload(Function&lt;T, String&gt; converter, T item) &#123;<br>    <span class="hljs-built_in">this</span>(converter.apply(item));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>The converter is represented by a <code>Function</code> from a generic type <code>T</code> to a <code>String</code>. Our parameterized constructor ensures that the second argument’s type is compatible with the converter.</p><p>So let’s use our new constructor. The following test does just that:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">data</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">var</span> <span class="hljs-variable">converter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LogConverter</span>();<br>  <span class="hljs-type">var</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Log</span>(<span class="hljs-number">12345L</span>, Level.INFO, <span class="hljs-string">&quot;A message&quot;</span>);<br>  <span class="hljs-type">var</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Payload</span>(converter::convert, log);<br><br>  assertEquals(p.data(), <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">  &#123;</span><br><span class="hljs-string">    &quot;millis&quot;: 12345,</span><br><span class="hljs-string">    &quot;level&quot;: &quot;INFO&quot;,</span><br><span class="hljs-string">    &quot;msg&quot;: &quot;A message&quot;</span><br><span class="hljs-string">  &#125;</span><br><span class="hljs-string">  &quot;&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>Good, our test passes. Granted, there is very little difference to the previous example using the canonical constructor. But it does its job as an example of generic constructors.</p><h2 id="Invoking-generic-constructors"><a href="#Invoking-generic-constructors" class="headerlink" title="Invoking generic constructors"></a>Invoking generic constructors</h2><p>In our last example we invoked our generic constructor just like we do with a non-generic one. In other words, we did not provide explicit type arguments to our generic constructor. The actual type arguments were <a href="https://docs.oracle.com/javase/specs/jls/se18/html/jls-18.html">inferred</a> by the compiler.</p><p>We can be explicit if we wanted. That is, we can provide a type argument list to the generic constructor.</p><h3 id="Providing-type-arguments-with-the-new-keyword"><a href="#Providing-type-arguments-with-the-new-keyword" class="headerlink" title="Providing type arguments with the new keyword"></a>Providing type arguments with the <code>new</code> keyword</h3><p>Taking again our last example, we can provide explicit type arguments. So the class instance creation becomes:</p><pre><code class="hljs">var p = new &lt;Log&gt; Payload(converter::convert, log);</code></pre><p>Notice the <code>&lt;Log&gt;</code> right after the <code>new</code> keyword. Providing explicit type arguments means that the following code does <strong>not</strong> compile:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">var</span> <span class="hljs-variable">converter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LogConverter</span>();<br><span class="hljs-type">var</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Log</span>(<span class="hljs-number">12345L</span>, Level.INFO, <span class="hljs-string">&quot;A message&quot;</span>);<br><span class="hljs-type">var</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> &lt;Category&gt; Payload(converter::convert, log);<br><span class="hljs-comment">// compilation error           ^^^                 ^^^</span><br></code></pre></td></tr></table></figure><p>The compiler tries to match the actual arguments to a “virtual” constructor having the following signature:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Payload</span><span class="hljs-params">(Function&lt;Category, String&gt; converter, Category item)</span>;<br></code></pre></td></tr></table></figure><p>As the types are not compatible, compilation fails.</p><h3 id="Providing-type-arguments-with-the-this-or-super-keyword"><a href="#Providing-type-arguments-with-the-this-or-super-keyword" class="headerlink" title="Providing type arguments with the this or super keyword"></a>Providing type arguments with the <code>this</code> or <code>super</code> keyword</h3><p>Apart from the class instance creation expression (i.e., <code>new</code> keyword), there are other ways to invoke constructors. In particular, constructors themselves can invoke other constructors:</p><ul><li>  a constructor in the same class using <code>this</code>; </li><li>  a constructor from the superclass using <code>super</code>.</li></ul><p>But what happens if the invoked constructor is generic? Let’s investigate.</p><p>Here’s the production from <a href="https://docs.oracle.com/javase/specs/jls/se18/html/jls-8.html#jls-8.8.7.1">Section 8.8.7.1</a> of the JLS:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ExplicitConstructorInvocation:<br>  [TypeArguments] <span class="hljs-built_in">this</span> ( [ArgumentList] ) ;<br>  [TypeArguments] <span class="hljs-built_in">super</span> ( [ArgumentList] ) ;<br>  ExpressionName . [TypeArguments] <span class="hljs-built_in">super</span> ( [ArgumentList] ) ;<br>  Primary . [TypeArguments] <span class="hljs-built_in">super</span> ( [ArgumentList] ) ;<br></code></pre></td></tr></table></figure><p>As suspected, both <code>this</code> and <code>super</code> can be invoked with a type arguments list.</p><p>So let’s try it with our <code>Payload</code> record. We can add a specialized constructor for a <code>Log</code> instance like so:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">Payload</span><span class="hljs-params">(String data)</span> &#123;<br>  <span class="hljs-keyword">public</span> &lt;T&gt; Payload(Function&lt;T, String&gt; converter, T item) &#123;<br>    <span class="hljs-built_in">this</span>(converter.apply(item));<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Function&lt;Log, String&gt; LOG_CONVERTER = LogConverter.INSTANCE::convert;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Payload</span><span class="hljs-params">(Log log)</span> &#123;<br>    &lt;Log&gt; <span class="hljs-built_in">this</span>(LOG_CONVERTER, log);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>We added an invocation to the other constructor in the same class. It supplies a type argument to it:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Payload</span><span class="hljs-params">(Log log)</span> &#123;<br>  &lt;Log&gt; <span class="hljs-built_in">this</span>(LOG_CONVERTER, log);<br>&#125;<br></code></pre></td></tr></table></figure><p>This means that the following code does <strong>not</strong> compile:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Payload</span><span class="hljs-params">(Log log)</span> &#123;<br>  &lt;LocalDate&gt; <span class="hljs-built_in">this</span>(LOG_CONVERTER, log);<br>  <span class="hljs-comment">// error         ^^^            ^^^</span><br>&#125;<br></code></pre></td></tr></table></figure><p>As the compiler tries to match the actual arguments to a “virtual” constructor having the following signature:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Payload</span><span class="hljs-params">(Function&lt;LocalDate, String&gt; converter, LocalDate item)</span>;<br></code></pre></td></tr></table></figure><p>As the types are not compatible, compilation fails.</p><h3 id="Caveat-with-new-keyword-and-diamond-form"><a href="#Caveat-with-new-keyword-and-diamond-form" class="headerlink" title="Caveat with new keyword and diamond form"></a>Caveat with <code>new</code> keyword and diamond form</h3><p><a href="https://docs.oracle.com/javase/specs/jls/se18/html/jls-15.html#jls-15.9">Section 15.9</a> of the JLS has the following in bold:</p><blockquote><p><strong>It is a compile-time error if a class instance creation expression provides type arguments to a constructor but uses the diamond form for type arguments to the class.</strong></p></blockquote><p>Let’s investigate. Here’s a small Java program:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Caveat</span>&lt;T&gt; &#123;<br>  <span class="hljs-keyword">public</span> &lt;E&gt; Caveat(T t, E e) &#123;&#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">var</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> LocalDate.now();<br>    <span class="hljs-type">var</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><br>    <span class="hljs-keyword">new</span> &lt;String&gt; Caveat&lt;&gt;(t, e);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>The class <code>Caveat</code> is generic on <code>&lt;T&gt;</code>. It declares a single constructor which is generic on <code>&lt;E&gt;</code>. In the <code>main</code> method it tries to create a new instance of the <code>Caveat</code> class.</p><p>Let’s compile it:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">$ javac src/main/java/iter3/Caveat.java<br>src/main/java/iter3/Caveat.java:<span class="hljs-number">17</span>: error: cannot infer type arguments <span class="hljs-keyword">for</span> Caveat&lt;T&gt;<br>    <span class="hljs-keyword">new</span> &lt;String&gt; Caveat&lt;&gt;(t, e);<br>                       ^<br>  reason: cannot use <span class="hljs-string">&#x27;&lt;&gt;&#x27;</span> with explicit type parameters <span class="hljs-keyword">for</span> constructor<br>  where T is a type-variable:<br>    T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Object</span> declared in <span class="hljs-keyword">class</span> <span class="hljs-title class_">Caveat</span><br><span class="hljs-number">1</span> error<br></code></pre></td></tr></table></figure><p>Here’s the explanation from the JLS:</p><blockquote><p>This rule is introduced because inference of a generic class’s type arguments may influence the constraints on a generic constructor’s type arguments.</p></blockquote><p>To be honest, I was not able to understand it. In any case, to fix the compilation error we replace the diamond form:</p><pre><code class="hljs">new &lt;String&gt; Caveat&lt;LocalDate&gt;(t, e);</code></pre><p>With an explicit <code>&lt;LocalDate&gt;</code>. The code now compiles.</p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>In this blog post we discussed a few topics on generic constructors. A feature of the Java language I did not know until recently.</p><p>We have seen how it is rarely used in the JDK source code. Is it safe to extrapolate and say that it is rarely used in general? I personally believe it is. But don’t take my word for it.</p><p>We then saw an example exercising a possible use-case.</p><p>Finally, we saw how to invoke generic constructors using:</p><ul><li>  <code>new</code> keyword; and</li><li>  <code>this</code> keyword (which can be equally applied to the <code>super</code> keyword).</li></ul><p>The source code of the examples in this post can be found in this <a href="https://github.com/objectos/blog-examples/tree/master/p011-generic-constructors">GitHub repository</a>.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.objectos.com.br/blog/java-generic-constructors.html">Things I didn’t know about Java: Generic Constructors</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Guide to Java HashMap</title>
    <link href="/2022/09/13/java/Guide-to-Java-HashMap/"/>
    <url>/2022/09/13/java/Guide-to-Java-HashMap/</url>
    
    <content type="html"><![CDATA[<p><strong>HashMap in Java</strong> is a collection class that implements the Map interface. It is used to store key &amp; value pairs. Each key is mapped to a single value in the map.</p><p>Keys are unique. It means we can insert a key ‘K’ only once in a map. Duplicate keys are not allowed. Though a value <code>&#39;V&#39;</code> can be mapped to multiple keys.</p><h2 id="1-java-util-HashMap-Class"><a href="#1-java-util-HashMap-Class" class="headerlink" title="1. java.util.HashMap Class"></a>1. <em>java.util.HashMap</em> Class</h2><h3 id="1-1-HashMap-class-declaration"><a href="#1-1-HashMap-class-declaration" class="headerlink" title="1.1. HashMap class declaration"></a>1.1. HashMap class declaration</h3><p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/HashMap.html">HashMap</a> has been declared as follows:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span>&lt;K,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K,V&gt;<br><span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>&lt;K,V&gt;, Cloneable, Serializable<br></code></pre></td></tr></table></figure><h3 id="1-2-HashMap-class-Hierarchy"><a href="#1-2-HashMap-class-Hierarchy" class="headerlink" title="1.2. HashMap class Hierarchy"></a>1.2. HashMap class Hierarchy</h3><p>As shown above, HashMap implements <code>Map</code> interface and extends <code>AbstractMap</code> class.</p><p><img src="img.png"></p><h2 id="2-Java-HashMap-Features"><a href="#2-Java-HashMap-Features" class="headerlink" title="2. Java HashMap Features"></a>2. Java HashMap Features</h2><ul><li>  HashMap cannot contain duplicate keys.</li><li>  HashMap allows multiple <code>null</code> values but only one <code>null</code> key.</li><li>  HashMap is an <strong>unordered collection</strong>. It does not guarantee any specific order of the elements.</li><li>  HashMap is <strong>not thread-safe</strong>. You must explicitly synchronize concurrent modifications to the HashMap. Or you can use <strong>Collections.synchronizedMap(hashMap)</strong> to get the synchronized version of HashMap.</li><li>  A value can be retrieved only using the associated key.</li><li>  HashMap stores only object references. So primitives must be used with their corresponding wrapper classes. Such as <code>int</code></li><li>  will be stored as <code>Integer</code>.</li><li>  HashMap implements <strong>Cloneable</strong> and <strong>Serializable</strong> interfaces.</li></ul><h2 id="3-Internal-Implementation-of-HashMap"><a href="#3-Internal-Implementation-of-HashMap" class="headerlink" title="3. Internal Implementation of HashMap"></a>3. Internal Implementation of HashMap</h2><p>HashMap works on principle of hashing. Hashing is a way to assigning a unique code for any variable/object after applying any formula/algorithm on its properties. Each object in java has it’s <strong>hash code</strong> in such a way that two equal objects must produce the same hash code consistently.</p><h3 id="3-1-HashMap-Entry-class"><a href="#3-1-HashMap-Entry-class" class="headerlink" title="3.1. HashMap.Entry class"></a>3.1. HashMap.Entry class</h3><p>The key-value pairs are stored as instances of the inner class <code>HashMap.Entry</code> which has key and value mapping stored as attributes. key has been marked as <code>final</code>.</p><pre><code class="hljs">static class Entry&lt;K ,V&gt; implements Map.Entry&lt;K, V&gt;&#123;    final K key;    V value;    Entry&lt;K ,V&gt; next;    final int hash;    ...//More code goes here&#125;</code></pre><h3 id="3-2-Internal-working"><a href="#3-2-Internal-working" class="headerlink" title="3.2. Internal working"></a>3.2. Internal working</h3><p>All instances of <em>Entry</em> class are stored in an array declared as <code>&#39;transient Entry[] table&#39;</code>. For each key-value to be stored in HashMap, a hash value is calculated using the key’s hash code. This hash value is used to calculate the <strong>index</strong> in the array for storing Entry object.</p><p>In case of <strong>collision</strong>, where multiple keys are mapped to a single index location, a <strong>linked list</strong> is formed to store all such key-value pairs that should go in a single array index location.</p><p>While retrieving the value by key, the first index location is found using key’s hashcode. Then all elements are iterated in the LinkedList, and the correct value object is found by identifying the correct key using its <strong>equals()</strong> method.</p><h2 id="4-Java-HashMap-Example"><a href="#4-Java-HashMap-Example" class="headerlink" title="4. Java HashMap Example"></a>4. Java HashMap Example</h2><p>Let’s quickly go through some examples to work with HashMap in Java.</p><h3 id="4-1-Add-key-value-–-HashMap-put"><a href="#4-1-Add-key-value-–-HashMap-put" class="headerlink" title="4.1. Add key-value – HashMap.put()"></a>4.1. Add key-value – HashMap.put()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMapExample</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException<br>    &#123;<br>        HashMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>        map.put(<span class="hljs-number">1</span>,  <span class="hljs-string">&quot;A&quot;</span>);<br>        map.put(<span class="hljs-number">2</span>,  <span class="hljs-string">&quot;B&quot;</span>);<br>        map.put(<span class="hljs-number">3</span>,  <span class="hljs-string">&quot;C&quot;</span>);<br><br>        System.out.println(map);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Program output.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<span class="hljs-number">1</span>=A, <span class="hljs-number">2</span>=B, <span class="hljs-number">3</span>=C&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-Get-value-by-key-–-HashMap-get"><a href="#4-2-Get-value-by-key-–-HashMap-get" class="headerlink" title="4.2. Get value by key – HashMap.get()"></a>4.2. Get value by key – HashMap.get()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>map.put(<span class="hljs-number">1</span>,  <span class="hljs-string">&quot;A&quot;</span>);<br>map.put(<span class="hljs-number">2</span>,  <span class="hljs-string">&quot;B&quot;</span>);<br>map.put(<span class="hljs-number">3</span>,  <span class="hljs-string">&quot;C&quot;</span>);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(<span class="hljs-number">2</span>);<br><br>System.out.println(<span class="hljs-string">&quot;The value is :: &quot;</span>+  value );<br></code></pre></td></tr></table></figure><p>Program output.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">The value is :: B<br></code></pre></td></tr></table></figure><h3 id="4-3-Remove-pair-by-key-–-HashMap-remove"><a href="#4-3-Remove-pair-by-key-–-HashMap-remove" class="headerlink" title="4.3. Remove pair by key – HashMap.remove()"></a>4.3. Remove pair by key – HashMap.remove()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;B&quot;</span>);<br>map.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;C&quot;</span>);<br><br>System.out.println(map);<br><br>map.remove(<span class="hljs-number">3</span>);<br><br>System.out.println(map);<br></code></pre></td></tr></table></figure><p>Program output.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;<span class="hljs-number">1</span>=A, <span class="hljs-number">2</span>=B, <span class="hljs-number">3</span>=C&#125;<br>&#123;<span class="hljs-number">1</span>=A, <span class="hljs-number">2</span>=B&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-Iterate-a-HashMap"><a href="#4-4-Iterate-a-HashMap" class="headerlink" title="4.4. Iterate a HashMap"></a>4.4. Iterate a HashMap</h3><p>Please note that iterators of this class are <strong>fail-fast</strong> and if any structure modification is done after creation of iterator, it will throw <code>ConcurrentModificationException</code>.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">HashMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>map.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;B&quot;</span>);<br>map.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;C&quot;</span>);<br><br>System.out.println(<span class="hljs-string">&quot;//Iterate over keys&quot;</span>);<br><br>Iterator&lt;Integer&gt; itr = map.keySet().iterator();<br><br><span class="hljs-keyword">while</span> (itr.hasNext())<br>&#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> itr.next();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> map.get(key);<br><br>    System.out.println(<span class="hljs-string">&quot;The key is :: &quot;</span> + key + <span class="hljs-string">&quot;, and value is :: &quot;</span> + value );<br>&#125;<br><br>System.out.println(<span class="hljs-string">&quot;//Iterate over entries set&quot;</span>);<br><br>Iterator&lt;Entry&lt;Integer, String&gt;&gt; entryIterator = map.entrySet().iterator();<br><br><span class="hljs-keyword">while</span> (entryIterator.hasNext())<br>&#123;<br>    Entry&lt;Integer, String&gt; entry = entryIterator.next();<br><br>    System.out.println(<span class="hljs-string">&quot;The key is :: &quot;</span> + entry.getKey() + <span class="hljs-string">&quot;, and value is :: &quot;</span> + entry.getValue() );<br>&#125;<br></code></pre></td></tr></table></figure><p>Program output.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//Iterate over keys</span><br>The key is :: <span class="hljs-number">1</span>, and value is :: A<br>The key is :: <span class="hljs-number">2</span>, and value is :: B<br>The key is :: <span class="hljs-number">3</span>, and value is :: C<br><br><span class="hljs-comment">//Iterate over entries set</span><br>The key is :: <span class="hljs-number">1</span>, and value is :: A<br>The key is :: <span class="hljs-number">2</span>, and value is :: B<br>The key is :: <span class="hljs-number">3</span>, and value is :: C<br></code></pre></td></tr></table></figure><h2 id="5-HashMap-Methods"><a href="#5-HashMap-Methods" class="headerlink" title="5. HashMap Methods"></a>5. HashMap Methods</h2><p>List of methods in HashMap class and their short description.</p><ol><li> <strong>void clear()</strong> : removes all the key-value pairs from the HashMap.</li><li> <strong>Object clone()</strong> : returns a shallow copy of the specified HashMap.</li><li> <strong>boolean containsKey(Object key)</strong> : returns <code>true</code> or <code>false</code> based on whether the specified key is found in the map or not.</li><li> <strong>boolean containsValue(Object Value)</strong> : Similar to containsKey() method, it looks for the specified value instead of key.</li><li> <strong>Object get(Object key)</strong> : returns the value for the specified key in the HashMap.</li><li> <strong>boolean isEmpty()</strong> : checks whether the map is empty.</li><li> <strong>Set keySet()</strong> : returns the <strong>Set</strong> of all keys stored in the HashMap.</li><li> <strong>Object put(Key k, Value v)</strong> : Inserts key-value pair into the HashMap.</li><li> <strong>int size()</strong> : returns the map size equal to the number of key-value pairs stored in the HashMap.</li><li> <strong>Collection values()</strong> : returns a collection of all values in the map.</li><li> <strong>Value remove(Object key)</strong> : removes the key-value pair for the specified key.</li><li> <strong>void putAll(Map m)</strong> : copies all the elements of a map to another specified map.</li></ol><h2 id="6-HashMap-Examples"><a href="#6-HashMap-Examples" class="headerlink" title="6. HashMap Examples"></a>6. HashMap Examples</h2><ul><li>  <a href="https://howtodoinjava.com/java/collections/hashmap/how-hashmap-works-in-java/">How HashMap works in Java</a></li><li>  <a href="https://howtodoinjava.com/java/collections/hashmap/performance-comparison-of-different-ways-to-iterate-over-hashmap/">Performance Comparison of Different Ways to Iterate over HashMap</a></li><li>  <a href="https://howtodoinjava.com/java/collections/hashmap/design-good-key-for-hashmap/">How to design a good custom key object for HashMap</a></li><li>  <a href="https://howtodoinjava.com/java/collections/hashmap-vs-hashtable/">Difference between HashMap and Hashtable in Java</a></li><li>  <a href="https://howtodoinjava.com/java/sort/java-sort-map-by-key/">Java sort Map by keys (ascending and descending orders)</a></li><li>  <a href="https://howtodoinjava.com/java/sort/java-sort-map-by-values/">Java sort Map by values (ascending and descending orders)</a></li><li>  <a href="https://howtodoinjava.com/java/basics/java-hashcode-equals-methods/">Java hashCode() and equals() – Contract, rules and best practices</a></li><li>  <a href="https://howtodoinjava.com/interview-questions/hashmap-concurrenthashmap-interview-questions/">HashMap and ConcurrentHashMap Interview Questions</a></li><li>  <a href="https://howtodoinjava.com/java/multi-threading/best-practices-for-using-concurrenthashmap/">Java ConcurrentHashMap Best Practices</a></li><li>  <a href="https://howtodoinjava.com/jackson/jackson-json-to-from-hashmap/">Convert JSON to Map and Map to JSON</a></li><li>  <a href="https://howtodoinjava.com/jaxb/jaxb-example-marshalling-and-unmarshalling-hashmap-in-java/">Marshal and Unmarshal HashMap in Java</a></li><li>  <a href="https://howtodoinjava.com/java/string/how-to-find-duplicate-words-in-a-string-in-java/">How to Find Duplicate Words in String using HashMap</a></li><li>  <a href="https://howtodoinjava.com/java/collections/hashmap/compare-two-hashmaps/">Compare two hashmaps</a></li><li>  <a href="https://howtodoinjava.com/java/collections/hashmap/synchronize-hashmap/">Synchronize HashMap</a></li><li>  <a href="https://howtodoinjava.com/java/collections/hashmap/merge-two-hashmaps/">Merge two HashMaps</a></li><li>  <a href="https://howtodoinjava.com/java/collections/hashmap/shallow-deep-copy-hashmap/">How to clone a HashMap</a></li></ul><h2 id="7-References"><a href="#7-References" class="headerlink" title="7. References"></a>7. References</h2><ul><li><a href="https://howtodoinjava.com/java/collections/hashmap/java-hashmap/">Guide to Java HashMap</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>hasMap</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD分层架构、洋葱架构、六边形架构</title>
    <link href="/2022/09/13/java/DDD%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E3%80%81%E6%B4%8B%E8%91%B1%E6%9E%B6%E6%9E%84%E3%80%81%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84/"/>
    <url>/2022/09/13/java/DDD%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E3%80%81%E6%B4%8B%E8%91%B1%E6%9E%B6%E6%9E%84%E3%80%81%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h2 id="一、DDD分层架构"><a href="#一、DDD分层架构" class="headerlink" title="一、DDD分层架构"></a>一、DDD分层架构</h2><p>DDD分层架构中有很重要的依赖原则：每层只能与位于下方的层发生耦合，类似于网络的7层或TCP/IP的4层模型架构，每一层各司其职，并且只关心向下一层的实现，而不会出现各层耦合。</p><p>DDD分层架构中包含四层：从上到下分别是用户接口层，应用层，领域层和基础层。</p><p><img src="DDD%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84.png"></p><h2 id="二、洋葱架构"><a href="#二、洋葱架构" class="headerlink" title="二、洋葱架构"></a>二、洋葱架构</h2><p>2008年Jeffrey Palermo已经提出了具有分层思想的洋葱架构，如下图，同心圆代表软件的不同部分，从里向外依次是领域模型，领域服务，应用服务和外层的基础设施和用户终端。</p><p>洋葱架构根据依赖原则，定义了各层的依赖关系，越往里依赖程度越低，代码级别越高，越是核心能力。外圆代码依赖只能指向内圆，内圆不需要知道外圆的情况，这种架构也是典型的分层架构，和DDD分层架构一样，都体现了高内聚，低耦合的设计特性。洋葱架构也常作为指导微服务设计的重要架构之一。</p><p><img src="%E6%B4%8B%E8%91%B1%E6%9E%B6%E6%9E%84.png"></p><h2 id="三、六边形架构"><a href="#三、六边形架构" class="headerlink" title="三、六边形架构"></a>三、六边形架构</h2><p>2005年Alistair Cockburn提出了六边形架构，在这个架构中，将应用分为内六边形和外六边形两层，内六边形实现应用的核心业务逻辑。外六边形完成外部应用，基础资源等的交互和访问，对于与不同的外部系统交互，由外六边形的适配器负责协议转换，保证内六边形业务逻辑的干净。</p><p>这种架构也是典型的分层架构，和DDD分层架构一样，都体现了高内聚，低耦合的设计特性。六边形也常作为指导微服务设计的重要架构之一。</p><p><img src="%E5%85%AD%E8%BE%B9%E5%BD%A2%E6%9E%B6%E6%9E%84.png"></p><h2 id="四、DDD分层协作"><a href="#四、DDD分层协作" class="headerlink" title="四、DDD分层协作"></a>四、DDD分层协作</h2><p>DDD各层的主要职责和怎么分工协作如下图：</p><p><img src="DDD%E5%88%86%E5%B1%82%E5%8D%8F%E4%BD%9C.png"></p><p>PO（数据持久化对象）：与数据库字段映射的数据载体</p><p>DO（领域对象）：领域模型核心业务对象的载体，包括实体和值对象</p><p>DTO（数据传输对象）：用于前端和微服务交互的数据传输载体</p><p><strong>用户接口层：主要有facade接口，Assembler转换器</strong></p><ul><li>微服务面向不同前端时，需要展示的数据可能不同，此时由于需要保持领域核心业务逻辑的稳定，不可能去定制开发各种领域服务和应用服务编排。因此，为避免暴露服务端业务逻辑，防止非必需的字段数据外泄<br>，同时保证领域逻辑的干净，用户接口层的facade接口和Assembler转换器就发挥作用了。</li><li>facade接口用于封装应用服务，适配不同前端需要的字段，提供不同要求的服务接口适配。Assembler根据不同前端的数据请求，完成DTO和领域DO对象的组装，转换，完成数据适配。</li></ul><p><strong>应用层：</strong></p><ul><li><p>应用层连接用户接口层和领域层，主要协调领域层，面向用例和业务流程，协调多个聚合完成服务的组合和编排，在这一层不实现任何业务逻辑，只是很薄的一层</p></li><li><p>如何判定一个东西是否属于业务逻辑？</p><p>很简单，只需设想你和产品聊这个事情时，需不需要把这部分信息输入给它？比如接口调用的处理，数据的转换，是否加了缓存等等都不属于产品关心的东西，所以不算是业务逻辑</p></li><li><p>应用层编排成应用服务后，被接口层facade封装，完成接口和数据适配后，以粗粒度向API网关发布服务</p></li><li><p>应用层还负责事件的订阅和发布，以及与其他外部服务的交互，事件的具体实现则在领域层</p></li></ul><p><strong>领域层：</strong></p><ul><li>领域层位于应用层之下，是领域模型的核心，主要实现领域模型的核心业务逻辑，体现领域模型的业务能力</li><li>领域层关注实现领域对象的充血模型和聚合本身的原子业务逻辑，至于用户操作和业务流程，则交给应用层去编排。这样设计可以保证领域模型不容易受外部需求变化的影响，保证领域模型的稳定</li><li>跨多个聚合的领域逻辑在领域层实现，由领域服务组织和协调多聚合的多实体，实现原子业务逻辑</li></ul><p><strong>基础层：</strong></p><ul><li>基础层贯穿了DDD所有层，包括第三方工具，API网关，消息中间件，分布式事务，消息最终一致性能力，数据库，缓存能能力的提供。</li><li>基础层有仓储模式的代码逻辑，通过仓储接口和仓储实现，解耦领域层和基础层，保证领域核心业务逻辑的干净，降低DB资源变化给领域层带来的影响，这部分内容，请见下回分解。</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li>《基于DDD和微服务的中台架构与实现》欧创新、邓頔</li><li>《领域驱动设计》Eric Evans</li><li>《架构真经》Martin L. Abbott</li><li><a href="https://www.cnblogs.com/jiyukai/p/14830869.html">DDD—分层架构、洋葱架构、六边形架构</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>architecture</tag>
      
      <tag>DDD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>COLA 4.0:应用架构的最佳实践</title>
    <link href="/2022/09/13/java/COLA%204.0%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <url>/2022/09/13/java/COLA%204.0%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://blog.csdn.net/significantfrank/article/details/110934799">COLA 4.0：应用架构的最佳实践</a></li><li><a href="https://github.com/alibaba/COLA">COLA</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>architecture</tag>
      
      <tag>COLA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Collections in Java</title>
    <link href="/2022/09/13/java/Collections%20in%20Java/"/>
    <url>/2022/09/13/java/Collections%20in%20Java/</url>
    
    <content type="html"><![CDATA[<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://howtodoinjava.com/java-collections/">Collections in Java</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>Collections</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/09/13/hello-world/"/>
    <url>/2022/09/13/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>5种限流算法,7种限流方式,挡住突发流量</title>
    <link href="/2022/09/13/java/5%20%E7%A7%8D%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%EF%BC%8C7%20%E7%A7%8D%E9%99%90%E6%B5%81%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%8C%A1%E4%BD%8F%E7%AA%81%E5%8F%91%E6%B5%81%E9%87%8F/"/>
    <url>/2022/09/13/java/5%20%E7%A7%8D%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95%EF%BC%8C7%20%E7%A7%8D%E9%99%90%E6%B5%81%E6%96%B9%E5%BC%8F%EF%BC%8C%E6%8C%A1%E4%BD%8F%E7%AA%81%E5%8F%91%E6%B5%81%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img.wdbyte.com/git/2021/20220314204028.png"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近几年，随着微服务的流行，服务和服务之间的依赖越来越强，调用关系越来越复杂，服务和服务之间的<strong>稳定性</strong>越来越重要。在遇到突发的请求量激增，恶意的用户访问，亦或请求频率过高给下游服务带来较大压力时，我们常常需要通过缓存、限流、熔断降级、负载均衡等多种方式保证服务的稳定性。其中<strong>限流</strong>是不可或缺的一环，这篇文章介绍<strong>限流</strong>相关知识。</p><h2 id="1-限流"><a href="#1-限流" class="headerlink" title="1. 限流"></a>1. 限流</h2><p><strong>限流</strong>顾名思义，就是对请求或并发数进行限制；通过对一个时间窗口内的请求量进行限制来保障系统的正常运行。如果我们的服务资源有限、处理能力有限，就需要对调用我们服务的上游请求进行限制，以防止自身服务由于资源耗尽而停止服务。</p><p>在限流中有两个概念需要了解。</p><ul><li>  <strong>阈值</strong>：在一个单位时间内允许的请求量。如 QPS 限制为10，说明 1 秒内最多接受 10 次请求。</li><li>  <strong>拒绝策略</strong>：超过阈值的请求的拒绝策略，常见的拒绝策略有直接拒绝、排队等待等。</li></ul><h2 id="2-固定窗口算法"><a href="#2-固定窗口算法" class="headerlink" title="2. 固定窗口算法"></a>2. 固定窗口算法</h2><p><strong>固定窗口算法</strong>又叫<strong>计数器算法</strong>，是一种<strong>简单</strong>方便的限流算法。主要通过一个支持<strong>原子操作</strong>的计数器来累计 1 秒内的请求次数，当 1 秒内计数达到限流阈值时触发拒绝策略。每过 1 秒，计数器重置为 0 开始重新计数。</p><h3 id="2-1-代码实现"><a href="#2-1-代码实现" class="headerlink" title="2.1. 代码实现"></a>2.1. 代码实现</h3><p>下面是简单的代码实现，QPS 限制为 2，这里的代码做了一些<strong>优化</strong>，并没有单独开一个线程去每隔 1 秒重置计数器，而是在每次调用时进行时间间隔计算来确定是否先重置计数器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> https://www.wdbyte.com</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimiterSimpleWindow</span> &#123;<br>    <span class="hljs-comment">// 阈值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">QPS</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">// 时间窗口（毫秒）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-variable">TIME_WINDOWS</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>    <span class="hljs-comment">// 计数器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">REQ_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-variable">START_TIME</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> ((System.currentTimeMillis() - START_TIME) &gt; TIME_WINDOWS) &#123;<br>            REQ_COUNT.set(<span class="hljs-number">0</span>);<br>            START_TIME = System.currentTimeMillis();<br>        &#125;<br>        <span class="hljs-keyword">return</span> REQ_COUNT.incrementAndGet() &lt;= QPS;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            Thread.sleep(<span class="hljs-number">250</span>);<br>            <span class="hljs-type">LocalTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalTime.now();<br>            <span class="hljs-keyword">if</span> (!tryAcquire()) &#123;<br>                System.out.println(now + <span class="hljs-string">&quot; 被限流&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(now + <span class="hljs-string">&quot; 做点什么&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs log">20:53:43.038922 做点什么<br>20:53:43.291435 做点什么<br>20:53:43.543087 被限流<br>20:53:43.796666 做点什么<br>20:53:44.050855 做点什么<br>20:53:44.303547 被限流<br>20:53:44.555008 被限流<br>20:53:44.809083 做点什么<br>20:53:45.063828 做点什么<br>20:53:45.314433 被限流<br></code></pre></td></tr></table></figure><p>从输出结果中可以看到大概每秒操作 3 次，由于限制 QPS 为 2，所以平均会有一次被限流。看起来可以了，不过我们思考一下就会发现这种简单的限流方式是有问题的，虽然我们限制了 QPS 为 2，但是当遇到时间窗口的临界突变时，如 1s 中的后 500 ms 和第 2s 的前 500ms 时，虽然是加起来是 1s 时间，却可以被请求 4 次。</p><p><img src="https://img.wdbyte.com/git/2021/20220223215006.png" alt="固定窗口算法"></p><p>简单修改测试代码，可以进行验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先休眠 400ms，可以更快的到达时间窗口。</span><br>Thread.sleep(<span class="hljs-number">400</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    Thread.sleep(<span class="hljs-number">250</span>);<br>    <span class="hljs-keyword">if</span> (!tryAcquire()) &#123;<br>        System.out.println(<span class="hljs-string">&quot;被限流&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;做点什么&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>得到输出中可以看到连续 4 次请求，间隔 250 ms 没有却被限制。：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">20:51:17.395087 做点什么<br>20:51:17.653114 做点什么<br>20:51:17.903543 做点什么<br>20:51:18.154104 被限流<br>20:51:18.405497 做点什么<br>20:51:18.655885 做点什么<br>20:51:18.906177 做点什么<br>20:51:19.158113 被限流<br>20:51:19.410512 做点什么<br>20:51:19.661629 做点什么<br></code></pre></td></tr></table></figure><h2 id="3-滑动窗口算法"><a href="#3-滑动窗口算法" class="headerlink" title="3. 滑动窗口算法"></a>3. 滑动窗口算法</h2><p>我们已经知道固定窗口算法的实现方式以及它所存在的问题，而滑动窗口算法是对固定窗口算法的改进。既然固定窗口算法在遇到时间窗口的临界突变时会有问题，那么我们在遇到下一个时间窗口前也调整时间窗口不就可以了吗？</p><p>下面是滑动窗口的示意图。</p><p><img src="https://img.wdbyte.com/git/2021/20220223215316.png" alt="滑动窗口算法"></p><p>上图的示例中，每 500ms 滑动一次窗口，可以发现窗口滑动的间隔越短，时间窗口的临界突变问题发生的概率也就越小，不过只要有时间窗口的存在，还是有可能发生<strong>时间窗口的临界突变问题</strong>。</p><h3 id="3-1-代码实现"><a href="#3-1-代码实现" class="headerlink" title="3.1. 代码实现"></a>3.1. 代码实现</h3><p>下面是基于以上滑动窗口思路实现的简单的滑动窗口限流工具类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wdbyte.rate.limiter;<br><br><span class="hljs-keyword">import</span> java.time.LocalTime;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 滑动窗口限流工具类</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> https://www.wdbyte.com</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimiterSlidingWindow</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 阈值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">qps</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 时间窗口总大小（毫秒）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">windowSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 多少个子窗口</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">windowCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 窗口列表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> WindowInfo[] windowArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowInfo</span>[windowCount];<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RateLimiterSlidingWindow</span><span class="hljs-params">(<span class="hljs-type">int</span> qps)</span> &#123;<br>        <span class="hljs-built_in">this</span>.qps = qps;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">currentTimeMillis</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; windowArray.length; i++) &#123;<br>            windowArray[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowInfo</span>(currentTimeMillis, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. 计算当前时间窗口</span><br><span class="hljs-comment">     * 2. 更新当前窗口计数 &amp; 重置过期窗口计数</span><br><span class="hljs-comment">     * 3. 当前 QPS 是否超过限制</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">currentTimeMillis</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">// 1. 计算当前时间窗口</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">currentIndex</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(currentTimeMillis % windowSize / (windowSize / windowCount));<br>        <span class="hljs-comment">// 2.  更新当前窗口计数 &amp; 重置过期窗口计数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; windowArray.length; i++) &#123;<br>            <span class="hljs-type">WindowInfo</span> <span class="hljs-variable">windowInfo</span> <span class="hljs-operator">=</span> windowArray[i];<br>            <span class="hljs-keyword">if</span> ((currentTimeMillis - windowInfo.getTime()) &gt; windowSize) &#123;<br>                windowInfo.getNumber().set(<span class="hljs-number">0</span>);<br>                windowInfo.setTime(currentTimeMillis);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (currentIndex == i &amp;&amp; windowInfo.getNumber().get() &lt; qps) &#123;<br>                windowInfo.getNumber().incrementAndGet();<br>            &#125;<br>            sum = sum + windowInfo.getNumber().get();<br>        &#125;<br>        <span class="hljs-comment">// 3. 当前 QPS 是否超过限制</span><br>        <span class="hljs-keyword">return</span> sum &lt;= qps;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WindowInfo</span> &#123;<br>        <span class="hljs-comment">// 窗口开始时间</span><br>        <span class="hljs-keyword">private</span> Long time;<br>        <span class="hljs-comment">// 计数器</span><br>        <span class="hljs-keyword">private</span> AtomicInteger number;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">WindowInfo</span><span class="hljs-params">(<span class="hljs-type">long</span> time, AtomicInteger number)</span> &#123;<br>            <span class="hljs-built_in">this</span>.time = time;<br>            <span class="hljs-built_in">this</span>.number = number;<br>        &#125;<br>        <span class="hljs-comment">// get...set...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>77</p><p>下面是测试用例，设置 QPS 为 2,测试次数 20 次，每次间隔 300 毫秒，预计成功次数在 12 次左右。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">qps</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>, count = <span class="hljs-number">20</span>, sleep = <span class="hljs-number">300</span>, success = count * sleep / <span class="hljs-number">1000</span> * qps;<br>    System.out.println(String.format(<span class="hljs-string">&quot;当前QPS限制为:%d,当前测试次数:%d,间隔:%dms,预计成功次数:%d&quot;</span>, qps, count, sleep, success));<br>    success = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">RateLimiterSlidingWindow</span> <span class="hljs-variable">myRateLimiter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RateLimiterSlidingWindow</span>(qps);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        Thread.sleep(sleep);<br>        <span class="hljs-keyword">if</span> (myRateLimiter.tryAcquire()) &#123;<br>            success++;<br>            <span class="hljs-keyword">if</span> (success % qps == <span class="hljs-number">0</span>) &#123;<br>                System.out.println(LocalTime.now() + <span class="hljs-string">&quot;: success, &quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.print(LocalTime.now() + <span class="hljs-string">&quot;: success, &quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(LocalTime.now() + <span class="hljs-string">&quot;: fail&quot;</span>);<br>        &#125;<br>    &#125;<br>    System.out.println();<br>    System.out.println(<span class="hljs-string">&quot;实际测试成功次数:&quot;</span> + success);<br>&#125;<br></code></pre></td></tr></table></figure><p>下面是测试的结果。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">当前QPS限制为:2,当前测试次数:20,间隔:300ms,预计成功次数:12<br>16:04:27.077782: success, 16:04:27.380715: success, <br>16:04:27.684244: fail<br>16:04:27.989579: success, 16:04:28.293347: success, <br>16:04:28.597658: fail<br>16:04:28.901688: fail<br>16:04:29.205262: success, 16:04:29.507117: success, <br>16:04:29.812188: fail<br>16:04:30.115316: fail<br>16:04:30.420596: success, 16:04:30.725897: success, <br>16:04:31.028599: fail<br>16:04:31.331047: fail<br>16:04:31.634127: success, 16:04:31.939411: success, <br>16:04:32.242380: fail<br>16:04:32.547626: fail<br>16:04:32.847965: success, <br>实际测试成功次数:11<br></code></pre></td></tr></table></figure><h2 id="4-滑动日志算法"><a href="#4-滑动日志算法" class="headerlink" title="4. 滑动日志算法"></a>4. 滑动日志算法</h2><p>滑动日志算法是实现限流的另一种方法，这种方法比较简单。基本逻辑就是记录下所有的请求时间点，新请求到来时先判断最近指定时间范围内的请求数量是否超过指定阈值，由此来确定是否达到限流，这种方式没有了时间窗口突变的问题，限流比较准确，但是因为要记录下每次请求的时间点，所以<strong>占用的内存较多</strong>。</p><h3 id="4-1-代码实现"><a href="#4-1-代码实现" class="headerlink" title="4.1. 代码实现"></a>4.1. 代码实现</h3><p>下面是简单实现的 一个滑动日志算法，因为滑动日志要每次请求单独存储一条记录，可能占用内存过多。所以下面这个实现其实不算严谨的滑动日志，更像一个把 1 秒时间切分成 1000 个时间窗口的滑动窗口算法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.wdbyte.rate.limiter;<br><br><span class="hljs-keyword">import</span> java.time.LocalTime;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Set;<br><span class="hljs-keyword">import</span> java.util.TreeMap;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 滑动日志方式限流</span><br><span class="hljs-comment"> * 设置 QPS 为 2.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> https://www.wdbyte.com</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimiterSildingLog</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 阈值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">qps</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 记录请求的时间戳,和数量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> TreeMap&lt;Long, Long&gt; treeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 清理请求记录间隔, 60 秒</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">claerTime</span> <span class="hljs-operator">=</span> <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RateLimiterSildingLog</span><span class="hljs-params">(Integer qps)</span> &#123;<br>        <span class="hljs-built_in">this</span>.qps = qps;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">// 清理过期的数据老数据，最长 60 秒清理一次</span><br>        <span class="hljs-keyword">if</span> (!treeMap.isEmpty() &amp;&amp; (treeMap.firstKey() - now) &gt; claerTime) &#123;<br>            Set&lt;Long&gt; keySet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(treeMap.subMap(<span class="hljs-number">0L</span>, now - <span class="hljs-number">1000</span>).keySet());<br>            <span class="hljs-keyword">for</span> (Long key : keySet) &#123;<br>                treeMap.remove(key);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 计算当前请求次数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (Long value : treeMap.subMap(now - <span class="hljs-number">1000</span>, now).values()) &#123;<br>            sum += value;<br>        &#125;<br>        <span class="hljs-comment">// 超过QPS限制，直接返回 false</span><br>        <span class="hljs-keyword">if</span> (sum + <span class="hljs-number">1</span> &gt; qps) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 记录本次请求</span><br>        <span class="hljs-keyword">if</span> (treeMap.containsKey(now)) &#123;<br>            treeMap.compute(now, (k, v) -&gt; v + <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            treeMap.put(now, <span class="hljs-number">1L</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum &lt;= qps;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">RateLimiterSildingLog</span> <span class="hljs-variable">rateLimiterSildingLog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RateLimiterSildingLog</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            Thread.sleep(<span class="hljs-number">250</span>);<br>            <span class="hljs-type">LocalTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalTime.now();<br>            <span class="hljs-keyword">if</span> (rateLimiterSildingLog.tryAcquire()) &#123;<br>                System.out.println(now + <span class="hljs-string">&quot; 做点什么&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(now + <span class="hljs-string">&quot; 被限流&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中把阈值 QPS 设定为 3，运行可以得到如下日志：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">20:51:17.395087 做点什么<br>20:51:17.653114 做点什么<br>20:51:17.903543 做点什么<br>20:51:18.154104 被限流<br>20:51:18.405497 做点什么<br>20:51:18.655885 做点什么<br>20:51:18.906177 做点什么<br>20:51:19.158113 被限流<br>20:51:19.410512 做点什么<br>20:51:19.661629 做点什么<br></code></pre></td></tr></table></figure><h2 id="5-漏桶算法"><a href="#5-漏桶算法" class="headerlink" title="5. 漏桶算法"></a>5. 漏桶算法</h2><p>漏桶算法中的漏桶是一个形象的比喻，这里可以用生产者消费者模式进行说明，请求是一个生产者，每一个请求都如一滴水，请求到来后放到一个队列（漏桶）中，而桶底有一个孔，不断的漏出水滴，就如消费者不断的在消费队列中的内容，消费的速率（漏出的速度）等于限流阈值。即假如 QPS 为 2，则每 <code>1s / 2= 500ms</code> 消费一次。漏桶的桶有大小，就如队列的容量，当请求堆积超过指定容量时，会触发拒绝策略。</p><p>下面是漏桶算法的示意图。</p><p><img src="https://img.wdbyte.com/git/2021/20220225161827.png" alt="漏桶算法"></p><p>由介绍可以知道，漏桶模式中的消费处理总是能以恒定的速度进行，可以很好的<strong>保护自身系统</strong>不被突如其来的流量冲垮；但是这也是漏桶模式的缺点，假设 QPS 为 2，同时 2 个请求进来，2 个请求并不能同时进行处理响应，因为每 <code>1s / 2= 500ms</code> 只能处理一个请求。</p><h2 id="6-令牌桶算法"><a href="#6-令牌桶算法" class="headerlink" title="6. 令牌桶算法"></a>6. 令牌桶算法</h2><p>令牌桶算法同样是实现限流是一种常见的思路，最为常用的 Google 的 Java 开发工具包 Guava 中的限流工具类 RateLimiter 就是令牌桶的一个实现。令牌桶的实现思路类似于生产者和消费之间的关系。</p><p>系统服务作为生产者，按照指定频率向桶（容器）中添加令牌，如 QPS 为 2，每 500ms 向桶中添加一个令牌，如果桶中令牌数量达到阈值，则不再添加。</p><p>请求执行作为消费者，每个请求都需要去桶中拿取一个令牌，取到令牌则继续执行；如果桶中无令牌可取，就触发拒绝策略，可以是超时等待，也可以是直接拒绝本次请求，由此达到限流目的。</p><p>下面是令牌桶限流算法示意图。</p><p><img src="https://img.wdbyte.com/git/2021/20220225160801.png" alt="令牌桶算法"></p><p>思考令牌桶的实现可以以下特点。</p><ol><li> 1s / 阈值（QPS） = 令牌添加时间间隔。</li><li> 桶的容量等于限流的阈值，令牌数量达到阈值时，不再添加。</li><li> 可以适应流量突发，N 个请求到来只需要从桶中获取 N 个令牌就可以继续处理。</li><li> 有启动过程，令牌桶启动时桶中无令牌，然后按照令牌添加时间间隔添加令牌，若启动时就有阈值数量的请求过来，会因为桶中没有足够的令牌而触发拒绝策略，不过如 RateLimiter 限流工具已经优化了这类问题。</li></ol><h3 id="6-1-代码实现"><a href="#6-1-代码实现" class="headerlink" title="6.1. 代码实现"></a>6.1. 代码实现</h3><p>Google 的 Java 开发工具包 Guava 中的限流工具类 RateLimiter 就是令牌桶的一个实现，日常开发中我们也不会手动实现了，这里直接使用 RateLimiter 进行测试。</p><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.guava<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>guava<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>31.0.1-jre<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br></code></pre></td></tr></table></figure><p>RateLimiter 限流体验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// qps 2</span><br><span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> RateLimiter.create(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> LocalDateTime.now().format(DateTimeFormatter.ISO_LOCAL_TIME);<br>    System.out.println(time + <span class="hljs-string">&quot;:&quot;</span> + rateLimiter.tryAcquire());<br>    Thread.sleep(<span class="hljs-number">250</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中限制 QPS 为 2，也就是每隔 500ms 生成一个令牌，但是程序每隔 250ms 获取一次令牌，所以两次获取中只有一次会成功。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">17:19:06.797557:true<br>17:19:07.061419:false<br>17:19:07.316283:true<br>17:19:07.566746:false<br>17:19:07.817035:true<br>17:19:08.072483:false<br>17:19:08.326347:true<br>17:19:08.577661:false<br>17:19:08.830252:true<br>17:19:09.085327:false<br></code></pre></td></tr></table></figure><h3 id="6-2-思考"><a href="#6-2-思考" class="headerlink" title="6.2. 思考"></a>6.2. 思考</h3><p>虽然演示了 Google Guava 工具包中的 RateLimiter 的实现，但是我们需要思考一个问题，就是令牌的添加方式，如果按照指定间隔添加令牌，那么需要开一个线程去定时添加，如果有很多个接口很多个 RateLimiter 实例，<strong>线程数会随之增加</strong>，这显然不是一个好的办法。显然 Google 也考虑到了这个问题，在 RateLimiter 中，是<strong>在每次令牌获取时才进行计算令牌是否足够的</strong>。它通过存储的下一个令牌生成的时间，和当前获取令牌的时间差，再结合阈值，去计算令牌是否足够，同时再记录下一个令牌的生成时间以便下一次调用。</p><p>下面是 Guava 中 RateLimiter 类的子类 SmoothRateLimiter 的 <code>resync()</code> 方法的代码分析，可以看到其中的令牌计算逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">resync</span><span class="hljs-params">(<span class="hljs-type">long</span> nowMicros)</span> &#123; <span class="hljs-comment">// 当前微秒时间</span><br>    <span class="hljs-comment">// 当前时间是否大于下一个令牌生成时间</span><br>    <span class="hljs-keyword">if</span> (nowMicros &gt; <span class="hljs-built_in">this</span>.nextFreeTicketMicros) &#123; <br>      <span class="hljs-comment">// 可生成的令牌数 newPermits = （当前时间 - 下一个令牌生成时间）/ 令牌生成时间间隔。</span><br>      <span class="hljs-comment">// 如果 QPS 为2，这里的 coolDownIntervalMicros 就是 500000.0 微秒(500ms)</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">newPermits</span> <span class="hljs-operator">=</span> (<span class="hljs-type">double</span>)(nowMicros - <span class="hljs-built_in">this</span>.nextFreeTicketMicros) / <span class="hljs-built_in">this</span>.coolDownIntervalMicros();<br><span class="hljs-comment">// 更新令牌库存 storedPermits。</span><br>      <span class="hljs-built_in">this</span>.storedPermits = Math.min(<span class="hljs-built_in">this</span>.maxPermits, <span class="hljs-built_in">this</span>.storedPermits + newPermits);<br><span class="hljs-comment">// 更新下一个令牌生成时间 nextFreeTicketMicros</span><br>      <span class="hljs-built_in">this</span>.nextFreeTicketMicros = nowMicros;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-Redis-分布式限流"><a href="#7-Redis-分布式限流" class="headerlink" title="7. Redis 分布式限流"></a>7. Redis 分布式限流</h2><p>Redis 是一个开源的内存数据库，可以用来作为数据库、缓存、消息中间件等。Redis 是单线程的，又在内存中操作，所以速度极快，得益于 Redis 的各种特性，所以使用 Redis 实现一个限流工具是十分方便的。</p><p>下面的演示都基于Spring Boot 项目，并需要以下依赖。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>配置 Redis 信息。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">password:</span> <br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">shutdown-timeout:</span> <span class="hljs-string">100ms</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">5</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">10</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">8</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-string">1ms</span><br></code></pre></td></tr></table></figure><h3 id="7-1-固定窗口限流"><a href="#7-1-固定窗口限流" class="headerlink" title="7.1. 固定窗口限流"></a>7.1. 固定窗口限流</h3><p>Redis 中的固定窗口限流是使用 <code>incr</code> 命令实现的，<code>incr</code> 命令通常用来自增计数；如果我们使用时间戳信息作为 key，自然就可以统计每秒的请求量了，以此达到限流目的。</p><p>这里有两点要注意。</p><ol><li> 对于不存在的 key，第一次新增时，value 始终为 1。</li><li> INCR 和 EXPIRE 命令操作应该在一个<strong>原子操作</strong>中提交，以保证每个 key 都正确设置了过期时间，不然会有 key 值无法自动删除而导致的内存溢出。</li></ol><p>由于 Redis 中实现事务的复杂性，所以这里直接只用 <code>lua</code> 脚本来实现原子操作。下面是 <code>lua</code> 脚本内容。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">local</span> count = redis.call(<span class="hljs-string">&quot;incr&quot;</span>,KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">if</span> count == <span class="hljs-number">1</span> <span class="hljs-keyword">then</span><br>  redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>,KEYS[<span class="hljs-number">1</span>],ARGV[<span class="hljs-number">2</span>])<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">if</span> count &gt; <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">1</span>]) <span class="hljs-keyword">then</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>下面是使用 Spring Boot 中 <code>RedisTemplate</code> 来实现的 <code>lua</code> 脚本调用测试代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> https://www.wdbyte.com</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisLuaLimiterByIncr</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;limiter_&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">QPS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;4&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">EXPIRE_TIME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">redisLuaLimiterTests</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, IOException &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">15</span>; i++) &#123;<br>            Thread.sleep(<span class="hljs-number">200</span>);<br>            System.out.println(LocalTime.now() + <span class="hljs-string">&quot; &quot;</span> + acquire(<span class="hljs-string">&quot;user1&quot;</span>));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计数器限流</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-comment">// 当前秒数作为 key</span><br>        key = KEY_PREFIX + key + System.currentTimeMillis() / <span class="hljs-number">1000</span>;<br>        DefaultRedisScript&lt;Long&gt; redisScript = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>        redisScript.setResultType(Long.class);<br>        <span class="hljs-comment">//lua文件存放在resources目录下</span><br>        redisScript.setScriptSource(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceScriptSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;limiter.lua&quot;</span>)));<br>        <span class="hljs-keyword">return</span> stringRedisTemplate.execute(redisScript, Arrays.asList(key), QPS, EXPIRE_TIME) == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中虽然限制了 QPS 为 4，但是因为这种限流实现是把毫秒时间戳作为 key 的，所以会有临界窗口突变的问题，下面是运行结果，可以看到因为时间窗口的变化，导致了 QPS 超过了限制值 4。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">17:38:23.122044 true<br>17:38:23.695124 true<br>17:38:23.903220 true<br><span class="hljs-meta prompt_"># </span><span class="language-bash">此处有时间窗口变化，所以下面继续 <span class="hljs-literal">true</span></span><br>17:38:24.106206 true<br>17:38:24.313458 true<br>17:38:24.519431 true<br>17:38:24.724446 true<br>17:38:24.932387 false<br>17:38:25.137912 true<br>17:38:25.355595 true<br>17:38:25.558219 true<br>17:38:25.765801 true<br>17:38:25.969426 false<br>17:38:26.176220 true<br>17:38:26.381918 true<br></code></pre></td></tr></table></figure><h3 id="7-3-滑动窗口限流"><a href="#7-3-滑动窗口限流" class="headerlink" title="7.3. 滑动窗口限流"></a>7.3. 滑动窗口限流</h3><p>通过对上面的基于 <code>incr</code> 命令实现的 Redis 限流方式的测试，我们已经发现了固定窗口限流所带来的问题，在这篇文章的第三部分已经介绍了滑动窗口限流的优势，它可以大幅度降低因为窗口临界突变带来的问题，那么如何使用 Redis 来实现滑动窗口限流呢？</p><p>这里主要使用 <code>ZSET</code> 有序集合来实现滑动窗口限流，<code>ZSET</code> 集合有下面几个特点：</p><ol><li> ZSET 集合中的 key 值可以自动排序。</li><li> ZSET 集合中的 value 不能有重复值。</li><li> ZSET 集合可以方便的使用 ZCARD 命令获取元素个数。</li><li> ZSET 集合可以方便的使用 ZREMRANGEBYLEX 命令移除指定范围的 key 值。</li></ol><p>基于上面的四点特性，可以编写出基于 <code>ZSET</code> 的滑动窗口限流 <code>lua</code> 脚本。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">--KEYS[1]: 限流 key</span><br><span class="hljs-comment">--ARGV[1]: 时间戳 - 时间窗口</span><br><span class="hljs-comment">--ARGV[2]: 当前时间戳（作为score）</span><br><span class="hljs-comment">--ARGV[3]: 阈值</span><br><span class="hljs-comment">--ARGV[4]: score 对应的唯一value</span><br><span class="hljs-comment">-- 1. 移除时间窗口之前的数据</span><br>redis.call(<span class="hljs-string">&#x27;zremrangeByScore&#x27;</span>, KEYS[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>, ARGV[<span class="hljs-number">1</span>])<br><span class="hljs-comment">-- 2. 统计当前元素数量</span><br><span class="hljs-keyword">local</span> res = redis.call(<span class="hljs-string">&#x27;zcard&#x27;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-comment">-- 3. 是否超过阈值</span><br><span class="hljs-keyword">if</span> (res == <span class="hljs-literal">nil</span>) <span class="hljs-keyword">or</span> (res &lt; <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">3</span>])) <span class="hljs-keyword">then</span><br>    redis.call(<span class="hljs-string">&#x27;zadd&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>], ARGV[<span class="hljs-number">4</span>])<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>下面是使用 Spring Boot 中 <code>RedisTemplate</code> 来实现的 <code>lua</code> 脚本调用测试代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisLuaLimiterByZset</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;limiter_&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">QPS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;4&quot;</span>;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate stringRedisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">redisLuaLimiterTests</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, IOException &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">15</span>; i++) &#123;<br>            Thread.sleep(<span class="hljs-number">200</span>);<br>            System.out.println(LocalTime.now() + <span class="hljs-string">&quot; &quot;</span> + acquire(<span class="hljs-string">&quot;user1&quot;</span>));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 计数器限流</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        key = KEY_PREFIX + key;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">oldest</span> <span class="hljs-operator">=</span> String.valueOf(now - <span class="hljs-number">1_000</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> String.valueOf(now);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">scoreValue</span> <span class="hljs-operator">=</span> score;<br>        DefaultRedisScript&lt;Long&gt; redisScript = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>        redisScript.setResultType(Long.class);<br>        <span class="hljs-comment">//lua文件存放在resources目录下</span><br>        redisScript.setScriptSource(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ResourceScriptSource</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;limiter2.lua&quot;</span>)));<br>        <span class="hljs-keyword">return</span> stringRedisTemplate.execute(redisScript, Arrays.asList(key), oldest, score, QPS, scoreValue) == <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码中限制 QPS 为 4，运行结果信息与之一致。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs text">17:36:37.150370 true<br>17:36:37.716341 true<br>17:36:37.922577 true<br>17:36:38.127497 true<br>17:36:38.335879 true<br>17:36:38.539225 false<br>17:36:38.745903 true<br>17:36:38.952491 true<br>17:36:39.159497 true<br>17:36:39.365239 true<br>17:36:39.570572 false<br>17:36:39.776635 true<br>17:36:39.982022 true<br>17:36:40.185614 true<br>17:36:40.389469 true<br></code></pre></td></tr></table></figure><p>这里介绍了 Redis 实现限流的两种方式，当然使用 Redis 也可以实现漏桶和令牌桶两种限流算法，这里就不做演示了，感兴趣的可以自己研究下。</p><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a>8. 总结</h2><p>这篇文章介绍实现限流的几种方式，主要是<strong>窗口算法和桶算法</strong>，两者各有优势。</p><ul><li>  窗口算法实现简单，逻辑清晰，可以很直观的得到当前的 QPS 情况，但是会有时间窗口的临界突变问题，而且不像桶一样有队列可以缓冲。</li><li>桶算法虽然稍微复杂，不好统计 QPS 情况，但是桶算法也有优势所在。<ul><li>  漏桶模式消费速率恒定，可以很好的<strong>保护自身系统</strong>，可以对流量进行整形，但是面对突发流量不能快速响应。</li><li>  令牌桶模式可以面对突发流量，但是启动时会有缓慢加速的过程，不过常见的开源工具中已经对此优化。</li></ul></li></ul><p><strong>单机限流与分布式限流</strong></p><p>上面演示的基于代码形式的窗口算法和桶算法限流都适用于单机限流，如果需要分布式限流可以结合注册中心、负载均衡计算每个服务的限流阈值，但这样会降低一定精度，如果对精度要求不是太高，可以使用。</p><p>而 Redis 的限流，由于 Redis 的单机性，本身就可以用于分布式限流。使用 Redis 可以实现各种可以用于限流算法，如果觉得麻烦也可以使用开源工具如 redisson，已经封装了基于 Redis 的限流。</p><p><strong>其他限流工具</strong></p><p>文中已经提到了 <code>Guava</code> 的限流工具包，不过它毕竟是单机的，开源社区中也有很多分布式限流工具，如阿里开源的 Sentinel 就是不错的工具，Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</p><p>一如既往，文章中的代码存放在：<a href="https://github.com/niumoo/JavaNotes/tree/master/core-java-rate-limiter">github.com/niumoo/JavaNotes</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.wdbyte.com/java/rate-limiter.html">5 种限流算法，7 种限流方式，挡住突发流量</a></li><li><a href="https://redis.io/commands/incr">Redis INCR</a></li><li><a href="https://en.wikipedia.org/wiki/Rate_limiting">Rate Limiting Wikipedia</a></li><li><a href="https://www.cnblogs.com/lenve/p/10965667.html">SpringBoot Redis</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>限流</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Structs</title>
    <link href="/2022/09/13/go/Structs/"/>
    <url>/2022/09/13/go/Structs/</url>
    
    <content type="html"><![CDATA[<h2 id="Go’s-structs-are-typed-collections-of-fields-They’re-useful-for-grouping-data-together-to-form-records"><a href="#Go’s-structs-are-typed-collections-of-fields-They’re-useful-for-grouping-data-together-to-form-records" class="headerlink" title="Go’s structs are typed collections of fields. They’re useful for grouping data together to form records."></a>Go’s structs are typed collections of fields. They’re useful for grouping data together to form records.</h2><h2 id="The-Go-Playground"><a href="#The-Go-Playground" class="headerlink" title="The Go Playground"></a><a href="https://go.dev/play/p/n7jt1x3iw4Z">The Go Playground</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-comment">// This `person` struct type has `name` and `age` fields.</span><br><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-comment">// `newPerson` constructs a new person struct with the given name.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">newPerson</span><span class="hljs-params">(name <span class="hljs-type">string</span>)</span></span> *person &#123;<br><span class="hljs-comment">// You can safely return a pointer to local variable</span><br><span class="hljs-comment">// as a local variable will survive the scope of the function.</span><br>p := person&#123;name: name&#125;<br>p.age = <span class="hljs-number">42</span><br><span class="hljs-keyword">return</span> &amp;p<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">// This syntax creates a new struct.</span><br>fmt.Println(person&#123;<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">20</span>&#125;)<br><br><span class="hljs-comment">// You can name the fields when initializing a struct.</span><br>fmt.Println(person&#123;name: <span class="hljs-string">&quot;Alice&quot;</span>, age: <span class="hljs-number">30</span>&#125;)<br><br><span class="hljs-comment">// Omitted fields will be zero-valued.</span><br>fmt.Println(person&#123;name: <span class="hljs-string">&quot;Fred&quot;</span>&#125;)<br><br><span class="hljs-comment">// An `&amp;` prefix yields a pointer to the struct.</span><br>fmt.Println(&amp;person&#123;name: <span class="hljs-string">&quot;Ann&quot;</span>, age: <span class="hljs-number">40</span>&#125;)<br><br><span class="hljs-comment">// It&#x27;s idiomatic to encapsulate new struct creation in constructor functions</span><br>fmt.Println(newPerson(<span class="hljs-string">&quot;Jon&quot;</span>))<br><br><span class="hljs-comment">// Access struct fields with a dot.</span><br>s := person&#123;name: <span class="hljs-string">&quot;Sean&quot;</span>, age: <span class="hljs-number">50</span>&#125;<br>fmt.Println(s.name)<br><br><span class="hljs-comment">// You can also use dots with struct pointers - the</span><br><span class="hljs-comment">// pointers are automatically dereferenced.</span><br>sp := &amp;s<br>fmt.Println(sp.age)<br><br><span class="hljs-comment">// Structs are mutable.</span><br>sp.age = <span class="hljs-number">51</span><br>fmt.Println(sp.age)<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><a href="https://gobyexample.com/structs">Go by Example: Structs</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>Structs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Interfaces</title>
    <link href="/2022/09/13/go/Interfaces/"/>
    <url>/2022/09/13/go/Interfaces/</url>
    
    <content type="html"><![CDATA[<p><img src="1.png"></p><h2 id="Interfaces-are-named-collections-of-method-signatures"><a href="#Interfaces-are-named-collections-of-method-signatures" class="headerlink" title="Interfaces are named collections of method signatures."></a>Interfaces are named collections of method signatures.</h2><h2 id="The-Go-Playground"><a href="#The-Go-Playground" class="headerlink" title="The Go Playground"></a><a href="https://go.dev/play/p/XJASG4MxBQr">The Go Playground</a></h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// _Interfaces_ are named collections of method signatures.</span><br><br><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;math&quot;</span><br>)<br><br><span class="hljs-comment">// Here&#x27;s a basic interface for geometric shapes.</span><br><span class="hljs-keyword">type</span> geometry <span class="hljs-keyword">interface</span> &#123;<br>area() <span class="hljs-type">float64</span><br>perim() <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-comment">// For our example we&#x27;ll implement this interface on</span><br><span class="hljs-comment">// `rect` and `circle` types.</span><br><span class="hljs-keyword">type</span> rect <span class="hljs-keyword">struct</span> &#123;<br>width, height <span class="hljs-type">float64</span><br>&#125;<br><span class="hljs-keyword">type</span> circle <span class="hljs-keyword">struct</span> &#123;<br>radius <span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-comment">// To implement an interface in Go, we just need to</span><br><span class="hljs-comment">// implement all the methods in the interface. Here we</span><br><span class="hljs-comment">// implement `geometry` on `rect`s.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r rect)</span></span> area() <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> r.width * r.height<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r rect)</span></span> perim() <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*r.width + <span class="hljs-number">2</span>*r.height<br>&#125;<br><br><span class="hljs-comment">// The implementation for `circle`s.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c circle)</span></span> area() <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> math.Pi * c.radius * c.radius<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c circle)</span></span> perim() <span class="hljs-type">float64</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * math.Pi * c.radius<br>&#125;<br><br><span class="hljs-comment">// If a variable has an interface type, then we can call</span><br><span class="hljs-comment">// methods that are in the named interface. Here&#x27;s a</span><br><span class="hljs-comment">// generic `measure` function taking advantage of this</span><br><span class="hljs-comment">// to work on any `geometry`.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">measure</span><span class="hljs-params">(g geometry)</span></span> &#123;<br>fmt.Println(g)<br>fmt.Println(g.area())<br>fmt.Println(g.perim())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>r := rect&#123;width: <span class="hljs-number">3</span>, height: <span class="hljs-number">4</span>&#125;<br>c := circle&#123;radius: <span class="hljs-number">5</span>&#125;<br><br><span class="hljs-comment">// The `circle` and `rect` struct types both</span><br><span class="hljs-comment">// implement the `geometry` interface so we can use</span><br><span class="hljs-comment">// instances of</span><br><span class="hljs-comment">// these structs as arguments to `measure`.</span><br>measure(r)<br>measure(c)<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><a href="https://gobyexample.com/interfaces">Go by Example: Interfaces</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GO</tag>
      
      <tag>Interfaces</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dubbo自定义路由设置</title>
    <link href="/2022/09/13/dubbo/router/dubbo%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E8%AE%BE%E7%BD%AE/"/>
    <url>/2022/09/13/dubbo/router/dubbo%E8%87%AA%E5%AE%9A%E4%B9%89%E8%B7%AF%E7%94%B1%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>开发人员进行本地开发时,经常会出现接口调到k8s容器内的服务上,我们本地和k8s共用一个nacos服务.</p><p>根据调研,打算使用dubbo的自定义路由实现.本地服务调接口时,使用路由过滤掉k8s内部的provider地址,从而实现,本地consumer能够一直本地provider服务.</p><p>由于过滤了k8s内部实例的ip,因此需要,将此路由只能在本地生效,在k8s环境内失效,通过spring.profiles实现.</p><h3 id="实现自定义路由"><a href="#实现自定义路由" class="headerlink" title="实现自定义路由"></a>实现自定义路由</h3><h4 id="继承AbstractRouter"><a href="#继承AbstractRouter" class="headerlink" title="继承AbstractRouter"></a>继承AbstractRouter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.apache.dubbo.common.URL;<br><span class="hljs-keyword">import</span> org.apache.dubbo.rpc.Invocation;<br><span class="hljs-keyword">import</span> org.apache.dubbo.rpc.Invoker;<br><span class="hljs-keyword">import</span> org.apache.dubbo.rpc.RpcException;<br><span class="hljs-keyword">import</span> org.apache.dubbo.rpc.cluster.router.AbstractRouter;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IpRouter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractRouter</span> &#123;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">IpRouter</span><span class="hljs-params">(URL url)</span> &#123;<br>        <span class="hljs-built_in">super</span>(url);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; List&lt;Invoker&lt;T&gt;&gt; <span class="hljs-title function_">route</span><span class="hljs-params">(List&lt;Invoker&lt;T&gt;&gt; invokers, URL url, Invocation invocation)</span> <span class="hljs-keyword">throws</span> RpcException &#123;<br><br>        <span class="hljs-keyword">if</span> (!SpringContextUtil.isLocal()) &#123; <span class="hljs-comment">//仅在本地进行路由</span><br>            <span class="hljs-keyword">return</span> invokers;<br>        &#125;<br>        <br>        log.info(<span class="hljs-string">&quot; before route :&#123;&#125;,&#123;&#125;&quot;</span>, invokers.size(), invokers);<br>        <span class="hljs-keyword">if</span> (invokers.size() &lt;= <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//存在少于一个provider时不进行路由,可选</span><br>            <span class="hljs-keyword">return</span> invokers;<br>        &#125;<br><br>        <span class="hljs-comment">//存在多个provider时,过滤掉属于k8s内服务的provider,保留本地服务</span><br>        Predicate&lt;Invoker&lt;T&gt;&gt; useLocalIP = str -&gt; !str.getUrl().toServiceString().contains(<span class="hljs-string">&quot;10.0.80.9&quot;</span>);<br>        List&lt;Invoker&lt;T&gt;&gt; collect = invokers.stream().filter(useLocalIP).collect(Collectors.toList());<br><br>        log.info(<span class="hljs-string">&quot; after route:&#123;&#125;,&#123;&#125;&quot;</span>, collect.size(), collect);<br>        <span class="hljs-keyword">return</span> collect;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="实现RouterFactory"><a href="#实现RouterFactory" class="headerlink" title="实现RouterFactory"></a>实现RouterFactory</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> org.apache.dubbo.common.URL;<br><span class="hljs-keyword">import</span> org.apache.dubbo.common.extension.Activate;<br><span class="hljs-keyword">import</span> org.apache.dubbo.rpc.cluster.Router;<br><span class="hljs-keyword">import</span> org.apache.dubbo.rpc.cluster.RouterFactory;<br><br><span class="hljs-meta">@Activate(group = &quot;consumer&quot;)</span><span class="hljs-comment">//只在consumer侧激活</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IpRouterFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RouterFactory</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Router <span class="hljs-title function_">getRouter</span><span class="hljs-params">(URL url)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IpRouter</span>(url);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="加载RouterFactory"><a href="#加载RouterFactory" class="headerlink" title="加载RouterFactory"></a>加载RouterFactory</h4><p>在resources 目录下创建目录META-INF\dubbo<br>创建文件:org.apache.dubbo.rpc.cluster.RouterFactory,<br>值为:ip=com.wtt.demo.app.route.IpRouterFactory</p><h3 id="解决只在本地生效"><a href="#解决只在本地生效" class="headerlink" title="解决只在本地生效"></a>解决只在本地生效</h3><h4 id="创建SpringContextUtil工具类"><a href="#创建SpringContextUtil工具类" class="headerlink" title="创建SpringContextUtil工具类"></a>创建SpringContextUtil工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.beans.BeansException;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContextAware;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.function.Predicate;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringContextUtil</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextAware</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String[] getActiveProfileList() &#123;<br>        <span class="hljs-keyword">return</span> context.getEnvironment().getActiveProfiles();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Boolean <span class="hljs-title function_">isLocal</span><span class="hljs-params">()</span> &#123;<br>        String[] activeProfileList = getActiveProfileList();<br>        Predicate&lt;String&gt; containsLocalProfile = m -&gt; m.contains(<span class="hljs-string">&quot;local&quot;</span>);<br>        <span class="hljs-keyword">return</span> Arrays.stream(activeProfileList).anyMatch(containsLocalProfile);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-built_in">this</span>.context = applicationContext;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><ul><li>深入理解Apache Dubbo与实战</li><li><a href="https://zzshuo.github.io/2021/05/21/005-dubbo-tag-invoker-chain/">dubbo自定义标签路由</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>dubbo</tag>
      
      <tag>router</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用docker搭建dnsmasq</title>
    <link href="/2022/09/13/dns/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAdnsmasq/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAdnsmasq/"/>
    <url>/2022/09/13/dns/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAdnsmasq/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAdnsmasq/</url>
    
    <content type="html"><![CDATA[<h3 id="关闭默认dns服务解决53端口被占用问题"><a href="#关闭默认dns服务解决53端口被占用问题" class="headerlink" title="关闭默认dns服务解决53端口被占用问题"></a>关闭默认dns服务解决53端口被占用问题</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">systemctl stop systemd-resolved<br>systemctl start systemd-resolved<br></code></pre></td></tr></table></figure><h3 id="docker启动命令"><a href="#docker启动命令" class="headerlink" title="docker启动命令"></a>docker启动命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run --name dnsmasq -d  --net=host \<br>--cap-add=NET_ADMIN  \<br>-v /home/baymax/dns/dnsmasq.conf:/etc/dnsmasq.conf \<br>-v /home/baymax/dns/resolv.conf:/etc/resolv.conf \<br> --log-opt &quot;max-size=100m&quot;   -e &quot;HTTP_USER=admin&quot;  -e &quot;HTTP_PASS=admin&quot; \<br>  --restart always jpillora/dnsmasq<br></code></pre></td></tr></table></figure><h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><p>本文未使用 –privileged,使用–cap-add和–cap-drop对功能进行细粒度控制</p><h3 id="DNS配置"><a href="#DNS配置" class="headerlink" title="DNS配置"></a>DNS配置</h3><p>修改/etc/resolv.conf目录下的nameserver为本机ip</p><h3 id="登录-http-localhost-8080-进行配置"><a href="#登录-http-localhost-8080-进行配置" class="headerlink" title="登录(http://localhost:8080)进行配置"></a>登录(<a href="http://localhost:8080)进行配置">http://localhost:8080)进行配置</a></h3><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h4><p>配置成功后直接在页面进行修改保存,启动即可</p><h4 id="配置文件demo"><a href="#配置文件demo" class="headerlink" title="配置文件demo"></a>配置文件demo</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">配置上行DNS</span><br>resolv-file=/etc/resolv.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">resolv.conf DNS寻址从上到下</span><br>strict-order<br><span class="hljs-meta prompt_"># </span><span class="language-bash">DNS解析hosts时对应的hosts文件，对应no-hosts</span><br>addn-hosts=/etc/hosts<br>cache-size=1024 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">多个IP用逗号分隔，192.168.x.x表示本机的ip地址，只有127.0.0.1的时候表示只有本机可以访问。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过这个设置就可以实现同一局域网内的设备，通过把网络DNS设置为本机IP从而实现局域网范围内的DNS泛解析(注：无效IP有可能导至服务无法启动）</span><br>listen-address=127.0.0.1,192.168.168.4<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重要！！这一行就是你想要泛解析的域名配置.</span><br>address=/baymax.bb/192.168.168.1<br>address=/blog.bb/192.168.168.1<br>address=/103.bb/192.168.168.2<br>address=/dns.bb/192.168.168.4<br>address=/gitlab.bb/192.168.168.4<br><span class="hljs-meta prompt_">#</span><span class="language-bash">指定使用哪个DNS服务器进行解析，对于不同的网站可以使用不同的域名对应解析。</span><br>server=/google.com/8.8.8.8<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">国内指定DNS</span><br>server=/bb/192.168.168.4<br>server=/cn/114.114.114.114<br>server=/com/8.8.8.8<br></code></pre></td></tr></table></figure><h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><ul><li>nslookup</li><li>dig</li><li>ping</li></ul><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><ul><li><a href="https://www.qikqiak.com/post/capabilities-on-k8s/">在 Kubernetes 中配置 Container Capabilities</a></li><li><a href="https://www.yisu.com/zixun/161163.html">Docker 1分钟搭建DNS服务器的方法</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>dns</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代理模式</title>
    <link href="/2022/09/13/design-patterns/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/09/13/design-patterns/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>提供另一个对象的代理或占位符来控制对它的访问</p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><h4 id="现实世界举例"><a href="#现实世界举例" class="headerlink" title="现实世界举例"></a>现实世界举例</h4><p>想象一下，有一座塔，当地的巫师去那里学习咒语。这个象牙塔只能通过一个代理访问，这个代理确保只有前三个巫师可以进入。这里的代理代表塔的功能并向其添加访问控制。</p><h4 id="大白话"><a href="#大白话" class="headerlink" title="大白话"></a>大白话</h4><p>使用代理模式，一个类代表另一个类的功能。</p><h4 id="维基百科解释"><a href="#维基百科解释" class="headerlink" title="维基百科解释"></a>维基百科解释</h4><p>代理，在其最一般的形式中，是作为其他事物的界面功能的类。代理是客户机调用的包装器或代理对象，用于在幕后访问真正的服务对象。<br>使用代理可以简单地转发到实际对象，也可以提供额外的逻辑。在代理中可以提供额外的功能，例如在对实际对象的操作是资源密集型时进行缓存，或者在调用对实际对象的操作之前检查先决条件。</p><h3 id="编程示例"><a href="#编程示例" class="headerlink" title="编程示例"></a>编程示例</h3><p>以我们上面的巫师塔为例。首先，我们有WizardTower接口和IvoryTower类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">WizardTower</span> &#123;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">enter</span><span class="hljs-params">(Wizard wizard)</span>;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IvoryTower</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WizardTower</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enter</span><span class="hljs-params">(Wizard wizard)</span> &#123;<br>    LOGGER.info(<span class="hljs-string">&quot;&#123;&#125; enters the tower.&quot;</span>, wizard);<br>  &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后是一个简单的Wizard类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Wizard</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Wizard</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> name;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>然后我们有了WizardTowerProxy来为WizardTower添加访问控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WizardTowerProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WizardTower</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NUM_WIZARDS_ALLOWED</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> numWizards;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WizardTower tower;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">WizardTowerProxy</span><span class="hljs-params">(WizardTower tower)</span> &#123;<br>    <span class="hljs-built_in">this</span>.tower = tower;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enter</span><span class="hljs-params">(Wizard wizard)</span> &#123;<br>    <span class="hljs-keyword">if</span> (numWizards &lt; NUM_WIZARDS_ALLOWED) &#123;<br>      tower.enter(wizard);<br>      numWizards++;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      LOGGER.info(<span class="hljs-string">&quot;&#123;&#125; is not allowed to enter!&quot;</span>, wizard);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是塔进入的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">var</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">WizardTowerProxy</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IvoryTower</span>());<br>proxy.enter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Wizard</span>(<span class="hljs-string">&quot;Red wizard&quot;</span>));<br>proxy.enter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Wizard</span>(<span class="hljs-string">&quot;White wizard&quot;</span>));<br>proxy.enter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Wizard</span>(<span class="hljs-string">&quot;Black wizard&quot;</span>));<br>proxy.enter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Wizard</span>(<span class="hljs-string">&quot;Green wizard&quot;</span>));<br>proxy.enter(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Wizard</span>(<span class="hljs-string">&quot;Brown wizard&quot;</span>));<br><br></code></pre></td></tr></table></figure><p>程序输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>Red wizard enters the tower.<br>White wizard enters the tower.<br>Black wizard enters the tower.<br>Green wizard is not allowed to enter!<br>Brown wizard is not allowed to enter!<br></code></pre></td></tr></table></figure><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="1.png"></p><h2 id="适应范围"><a href="#适应范围" class="headerlink" title="适应范围"></a>适应范围</h2><p>当需要比简单指针更通用或更复杂的对象引用时，代理是适用的。以下是代理模式适用的几种常见情况。</p><ul><li>远程代理为不同地址空间中的对象提供本地代表。</li><li>虚拟代理按需创建昂贵的对象。</li><li>保护代理控制对原始对象的访问。当对象应具有不同的访问权限时，保护代理很有用。</li></ul><p>通常，代理模式用于</p><ul><li>控制对另一个对象的访问</li><li>惰性初始化</li><li>实现日志记录</li><li>促进网络连接</li><li>计数对对象的引用</li></ul><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><a href="https://java-design-patterns.com/patterns/proxy/">Proxy</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>代理</tag>
      
      <tag>proxy</tag>
      
      <tag>译文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>苏格拉底的申辩</title>
    <link href="/2022/09/13/book/%E8%8B%8F%E6%A0%BC%E6%8B%89%E5%BA%95%E7%9A%84%E7%94%B3%E8%BE%A9/"/>
    <url>/2022/09/13/book/%E8%8B%8F%E6%A0%BC%E6%8B%89%E5%BA%95%E7%9A%84%E7%94%B3%E8%BE%A9/</url>
    
    <content type="html"><![CDATA[<p><img src="1.png"></p><h2 id="译者"><a href="#译者" class="headerlink" title="译者"></a>译者</h2><p>吴飞</p><h2 id="原文摘录"><a href="#原文摘录" class="headerlink" title="原文摘录"></a>原文摘录</h2><ul><li><p><strong>我很难赢得你们，不是因为缺少语言，而是缺乏勇气和无耻，我不愿对你们说那些你们最喜欢听得到话，我不哀悼，不悲恸，不做也不说别的很多我认为不合我品行、而你们习惯从别人那里听到的那些。我宁愿选择这样申辩而死，也不选择那样活着。</strong></p></li><li><p><strong>不过，是该走的时候了，我去死，你们去生。我们所去做的哪个事更好，谁也不知道，除了神。</strong></p></li><li><p><strong>一个未经省察的生活是不值得人过的生活</strong></p></li></ul><h2 id="短评"><a href="#短评" class="headerlink" title="短评"></a>短评</h2><p><strong>苏格拉底的申辩毋宁是哲学在政治面前的申辩，与孔子的礼法调和不同，苏格拉底宣判了哲学和政治间矛盾的不可化解，一个德性的原则，一个现实的原则，是理念和实践、应然和实然的分野，由此看，哲学永无法在尘世中战胜政治，只能获得德性的飞升。无知之知，“认识你自己”，局限，省察，VS康德反思性理念VS黑格尔辩证法。正义与众议，说服与取悦，真理与修辞。法庭是政治上取胜，苏却只想说出哲学真理。和康德以道德化的上帝代替宗教化的上帝一样，苏拉拉底的精灵在实质上亦改变了宗教基础。吴飞好牛，文风又晓畅，引言从奥古斯丁狄德罗卢梭到康德黑格尔马克思施特劳斯福柯，各种贯通。后边义疏理路十分清晰，简直没得多说。中间申辨数次感动，结尾牛逼闪闪。“不过，是该走的时候了，我去死，你们去生。我们所做的哪个事更好，谁也不知道，除非是神。</strong></p><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li><a href="https://book.douban.com/subject/2170983/">豆瓣读书</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哲学</tag>
      
      <tag>柏拉图注疏集</tag>
      
      <tag>吴飞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>活着</title>
    <link href="/2022/09/13/book/%E6%B4%BB%E7%9D%80/"/>
    <url>/2022/09/13/book/%E6%B4%BB%E7%9D%80/</url>
    
    <content type="html"><![CDATA[<p><img src="%E6%B4%BB%E7%9D%80.png"></p><h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>余华</p><h2 id="原文摘录"><a href="#原文摘录" class="headerlink" title="原文摘录"></a>原文摘录</h2><ul><li><p><strong>作为一个词语，“活着”在我们中国的语言中充满了力量，它的力量不是来自于喊叫，也不是来自于进攻，而是忍受，去忍受生命赋予我们的责任，去忍受现实给予我们的幸福和苦难、无聊和平庸。</strong></p></li><li><p><strong>做人不能忘记四条，话不要说错，床不要睡错，门槛不要踏错，口袋不要摸错。</strong></p></li><li><p><strong>做人还是平常点好，争这个争那个，争来争去赔了自己的命。</strong></p></li></ul><h2 id="短评"><a href="#短评" class="headerlink" title="短评"></a>短评</h2><p><strong>一个长寿的悲剧，生命本就是孤孤单单的来，最后只落得和一头牛为友，让它象征自己生命中走过的人们。这位曾经的富家子弟现在的垂垂老者，一生之中谨守本份，随波逐流，就像每个平凡的中国人，皆是有起有落的生活。</strong></p><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li><a href="https://book.douban.com/subject/1082154/">豆瓣读书</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文学</tag>
      
      <tag>余华</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>凤凰架构</title>
    <link href="/2022/09/13/book/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/"/>
    <url>/2022/09/13/book/%E5%87%A4%E5%87%B0%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><img src="1.png"></p><h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>周志明</p><h2 id="原文摘录"><a href="#原文摘录" class="headerlink" title="原文摘录"></a>原文摘录</h2><h2 id="短评"><a href="#短评" class="headerlink" title="短评"></a>短评</h2><p><strong>作者一如既往的高屋建瓴、用词严谨、逻辑清晰，深度与广度并存，适合一气读完。</strong></p><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li><a href="https://book.douban.com/subject/35492898/">豆瓣读书</a></li><li><a href="https://icyfenix.cn/">官方电子书链接</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机</tag>
      
      <tag>周志明</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>人人都是产品经理2.0</title>
    <link href="/2022/09/13/book/%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%862.0/"/>
    <url>/2022/09/13/book/%E4%BA%BA%E4%BA%BA%E9%83%BD%E6%98%AF%E4%BA%A7%E5%93%81%E7%BB%8F%E7%90%862.0/</url>
    
    <content type="html"><![CDATA[<p><img src="2.jpg"></p><h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>苏杰</p><h2 id="原文摘录"><a href="#原文摘录" class="headerlink" title="原文摘录"></a>原文摘录</h2><p><strong>一看到问题，马上就想答案，这是典型的“学生”思维，因为我们所 受的学校训练，绝大多数都是针对“经过简化的问题”：有确定的目标、 完备的信息，有刚刚学过的解法，有标准答案……而职场中，面对的问 题通常目标不明、信息片面、闻所未闻。特别对产品经理而言，各种用 户提的问题，一般都是经过扭曲、有欺骗性的，要怎么解决也没有标准 答案。</strong></p><h2 id="短评"><a href="#短评" class="headerlink" title="短评"></a>短评</h2><p><strong>苏杰这本书细说了人人都是产品经理这个名字的含义，从这个层面来看，未来确实人人都可能是“泛产品经理”，每个人都应该具备一定的产品思维，通过这些思路来解决生活和工作的问题。</strong></p><h2 id="references"><a href="#references" class="headerlink" title="references"></a>references</h2><ul><li><a href="https://book.douban.com/subject/27029547/">豆瓣读书</a></li></ul><p><img src="1.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>管理</tag>
      
      <tag>苏杰</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>丑陋的中国人</title>
    <link href="/2022/09/13/book/%E4%B8%91%E9%99%8B%E7%9A%84%E4%B8%AD%E5%9B%BD%E4%BA%BA/"/>
    <url>/2022/09/13/book/%E4%B8%91%E9%99%8B%E7%9A%84%E4%B8%AD%E5%9B%BD%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<p><img src="%E4%B8%91%E9%99%8B%E7%9A%84%E4%B8%AD%E5%9B%BD%E4%BA%BA.png"></p><h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>柏杨</p><h2 id="原文摘录"><a href="#原文摘录" class="headerlink" title="原文摘录"></a>原文摘录</h2><ul><li><p><strong>没有包容性的性格，如此这般狭窄的心胸，造成中国人两个极端，不够平衡。一方面是绝对的自卑，一方面是绝对的自傲。 自卑的时候，成了奴才；自傲的时候，成了主人！独独的，没有自尊。自卑的时候觉得自己是团狗屎，和权势走得越近，脸上的笑容越多。 自傲的时候觉得其他人都是狗屎，不屑一顾；变成了一种人格分裂的奇异动物。</strong></p></li><li><p><strong>”算了算了”四个字，不知害死了多少中国人，使我们民族的元气，受到挫伤。这种神经质的恐惧，是培养暴君、暴官最好的温床，所以中国的暴君、暴官，永远不会绝迹。 中国传统文化里———各位在《资治通鉴》中可以看到———一再强调明哲保身，暴君暴官最喜欢、最欣赏的就是人民明哲保身，所以中国人就越来越堕落萎缩</strong>。</p></li><li><p><strong>一个人生活在世上，就好像水泥搅拌器里的石子一样，运转起来之后，身不由主。使我们感到，不是某一个人的问题，而是社会问题，而是文化问题。 耶稣临死的时候说：＂宽容他们！他们做的他们不知道。</strong></p></li></ul><h2 id="短评"><a href="#短评" class="headerlink" title="短评"></a>短评</h2><ul><li><strong>这本书创作于十年文革结束，中国从动乱中开始觉醒的这个特殊时间，创作背景很特殊，但其中有些观点评论依旧适用于今日的中国。 有人说作者有些偏激，但有些观点确实就是这个社会的现状。这本书毁誉参半，我认为应该用历史观，辩证地看待它，还是有不小意义的。</strong></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://book.douban.com/subject/1027247/">豆瓣读书</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文学</tag>
      
      <tag>柏杨</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes网络权威指南：基础、原理与实践</title>
    <link href="/2022/09/13/book/Kubernetes%E7%BD%91%E7%BB%9C%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
    <url>/2022/09/13/book/Kubernetes%E7%BD%91%E7%BB%9C%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p><img src="img.png"></p><h2 id="作者"><a href="#作者" class="headerlink" title="作者"></a>作者</h2><p>杜军</p><h2 id="原文摘录"><a href="#原文摘录" class="headerlink" title="原文摘录"></a>原文摘录</h2><h2 id="短评"><a href="#短评" class="headerlink" title="短评"></a>短评</h2><ul><li><strong>1-3章还是比较基础的， 4章讲解了一些原理性的东西 总体比较全面吧，但是讲解的不是很深入，适合初学者。</strong></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://book.douban.com/subject/34855927/">豆瓣读书</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>network</tag>
      
      <tag>杜军</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WireGuard杂记</title>
    <link href="/2022/09/13/other/WireGuard%E6%9D%82%E8%AE%B0/"/>
    <url>/2022/09/13/other/WireGuard%E6%9D%82%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="安装WireGuard"><a href="#安装WireGuard" class="headerlink" title="安装WireGuard"></a>安装WireGuard</h2><h3 id="通过密钥对安装"><a href="#通过密钥对安装" class="headerlink" title="通过密钥对安装"></a>通过密钥对安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">wg genkey | tee aliyun_privatekey | wg pubkey &gt; aliyun_publickey<br>wg genkey | tee thinkpad_privatekey | wg pubkey &gt; thinkpad_publickey<br><br></code></pre></td></tr></table></figure><h3 id="通过wg-gen-web安装"><a href="#通过wg-gen-web安装" class="headerlink" title="通过wg-gen-web安装"></a>通过wg-gen-web安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker run  --name wg-web -itd -v /etc/wireguard:/data -p 8080:8080 -e &quot;WG_CONF_DIR=/data&quot; vx3r/wg-gen-web:latest<br></code></pre></td></tr></table></figure><h3 id="使用docker部署"><a href="#使用docker部署" class="headerlink" title="使用docker部署"></a>使用docker部署</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>docker run -d --network=host --name=wireguard  --cap-add=NET_ADMIN   --cap-add=SYS_MODULE   --restart unless-stopped   linuxserver/wireguard<br><br></code></pre></td></tr></table></figure><h3 id="使用k8s部署"><a href="#使用k8s部署" class="headerlink" title="使用k8s部署"></a>使用k8s部署</h3><h4 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">wg-deployment</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">selector:</span><br>    <span class="hljs-attr">matchLabels:</span><br>      <span class="hljs-attr">app:</span> <span class="hljs-string">wg</span><br>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">metadata:</span><br>      <span class="hljs-attr">labels:</span><br>        <span class="hljs-attr">app:</span> <span class="hljs-string">wg</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">wg</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">linuxserver/wireguard</span><br>        <span class="hljs-attr">securityContext:</span><br>          <span class="hljs-attr">capabilities:</span><br>            <span class="hljs-attr">add:</span> <span class="hljs-comment"># 添加</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">NET_ADMIN</span><br>      <span class="hljs-attr">hostNetwork:</span> <span class="hljs-literal">true</span><br><br></code></pre></td></tr></table></figure><h4 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">wireguard</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">containers:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">wireguard</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">linuxserver/wireguard</span><br>    <span class="hljs-attr">securityContext:</span><br>      <span class="hljs-attr">capabilities:</span><br>        <span class="hljs-attr">add:</span> <span class="hljs-comment"># 添加</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">NET_ADMIN</span><br>  <span class="hljs-attr">hostNetwork:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h2 id="通过WireGuard访问节点内局域网内ip"><a href="#通过WireGuard访问节点内局域网内ip" class="headerlink" title="通过WireGuard访问节点内局域网内ip"></a>通过WireGuard访问节点内局域网内ip</h2><p>使用iptables实现,需开启开启IP地址转发</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在需要使用的节点添加如下配置</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">xxx 为对应的网卡名</span><br>PostUp = iptables -A FORWARD -i %i -j ACCEPT<br>PostUp = iptables -t nat -A POSTROUTING -o xxx -j MASQUERADE<br>PostDown = iptables -D FORWARD -i %i -j ACCEPT<br>PostDown = iptables -t nat -D POSTROUTING -o xxx -j MASQUERADE<br><br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="WireGuard常用命令"><a href="#WireGuard常用命令" class="headerlink" title="WireGuard常用命令"></a>WireGuard常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">启动server端</span><br>systemctl start wg-quick@wg0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">新建节点后需要重启服务</span><br>systemctl restart wg-quick@wg0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询网卡信息</span><br>wg show wg0<br><br>sudo apt install wireguard<br>wg-quick up wg0<br>wg-quick down wg0<br><br></code></pre></td></tr></table></figure><h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">清除iptables规则：</span><br>iptables -P INPUT ACCEPT<br>iptables -P FORWARD ACCEPT<br>iptables -P OUTPUT ACCEPT<br>iptables -t nat -F<br>iptables -t mangle -F<br>iptables -F<br>iptables -X<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">清除ip6tables规则：</span><br>ip6tables -P INPUT ACCEPT<br>ip6tables -P FORWARD ACCEPT<br>ip6tables -P OUTPUT ACCEPT<br>ip6tables -t nat -F<br>ip6tables -t mangle -F<br>ip6tables -F<br>ip6tables -X<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用tcpdump监听client网口icmp包</span><br>tcpdump -i client icmp<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启IP地址转发</span><br>sysctl -w net.ipv4.ip_forward=1<br><span class="hljs-meta prompt_">#</span><span class="language-bash">查询ip地址转发是否开启</span><br>sysctl net.ipv4.ip_forward<br><br></code></pre></td></tr></table></figure><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>使用公网服务时,记得放开WireGuard使用的UDP端口</li><li>WireGuard未内置,则需要先安装(sudo apt install wireguard)</li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="884358.com/wireguard/#kai_qiIP_de_zhi_zhuan_fa">通过WireGuard实现内网穿透</a></li><li><a href="https://qastack.cn/server/200635/best-way-to-clear-all-iptables-rules">清除所有iptables规则的最佳方法</a></li><li><a href="https://github.com/vx3r/wg-gen-web">wg-gen-web</a></li><li><a href="https://www.zsythink.net/archives/category/%e8%bf%90%e7%bb%b4%e7%9b%b8%e5%85%b3/iptables">iptables</a></li><li><a href="https://icloudnative.io/posts/configure-wireguard-using-wg-gen-web/">WireGuard 配置教程：使用 wg-gen-web 来管理 WireGuard 的配置</a></li><li><a href="https://stackoverflow.com/questions/27708376/why-am-i-getting-an-rtnetlink-operation-not-permitted-when-using-pipework-with-d">Why am I getting an RTNETLINK Operation Not Permitted when using Pipework with Docker containers?</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>other</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WireGuard</tag>
      
      <tag>内网穿透</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Raft 动画演示</title>
    <link href="/2022/09/13/Raft%20%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA/"/>
    <url>/2022/09/13/Raft%20%E5%8A%A8%E7%94%BB%E6%BC%94%E7%A4%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="raft算法"><a href="#raft算法" class="headerlink" title="raft算法"></a>raft算法</h3><p>Raft 是一种为了管理复制日志的一致性算法。它提供了和 Paxos 算法相同的功能和性能，但是它的算法结构和 Paxos 不同，使得 Raft 算法更加容易理解并且更容易构建实际的系统。<br>为了提升可理解性，Raft 将一致性算法分解成了几个关键模块，如领导人选举、日志复制。这个演示动画就是为了方便理解这几个关键模块而设计的。</p><h3 id="动画演示地址"><a href="#动画演示地址" class="headerlink" title="动画演示地址"></a>动画演示地址</h3><ul><li><a href="http://www.kailing.pub/raft/index.html#home">中文</a></li><li><a href="http://thesecretlivesofdata.com/raft/">英文</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Raft</tag>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>034--设计模式常见面试题汇总</title>
    <link href="/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/034--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/034--%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h4 id="1-说一下设计模式？你都知道哪些？"><a href="#1-说一下设计模式？你都知道哪些？" class="headerlink" title="1.说一下设计模式？你都知道哪些？"></a>1.说一下设计模式？你都知道哪些？</h4><p>答：设计模式总共有 23 种，总体来说可以分为三大类：创建型模式（ Creational Patterns ）、结构型模式（ Structural Patterns ）和行为型模式（ Behavioral Patterns ）。</p><table><thead><tr><th align="left"><strong>分类</strong></th><th><strong>包含</strong></th><th><strong>关注点</strong></th></tr></thead><tbody><tr><td align="left">创建型模式</td><td>工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式</td><td>关注于对象的创建，同时隐藏创建逻辑</td></tr><tr><td align="left">结构型模式</td><td>适配器模式、过滤器模式、装饰模式、享元模式、代理模式、外观模式、组合模式、桥接模式</td><td>关注类和对象之间的组合</td></tr><tr><td align="left">行为型模式</td><td>责任链模式、命令模式、中介者模式、观察者模式、状态模式、策略模式、模板模式、空对象模式、备忘录模式、迭代器模式、解释器模式、访问者模式</td><td>关注对象之间的通信</td></tr></tbody></table><p>下面会对常用的设计模式分别做详细的说明。</p><h4 id="2-什么是单例模式？"><a href="#2-什么是单例模式？" class="headerlink" title="2.什么是单例模式？"></a>2.什么是单例模式？</h4><p>答：单例模式是一种常用的软件设计模式，在应用这个模式时，单例对象的类必须保证只有一个实例存在，整个系统只能使用一个对象实例。</p><p>优点：不会频繁地创建和销毁对象，浪费系统资源。</p><p>使用场景：IO 、数据库连接、Redis 连接等。</p><p>单例模式代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>单例模式调用代码：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Lesson7_3</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton1</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br>        <span class="hljs-type">Singleton</span> <span class="hljs-variable">singleton2</span> <span class="hljs-operator">=</span> Singleton.getInstance();<br>        System.out.println(singleton1 == singleton2); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序的输出结果：true</p><p>可以看出以上单例模式是在类加载的时候就创建了，这样会影响程序的启动速度，那如何实现单例模式的延迟加载？在使用时再创建？</p><p>单例延迟加载代码：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 单例模式-延迟加载版</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonLazy</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonLazy instance;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonLazy <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonLazy</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上为非线程安全的，单例模式如何支持多线程？</p><p>使用 synchronized 来保证，单例模式的线程安全代码：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonLazy</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> SingletonLazy instance;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> SingletonLazy <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonLazy</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-什么是简单工厂模式？"><a href="#3-什么是简单工厂模式？" class="headerlink" title="3.什么是简单工厂模式？"></a>3.什么是简单工厂模式？</h4><p>答：简单工厂模式又叫静态工厂方法模式，就是建立一个工厂类，对实现了同一接口的一些类进行实例的创建。比如，一台咖啡机就可以理解为一个工厂模式，你只需要按下想喝的咖啡品类的按钮（摩卡或拿铁），它就会给你生产一杯相应的咖啡，你不需要管它内部的具体实现，只要告诉它你的需求即可。</p><p><strong>优点</strong> ：</p><ul><li>工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅“消费”产品；简单工厂模式通过这种做法实现了对责任的分割，它提供了专门的工厂类用于创建对象；</li><li>客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量；</li><li>通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。</li></ul><p><strong>缺点</strong> ：</p><ul><li>不易拓展，一旦添加新的产品类型，就不得不修改工厂的创建逻辑；</li><li>产品类型较多时，工厂的创建逻辑可能过于复杂，一旦出错可能造成所有产品的创建失败，不利于系统的维护。</li></ul><p>简单工厂示意图如下：</p><p><img src="https://images.gitbook.cn/35024ce0-e066-11e9-bc61-0549c31758ee" alt="1"></p><p>简单工厂 <strong>代码实现</strong> ：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">createProduct</span><span class="hljs-params">(String product)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span> (product) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Mocca&quot;</span>:<br>                result = <span class="hljs-string">&quot;摩卡&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Latte&quot;</span>:<br>                result = <span class="hljs-string">&quot;拿铁&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                result = <span class="hljs-string">&quot;其他&quot;</span>;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-什么是抽象工厂模式？"><a href="#4-什么是抽象工厂模式？" class="headerlink" title="4.什么是抽象工厂模式？"></a>4.什么是抽象工厂模式？</h4><p>答：抽象工厂模式是在简单工厂的基础上将未来可能需要修改的代码抽象出来，通过继承的方式让子类去做决定。</p><p>比如，以上面的咖啡工厂为例，某天我的口味突然变了，不想喝咖啡了想喝啤酒，这个时候如果直接修改简单工厂里面的代码，这种做法不但不够优雅，也不符合软件设计的“开闭原则”，因为每次新增品类都要修改原来的代码。这个时候就可以使用抽象工厂类了，抽象工厂里只声明方法，具体的实现交给子类（子工厂）去实现，这个时候再有新增品类的需求，只需要新创建代码即可。</p><p>抽象工厂实现代码如下：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFactoryTest</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       <span class="hljs-comment">// 抽象工厂</span><br>       <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">CoffeeFactory</span>()).createProduct(<span class="hljs-string">&quot;Latte&quot;</span>);<br>       System.out.println(result); <span class="hljs-comment">// output:拿铁</span><br>   &#125;<br>&#125;<br><span class="hljs-comment">// 抽象工厂</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractFactory</span>&#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title function_">createProduct</span><span class="hljs-params">(String product)</span>;<br>&#125;<br><span class="hljs-comment">// 啤酒工厂</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BeerFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractFactory</span>&#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">createProduct</span><span class="hljs-params">(String product)</span> &#123;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>       <span class="hljs-keyword">switch</span> (product) &#123;<br>           <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Hans&quot;</span>:<br>               result = <span class="hljs-string">&quot;汉斯&quot;</span>;<br>               <span class="hljs-keyword">break</span>;<br>           <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Yanjing&quot;</span>:<br>               result = <span class="hljs-string">&quot;燕京&quot;</span>;<br>               <span class="hljs-keyword">break</span>;<br>           <span class="hljs-keyword">default</span>:<br>               result = <span class="hljs-string">&quot;其他啤酒&quot;</span>;<br>               <span class="hljs-keyword">break</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> result;<br>   &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 咖啡工厂</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CoffeeFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractFactory</span>&#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">createProduct</span><span class="hljs-params">(String product)</span> &#123;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>       <span class="hljs-keyword">switch</span> (product) &#123;<br>           <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Mocca&quot;</span>:<br>               result = <span class="hljs-string">&quot;摩卡&quot;</span>;<br>               <span class="hljs-keyword">break</span>;<br>           <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Latte&quot;</span>:<br>               result = <span class="hljs-string">&quot;拿铁&quot;</span>;<br>               <span class="hljs-keyword">break</span>;<br>           <span class="hljs-keyword">default</span>:<br>               result = <span class="hljs-string">&quot;其他咖啡&quot;</span>;<br>               <span class="hljs-keyword">break</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> result;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-什么是观察者模式？"><a href="#5-什么是观察者模式？" class="headerlink" title="5.什么是观察者模式？"></a>5.什么是观察者模式？</h4><p>观察者模式是定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅（Publish/Subscribe）模式、模型-视图（Model/View）模式、源-监听器（Source/Listener）模式或从属者（Dependents）模式。 </p><p><strong>优点</strong> ：</p><ul><li>观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色；</li><li>观察者模式在观察目标和观察者之间建立一个抽象的耦合；</li><li>观察者模式支持广播通信；</li><li>观察者模式符合开闭原则（对拓展开放，对修改关闭）的要求。</li></ul><p><strong>缺点</strong> ：</p><ul><li>如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间；</li><li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃；</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li></ul><p>在观察者模式中有如下角色：</p><ul><li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象；</li><li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知；</li><li>Observer：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己；</li><li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li></ul><p>观察者模式实现代码如下。</p><h5 id="1）定义观察者（消息接收方）"><a href="#1）定义观察者（消息接收方）" class="headerlink" title="1）定义观察者（消息接收方）"></a>1）定义观察者（消息接收方）</h5><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 观察者（消息接收方）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String message)</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 具体的观察者（消息接收方）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcrereObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Observer</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcrereObserver</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String message)</span> &#123;<br>        System.out.println(name + <span class="hljs-string">&quot;：&quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2）定义被观察者（消息发送方）"><a href="#2）定义被观察者（消息发送方）" class="headerlink" title="2）定义被观察者（消息发送方）"></a>2）定义被观察者（消息发送方）</h5><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 被观察者（消息发布方）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-comment">// 增加订阅者</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(Observer observer)</span>;<br>    <span class="hljs-comment">// 删除订阅者</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(Observer observer)</span>;<br>    <span class="hljs-comment">// 通知订阅者更新消息</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message)</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 具体被观察者（消息发布方）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subject</span> &#123;<br>    <span class="hljs-comment">// 订阅者列表（存储信息）</span><br>    <span class="hljs-keyword">private</span> List&lt;Observer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Observer&gt;();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attach</span><span class="hljs-params">(Observer observer)</span> &#123;<br>        list.add(observer);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">detach</span><span class="hljs-params">(Observer observer)</span> &#123;<br>        list.remove(observer);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Observer observer : list) &#123;<br>            observer.update(message);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3）代码调用"><a href="#3）代码调用" class="headerlink" title="3）代码调用"></a>3）代码调用</h5><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ObserverTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 定义发布者</span><br>        <span class="hljs-type">ConcreteSubject</span> <span class="hljs-variable">concreteSubject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcreteSubject</span>();<br>        <span class="hljs-comment">// 定义订阅者</span><br>        <span class="hljs-type">ConcrereObserver</span> <span class="hljs-variable">concrereObserver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcrereObserver</span>(<span class="hljs-string">&quot;老王&quot;</span>);<br>        <span class="hljs-type">ConcrereObserver</span> <span class="hljs-variable">concrereObserver2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcrereObserver</span>(<span class="hljs-string">&quot;Java&quot;</span>);<br>        <span class="hljs-comment">// 添加订阅</span><br>        concreteSubject.attach(concrereObserver);<br>        concreteSubject.attach(concrereObserver2);<br>        <span class="hljs-comment">// 发布信息</span><br>        concreteSubject.notify(<span class="hljs-string">&quot;更新了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行结果如下：</p><blockquote><p>老王：更新了</p></blockquote><blockquote></blockquote><blockquote><p>Java：更新了</p></blockquote><h4 id="6-什么是装饰器模式？"><a href="#6-什么是装饰器模式？" class="headerlink" title="6.什么是装饰器模式？"></a>6.什么是装饰器模式？</h4><p>答：装饰器模式是指动态地给一个对象增加一些额外的功能，同时又不改变其结构。</p><p><strong>优点</strong>：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p><p><strong>装饰器模式的关键</strong>：装饰器中使用了被装饰的对象。</p><p>比如，创建一个对象“laowang”，给对象添加不同的装饰，穿上夹克、戴上帽子……，这个执行过程就是装饰者模式，实现代码如下。</p><h5 id="1）定义顶层对象，定义行为"><a href="#1）定义顶层对象，定义行为" class="headerlink" title="1）定义顶层对象，定义行为"></a>1）定义顶层对象，定义行为</h5><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IPerson</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2）定义装饰器超类"><a href="#2）定义装饰器超类" class="headerlink" title="2）定义装饰器超类"></a>2）定义装饰器超类</h5><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoratorBase</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IPerson</span>&#123;<br>    IPerson iPerson;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DecoratorBase</span><span class="hljs-params">(IPerson iPerson)</span>&#123;<br>        <span class="hljs-built_in">this</span>.iPerson = iPerson;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        iPerson.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3）定义具体装饰器"><a href="#3）定义具体装饰器" class="headerlink" title="3）定义具体装饰器"></a>3）定义具体装饰器</h5><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Jacket</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DecoratorBase</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Jacket</span><span class="hljs-params">(IPerson iPerson)</span> &#123;<br>        <span class="hljs-built_in">super</span>(iPerson);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 执行已有功能</span><br>        iPerson.show();<br>        <span class="hljs-comment">// 定义新行为</span><br>        System.out.println(<span class="hljs-string">&quot;穿上夹克&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">DecoratorBase</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Hat</span><span class="hljs-params">(IPerson iPerson)</span> &#123;<br>        <span class="hljs-built_in">super</span>(iPerson);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 执行已有功能</span><br>        iPerson.show();<br>        <span class="hljs-comment">// 定义新行为</span><br>        System.out.println(<span class="hljs-string">&quot;戴上帽子&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4）定义具体对象"><a href="#4）定义具体对象" class="headerlink" title="4）定义具体对象"></a>4）定义具体对象</h5><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">LaoWang</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IPerson</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;什么都没穿&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5）装饰器模式调用"><a href="#5）装饰器模式调用" class="headerlink" title="5）装饰器模式调用"></a>5）装饰器模式调用</h5><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DecoratorTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LaoWang</span> <span class="hljs-variable">laoWang</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LaoWang</span>();<br>        <span class="hljs-type">Jacket</span> <span class="hljs-variable">jacket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Jacket</span>(laoWang);<br>        <span class="hljs-type">Hat</span> <span class="hljs-variable">hat</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Hat</span>(jacket);<br>        hat.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-什么是模板方法模式？"><a href="#7-什么是模板方法模式？" class="headerlink" title="7.什么是模板方法模式？"></a>7.什么是模板方法模式？</h4><p>答：模板方法模式是指定义一个模板结构，将具体内容延迟到子类去实现。</p><p><strong>优点</strong> ：</p><ul><li>提高代码复用性：将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中；</li><li>实现了反向控制：通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制并且符合开闭原则。</li></ul><p>以给冰箱中放水果为例，比如，我要放一个香蕉：开冰箱门 → 放香蕉 → 关冰箱门；如果我再要放一个苹果：开冰箱门 → 放苹果 →<br>关冰箱门。可以看出它们之间的行为模式都是一样的，只是存放的水果品类不同而已，这个时候就非常适用模板方法模式来解决这个问题，实现代码如下：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 添加模板方法 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Refrigerator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">open</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开冰箱门&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;关冰箱门&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Banana</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Refrigerator</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;放香蕉&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apple</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Refrigerator</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;放苹果&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 调用模板方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TemplateTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Refrigerator</span> <span class="hljs-variable">refrigerator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Banana</span>();<br>        refrigerator.open();<br>        refrigerator.put();<br>        refrigerator.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行结果：</p><blockquote><p>开冰箱门</p></blockquote><blockquote></blockquote><blockquote><p>放香蕉</p></blockquote><blockquote></blockquote><blockquote><p>关冰箱门</p></blockquote><h4 id="8-什么是代理模式？"><a href="#8-什么是代理模式？" class="headerlink" title="8.什么是代理模式？"></a>8.什么是代理模式？</h4><p>代理模式是给某一个对象提供一个代理，并由代理对象控制对原对象的引用。</p><p><strong>优点</strong> ：</p><ul><li>代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；</li><li>可以灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务。</li></ul><p><strong>缺点</strong> ：</p><ul><li>由于使用了代理模式，因此程序的性能没有直接调用性能高；</li><li>使用代理模式提高了代码的复杂度。</li></ul><p>举一个生活中的例子：比如买飞机票，由于离飞机场太远，直接去飞机场买票不太现实，这个时候我们就可以上携程 App 上购买飞机票，这个时候携程 App就相当于是飞机票的代理商。</p><p>代理模式实现代码如下：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 定义售票接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">IAirTicket</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">buy</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 定义飞机场售票</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AirTicket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IAirTicket</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buy</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;买票&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 代理售票平台</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyAirTicket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">IAirTicket</span> &#123;<br>    <span class="hljs-keyword">private</span> AirTicket airTicket;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProxyAirTicket</span><span class="hljs-params">()</span> &#123;<br>        airTicket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AirTicket</span>();<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buy</span><span class="hljs-params">()</span> &#123;<br>        airTicket.buy();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 代理模式调用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">IAirTicket</span> <span class="hljs-variable">airTicket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyAirTicket</span>();<br>        airTicket.buy();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="9-什么是策略模式？"><a href="#9-什么是策略模式？" class="headerlink" title="9.什么是策略模式？"></a>9.什么是策略模式？</h4><p>答：策略模式是指定义一系列算法，将每个算法都封装起来，并且使他们之间可以相互替换。</p><p><strong>优点</strong> ：遵循了开闭原则，扩展性良好。</p><p><strong>缺点</strong> ：随着策略的增加，对外暴露越来越多。</p><p>以生活中的例子来说，比如我们要出去旅游，选择性很多，可以选择骑车、开车、坐飞机、坐火车等，就可以使用策略模式，把每种出行作为一种策略封装起来，后面增加了新的交通方式了，如超级高铁、火箭等，就可以不需要改动原有的类，新增交通方式即可，这样也符合软件开发的开闭原则。<br>策略模式实现代码如下：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 声明旅行</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITrip</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">going</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bike</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITrip</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">going</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;骑自行车&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Drive</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITrip</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">going</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开车&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 定义出行类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Trip</span> &#123;<br>    <span class="hljs-keyword">private</span> ITrip trip;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Trip</span><span class="hljs-params">(ITrip trip)</span> &#123;<br>        <span class="hljs-built_in">this</span>.trip = trip;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doTrip</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.trip.going();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 执行方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Trip</span> <span class="hljs-variable">trip</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Trip</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Bike</span>());<br>        trip.doTrip();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行的结果：</p><blockquote><p>骑自行车</p></blockquote><h4 id="10-什么是适配器模式？"><a href="#10-什么是适配器模式？" class="headerlink" title="10.什么是适配器模式？"></a>10.什么是适配器模式？</h4><p>答：适配器模式是将一个类的接口变成客户端所期望的另一种接口，从而使原本因接口不匹配而无法一起工作的两个类能够在一起工作。</p><p><strong>优点</strong> ：</p><ul><li>可以让两个没有关联的类一起运行，起着中间转换的作用；</li><li>灵活性好，不会破坏原有的系统。</li></ul><p><strong>缺点</strong> ：过多地使用适配器，容易使代码结构混乱，如明明看到调用的是 A 接口，内部调用的却是 B 接口的实现。</p><p>以生活中的例子来说，比如有一个充电器是 MicroUSB 接口，而手机充电口却是 TypeC 的，这个时候就需要一个把 MicroUSB 转换成 TypeC的适配器，如下图所示：</p><p><img src="https://images.gitbook.cn/55a69fa0-e066-11e9-bc61-0549c31758ee" alt="2"></p><p>适配器实现代码如下：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 传统的充电线 MicroUSB</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MicroUSB</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">charger</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * TypeC 充电口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">ITypeC</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">charger</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TypeC</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ITypeC</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">charger</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;TypeC 充电&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 适配器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AdapterMicroUSB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MicroUSB</span> &#123;<br>    <span class="hljs-keyword">private</span> TypeC typeC;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AdapterMicroUSB</span><span class="hljs-params">(TypeC typeC)</span> &#123;<br>        <span class="hljs-built_in">this</span>.typeC = typeC;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">charger</span><span class="hljs-params">()</span> &#123;<br>        typeC.charger();<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 测试调用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdapterTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TypeC</span> <span class="hljs-variable">typeC</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeC</span>();<br>        <span class="hljs-type">MicroUSB</span> <span class="hljs-variable">microUSB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AdapterMicroUSB</span>(typeC);<br>        microUSB.charger();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行结果：</p><blockquote><p>TypeC 充电</p></blockquote><h4 id="11-JDK-类库常用的设计模式有哪些？"><a href="#11-JDK-类库常用的设计模式有哪些？" class="headerlink" title="11.JDK 类库常用的设计模式有哪些？"></a>11.JDK 类库常用的设计模式有哪些？</h4><p>答：JDK 常用的设计模式如下：</p><h5 id="1）工厂模式"><a href="#1）工厂模式" class="headerlink" title="1）工厂模式"></a>1）工厂模式</h5><p>java.text.DateFormat 工具类，它用于格式化一个本地日期或者时间。</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> DateFormat <span class="hljs-title function_">getDateInstance</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> DateFormat <span class="hljs-title function_">getDateInstance</span><span class="hljs-params">(<span class="hljs-type">int</span> style)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> DateFormat <span class="hljs-title function_">getDateInstance</span><span class="hljs-params">(<span class="hljs-type">int</span> style,Locale locale)</span>;<br></code></pre></td></tr></table></figure><p>加密类</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">KeyGenerator</span> <span class="hljs-variable">keyGenerator</span> <span class="hljs-operator">=</span> KeyGenerator.getInstance(<span class="hljs-string">&quot;DESede&quot;</span>);<br><span class="hljs-type">Cipher</span> <span class="hljs-variable">cipher</span> <span class="hljs-operator">=</span> Cipher.getInstance(<span class="hljs-string">&quot;DESede&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="2）适配器模式"><a href="#2）适配器模式" class="headerlink" title="2）适配器模式"></a>2）适配器模式</h5><p>把其他类适配为集合类</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; arrayList = java.util.Arrays.asList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;);<br>List&lt;Integer&gt; arrayList = java.util.Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h5 id="3）代理模式"><a href="#3）代理模式" class="headerlink" title="3）代理模式"></a>3）代理模式</h5><p>如 JDK 本身的动态代理。</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span>;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The dog is eating&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Animal</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eat</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;The cat is eating&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// JDK 代理类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AnimalProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>    <span class="hljs-keyword">private</span> Object target; <span class="hljs-comment">// 代理对象</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getInstance</span><span class="hljs-params">(Object target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>        <span class="hljs-comment">// 取得代理对象</span><br>        <span class="hljs-keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        System.out.println(<span class="hljs-string">&quot;调用前&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args); <span class="hljs-comment">// 方法调用</span><br>        System.out.println(<span class="hljs-string">&quot;调用后&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// JDK 动态代理调用</span><br>    <span class="hljs-type">AnimalProxy</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnimalProxy</span>();<br>    <span class="hljs-type">Animal</span> <span class="hljs-variable">dogProxy</span> <span class="hljs-operator">=</span> (Animal) proxy.getInstance(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>());<br>    dogProxy.eat();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4）单例模式"><a href="#4）单例模式" class="headerlink" title="4）单例模式"></a>4）单例模式</h5><p>全局只允许有一个实例，比如：</p><p>​<br>    Runtime.getRuntime();</p><h5 id="5）装饰器"><a href="#5）装饰器" class="headerlink" title="5）装饰器"></a>5）装饰器</h5><p>为一个对象动态的加上一系列的动作，而不需要因为这些动作的不同而产生大量的继承类。</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">java.io.BufferedInputStream(InputStream);  <br>java.io.DataInputStream(InputStream);  <br>java.io.BufferedOutputStream(OutputStream);  <br>java.util.zip.ZipOutputStream(OutputStream);  <br>java.util.Collections.checkedList(List list, Class type) ;<br></code></pre></td></tr></table></figure><h5 id="6）模板方法模式"><a href="#6）模板方法模式" class="headerlink" title="6）模板方法模式"></a>6）模板方法模式</h5><p>定义一个操作中算法的骨架，将一些步骤的执行延迟到其子类中。</p><p>比如，Arrays.sort() 方法，它要求对象实现 Comparable 接口。</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&#123;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Person</span><span class="hljs-params">(Integer age)</span>&#123;<br>        <span class="hljs-built_in">this</span>.age = age;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person)o;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age.compareTo(person.age);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SortTest</span>()&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">5</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">p3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-number">15</span>);<br>        Person[] persons = &#123;p1,p2,p3&#125;;<br>        <span class="hljs-comment">//排序</span><br>        Arrays.sort(persons);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="12-IO-使用了什么设计模式？"><a href="#12-IO-使用了什么设计模式？" class="headerlink" title="12.IO 使用了什么设计模式？"></a>12.IO 使用了什么设计模式？</h4><p>答：IO 使用了适配器模式和装饰器模式。</p><ul><li>适配器模式：由于 InputStream 是字节流不能享受到字符流读取字符那么便捷的功能，借助 InputStreamReader 将其转为 Reader 子类，因而可以拥有便捷操作文本文件方法；</li><li>装饰器模式：将 InputStream 字节流包装为其他流的过程就是装饰器模式，比如，包装为 FileInputStream、ByteArrayInputStream、PipedInputStream 等。</li></ul><h4 id="13-Spring-中都使用了哪些设计模式？"><a href="#13-Spring-中都使用了哪些设计模式？" class="headerlink" title="13.Spring 中都使用了哪些设计模式？"></a>13.Spring 中都使用了哪些设计模式？</h4><p>答：Spring 框架使用的设计模式如下。</p><ul><li>代理模式：在 AOP 中有使用</li><li>单例模式：bean 默认是单例模式</li><li>模板方法模式：jdbcTemplate</li><li>工厂模式：BeanFactory</li><li>观察者模式：Spring 事件驱动模型就是观察者模式很经典的一个应用，比如，ContextStartedEvent 就是 ApplicationContext 启动后触发的事件</li><li>适配器模式：Spring MVC 中也是用到了适配器模式适配 Controller</li></ul><blockquote><p>[点击此处下载本文源码](<a href="https://github.com/vipstone/java-">https://github.com/vipstone/java-</a><br>interview/tree/master/interview-code/src/main/java/com/interview)</p></blockquote><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul><li>设计模式之禅（第2版）</li><li><a href="https://java-design-patterns.com/patterns/">Java Design Patterns</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java面试全解析核心知识点与典型面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>036--JVM面试题汇总</title>
    <link href="/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/036--JVM%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/036--JVM%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h4 id="1-什么是-JVM？它有什么作用？"><a href="#1-什么是-JVM？它有什么作用？" class="headerlink" title="1.什么是 JVM？它有什么作用？"></a>1.什么是 JVM？它有什么作用？</h4><p>答：JVM 是 Java Virtual Machine（Java 虚拟机）的缩写，顾名思义它是一个虚拟计算机，也是 Java程序能够实现跨平台的基础。它的作用是加载 Java 程序，把字节码翻译成机器码再交由 CPU 执行的一个虚拟计算器。</p><h4 id="2-JVM-主要组成部分有哪些？"><a href="#2-JVM-主要组成部分有哪些？" class="headerlink" title="2.JVM 主要组成部分有哪些？"></a>2.JVM 主要组成部分有哪些？</h4><p>答：JVM 主要组成部分如下：</p><ul><li>类加载器（ClassLoader）</li><li>运行时数据区（Runtime Data Area）</li><li>执行引擎（Execution Engine）</li><li>本地库接口（Native Interface）</li></ul><h4 id="3-JVM-是如何工作的？"><a href="#3-JVM-是如何工作的？" class="headerlink" title="3.JVM 是如何工作的？"></a>3.JVM 是如何工作的？</h4><p>答：首先程序在执行之前先要把 Java 代码（.java）转换成字节码（.class），JVM通过类加载器（ClassLoader）把字节码加载到内存中，但字节码文件是 JVM的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine） 将字节码翻译成底层机器码，再交由CPU 去执行，CPU 执行的过程中需要调用本地库接口（Native Interface）来完成整个程序的运行。</p><h4 id="4-JVM-内存布局是怎样的？"><a href="#4-JVM-内存布局是怎样的？" class="headerlink" title="4.JVM 内存布局是怎样的？"></a>4.JVM 内存布局是怎样的？</h4><p>答：不同虚拟机实现可能略微有所不同，但都会遵从 Java 虚拟机规范，Java 8 虚拟机规范规定，Java 虚拟机所管理的内存将会包括以下几个区域：</p><ul><li>程序计数器（Program Counter Register）</li><li>Java 虚拟机栈（Java Virtual Machine Stacks）</li><li>本地方法栈（Native Method Stack）</li><li>Java 堆（Java Heap）</li><li>方法区（Method Area）</li></ul><p><strong>① 程序计数器</strong></p><p>程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解析器的工作是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于 JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，也就是任何时刻，一个处理器（或者说一个内核）都只会执行一条线程中的指令。因此为了线程切换后能恢复到正确地执行位置，每个线程都有独立的程序计数器。</p><p>如果线程正在执行 Java 中的方法，程序计数器记录的就是正在执行虚拟机字节码指令的地址，如果是 Native方法，这个计数器就为空（undefined），因此该内存区域是唯一一个在 Java 虚拟机规范中没有规定 OutOfMemoryError 的区域。</p><p><strong>② Java 虚拟机栈</strong></p><p>Java 虚拟机栈（Java Virtual Machine Stacks）描述的是 Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack<br>Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每个方法从调用直至执行完成的过程，都对应着一个线帧在虚拟机栈中入栈到出栈的过程。</p><ul><li>如果线程请求的栈深度大于虚拟机所允许的栈深度就会抛出 StackOverflowError 异常。</li><li>如果虚拟机是可以动态扩展的，如果扩展时无法申请到足够的内存就会抛出 OutOfMemoryError 异常。</li></ul><p><strong>③ 本地方法栈</strong></p><p>本地方法栈（Native Method Stack）与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用<br>Native 方法服务的。</p><p>在 Java 虚拟机规范中对于本地方法栈没有特殊的要求，虚拟机可以自由地实现它，因此在 Sun HotSpot 虚拟机直接把本地方法栈和虚拟机栈合二为一了。</p><p><strong>④ Java 堆</strong></p><p>Java 堆（Java Heap）是 JVM 中内存最大的一块，是被所有线程共享的，在虚拟机启动时候创建，Java堆唯一的目的就是存放对象实例，几乎所有的对象实例都在这里分配内存，随着JIT编译器的发展和逃逸分析技术的逐渐成熟，栈上分配、标量替换优化的技术将会导致一些微妙的变化，所有的对象都分配在堆上渐渐变得不那么绝对了。</p><p>如果在堆中没有内存完成实例分配，并且堆不可以再扩展时，将会抛出 OutOfMemoryError。 Java 虚拟机规范规定，Java堆可以处在物理上不连续的内存空间中，只要逻辑上连续即可，就像我们的磁盘空间一样。在实现上也可以是固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是可扩展的，通过-Xmx 和 -Xms 控制。</p><p><strong>⑤ 方法区</strong></p><p>方法区（Method Area）用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</p><p>很多人把方法区称作“永久代”（Permanent Generation），本质上两者并不等价，只是 HotSpot 虚拟机垃圾回收器团队把 GC分代收集扩展到了方法区，或者说是用来永久代来实现方法区而已，这样能省去专门为方法区编写内存管理的代码，但是在 JDK 8 也移除了“永久代”，使用Native Memory 来实现方法区。</p><p>当方法无法满足内存分配需求时会抛出 OutOfMemoryError 异常。</p><h4 id="5-在-Java-中负责字节码解释执行的是？"><a href="#5-在-Java-中负责字节码解释执行的是？" class="headerlink" title="5.在 Java 中负责字节码解释执行的是？"></a>5.在 Java 中负责字节码解释执行的是？</h4><p>A：应用服务器<br>B：垃圾回收器<br>C：虚拟机<br>D：编译器</p><p>答：C</p><h4 id="6-静态变量存储在哪个区？"><a href="#6-静态变量存储在哪个区？" class="headerlink" title="6.静态变量存储在哪个区？"></a>6.静态变量存储在哪个区？</h4><p>A：栈区<br>B：堆区<br>C：全局区<br>D：常量区</p><p>答：C</p><p>题目解析：栈区存放函数的参数值，局部变量的值等；堆区存放的是程序员创建的对象；全局区存放全局变量和静态变量；常量区存放常量字符串。</p><h4 id="7-垃圾回收算法有哪些？"><a href="#7-垃圾回收算法有哪些？" class="headerlink" title="7.垃圾回收算法有哪些？"></a>7.垃圾回收算法有哪些？</h4><p>答：垃圾回收算法如下。</p><ul><li>引用计数器算法：引用计算器判断对象是否存活的算法是这样的，给每一个对象设置一个引用计数器，每当有一个地方引用这个对象的时候，计数器就加 1，与之相反，每当引用失效的时候就减 1。</li><li>可达性分析算法：在主流的语言的主流实现中，比如 Java、C#，甚至是古老的 Lisp 都是使用的可达性分析算法来判断对象是否存活的。这个算法的核心思路就是通过一些列的“GC Roots”对象作为起始点，从这些对象开始往下搜索，搜索所经过的路径称之为“引用链”。当一个对象到 GC Roots 没有任何引用链相连的时候，证明此对象是可以被回收的。</li><li>复制算法：复制算法是将内存分为大小相同的两块，当这一块使用完了，就把当前存活的对象复制到另一块，然后一次性清空当前区块。此算法的缺点是只能利用一半的内存空间。</li><li>标记-清除算法：此算法执行分两阶段，第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，同时，会产生内存碎片。</li><li>标记-整理：此算法结合了“标记-清除”和“复制”两个算法的优点。分为两个阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。</li></ul><h4 id="8-哪些对象可以作为引用链的-Root-对象？"><a href="#8-哪些对象可以作为引用链的-Root-对象？" class="headerlink" title="8.哪些对象可以作为引用链的 Root 对象？"></a>8.哪些对象可以作为引用链的 Root 对象？</h4><p>答：引用链的 Root 对象可以为以下内容：</p><ul><li>Java 虚拟机栈中的引用对象；</li><li>本地方法栈中 JNI（既一般说的 Native 方法）引用的对象；</li><li>方法区中类静态常量的引用对象；</li><li>方法区中常量的引用对象。</li></ul><h4 id="9-对象引用关系都有哪些？"><a href="#9-对象引用关系都有哪些？" class="headerlink" title="9.对象引用关系都有哪些？"></a>9.对象引用关系都有哪些？</h4><p>答：不管是引用计数法还是可达性分析算法都与对象的“引用”有关，这说明对象的引用决定了对象的生死，对象的引用关系如下。</p><ul><li>强引用：在代码中普遍存在的，类似 <code>Object obj = new Object()</code> 这类引用，只要强引用还在，垃圾收集器永远不会回收掉被引用的对象。</li><li>软引用：是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当JVM 认为内存不足时，才会去试图回收软引用指向的对象，JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。</li><li>弱引用：非必需对象，但它的强度比软引用更弱，弱引用关联的对象只能生存到下一次垃圾收集发生之前。</li><li>虚引用：也称为幽灵引用或幻影引用，是最弱的一种引用关系，无法通过虚引用来获取一个对象实例，为对象设置虚引用的目的只有一个，就是当着个对象被收集器回收时收到一条系统通知。</li></ul><h4 id="10-内存溢出和内存泄漏的区别是什么？"><a href="#10-内存溢出和内存泄漏的区别是什么？" class="headerlink" title="10.内存溢出和内存泄漏的区别是什么？"></a>10.内存溢出和内存泄漏的区别是什么？</h4><p>答：内存溢出和内存泄漏的区别如下：</p><ul><li>内存溢出是指程序申请内存时，没有足够的内存，就会报错 OutOfMemory；</li><li>内存泄漏是指垃圾对象无法回收，可以使用 Memory Analyzer 等工具排出内存泄漏。</li></ul><h4 id="11-垃圾回收的分类都有哪些？"><a href="#11-垃圾回收的分类都有哪些？" class="headerlink" title="11.垃圾回收的分类都有哪些？"></a>11.垃圾回收的分类都有哪些？</h4><p>答：垃圾回收的分类如下：</p><ul><li>新生代回收器：Serial、ParNew、Parallel Scavenge</li><li>老年代回收器：Serial Old、Parallel Old、CMS</li><li>整堆回收器：G1</li></ul><h4 id="12-分代垃圾回收器的组成部分有哪些？"><a href="#12-分代垃圾回收器的组成部分有哪些？" class="headerlink" title="12.分代垃圾回收器的组成部分有哪些？"></a>12.分代垃圾回收器的组成部分有哪些？</h4><p>答：分代垃圾回收器是由：新生代（Young Generation）和老生代（Tenured Generation）组成的，默认情况下新生代和老生代的内存比例是 1:2。</p><h4 id="13-新生代的组成部分有哪些？"><a href="#13-新生代的组成部分有哪些？" class="headerlink" title="13.新生代的组成部分有哪些？"></a>13.新生代的组成部分有哪些？</h4><p>答：新生代是由：Eden、Form Survivor、To Survivor 三个区域组成的，它们内存默认占比是 8:1:1。</p><h4 id="14-新生代垃圾回收是怎么执行的？"><a href="#14-新生代垃圾回收是怎么执行的？" class="headerlink" title="14.新生代垃圾回收是怎么执行的？"></a>14.新生代垃圾回收是怎么执行的？</h4><p>答：新生代垃圾回收的执行过程如下：</p><p>① Eden 区 + From Survivor 区存活着的对象复制到 To Survivor 区；<br>② 清空 Eden 和 From Survivor 分区；<br>③ From Survivor 和 To Survivor 分区交换（From 变 To，To 变 From）。</p><h4 id="15-为什么新生代有两个-Survivor-分区？"><a href="#15-为什么新生代有两个-Survivor-分区？" class="headerlink" title="15.为什么新生代有两个 Survivor 分区？"></a>15.为什么新生代有两个 Survivor 分区？</h4><p>答：当新生代的 Survivor 分区为 2 个的时候，不论是空间利用率还是程序运行的效率都是最优的。</p><ul><li>如果 Survivor 是 0 的话，也就是说新生代只有一个 Eden 分区，每次垃圾回收之后，存活的对象都会进入老生代，这样老生代的内存空间很快就被占满了，从而触发最耗时的 Full GC ，显然这样的收集器的效率是我们完全不能接受的。</li><li>如果 Survivor 分区是 1 个的话，假设把两个区域分为 1:1，那么任何时候都有一半的内存空间是闲置的，显然空间利用率太低不是最佳的方案。但如果设置内存空间的比例是 8:2 ，只是看起来似乎“很好”，假设新生代的内存为 100 MB（ Survivor 大小为 20 MB ），现在有 70 MB 对象进行垃圾回收之后，剩余活跃的对象为 15 MB 进入 Survivor 区，这个时候新生代可用的内存空间只剩了 5 MB，这样很快又要进行垃圾回收操作，显然这种垃圾回收器最大的问题就在于，需要频繁进行垃圾回收。</li><li>如果 Survivor 分区有 2 个分区，我们就可以把 Eden、From Survivor、To Survivor 分区内存比例设置为 8:1:1 ，那么任何时候新生代内存的利用率都 90% ，这样空间利用率基本是符合预期的。再者就是虚拟机的大部分对象都符合“朝生夕死”的特性，因此每次新对象的产生都在空间占比比较大的 Eden 区，垃圾回收之后再把存活的对象方法存入 Survivor 区，如果是 Survivor 区存活的对象，那么“年龄”就 +1 ，当年龄增长到 15 （可通过 -XX:+MaxTenuringThreshold 设定）对象就升级到老生代。</li></ul><p>经过以上对比，可以得出结论，当新生代的 Survivor 分区为 2 个的时候，不论是空间利用率还是程序运行的效率都是最优的。</p><h4 id="16-什么是-CMS-垃圾回收器？"><a href="#16-什么是-CMS-垃圾回收器？" class="headerlink" title="16.什么是 CMS 垃圾回收器？"></a>16.什么是 CMS 垃圾回收器？</h4><p>答：CMS（Concurrent Mark Sweep）一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。</p><h4 id="17-CMS-垃圾回收器有哪些优缺点？"><a href="#17-CMS-垃圾回收器有哪些优缺点？" class="headerlink" title="17.CMS 垃圾回收器有哪些优缺点？"></a>17.CMS 垃圾回收器有哪些优缺点？</h4><p>答：CMS 垃圾回收器的优点是使用多线程，标记清除垃圾的，它缺点如下。</p><ul><li>对 CPU 资源要求敏感：CMS 回收器过分依赖于多线程环境，默认情况下，开启的线程数为（CPU 的数量 + 3）/ 4，当 CPU 数量少于 4 个时，CMS 对用户本身的操作的影响将会很大，因为要分出一半的运算能力去执行回收器线程；</li><li>CMS 无法清除浮动垃圾：浮动垃圾指的是 CMS 清除垃圾的时候，还有用户线程产生新的垃圾，这部分未被标记的垃圾叫做“浮动垃圾”，只能在下次 GC 的时候进行清除；</li><li>CMS 垃圾回收会产生大量空间碎片：CMS 使用的是标记-清除算法，所有在垃圾回收的时候回产生大量的空间碎片。</li></ul><h4 id="18-什么是-G1-垃圾回收器？"><a href="#18-什么是-G1-垃圾回收器？" class="headerlink" title="18.什么是 G1 垃圾回收器？"></a>18.什么是 G1 垃圾回收器？</h4><p>答：G1 垃圾回收器是一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。G1 可以直观的设定停顿时间的目标，相比于 CMS，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多。</p><p>G1 GC 仍然存在着年代的概念，但是其内存结构并不是简单的条带式划分，而是类似棋盘的一个个 Region。Region之间是复制算法，但整体上实际可看作是标记 - 整理（Mark-Compact）算法，可以有效地避免内存碎片，尤其是当 Java 堆非常大的时候，G1的优势更加明显。</p><h4 id="19-垃圾回收的调优参数有哪些？"><a href="#19-垃圾回收的调优参数有哪些？" class="headerlink" title="19.垃圾回收的调优参数有哪些？"></a>19.垃圾回收的调优参数有哪些？</h4><p>答：垃圾回收的常用调优如下：</p><ul><li>-Xmx:512 设置最大堆内存为 512 M；</li><li>-Xms:215 初始堆内存为 215 M；</li><li>-XX:MaxNewSize 设置最大年轻区内存；</li><li>-XX:MaxTenuringThreshold=5 设置新生代对象经过 5 次 GC 晋升到老年代；</li><li>-XX:PretrnureSizeThreshold 设置大对象的值，超过这个值的大对象直接进入老生代；</li><li>-XX:NewRatio 设置分代垃圾回收器新生代和老生代内存占比；</li><li>-XX:SurvivorRatio 设置新生代 Eden、Form Survivor、To Survivor 占比。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java面试全解析核心知识点与典型面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>033--Redis面试题汇总</title>
    <link href="/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/033--Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/033--Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis-面试题汇总"><a href="#Redis-面试题汇总" class="headerlink" title="Redis 面试题汇总"></a>Redis 面试题汇总</h2><h4 id="1-Redis-使用场景有哪些？"><a href="#1-Redis-使用场景有哪些？" class="headerlink" title="1.Redis 使用场景有哪些？"></a>1.Redis 使用场景有哪些？</h4><p>答：Redis 使用场景如下：</p><ul><li>记录帖子点赞数、点击数、评论数</li><li>缓存近期热帖</li><li>缓存文章详情信息</li><li>记录用户会话信息</li></ul><h4 id="2-Redis-有哪些功能？"><a href="#2-Redis-有哪些功能？" class="headerlink" title="2.Redis 有哪些功能？"></a>2.Redis 有哪些功能？</h4><p>答：Redis 功能如下：</p><ul><li>数据缓存功能</li><li>分布式锁的功能</li><li>支持数据持久化</li><li>支持事务</li><li>支持消息队列</li></ul><h4 id="3-Redis-支持哪些数据类型？"><a href="#3-Redis-支持哪些数据类型？" class="headerlink" title="3.Redis 支持哪些数据类型？"></a>3.Redis 支持哪些数据类型？</h4><p>答：Redis 支持的数据类型如下：</p><ul><li>String 字符串</li><li>List 列表</li><li>Set 无序集合</li><li>ZSet 有序集合</li><li>Hash 哈希类型</li></ul><h4 id="4-Redis-相比-Memcached-有哪些优势？"><a href="#4-Redis-相比-Memcached-有哪些优势？" class="headerlink" title="4.Redis 相比 Memcached 有哪些优势？"></a>4.Redis 相比 Memcached 有哪些优势？</h4><p>答：Redis 相比 Memcached 优势如下：</p><ul><li>Memcached 所有的值均是简单的字符串，Redis 支持更为丰富的数据类型</li><li>Redis 的速度比 Memcached 要快</li><li>Redis 可以持久化</li><li>Redis 可以设置过期时间</li><li>Redis 支持主从同步</li></ul><h4 id="5-Redis-支持哪些淘汰策略？"><a href="#5-Redis-支持哪些淘汰策略？" class="headerlink" title="5.Redis 支持哪些淘汰策略？"></a>5.Redis 支持哪些淘汰策略？</h4><p>答：Redis 淘汰策略如下：</p><ul><li>noeviction：禁止淘汰数据；</li><li>allkeys-lru：尝试回收最少使用的键，使得新添加的数据有空间存放；</li><li>volatile-lru：尝试回收最少使用的键，但仅限于在过期集合的键，使得新添加的数据有空间存放；</li><li>allkeys-random：回收随机的键使得新添加的数据有空间存放；</li><li>volatile-random：回收随机的键使得新添加的数据有空间存放，但仅限于在过期集合的键；</li><li>volatile-ttl：回收在过期集合的键，并且优先回收存活时间较短的键，使得新添加的数据有空间存放。</li></ul><h4 id="6-官方为什么不支持-Windows-版本？"><a href="#6-官方为什么不支持-Windows-版本？" class="headerlink" title="6.官方为什么不支持 Windows 版本？"></a>6.官方为什么不支持 Windows 版本？</h4><p>答：Redis 官方是不支持 Windows 版的，因为目前 Linux 版本已经相当稳定，如果开发 Windows 版本，反而会带来兼容性等问题。</p><h4 id="7-为什么-Redis-是单线程的？"><a href="#7-为什么-Redis-是单线程的？" class="headerlink" title="7.为什么 Redis 是单线程的？"></a>7.为什么 Redis 是单线程的？</h4><p>答：因为 Redis 的瓶颈最有可能是机器内存或者网络带宽，而非单线程，既然单线程不是 Redis 的性能瓶颈，并且单线程又比较容易实现，所以 Redis就选择使用单线程来实现。</p><p>单线程并不代表运行速度就慢，比如，Nginx 和 NodeJs 都是单线程高性能的代表。</p><h4 id="8-为什么-Redis-需要把所有数据放到内存中？"><a href="#8-为什么-Redis-需要把所有数据放到内存中？" class="headerlink" title="8.为什么 Redis 需要把所有数据放到内存中？"></a>8.为什么 Redis 需要把所有数据放到内存中？</h4><p>答：Redis 为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘，这样 Redis 就拥有了快速查询和数据持久化等特征。</p><h4 id="9-在-Redis-中-key-的最大容量是多少？"><a href="#9-在-Redis-中-key-的最大容量是多少？" class="headerlink" title="9.在 Redis 中 key 的最大容量是多少？"></a>9.在 Redis 中 key 的最大容量是多少？</h4><p>答：最大容量 512 MB，官方说明如下图所示：</p><p><img src="https://images.gitbook.cn/4ea56a20-e05b-11e9-99bc-59d43b30c641" alt="1"></p><h4 id="10-Jedis-和-Redisson-有什么区别？"><a href="#10-Jedis-和-Redisson-有什么区别？" class="headerlink" title="10.Jedis 和 Redisson 有什么区别？"></a>10.Jedis 和 Redisson 有什么区别？</h4><p>答：Jedis 和 Redisson 的区别如下：</p><ul><li>Jedis 是 Redis 的 Java 实现客户端，其 API 提供了比较全面的 Redis 命令的支持；</li><li>Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等 Redis 特性。Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</li></ul><h4 id="11-Redis-如何设置过期时间？如何设置永久有效？"><a href="#11-Redis-如何设置过期时间？如何设置永久有效？" class="headerlink" title="11.Redis 如何设置过期时间？如何设置永久有效？"></a>11.Redis 如何设置过期时间？如何设置永久有效？</h4><p>答：Redis 通过 expire() 方法设置过期时间，语法：redis.expire(key, expiration)。当 expire的过期时间设置为 -1 时，表示永不过期。</p><h4 id="12-如何保证-Redis-的数据一致性？"><a href="#12-如何保证-Redis-的数据一致性？" class="headerlink" title="12.如何保证 Redis 的数据一致性？"></a>12.如何保证 Redis 的数据一致性？</h4><p>答：可使用以下方法来保证 Redis 的数据一致性：</p><ul><li>合理设置缓存的过期时间；</li><li>新增、更改、删除数据库操作时同步更新 Redis，可以使用事物机制来保证数据的一致性。</li></ul><h4 id="13-Redis-的数据结构是什么？它有什么优缺点？"><a href="#13-Redis-的数据结构是什么？它有什么优缺点？" class="headerlink" title="13.Redis 的数据结构是什么？它有什么优缺点？"></a>13.Redis 的数据结构是什么？它有什么优缺点？</h4><p>答：Redis的数据结构是跳跃表，跳跃表是一种基于链表的扩展，跳跃表还是一个链表，是一个有序的链表，在遍历的时候基于比较，但普通链表只能遍历，跳跃表加入了一个层的概念，层级越高元素越少，每次先从高层查找，直到找到合适的位置，从图中可以看到高层的节点远远少于底层的节点数，从而实现了跳跃式查找。</p><p><img src="https://images.gitbook.cn/693382a0-e05b-11e9-bc61-0549c31758ee" alt="2"></p><p>跳跃表优点：</p><ul><li>实现比红黑树简单</li><li>比红黑树更容易扩展</li><li>红黑树插入删除时为了平衡高度需要旋转附近节点，高并发需要锁，跳跃表不需要考虑</li></ul><p>跳跃表缺点：</p><ul><li>比红黑树占用更多的内存，每个节点的大小取决于该节点层数</li><li>空间局部性差导致缓存命中率低，比红黑树略慢</li></ul><h4 id="14-Redis-为什么用跳跃表来存储？"><a href="#14-Redis-为什么用跳跃表来存储？" class="headerlink" title="14.Redis 为什么用跳跃表来存储？"></a>14.Redis 为什么用跳跃表来存储？</h4><p>答：第一是因为红黑树存储比较复杂，调整涉及到多个节点的并发修改；第二是越接近根节点的地方越容易产生竞争，即使是不同叶子节点的操作由于平衡操作也可能逐级向上涉及到接近根的节点，而跳跃表可以用CAS（Compare And Swap）来并发操作节点，比较容易实现，且更加局部化。</p><h4 id="15-什么是缓存穿透？如何解决？"><a href="#15-什么是缓存穿透？如何解决？" class="headerlink" title="15.什么是缓存穿透？如何解决？"></a>15.什么是缓存穿透？如何解决？</h4><p>答：缓存穿透是指查询一个一定不存在的数据，由于缓存中没有，因而每次需要从数据库中查询，但数据库也没有相应的数据，所以不会写入缓存，这就将导致每次请求都会去数据库查询，这种行为就叫缓存穿透。</p><p>解决方案是不管查询数据库是否有数据，都缓存起来，只不过把没有数据的缓存结果的过期时间设置为比较短的一个值，比如 3 分钟。</p><h4 id="16-什么是缓存雪崩，该如何解决？"><a href="#16-什么是缓存雪崩，该如何解决？" class="headerlink" title="16.什么是缓存雪崩，该如何解决？"></a>16.什么是缓存雪崩，该如何解决？</h4><p>答：指缓存由于某些原因，比如，宕机或者缓存大量过期等，从而导致大量请求到达后端数据库，进而导致数据库崩溃的情况。</p><p>解决缓存雪崩的方案如下：</p><ul><li>分析业务功能，尽量让缓存的失效时间点均匀分布；</li><li>使用 Redis 主备，保证缓存系统的高可用。</li></ul><h4 id="17-什么是缓存预热？有几种实现方式？"><a href="#17-什么是缓存预热？有几种实现方式？" class="headerlink" title="17.什么是缓存预热？有几种实现方式？"></a>17.什么是缓存预热？有几种实现方式？</h4><p>答：缓存预热是指系统上线后，将相关的缓存数据直接加载到缓存系统，这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。</p><p>缓存预热的实现方式，可分为以下两种：</p><ul><li>数据量不大的时候，工程启动的时候进行加载缓存动作；</li><li>数据量大的时候，设置一个定时任务脚本，进行缓存的刷新。</li></ul><h4 id="18-在-Java-程序中如何使用-Redis？"><a href="#18-在-Java-程序中如何使用-Redis？" class="headerlink" title="18.在 Java 程序中如何使用 Redis？"></a>18.在 Java 程序中如何使用 Redis？</h4><p>答：在 Java 程序中可使用 Jedis 来操作 Redis，使用步骤如下：</p><p>1）添加 Jedis 引用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>x.x.x<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2）连接并操作 Redis</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml">Jedis jedis = new Jedis(&quot;127.0.0.1&quot;,6379);<br>    // 存值<br>    jedis.set(&quot;hello&quot;,&quot;world&quot;);<br>    // 取值<br>    jedis.get(&quot;hello&quot;);<br>    // 关闭连接<br>    jedis.close();<br></code></pre></td></tr></table></figure><h4 id="19-什么是-Redis-持久化？如何进行-Redis-持久化？"><a href="#19-什么是-Redis-持久化？如何进行-Redis-持久化？" class="headerlink" title="19.什么是 Redis 持久化？如何进行 Redis 持久化？"></a>19.什么是 Redis 持久化？如何进行 Redis 持久化？</h4><p>答：Redis 持久化是指将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。 Redis 有以下两种持久化方案：</p><ul><li>RDB（Redis DataBase）：是指在制定的时间间隔内将内存中的数据集快照写入磁盘；</li><li>AOF（Append Only File）：该机制将以日志的形式记录服务器所处理的每一个写操作，在 Redis 服务器启动之初会读取该文件来重新构建数据库，以保证启动后数据库中的数据是完整的。</li></ul><p>Redis 默认支持的持久化方式是 RDB 方式。</p><h4 id="20-RDB-和-AOF-有什么区别？"><a href="#20-RDB-和-AOF-有什么区别？" class="headerlink" title="20.RDB 和 AOF 有什么区别？"></a>20.RDB 和 AOF 有什么区别？</h4><p>答：RDB 和 AOF 的区别如下：</p><ul><li>RDB 可能会引起一定程度的数据丢失，AOF 不会造成数据丢失</li><li>RDB 的启动效率更高</li><li>AOF 占用的空间比 RDB 大，AOF 的同步速度比 RDB 慢</li></ul><p>总体来说如果对数据的完整性要求不高，RDB 是最好的解决方案，反之则选择 AOF。</p><h4 id="21-Redis-的监控工具都有哪些？"><a href="#21-Redis-的监控工具都有哪些？" class="headerlink" title="21.Redis 的监控工具都有哪些？"></a>21.Redis 的监控工具都有哪些？</h4><p>答：常用的 Redis 监控工具如下：</p><ul><li>Redis-stat：采用 Ruby 开发，基于 Redis 的 info 命令来统计，不影响 Redis 的性能；</li><li>RedisLive：采用 Python 开发的可视化及查询分析工具，它是通过监控脚本来 Redis 提供的 MONITOR 命令从被监控 Redis 实例中获取数据，并存储到 Redis 的监控实例中。</li></ul><h4 id="22-如何定位-Redis-的慢查询？"><a href="#22-如何定位-Redis-的慢查询？" class="headerlink" title="22.如何定位 Redis 的慢查询？"></a>22.如何定位 Redis 的慢查询？</h4><p>答：使用 slowlog get 来定位慢查询操作，如下所示：</p><blockquote><p>127.0.0.1:6379&gt; slowlog get</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-number">1</span>) <span class="hljs-number">1</span>) (<span class="hljs-type">integer</span>) <span class="hljs-number">219</span><br>   <span class="hljs-number">2</span>) (<span class="hljs-type">integer</span>) <span class="hljs-number">1658999722</span><br>   <span class="hljs-number">3</span>) (<span class="hljs-type">integer</span>) <span class="hljs-number">17351</span><br>   <span class="hljs-number">4</span>) <span class="hljs-number">1</span>) &quot;SUNION&quot;<br>      <span class="hljs-number">2</span>) &quot;pms:role:permission:1534381742130094080&quot;<br>      <span class="hljs-number">3</span>) &quot;pms:role:permission:1534783302026846208&quot;<br>   <span class="hljs-number">5</span>) &quot;172.21.226.147:44782&quot;<br>   <span class="hljs-number">6</span>) &quot;&quot;<br></code></pre></td></tr></table></figure><p>其中：</p><ol><li><p>表示慢查询记录 id</p></li><li><p>表示发起命令的时间戳</p></li><li><p>表示命令耗时，单位为微秒</p></li><li><p>表示该条记录的命令及参数</p></li></ol><h4 id="23-SAVE-和-BGSAVE-有什么区别？"><a href="#23-SAVE-和-BGSAVE-有什么区别？" class="headerlink" title="23.SAVE 和 BGSAVE 有什么区别？"></a>23.SAVE 和 BGSAVE 有什么区别？</h4><p>答：SAVE 和 BGSAVE 都是用于 Redis 持久化的，它们的区别如下：</p><ul><li>SAVE 直接调用 rdbSave 函数（用于 Redis 持久化的函数），阻塞 Redis 主进程，直到保存完成为止，在主进程阻塞期间，服务器不能处理客户端的任何请求；</li><li>BGSAVE 则会创建一个子进程，子进程负责调用 rdbSave 函数，并在保存完成之后向主进程发送完成信号，Redis 服务器在 BGSAVE 执行期间仍然可以继续处理客户端的请求。</li></ul><h4 id="24-Redis-是如何实现同步的？"><a href="#24-Redis-是如何实现同步的？" class="headerlink" title="24.Redis 是如何实现同步的？"></a>24.Redis 是如何实现同步的？</h4><p>答：Redis 可以实现主从同步和从从同步。当第一次同步时，主节点做一次 BGSAVE，并同时将后续修改操作记录到内存中，待完成后将 RDB文件全量同步到复制节点，复制节点接受完成后将 RDB镜像加载到内存，加载完成后再通知主节点将期间修改的操作记录，同步到复制节点进行重放，这样就完成了同步过程。</p><h4 id="25-Redis-可以切换数据库吗？如何切换？"><a href="#25-Redis-可以切换数据库吗？如何切换？" class="headerlink" title="25.Redis 可以切换数据库吗？如何切换？"></a>25.Redis 可以切换数据库吗？如何切换？</h4><p>答：Redis 不像 MySQL 等关系型数据库那样有数据库的概念，不同的数据存在不同的数据库中，Redis数据库是由一个整数索引标识，而不是一个数据库名称，默认情况下客户端连接到数据库 0，可以在配置文件中控制数据库总数，默认是 16 个。</p><p>可以使用 select index 来切换数据库，如下所示：</p><blockquote><p>127.0.0.1:6379&gt; select 0</p></blockquote><blockquote><p>OK</p></blockquote><h4 id="26-Redis-有哪些集群策略？"><a href="#26-Redis-有哪些集群策略？" class="headerlink" title="26.Redis 有哪些集群策略？"></a>26.Redis 有哪些集群策略？</h4><p>答：Redis 集群策略有以下 3 种：</p><ul><li>主从策略：1 台机器作为写操作，另外 2 台作为读操作，类似于 MySQL 的主从方式；</li><li>哨兵策略：增加 1 台机器作为哨兵，监控 3 台主从机器，当主节点挂机的时候，机器内部进行选举，从集群中从节点里指定一台机器升级为主节点，从而实现高可用。当主节点恢复的时候，加入到从节点中继续提供服务；</li><li>集群策略：Redis 3.0 之后增加了集群的概念，可实现多主多从的结构，实现真正的高可用。</li></ul><h4 id="27-Redis-集群方案都有哪些？"><a href="#27-Redis-集群方案都有哪些？" class="headerlink" title="27.Redis 集群方案都有哪些？"></a>27.Redis 集群方案都有哪些？</h4><p>答：Redis 集群实现方案如下：</p><ul><li>Twemproxy 是 Twitter 开源的 Redis 代理，它的使用和普通 Redis 完全一致，它会以一个代理的身份接收请求，并使用 hash 算法将请求转接到具体 Redis，将结果再返回 Twemproxy；</li><li>Codis 是开源解决方案，也是目前用的最多的集群方案，基本和 Twemproxy 效果一致，但它支持在节点数量改变情况下，旧节点数据可恢复到新 hash 节点；</li><li>Redis Cluster 是 Redis 3.0 自带的集群方案，特点在于他的分布式算法不是一致性 hash，而是 hash 槽的概念，以及自身支持节点设置从节点；</li><li>业务代码层实现，创建几个独立的 Redis 实例，在代码层对 key 进行 hash 计算，然后去对应的 Redis 实例操作数据。这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复、实例的监控等。</li></ul><h4 id="28-Redis-如何做内存优化？"><a href="#28-Redis-如何做内存优化？" class="headerlink" title="28.Redis 如何做内存优化？"></a>28.Redis 如何做内存优化？</h4><p>答：把相关的信息整体存储，而不是把每个信息独立存储，这样就可以有效的减少内存使用。</p><h4 id="29-分布式锁设计时需要注意哪些事项？"><a href="#29-分布式锁设计时需要注意哪些事项？" class="headerlink" title="29.分布式锁设计时需要注意哪些事项？"></a>29.分布式锁设计时需要注意哪些事项？</h4><p>答：通常分布式锁在设计时，需同时满足以下四个约束条件。</p><ul><li>互斥性：在任意时刻，只有一个客户端能持有锁。</li><li>安全性：即不会形成死锁，当一个客户端在持有锁的期间崩溃而没有主动解锁的情况下，其持有的锁也能够被正确释放，并保证后续其他客户端能加锁。</li><li>可用性：就 Redis 而言，当提供锁服务的 Redis master 节点发生宕机等不可恢复性故障时，slave 节点能够升主并继续提供服务，支持客户端加锁和解锁；对基于分布式一致性算法实现的锁服务，如 ETCD 而言，当 leader 节点宕机时，follow 节点能够选举出新的 leader 继续提供锁服务。</li><li>对称性：对于任意一个锁，其加锁和解锁必须是同一个客户端，即，客户端 A 不能把客户端 B 加的锁给解了。</li></ul><h4 id="30-Redis-集群实现的原理是什么？"><a href="#30-Redis-集群实现的原理是什么？" class="headerlink" title="30.Redis 集群实现的原理是什么？"></a>30.Redis 集群实现的原理是什么？</h4><p>答：集群的实现原理和集群的实现方式有关，如下所述：</p><ul><li>Redis Sentinal 着眼于高可用，在 Master 宕机时会自动将 Slave 提升为 Master，继续提供服务；</li><li>Redis Cluster 着眼于扩展性，在单个 Redis 内存不足时，使用 Cluster 进行分片存储。</li></ul><h4 id="31-Redis-常见的性能问题有哪些？"><a href="#31-Redis-常见的性能问题有哪些？" class="headerlink" title="31.Redis 常见的性能问题有哪些？"></a>31.Redis 常见的性能问题有哪些？</h4><p>答：Redis 常见性能问题如下：</p><ul><li>主服务器写内存快照，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，因此主服务器最好不要写内存快照；</li><li>Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，主从库最好在同一个局域网内。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java面试全解析核心知识点与典型面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>025--Spring核心功能演示+面试题</title>
    <link href="/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/025--Spring%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E6%BC%94%E7%A4%BA+%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/025--Spring%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E6%BC%94%E7%A4%BA+%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="Spring-核心功能演示-面试题"><a href="#Spring-核心功能演示-面试题" class="headerlink" title="Spring 核心功能演示 + 面试题"></a>Spring 核心功能演示 + 面试题</h2><p>Spring Framework 简称 Spring，是 Java 开发中最常用的框架，地位仅次于 Java API，就连近几年比较流行的微服务框架SpringBoot，也是基于 Spring 实现的，SpringBoot 的诞生是为了让开发者更方便地使用 Spring，因此 Spring 在 Java体系中的地位可谓首屈一指。<br>当然，如果想要把 Spring 所有功能都讲的一清二楚，远远不是一两篇文章能够做到的，但幸运的是，Spring<br>的基础资料可以很轻易的搜索到，那么我们本讲主要的目的就是把 Spring 中的核心知识点和常见面试题分享给大家，希望对大家能有所帮助。</p><h3 id="Spring-介绍"><a href="#Spring-介绍" class="headerlink" title="Spring 介绍"></a>Spring 介绍</h3><p>Spring 是一个开源框架，为了解决企业应用程序开发复杂性而创建的，Spring 的概念诞生于 2002 年，于 2003 年正式发布第一个版本<br>Spring Framework 0.9。下面一起来看 Spring 各个版本的更新特性和它的发展变化吧。</p><h4 id="Spring-1-x"><a href="#Spring-1-x" class="headerlink" title="Spring 1.x"></a>Spring 1.x</h4><p>此版本主要是为了解决企业应用程序开发复杂性而创建的，当时 J2EE 应用的经典架构是分层架构：表现层、业务层、持久层，最流行的组合就是<br>SSH（Struts、Spring、Hibernate）。<br>Spring 1.x 仅支持基于 XML 的配置，确保用户代码不依赖<br>Spring，它主要包含了以下功能模块：aop、beans、ejb、jdbc、jndi、orm、transation、validation、web 等。</p><h4 id="Spring-2-x"><a href="#Spring-2-x" class="headerlink" title="Spring 2.x"></a>Spring 2.x</h4><p>Spring 2.x 的改动并不是很大，主要是在 Spring 1.x 的基础上增加了几个新模块，如<br>ehcache、jms、jmx、scripting、stereotype 等。</p><h4 id="Spring-3-x"><a href="#Spring-3-x" class="headerlink" title="Spring 3.x"></a>Spring 3.x</h4><p>Spring 3.x 开始不止支持 XML 的配置，还扩展了基于 Java 类的配置，还增加了<br>Expression、Instructment、Tomcat、oxm 等组件，同时将原来的 Web 细分为：Portlet、Servlet。</p><h4 id="Spring-4-x"><a href="#Spring-4-x" class="headerlink" title="Spring 4.x"></a>Spring 4.x</h4><p>Spring 4.x 扩充了 Groovy、Messaging、WebMvc、Tiles2、WebSocket 等功能组件，同时 Spring 还适配了<br>Java 版本，全面支持 Java 8.0、Lambda 表达式等。随着 RESTful 架构风格被越来越多的用户所采用，Spring 4.x 也提供了<br>RestController 等注解新特性。</p><h4 id="Spring-5-x"><a href="#Spring-5-x" class="headerlink" title="Spring 5.x"></a>Spring 5.x</h4><p>Spring 5.x 紧跟 Java 相关技术的更新迭代，不断适配 Java 的新版本，同时不断重构优化自身核心框架代码，支持函数式、响应式编程模型等。</p><h3 id="Spring-核心"><a href="#Spring-核心" class="headerlink" title="Spring 核心"></a>Spring 核心</h3><p>Spring 核心包括以下三个方面：</p><ul><li>控制反转（Ioc）</li><li>依赖注入（DI）</li><li>面向切面编程（AOP）</li></ul><p>下面分别来看它的这些特性。</p><h4 id="控制反转（IoC）"><a href="#控制反转（IoC）" class="headerlink" title="控制反转（IoC）"></a>控制反转（IoC）</h4><p>控制反转（Inversion of Control，IoC），顾名思义所谓的控制反转就是把创建对象的权利交给框架去控制，而不需要人为地去创建，这样就实现了可插拔式的接口编程，有效地降低代码的耦合度，降低了扩展和维护的成本。<br>比如，你去某地旅游不再用自己亲自为订购 A 酒店还是 B酒店而发愁了，只需要把住店的需求告诉给某个托管平台，这个托管平台就会帮你订购一个既便宜又舒适的酒店，而这个帮你订购酒店的行为就可以称之为控制反转。</p><h4 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h4><p>依赖注入（Dependency Injection，DI），是组件之间依赖关系由容器在运行期决定，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><h5 id="IoC-和-DI-的关系"><a href="#IoC-和-DI-的关系" class="headerlink" title="IoC 和 DI 的关系"></a>IoC 和 DI 的关系</h5><p>IoC 是 Spring 中一个极为重要的概念，而 DI 则是实现 IoC 的方法和手段。<br>接下来，我们来看依赖注入的常见实现方式有哪些？<br>依赖注入的常见实现方式如下：</p><ol><li>setter 注入</li><li>构造方法注入</li><li>注解注入</li></ol><h5 id="1）setter-注入"><a href="#1）setter-注入" class="headerlink" title="1）setter 注入"></a>1）setter 注入</h5><p>Java 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-comment">// 注入 UserService 对象</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserService</span><span class="hljs-params">(UserService userService)</span>&#123;<br>        <span class="hljs-built_in">this</span>.userService = userService;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>XML 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userController&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.learning.controller.UserController&quot;</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- 依赖注入 --&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userService&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.learning.dao.impl.UserServiceImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>Bean 标签的常用属性说明：</strong></p><ul><li>id：为实例化对象起名称，根据 id 值可以得到我们配置的实例化对象，id 属性的名称原则上可以任意命名，但是能包含任何特殊符号；</li><li>class：创建对象所在类的全路径；</li><li>name：功能和 id 属性一样，但是现在一般不用；与 id 的区别在于：name 属性值里可以包含特殊符号，但是 id 不可以；</li><li>scope：一般最常用的有两个值： Singleton：单例模式，整个应用程序，只创建 bean 的一个实例；Prototype：原型模式，每次注入都会创建一个新的 bean 实例，Spring 默认的是单例模式。</li></ul><h5 id="2）构造方法注入"><a href="#2）构造方法注入" class="headerlink" title="2）构造方法注入"></a>2）构造方法注入</h5><p>Java 代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-keyword">private</span> UserService userService;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserController</span><span class="hljs-params">(UserService userService)</span>&#123;<br>        <span class="hljs-built_in">this</span>.userService = userService;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>XML 配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userController&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.learning.controller.UserController&quot;</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- 依赖注入 --&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userService&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>  <br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.learning.dao.impl.UserServiceImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>  <br><br></code></pre></td></tr></table></figure><h5 id="3）注解注入"><a href="#3）注解注入" class="headerlink" title="3）注解注入"></a>3）注解注入</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-comment">// 使用注解自动注入</span><br>    <span class="hljs-meta">@Autowired()</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br>    <span class="hljs-comment">// do something</span><br>&#125;<br><span class="hljs-comment">// 创建依赖对象</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserService</span> &#123;<br>   <span class="hljs-comment">// do something </span><br>&#125;<br></code></pre></td></tr></table></figure><p>创建依赖对象的常见注解：@Component、@Controller、@Service、@Repository。</p><p><strong>总结</strong> ：可以看出注解的方式要比传统的 XML（setter 和构造器注入）实现注入更为方便，同时注解方式也是官方力推的依赖注入最佳使用方式。</p><h4 id="面向切面编程（AOP）"><a href="#面向切面编程（AOP）" class="headerlink" title="面向切面编程（AOP）"></a>面向切面编程（AOP）</h4><p>面向切面编程（Aspect Oriented Programming，AOP），它就好比将系统按照功能分类，每一个类别就是一个“切面”，我们再针对不同的切面制定相应的规则，类似开发模式被称为面向切面编程。</p><h5 id="AOP-使用场景"><a href="#AOP-使用场景" class="headerlink" title="AOP 使用场景"></a>AOP 使用场景</h5><ul><li>日志系统</li><li>安全统一效验</li></ul><h5 id="AOP-优点"><a href="#AOP-优点" class="headerlink" title="AOP 优点"></a>AOP 优点</h5><ul><li>集中处理某一类问题，方便维护</li><li>逻辑更加清晰</li><li>降低模块间的耦合度</li></ul><h5 id="AOP-相关概念"><a href="#AOP-相关概念" class="headerlink" title="AOP 相关概念"></a>AOP 相关概念</h5><ul><li>Join point：连接点，程序执行期间的某一个点，例如执行方法或处理异常时候的点，在 Spring AOP 中，连接点总是表示方法的执行。</li><li>Advice：通知，通知分为方法执行前通知，方法执行后通知、环绕通知等。许多 AOP 框架（包括 Spring）都将通知建模为拦截器，在连接点周围维护一系列拦截器（形成拦截器链），对连接点的方法进行增强。</li><li>Pointcut：切点，匹配连接点（Join point）的表达式，是 AOP 的核心，并且 Spring 默认使用 AspectJ 作为切入点表达式语言。</li><li>Aspect：切面，是一个跨越多个类的模块化的关注点，它是通知（Advice）和切点（Pointcut）合起来的抽象，它定义了一个切点（Pointcut）用来匹配连接点（Join point），也就是需要对需要拦截的那些方法进行定义。</li><li>Target object：目标对象，被一个或者多个切面（Aspect）通知的对象，也就是需要被 AOP 进行拦截对方法进行增强（使用通知）的对象，也称为被通知的对象。由于在 AOP 里面使用运行时代理，因而目标对象一直是被代理的对象。</li><li>AOP proxy：AOP 代理，为了实现切面（Aspect）功能使用 AOP 框架创建一个对象，在 Spring 框架里面一个 AOP 代理指的是 JDK 自身的动态代理或 CGLIB 实现的动态代理。</li><li>Weaving：把切面加入到对象，并创建出代理对象的过程。</li><li>Advisor：一个 Advisor 相当于一个小型的切面，不同的是它只有一个通知（Advice），Advisor 在事务管理里面会经常遇到。</li></ul><h5 id="AOP-代码实现"><a href="#AOP-代码实现" class="headerlink" title="AOP 代码实现"></a>AOP 代码实现</h5><p>AOP 的示例我们就以开车为例，开车的完成流程是这样的：巡视车体及周围情况 → 发动 → 开车 → 熄火 → 锁车。</p><p>当然我们的主要目的是“开车”，但在开车之前和开完车之后，我们要做一些其他的工作，这些“其他”的工作，可以理解为 AOP 编程。</p><h5 id="1）创建类和方法"><a href="#1）创建类和方法" class="headerlink" title="1）创建类和方法"></a>1）创建类和方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.learning.aop;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component(&quot;person&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">drive</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;开车&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2）创建-AOP-拦截"><a href="#2）创建-AOP-拦截" class="headerlink" title="2）创建 AOP 拦截"></a>2）创建 AOP 拦截</h5><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.learning.aop;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.After;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Aspect;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.Before;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CarAop</span> &#123;<br>    <span class="hljs-meta">@Before(&quot;execution(* com.learning.aop.Person.drive())&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">before</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;巡视车体及周围情况&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;发动&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@After(&quot;execution(* com.learning.aop.Person.drive())&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">after</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;熄火&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;锁车&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3）XML-配置注入扫描包路径"><a href="#3）XML-配置注入扫描包路径" class="headerlink" title="3）XML 配置注入扫描包路径"></a>3）XML 配置注入扫描包路径</h5><p>​</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag">       http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.learning&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="4）创建测试类"><a href="#4）创建测试类" class="headerlink" title="4）创建测试类"></a>4）创建测试类</h5><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.learning.aop;<br><br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PersonTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>        <span class="hljs-type">Person</span> <span class="hljs-variable">landlord</span> <span class="hljs-operator">=</span> context.getBean(<span class="hljs-string">&quot;person&quot;</span>, Person.class);<br>        landlord.drive();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行测试代码，执行结果如下：</p><blockquote><p>巡视车体及周围情况</p></blockquote><blockquote></blockquote><blockquote><p>发动</p></blockquote><blockquote></blockquote><blockquote><p>开车</p></blockquote><blockquote></blockquote><blockquote><p>熄火</p></blockquote><blockquote></blockquote><blockquote><p>锁车</p></blockquote><h5 id="AspectJ-注解说明："><a href="#AspectJ-注解说明：" class="headerlink" title="AspectJ 注解说明："></a>AspectJ 注解说明：</h5><ul><li>@Before — 前置通知，在连接点方法前调用；</li><li>@Around — 环绕通知，它将覆盖原有方法，但是允许你通过反射调用原有方法；</li><li>@After — 后置通知，在连接点方法后调用；</li><li>@AfterReturning — 返回通知，在连接点方法执行并正常返回后调用，要求连接点方法在执行过程中没有发生异常；</li><li>@AfterThrowing — 异常通知，当连接点方法异常时调用。</li></ul><h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="1-Value-注解的作用是什么？"><a href="#1-Value-注解的作用是什么？" class="headerlink" title="1.@Value 注解的作用是什么？"></a>1.@Value 注解的作用是什么？</h4><p>答：基于 @Value 的注解可以读取 properties 配置文件，使用如下:</p><blockquote><p>@Value(“#{configProperties[‘jdbc.username’]}”)</p></blockquote><blockquote></blockquote><blockquote><p>private String userName;</p></blockquote><p>以上为读取 configProperties 下的 jdbc.username 配置。</p><h4 id="2-Spring-通知类型有哪些？"><a href="#2-Spring-通知类型有哪些？" class="headerlink" title="2.Spring 通知类型有哪些？"></a>2.Spring 通知类型有哪些？</h4><p>答：Spring 通知类型总共有 5 种：前置通知、环绕通知、后置通知、异常通知、最终通知。</p><ul><li>前置通知（Before advice）：在目标方法执行之前执行的通知。在某连接点（ join point ）之前执行的通知，但这个通知不能阻止连接点前的执行（除非它抛出一个异常）。</li><li>环绕通知（Around Advice）：在目标方法执行之前和之后都可以执行额外代码的通知，也可以选择是否继续执行连接点或直接返回它们自己的返回值或抛出异常来结束执行。</li><li>后置通知（After (finally) advice）：目标方法执行之后（某连接点退出的时候）执行的通知（不论是正常返回还是异常退出）。</li><li>异常后通知（After throwing advice）：在方法抛出异常退出时执行的通知。</li><li>最终通知（After returning advice）：在某连接点（join point）正常完成后执行的通知，例如，一个方法没有抛出任何异常，正常返回。</li></ul><h4 id="3-怎么理解-Spring-中的-IOC-容器？"><a href="#3-怎么理解-Spring-中的-IOC-容器？" class="headerlink" title="3.怎么理解 Spring 中的 IOC 容器？"></a>3.怎么理解 Spring 中的 IOC 容器？</h4><p>答：Spring IOC 就是把创建对象的权利交给框架去控制，而不需要人为的去创建，这样就实现了可插拔式的接口编程，有效地降低代码的耦合度，降低了扩展和维护的成本。</p><p>比如，去某地旅游不再用自己亲自为订购 A 酒店还是 B 酒店而发愁了，只需要把住店的需求告诉给某个托管平台，这个托管平台就会帮你订购一个既便宜又舒适的酒店，而这个帮你订购酒店的行为就可以称之为控制反转。</p><h4 id="4-怎么理解-Spring-中的依赖注入？"><a href="#4-怎么理解-Spring-中的依赖注入？" class="headerlink" title="4.怎么理解 Spring 中的依赖注入？"></a>4.怎么理解 Spring 中的依赖注入？</h4><p>答：依赖注入是指组件之间的依赖关系由容器在运行期决定，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。</p><h4 id="5-IoC-和-DI-有什么关系？"><a href="#5-IoC-和-DI-有什么关系？" class="headerlink" title="5.IoC 和 DI 有什么关系？"></a>5.IoC 和 DI 有什么关系？</h4><p>答：IoC 是 Spring 中一个极为重要的概念，提供了对象管理的功能，从而省去了人为创建麻烦，而 DI 正是实现 IoC 的方法和手段。</p><h4 id="6-Component-和-Bean-有什么区别？"><a href="#6-Component-和-Bean-有什么区别？" class="headerlink" title="6.@Component 和 @Bean 有什么区别？"></a>6.@Component 和 @Bean 有什么区别？</h4><p>答：它们的作用对象不同：@Component 作用于类，而 @Bean 注解作用于方法。</p><p>@Component 通常是通过类路径扫描来自动侦测和装配对象到 Spring 容器中，比如 @ComponentScan 注解就是定义扫描路径中的类装配到Spring 的 Bean 容器中；@Bean 注解是告诉 Spring 这是某个类的实例，当我需要用它的时把它给我，@Bean 注解比<br>@Component 注解自定义性更强，很多地方我们只能通过 @Bean 注解来注册 Bean，比如当我们引用第三方库中的类需要装配到<br>Spring容器时，则只能通过 @Bean 来实现，比如以下示例，只能通过 @Bean 注解来实现：</p><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WireThirdLibClass</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ThirdLibClass <span class="hljs-title function_">getThirdLibClass</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThirdLibClass</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-Spring-中-bean-的作用域有几种类型？"><a href="#7-Spring-中-bean-的作用域有几种类型？" class="headerlink" title="7.Spring 中 bean 的作用域有几种类型？"></a>7.Spring 中 bean 的作用域有几种类型？</h4><p>答：Spring 中 bean 的作用域有四种类型，如下列表：</p><ul><li>单例（Singleton）：整个应用程序，只创建 bean 的一个实例；</li><li>原型（Prototype）：每次注入都会创建一个新的 bean 实例；</li><li>会话（Session）：每个会话创建一个 bean 实例，只在 Web 系统中有效；</li><li>请求（Request）：每个请求创建一个 bean 实例，只在 Web 系统中有效。</li></ul><p>Spring 默认的是单例模式。</p><h4 id="8-什么是-Spring-的内部-bean？"><a href="#8-什么是-Spring-的内部-bean？" class="headerlink" title="8.什么是 Spring 的内部 bean？"></a>8.什么是 Spring 的内部 bean？</h4><p>答：当一个 bean 仅被用作另一个 bean 的属性时，它能被声明为一个内部 bean，为了定义 inner Bean，在 Spring 的基于 XML<br>的配置元数据中，可以在 <code>&lt;property/&gt;</code> 或 <code>&lt;constructor-arg/&gt;</code> 元素内使用 <code>&lt;bean/&gt;</code> 元素，内部 bean通常是匿名的，它们的 Scope 一般是 prototype。</p><h4 id="9-Spring-注入方式有哪些？"><a href="#9-Spring-注入方式有哪些？" class="headerlink" title="9.Spring 注入方式有哪些？"></a>9.Spring 注入方式有哪些？</h4><p>答：Spring 的注入方式包含以下五种：</p><ul><li>setter 注入</li><li>构造方法注入</li><li>注解注入</li><li>静态工厂注入</li><li>实例工厂注入</li></ul><p>其中最常用的是前三种，官方推荐使用的是注解注入，相对使用更简单，维护成本更低，更直观。</p><h4 id="10-在-Spring-中如何操作数据库？"><a href="#10-在-Spring-中如何操作数据库？" class="headerlink" title="10.在 Spring 中如何操作数据库？"></a>10.在 Spring 中如何操作数据库？</h4><p>答：在 Spring 中操作数据库，可以使用 Spring 提供的 JdbcTemplate 对象，JdbcTemplate类提供了很多便利的方法，比如把数据库数据转变成基本数据类型或对象，执行自定义的 SQL 语句，提供了自定义的数据错误处理等，JdbcTemplate使用示例如下：</p><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br><span class="hljs-comment">// 新增</span><br><span class="hljs-meta">@GetMapping(&quot;save&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">save</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;INSERT INTO USER (USER_NAME,PASS_WORD) VALUES (&#x27;laowang&#x27;,&#x27;123&#x27;)&quot;</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> jdbcTemplate.update(sql);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;执行成功，影响&quot;</span> + rows + <span class="hljs-string">&quot;行&quot;</span>;<br>&#125;<br><span class="hljs-comment">// 删除</span><br><span class="hljs-meta">@GetMapping(&quot;del&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">del</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span>&#123;<br>    <span class="hljs-type">int</span> rows= jdbcTemplate.update(<span class="hljs-string">&quot;DELETE FROM  USER  WHERE ID = ?&quot;</span>,id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;执行成功，影响&quot;</span> + rows + <span class="hljs-string">&quot;行&quot;</span>;<br>&#125;<br><span class="hljs-comment">// 查询</span><br><span class="hljs-meta">@GetMapping(&quot;getMapById&quot;)</span><br><span class="hljs-keyword">public</span> Map <span class="hljs-title function_">getMapById</span><span class="hljs-params">(Integer id)</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;SELECT * FROM USER WHERE ID = ?&quot;</span>;<br>    Map map= jdbcTemplate.queryForMap(sql,id);<br>    <span class="hljs-keyword">return</span> map;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="11-Spring-的-JdbcTemplate-对象和-JDBC-有什么区别？"><a href="#11-Spring-的-JdbcTemplate-对象和-JDBC-有什么区别？" class="headerlink" title="11.Spring 的 JdbcTemplate 对象和 JDBC 有什么区别？"></a>11.Spring 的 JdbcTemplate 对象和 JDBC 有什么区别？</h4><p>答：Spring 的 JdbcTemplate 是对 JDBC API 的封装，提供更多的功能和更便利的操作，比如 JdbcTemplate 拥有：</p><ul><li>JdbcTemplate 是线程安全的；</li><li>实例化操作比较简单，仅需要传递 DataSource；</li><li>自动完成资源的创建和释放工作；</li><li>创建一次 JdbcTemplate，到处可用，避免重复开发。</li></ul><h4 id="12-Spring-有几种实现事务的方式？"><a href="#12-Spring-有几种实现事务的方式？" class="headerlink" title="12.Spring 有几种实现事务的方式？"></a>12.Spring 有几种实现事务的方式？</h4><p>答：Spring 实现事务有两种方式：编程式事务和声明式事务。<br>编程式事务，使用 TransactionTemplate 或 PlatformTransactionManager 实现，示例代码如下：</p><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TransactionTemplate transactionTemplate;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(User user)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>    <span class="hljs-comment">// Spring编码式事务，回调机制</span><br>    transactionTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionCallback</span>&lt;Object&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">doInTransaction</span><span class="hljs-params">(TransactionStatus status)</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                userMapper.insertSelective(user);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-comment">// 异常，设置为回滚</span><br>                status.setRollbackOnly();<br>                <span class="hljs-keyword">throw</span> e;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果有异常，调用 status.setRollbackOnly() 回滚事务，否则正常执行 doInTransaction() 方法，正常提交事务。<br>如果事务控制的方法不需要返回值，就可以使用 TransactionCallbackWithoutResult（TransactionCallback接口的抽象实现类）示例代码如下：</p><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(User user)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// Spring编码式事务，回调机制</span><br>    transactionTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionCallbackWithoutResult</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doInTransactionWithoutResult</span><span class="hljs-params">(TransactionStatus status)</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                userMapper.insertSelective(user);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-comment">// 异常，设置为回滚</span><br>                status.setRollbackOnly();<br>                <span class="hljs-keyword">throw</span> e;<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>声明式事务，底层是建立在 Spring AOP的基础上，在方式执行前后进行拦截，并在目标方法开始执行前创建新事务或加入一个已存在事务，最后在目标方法执行完后根据情况提交或者回滚事务。<br>声明式事务的优点：不需要编程，减少了代码的耦合，在配置文件中配置并在目标方法上添加 @Transactional 注解来实现，示例代码如下：</p><p>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">save</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;laowang&quot;</span>);<br>    userMapper.insertSelective(user);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;异常&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>抛出异常，事务会自动回滚，如果方法正常执行，则会自动提交事务。</p><h4 id="13-Spring-事务隔离级别有哪些？"><a href="#13-Spring-事务隔离级别有哪些？" class="headerlink" title="13.Spring 事务隔离级别有哪些？"></a>13.Spring 事务隔离级别有哪些？</h4><p>答：Spring 的注入方式包含以下五种：</p><ul><li>ISOLATION_DEFAULT：用底层数据库的设置隔离级别，数据库设置的是什么我就用什么；</li><li>ISOLATIONREADUNCOMMITTED：未提交读，最低隔离级别、事务未提交前，就可被其他事务读取（会出现幻读、脏读、不可重复读）；</li><li>ISOLATIONREADCOMMITTED：提交读，一个事务提交后才能被其他事务读取到（会造成幻读、不可重复读），SQL server 的默认级别；</li><li>ISOLATIONREPEATABLEREAD：可重复读，保证多次读取同一个数据时，其值都和事务开始时候的内容是一致，禁止读取到别的事务未提交的数据（会造成幻读），MySQL 的默认级别；</li><li>ISOLATION_SERIALIZABLE：序列化，代价最高最可靠的隔离级别，该隔离级别能防止脏读、不可重复读、幻读。</li></ul><p>默认值为 ISOLATION_DEFAULT 遵循数据库的事务隔离级别设置。</p><h4 id="14-Spring-声明式事务无效可能的原因有哪些？"><a href="#14-Spring-声明式事务无效可能的原因有哪些？" class="headerlink" title="14.Spring 声明式事务无效可能的原因有哪些？"></a>14.Spring 声明式事务无效可能的原因有哪些？</h4><p>答：可能的原因如下：</p><ul><li>MySQL 使用的是 MyISAM 引擎，而 MyISAM 是不支持事务的；</li><li>@Transactional 使用在非 public 方法上，@Transactional 注解只能支持 public 级别，其他类型声明的事务不会生效；</li><li>@Transactional 在同一个类中无事务方法 A() 内部调用有事务方法 B()，那么此时 B() 事物不会生效。</li></ul><p>Spring 中的 AOP 的底层实现原理是什么？</p><p>答：Spring AOP 的底层实现原理就是动态代理。Spring AOP 的动态代理有两种实现方式，对于接口使用的是 JDK自带的动态代理来实现的，而对比非接口使用的是 CGLib 来实现的，关于动态代理的详细内容，可参考前面【反射和动态代理】的那篇文章。</p><h4 id="15-Spring-中的-Bean-是线程安全的吗？"><a href="#15-Spring-中的-Bean-是线程安全的吗？" class="headerlink" title="15.Spring 中的 Bean 是线程安全的吗？"></a>15.Spring 中的 Bean 是线程安全的吗？</h4><p>答：Spring 中的 Bean 默认是单例模式，Spring 框架并没有对单例 Bean 进行多线程的封装处理，因此默认的情况 Bean<br>并非是安全的，最简单保证 Bean 安全的举措就是设置 Bean 的作用域为 Prototype（原型）模式，这样每次请求都会新建一个 Bean。</p><h4 id="16-说一下-Spring-中-Bean-的生命周期？"><a href="#16-说一下-Spring-中-Bean-的生命周期？" class="headerlink" title="16.说一下 Spring 中 Bean 的生命周期？"></a>16.说一下 Spring 中 Bean 的生命周期？</h4><p>答：Spring 中 Bean 的生命周期如下：</p><ul><li><p>① 实例化 Bean：对于 BeanFactory 容器，当客户向容器请求一个尚未初始化的 Bean 时，或初始化 Bean 的时候需要注入另一个尚未初始化的依赖时，容器就会调用 createBean 进行实例化。对于 ApplicationContext 容器，当容器启动结束后，通过获取 BeanDefinition 对象中的信息，实例化所有的 Bean；</p></li><li><p>② 设置对象属性（依赖注入）：实例化后的对象被封装在 BeanWrapper 对象中，紧接着 Spring 根据 BeanDefinition 中的信息以及通过 BeanWrapper 提供的设置属性的接口完成依赖注入；</p></li><li><p>③ 处理 Aware 接口：Spring 会检测该对象是否实现了 xxxAware 接口，并将相关的 xxxAware 实例注入给 Bean：</p><ul><li>如果这个 Bean 已经实现了 BeanNameAware 接口，会调用它实现的 setBeanName(String BeanId) 方法，此处传递的就是 Spring 配置文件中 Bean 的 id 值；</li><li>如果这个 Bean 已经实现了 BeanFactoryAware 接口，会调用它实现的 setBeanFactory() 方法，传递的是 Spring 工厂自身；</li><li>如果这个 Bean 已经实现了 ApplicationContextAware 接口，会调用 setApplicationContext(ApplicationContext) 方法，传入 Spring 上下文；</li></ul></li><li><p>④ BeanPostProcessor：如果想对 Bean 进行一些自定义的处理，那么可以让 Bean 实现了 BeanPostProcessor 接口，那将会调用 postProcessBeforeInitialization(Object obj, String s) 方法；</p></li><li><p>⑤ InitializingBean 与 init-method：如果 Bean 在 Spring 配置文件中配置了 init-method 属性，则会自动调用其配置的初始化方法；</p></li><li><p>⑥ 如果这个 Bean 实现了 BeanPostProcessor 接口，将会调用 postProcessAfterInitialization(Object obj, String s) 方法；由于这个方法是在 Bean 初始化结束时调用的，因而可以被应用于内存或缓存技术；</p></li></ul><p>以上几个步骤完成后，Bean 就已经被正确创建了，之后就可以使用这个 Bean 了。</p><ul><li>⑦ DisposableBean：当 Bean 不再需要时，会经过清理阶段，如果 Bean 实现了 DisposableBean 这个接口，会调用其实现的 destroy() 方法；</li><li>⑧ destroy-method：最后，如果这个 Bean 的 Spring 配置中配置了 destroy-method 属性，会自动调用其配置的销毁方法。</li></ul><h4 id="17-Spring-有哪些优点"><a href="#17-Spring-有哪些优点" class="headerlink" title="17.Spring 有哪些优点?"></a>17.Spring 有哪些优点?</h4><p>答：Spring 优点如下：</p><ul><li>开源免费的热门框架，稳定性高、解决问题成本低；</li><li>方便集成各种优秀的框架；</li><li>降低了代码耦合性，通过 Spring 提供的 IoC 容器，我们可以将对象之间的依赖关系交由 Spring 进行控制，避免硬编码所造成的过度程序耦合；</li><li>方便程序测试，在 Spring 里，测试变得非常简单，例如：Spring 对 Junit 的支持，可以通过注解方便的测试 Spring 程序；</li><li>降低 Java EE API 的使用难度，Spring 对很多难用的 Java EE API（如 JDBC、JavaMail、远程调用等）提供了一层封装，通过 Spring 的简易封装，让这些 Java EE API 的使用难度大为降低。</li></ul><h4 id="18-Spring-和-Struts-的区别？"><a href="#18-Spring-和-Struts-的区别？" class="headerlink" title="18.Spring 和 Struts 的区别？"></a>18.Spring 和 Struts 的区别？</h4><p>答：Spring 和 Struts 区别如下：<br>Spring 特性如下：</p><ul><li>具备 IOC/DI、AOP 等通用能力，提高研发效率</li><li>除了支持 Web 层建设以外，还提供了 J2EE 整体服务</li><li>方便与其他不同技术结合使用，如 Hibernate、MyBatis 等</li><li>Spring 拦截机制是方法级别</li></ul><p>Struts 特性如下：</p><ul><li>是一个基于 MVC 模式的一个 Web 层的处理</li><li>Struts 拦截机制是类级别</li></ul><h4 id="19-Spring、SpringBoot、SpringCloud-的区别是什么？"><a href="#19-Spring、SpringBoot、SpringCloud-的区别是什么？" class="headerlink" title="19.Spring、SpringBoot、SpringCloud 的区别是什么？"></a>19.Spring、SpringBoot、SpringCloud 的区别是什么？</h4><p>答：它们的区别如下：</p><ul><li>Spring Framework 简称 Spring，是整个 Spring 生态的基础。</li><li>Spring Boot 是一个快速开发框架，让开发者可以迅速搭建一套基于 Spring 的应用程序，并且将常用的 Spring 模块以及第三方模块，如 MyBatis、Hibernate 等都做了很好的集成，只需要简单的配置即可使用，不需要任何的 XML 配置文件，真正做到了开箱即用，同时默认支持 JSON 格式的数据，使用 Spring Boot 进行前后端分离开发也非常便捷。</li><li>Spring Cloud 是一套整合了分布式应用常用模块的框架，使得开发者可以快速实现微服务应用。作为目前非常热门的技术，有关微服务的话题总是在各种场景下被大家讨论，企业的招聘信息中也越来越多地出现对于微服务架构能力的要求。</li></ul><h4 id="20-Spring-中都是用了哪些设计模式？"><a href="#20-Spring-中都是用了哪些设计模式？" class="headerlink" title="20.Spring 中都是用了哪些设计模式？"></a>20.Spring 中都是用了哪些设计模式？</h4><p>答：Spring 中使用的设计模式如下：</p><ul><li>工厂模式：通过 BeanFactory、ApplicationContext 来创建 bean 都是属于工厂模式；</li><li>单例、原型模式：创建 bean 对象设置作用域时，就可以声明 Singleton（单例模式）、Prototype（原型模式）；</li><li>观察者模式：Spring 可以定义一下监听，如 ApplicationListener 当某个动作触发时就会发出通知；</li><li>责任链模式：AOP 拦截器的执行；</li><li>策略模式：在创建代理类时，如果代理的是接口使用的是 JDK 自身的动态代理，如果不是接口使用的是 CGLIB 实现动态代理。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过本节内容我们充分的了解了 Spring 的核心：IoC、DI、AOP，也是用代码演示了 Spring 核心功能的示例，其中可以发现的是 Spring<br>正在从之前的 XML 配置编程变为 Java 注解编程，注解编程让 Spring 更加轻量化简单化了，这一点在我们后面介绍 SpringBoot的时候，会让你更加感同身受。对于开发者来说，只有真正掌握了 Spring，才能称得上是一名合格的 Java<br>工程师。当然，学习的目的是为了更好的应用，因此现在就一起动手实践起来吧。</p><blockquote><p><a href="https://github.com/vipstone/java-interview/tree/master/springlearning">点击此处下载本文源码</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java面试全解析核心知识点与典型面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>028--MyBatis 核心组件</title>
    <link href="/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/028--MyBatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    <url>/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/028--MyBatis%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="MyBatis-介绍"><a href="#MyBatis-介绍" class="headerlink" title="MyBatis 介绍"></a>MyBatis 介绍</h3><p>MyBatis 是一款优秀的 ORM（Object Relational Mapping，对象关系映射）框架，它可以通过对象和数据库之间的映射，将程序中的对象自动存储到数据库中。它是 Apache提供的一个开源项目，之前的名字叫做 iBatis，2010 年迁移到了 Google Code，并且将名字改为我们现在所熟知的 MyBatis，又于2013 年 11 月迁移到了 Github。</p><p>MyBatis 提供了普通 SQL 查询、事务、存储过程等功能，它的优缺点如下。</p><p><strong>优点</strong> ：</p><ul><li>相比于 JDBC 需要编写的代码更少</li><li>使用灵活，支持动态 SQL</li><li>提供映射标签，支持对象与数据库的字段关系映射</li></ul><p><strong>缺点</strong> ：</p><ul><li>SQL 语句依赖于数据库，数据库移植性差</li><li>SQL 语句编写工作量大，尤其在表、字段比较多的情况下</li></ul><p>总体来说，MyBatis 是一个非常优秀和灵活的数据持久化框架，适用于需求多变的互联网项目，也是当前主流的 ORM 框架。</p><h4 id="MyBatis-重要组件"><a href="#MyBatis-重要组件" class="headerlink" title="MyBatis 重要组件"></a>MyBatis 重要组件</h4><p>MyBatis 中的重要组件如下：</p><ul><li>Mapper 配置：用于组织具体的查询业务和映射数据库的字段关系，可以使用 XML 格式或 Java 注解格式来实现；</li><li>Mapper 接口：数据操作接口也就是通常说的 DAO 接口，要和 Mapper 配置文件中的方法一一对应；</li><li>Executor：MyBatis 中所有的 Mapper 语句的执行都是通过 Executor 执行的；</li><li>SqlSession：类似于 JDBC 中的 Connection，可以用 SqlSession 实例来直接执行被映射的 SQL 语句；</li><li>SqlSessionFactory：SqlSessionFactory 是创建 SqlSession 的工厂，可以通过 SqlSession openSession() 方法创建 SqlSession 对象。</li></ul><h4 id="MyBatis-执行流程"><a href="#MyBatis-执行流程" class="headerlink" title="MyBatis 执行流程"></a>MyBatis 执行流程</h4><p>MyBatis 完整执行流程如下图所示：</p><p><img src="https://images.gitbook.cn/4070e4c0-da75-11e9-b7a4-5f21fd84c626" alt="1"></p><p>MyBatis 执行流程说明：</p><ol><li>首先加载 Mapper 配置的 SQL 映射文件，或者是注解的相关 SQL 内容。</li><li>创建会话工厂，MyBatis 通过读取配置文件的信息来构造出会话工厂（SqlSessionFactory）。</li><li>创建会话，根据会话工厂，MyBatis 就可以通过它来创建会话对象（SqlSession），会话对象是一个接口，该接口中包含了对数据库操作的增、删、改、查方法。</li><li>创建执行器，因为会话对象本身不能直接操作数据库，所以它使用了一个叫做数据库执行器（Executor）的接口来帮它执行操作。</li><li>封装 SQL 对象，在这一步，执行器将待处理的 SQL 信息封装到一个对象中（MappedStatement），该对象包括 SQL 语句、输入参数映射信息（Java 简单类型、HashMap 或 POJO）和输出结果映射信息（Java 简单类型、HashMap 或 POJO）。</li><li>操作数据库，拥有了执行器和 SQL 信息封装对象就使用它们访问数据库了，最后再返回操作结果，结束流程。</li></ol><h3 id="MyBatis-XML-版"><a href="#MyBatis-XML-版" class="headerlink" title="MyBatis XML 版"></a>MyBatis XML 版</h3><p>MyBatis 使用分为两个版本：XML 版和 Java 注解版。接下来我们使用 Spring Boot 结合 MyBatis 的 XML版，来实现对数据库的基本操作，步骤如下。</p><h4 id="1）创建数据表"><a href="#1）创建数据表" class="headerlink" title="1）创建数据表"></a>1）创建数据表</h4><p>​    </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> `t_user`;<br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> `t_user` (<br>  `id` <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment comment <span class="hljs-string">&#x27;主键id&#x27;</span>,<br>  `username` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;用户名&#x27;</span>,<br>  `password` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;密码&#x27;</span>,<br>  `nick_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span>,<br>  <span class="hljs-keyword">primary</span> key (`id`)<br>) engine<span class="hljs-operator">=</span>innodb auto_increment<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">default</span> charset<span class="hljs-operator">=</span>utf8;<br></code></pre></td></tr></table></figure><h4 id="2）添加依赖"><a href="#2）添加依赖" class="headerlink" title="2）添加依赖"></a>2）添加依赖</h4><p>在项目添加对 MyBatis 和 MySQL 支持的依赖包，在 pom.xml 文件中添加如下代码：</p><p>​    </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/mysql/mysql-connector-java --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>mybatis-spring-boot-starter 是 MyBatis 官方帮助我们快速集成 Spring Boot 提供的一个组件包，mybatis-spring-boot-starter 2.1.0 对应 MyBatis 的版本是 3.5.2。</p><h4 id="3）增加配置文件"><a href="#3）增加配置文件" class="headerlink" title="3）增加配置文件"></a>3）增加配置文件</h4><p>在 application.yml 文件中添加以下内容：</p><p>​    </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/learndb?serverTimezone=UTC&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=true</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">config-location:</span> <span class="hljs-string">classpath:mybatis/mybatis-config.xml</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mybatis/mapper/*.xml</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.interview.mybatislearning.model</span><br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>mybatis.config-location：配置 MyBatis 基础属性；</li><li>mybatis.mapper-locations：配置 Mapper 对应的 XML 文件路径；</li><li>mybatis.type-aliases-package：配置项目中实体类包路径。</li></ul><p>注：如果配置文件使用的是 application.properties，配置内容是相同的，只是内容格式不同。</p><h4 id="4）创建实体类"><a href="#4）创建实体类" class="headerlink" title="4）创建实体类"></a>4）创建实体类</h4><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserEntity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">5980266333958177104L</span>;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-keyword">private</span> String passWord;<br>    <span class="hljs-keyword">private</span> String nickName;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserEntity</span><span class="hljs-params">(String userName, String passWord, String nickName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userName = userName;<br>        <span class="hljs-built_in">this</span>.passWord = passWord;<br>        <span class="hljs-built_in">this</span>.nickName = nickName;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(Integer id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUserName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> userName;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserName</span><span class="hljs-params">(String userName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userName = userName;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPassWord</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> passWord;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPassWord</span><span class="hljs-params">(String passWord)</span> &#123;<br>        <span class="hljs-built_in">this</span>.passWord = passWord;<br>    &#125;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getNickName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> nickName;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNickName</span><span class="hljs-params">(String nickName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.nickName = nickName;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5）创建-XML-文件"><a href="#5）创建-XML-文件" class="headerlink" title="5）创建 XML 文件"></a>5）创建 XML 文件</h4><p><strong>mybatis-config.xml</strong> （基础配置文件）：</p><p>​    </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">configuration</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span> <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;Integer&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.Integer&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;Long&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.lang.Long&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;HashMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.util.HashMap&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;LinkedHashMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.util.LinkedHashMap&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;ArrayList&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.util.ArrayList&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;LinkedList&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;java.util.LinkedList&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>mybatis-config.xml 主要是为常用的数据类型设置别名，用于减少类完全限定名的长度，比如：<code>resultType=&quot;Integer&quot;</code><br>完整示例代码如下：</p><p>​    </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllCount&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;Integer&quot;</span>&gt;</span><br>    select<br>    count(*)<br>    from t_user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>UserMapper.xml</strong> （业务配置文件）：</p><p>​    </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.interview.mybatislearning.mapper.UserMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.interview.mybatislearning.model.UserEntity&quot;</span> &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;BIGINT&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;userName&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;passWord&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;nick_name&quot;</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;nickName&quot;</span> <span class="hljs-attr">jdbcType</span>=<span class="hljs-string">&quot;VARCHAR&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Base_Column_List&quot;</span> &gt;</span><br>        id, username, password, nick_name<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;Base_Where_List&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;userName != null  and userName != &#x27;&#x27;&quot;</span>&gt;</span><br>            and userName = #&#123;userName&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAll&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span>  &gt;</span><br>        SELECT<br>        <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;Base_Column_List&quot;</span> /&gt;</span><br>        FROM t_user<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getOne&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Long&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;BaseResultMap&quot;</span> &gt;</span><br>        SELECT<br>        <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;Base_Column_List&quot;</span> /&gt;</span><br>        FROM t_user<br>        WHERE id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insert&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.interview.mybatislearning.model.UserEntity&quot;</span> &gt;</span><br>       INSERT INTO<br>               t_user<br>               (username,password,nick_name)<br>           VALUES<br>               (#&#123;userName&#125;, #&#123;passWord&#125;, #&#123;nickName&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;update&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.interview.mybatislearning.model.UserEntity&quot;</span> &gt;</span><br>        UPDATE<br>        t_user<br>        SET<br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;userName != null&quot;</span>&gt;</span>username = #&#123;userName&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;passWord != null&quot;</span>&gt;</span>password = #&#123;passWord&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        nick_name = #&#123;nickName&#125;<br>        WHERE<br>        id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;delete&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;Long&quot;</span> &gt;</span><br>       DELETE FROM<br>                t_user<br>       WHERE<br>                id =#&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>以上配置我们增加了增删改查等基础方法。</p><h4 id="6）增加-Mapper-文件"><a href="#6）增加-Mapper-文件" class="headerlink" title="6）增加 Mapper 文件"></a>6）增加 Mapper 文件</h4><p>此步骤我们需要创建一个与 XML 对应的业务 Mapper 接口，代码如下：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserMapper</span> &#123;<br>    List&lt;UserEntity&gt; <span class="hljs-title function_">getAll</span><span class="hljs-params">()</span>;<br>    UserEntity <span class="hljs-title function_">getOne</span><span class="hljs-params">(Long id)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(UserEntity user)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">(UserEntity user)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Long id)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7）添加-Mapper-包扫描"><a href="#7）添加-Mapper-包扫描" class="headerlink" title="7）添加 Mapper 包扫描"></a>7）添加 Mapper 包扫描</h4><p>在启动类中添加 @MapperScan，设置 Spring Boot 启动的时候会自动加载包路径下的 Mapper。</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;com.interview.mybatislearning.mapper&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBatisLearningApplication</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       SpringApplication.run(MyBatisLearningApplication.class, args);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8）编写测试代码"><a href="#8）编写测试代码" class="headerlink" title="8）编写测试代码"></a>8）编写测试代码</h4><p>经过以上步骤之后，整个 MyBatis 的集成就算完成了。接下来我们写一个单元测试，验证一下。</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MybatislearningApplicationTests</span> &#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testInsert</span><span class="hljs-params">()</span> &#123;<br>        userMapper.insert(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserEntity</span>(<span class="hljs-string">&quot;laowang&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>, <span class="hljs-string">&quot;老王&quot;</span>));<br>        Assert.assertEquals(<span class="hljs-number">1</span>, userMapper.getAll().size());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过本文我们知道 MyBatis 是一个优秀和灵活的数据持久化框架，MyBatis 包含 Mapper 配置、Mapper接口、Executor、SqlSession、SqlSessionFactory 等几个重要的组件，知道了 MyBatis 基本流程：MyBatis首先加载 Mapper 配置和 SQL 映射文件，通过创建会话工厂得到 SqlSession 对象，再执行 SQL 语句并返回操作信息。我们也使用 XML的方式，实现了 MyBatis 对数据库的基础操作。</p><blockquote><p>[点击此处下载本文源码](<a href="https://github.com/vipstone/java-">https://github.com/vipstone/java-</a><br>interview/tree/master/mybatislearning-xml)</p></blockquote><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://tech.meituan.com/2018/01/19/mybatis-cache.html">聊聊MyBatis缓存机制</a></li><li><a href="https://www.cnblogs.com/shamo89/p/8051397.html">Mybatis(三)：MyBatis缓存详解</a></li><li><a href="http://cnblogs.com/shamo89/p/9957291.html">Mybatis(四)：MyBatis核心组件介绍原理解析和源码解读</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java面试全解析核心知识点与典型面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ORM</tag>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>032--MySQL面试题汇总</title>
    <link href="/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/032--MySQL%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/032--MySQL%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="MySQL-面试题汇总"><a href="#MySQL-面试题汇总" class="headerlink" title="MySQL 面试题汇总"></a>MySQL 面试题汇总</h2><h4 id="1-说一下-MySQL-执行一条查询语句的内部执行过程？"><a href="#1-说一下-MySQL-执行一条查询语句的内部执行过程？" class="headerlink" title="1.说一下 MySQL 执行一条查询语句的内部执行过程？"></a>1.说一下 MySQL 执行一条查询语句的内部执行过程？</h4><p>答：MySQL 执行一条查询的流程如下：</p><ul><li>客户端先通过连接器连接到 MySQL 服务器；</li><li>连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器；</li><li>分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器；</li><li>优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好；</li><li>优化器执行完就进入执行器，执行器则开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。</li></ul><h4 id="2-MySQL-查询缓存有什么优缺点？"><a href="#2-MySQL-查询缓存有什么优缺点？" class="headerlink" title="2.MySQL 查询缓存有什么优缺点？"></a>2.MySQL 查询缓存有什么优缺点？</h4><p>答：MySQL 查询缓存功能是在连接器之后发生的，它的优点是效率高，如果已经有缓存则会直接返回结果。</p><p>查询缓存的缺点是失效太频繁导致缓存命中率比较低，任何更新表操作都会清空查询缓存，因此导致查询缓存非常容易失效。</p><h4 id="3-MySQL-的常用引擎都有哪些？"><a href="#3-MySQL-的常用引擎都有哪些？" class="headerlink" title="3.MySQL 的常用引擎都有哪些？"></a>3.MySQL 的常用引擎都有哪些？</h4><p>答：MySQL 的常用引擎有 InnoDB、MyISAM、Memory 等，从 MySQL 5.5.5 版本开始 InnoDB 就成为了默认的存储引擎。</p><h4 id="4-常用的存储引擎-InnoDB-和-MyISAM-有什么区别？"><a href="#4-常用的存储引擎-InnoDB-和-MyISAM-有什么区别？" class="headerlink" title="4.常用的存储引擎 InnoDB 和 MyISAM 有什么区别？"></a>4.常用的存储引擎 InnoDB 和 MyISAM 有什么区别？</h4><p>答：InnoDB 和 MyISAM 最大的区别是 InnoDB 支持事务，而 MyISAM 不支持事务，它们其他主要区别如下：</p><ul><li>InnoDB 支持崩溃后安全恢复，MyISAM 不支持崩溃后安全恢复；</li><li>InnoDB 支持行级锁，MyISAM 不支持行级锁，只支持到表锁；</li><li>InnoDB 支持外键，MyISAM 不支持外键；</li><li>MyISAM 性能比 InnoDB 高；</li><li>MyISAM 支持 FULLTEXT 类型的全文索引，InnoDB 不支持 FULLTEXT 类型的全文索引，但是 InnoDB 可以使用 sphinx 插件支持全文索引，并且效果更好；</li><li>InnoDB 主键查询性能高于 MyISAM。</li></ul><h4 id="5-什么叫回表查询？"><a href="#5-什么叫回表查询？" class="headerlink" title="5.什么叫回表查询？"></a>5.什么叫回表查询？</h4><p>答：普通索引查询到主键索引后，回到主键索引树搜索的过程，我们称为回表查询。</p><h4 id="6-如果把一个-InnoDB-表的主键删掉，是不是就没有主键，就没办法进行回表查询了？"><a href="#6-如果把一个-InnoDB-表的主键删掉，是不是就没有主键，就没办法进行回表查询了？" class="headerlink" title="6.如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？"></a>6.如果把一个 InnoDB 表的主键删掉，是不是就没有主键，就没办法进行回表查询了？</h4><p>答：不是，如果把主键删掉了，那么 InnoDB 会自己生成一个长度为 6 字节的 rowid 作为主键。</p><h4 id="7-一张自增表中有三条数据，删除两条数据之后重启数据库，再新增一条数据，此时这条数据的-ID-是几？"><a href="#7-一张自增表中有三条数据，删除两条数据之后重启数据库，再新增一条数据，此时这条数据的-ID-是几？" class="headerlink" title="7.一张自增表中有三条数据，删除两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？"></a>7.一张自增表中有三条数据，删除两条数据之后重启数据库，再新增一条数据，此时这条数据的 ID 是几？</h4><p>答：如果这张表的引擎是 MyISAM，那么 ID=4，如果是 InnoDB 那么 ID=2（MySQL 8 之前的版本）。</p><h4 id="8-什么是独立表空间和共享表空间？它们的区别是什么？"><a href="#8-什么是独立表空间和共享表空间？它们的区别是什么？" class="headerlink" title="8.什么是独立表空间和共享表空间？它们的区别是什么？"></a>8.什么是独立表空间和共享表空间？它们的区别是什么？</h4><p>答：共享表空间指的是数据库的所有表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。</p><p>独立表空间：每一个表都将会生成以独立的文件方式来进行存储。</p><p>共享表空间和独立表空间最大的区别是如果把表放再共享表空间，即使表删除了空间也不会删除，因此表依然很大，而独立表空间如果删除表就会清除空间。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 查看当前数据库的表空间管理类型</span><br><span class="hljs-string">show</span> <span class="hljs-string">variables</span> <span class="hljs-string">like</span> <span class="hljs-string">&quot;innodb_file_per_table&quot;</span><span class="hljs-string">;</span><br><span class="hljs-comment"># ON代表独立表空间管理，OFF代表共享表空间管理；（查看单表的表空间管理方式，需要查看每个表是否有单独的数据文件）</span><br><span class="hljs-string">innodb_file_per_table=1</span> <span class="hljs-string">为使用独占表空间</span><br><br><span class="hljs-string">innodb_file_per_table=0</span> <span class="hljs-string">为使用共享表空间</span><br><br></code></pre></td></tr></table></figure><h4 id="9-清空表的所有数据性能最好的语句是？"><a href="#9-清空表的所有数据性能最好的语句是？" class="headerlink" title="9.清空表的所有数据性能最好的语句是？"></a>9.清空表的所有数据性能最好的语句是？</h4><p>A：delete from t<br>B：delete t<br>C：drop table t<br>D：truncate table t</p><p>答：D</p><p>题目解析：truncate 清除表数据不会写日志，delete 要写日志，因此 truncate 的效率要高于 delete。</p><h4 id="10-唯一索引和普通索引哪个性能更好？"><a href="#10-唯一索引和普通索引哪个性能更好？" class="headerlink" title="10.唯一索引和普通索引哪个性能更好？"></a>10.唯一索引和普通索引哪个性能更好？</h4><p>答：唯一索引和普通索引的性能对比分为以下两种情况：</p><ul><li>对于查询来说两者都是从索引树进行查询，性能几乎没有任何区别；</li><li>对于更新操作来说，因为唯一索引需要先将数据读取到内存，然后需要判断是否有冲突，因此比唯一索引要多了判断操作，从而性能就比普通索引性能要低。</li></ul><h4 id="11-left-join-和-right-join-的区别是什么？"><a href="#11-left-join-和-right-join-的区别是什么？" class="headerlink" title="11.left join 和 right join 的区别是什么？"></a>11.left join 和 right join 的区别是什么？</h4><p>答：left join 和 right join 的区别如下：</p><ul><li>left join（左联结），返回左表全部记录和右表联结字段相等的记录；</li><li>right join（右联结），返回右表全部记录和左表联结字段相等的记录。</li></ul><h4 id="12-什么是最左匹配原则？它的生效原则有哪些？"><a href="#12-什么是最左匹配原则？它的生效原则有哪些？" class="headerlink" title="12.什么是最左匹配原则？它的生效原则有哪些？"></a>12.什么是最左匹配原则？它的生效原则有哪些？</h4><p>答：最左匹配原则也叫最左前缀原则，是 MySQL中的一个重要原则，指的是索引以最左边为起点任何连续的索引都能匹配上，当遇到范围查询（&gt;、&lt;、between、like）就会停止匹配。<br>生效原则来看以下示例，比如表中有一个联合索引字段 index(a,b,c)：</p><ul><li>where a=1 只使用了索引 a；</li><li>where a=1 and b=2 只使用了索引 a,b；</li><li>where a=1 and b=2 and c=3 使用a,b,c；</li><li>where b=1 or where c=1 不使用索引；</li><li>where a=1 and c=3 只使用了索引 a；</li><li>where a=3 and b like ‘xx%’ and c=3 只使用了索引 a,b。</li></ul><h4 id="13-以下-or-查询有什么问题吗？该如何优化？"><a href="#13-以下-or-查询有什么问题吗？该如何优化？" class="headerlink" title="13.以下 or 查询有什么问题吗？该如何优化？"></a>13.以下 or 查询有什么问题吗？该如何优化？</h4><blockquote><p>select * from t where num=10 or num=20;</p></blockquote><p>答：如果使用 or 查询会使 MySQL 放弃索引而全表扫描，可以改为：</p><blockquote><p>select * from t where num=10</p></blockquote><blockquote></blockquote><blockquote><p>union</p></blockquote><blockquote></blockquote><blockquote><p>select * from t where num=20;</p></blockquote><h4 id="14-事务是什么？它有什么特性？"><a href="#14-事务是什么？它有什么特性？" class="headerlink" title="14.事务是什么？它有什么特性？"></a>14.事务是什么？它有什么特性？</h4><p>答：事务是一系列的数据库操作，是数据库应用的基本单位。</p><p>在 MySQL 中只有 InnoDB 引擎支持事务，它的四个特性如下：</p><ul><li>原子性（Atomic），要么全部执行，要么全部不执行；</li><li>一致性（Consistency），事务的执行使得数据库从一种正确状态转化为另一种正确状态；</li><li>隔离性（Isolation），在事务正确提交之前，不允许把该事务对数据的任何改变提供给其他事务；</li><li>持久性（Durability），事务提交后，其结果永久保存在数据库中。</li></ul><h4 id="15-MySQL-中有几种事务隔离级别？分别是什么？"><a href="#15-MySQL-中有几种事务隔离级别？分别是什么？" class="headerlink" title="15.MySQL 中有几种事务隔离级别？分别是什么？"></a>15.MySQL 中有几种事务隔离级别？分别是什么？</h4><p>答：MySQL 中有四种事务隔离级别，分别是：</p><ul><li>read uncommited，未提交读，读到未提交数据；</li><li>read committed，读已提交，也叫不可重复读，两次读取到的数据不一致；</li><li>repetable read，可重复读；</li><li>serializable，串行化，读写数据都会锁住整张表，数据操作不会出错，但并发性能极低，开发中很少用到。</li></ul><p>MySQL 默认使用 repetable read 的事务隔离级别。</p><h4 id="16-如何设置-MySQL-的事务隔离级别？"><a href="#16-如何设置-MySQL-的事务隔离级别？" class="headerlink" title="16.如何设置 MySQL 的事务隔离级别？"></a>16.如何设置 MySQL 的事务隔离级别？</h4><p>答：MySQL 事务隔离级别 mysql.cnf 文件里设置的（默认目录 /etc/my.cnf），在文件的文末添加配置：</p><blockquote><p>transaction-isolation = REPEATABLE-READ</p></blockquote><p>可用的配置值：READ-UNCOMMITTED、READ-COMMITTED、REPEATABLE-READ、SERIALIZABLE。</p><h4 id="17-MySQL-出现了中文乱码该如何解决？"><a href="#17-MySQL-出现了中文乱码该如何解决？" class="headerlink" title="17.MySQL 出现了中文乱码该如何解决？"></a>17.MySQL 出现了中文乱码该如何解决？</h4><p>答：解决 MySQL 中文乱码的问题，可以设置全局编码或设置某个数据库或表的编码为 utf8。 设置全局编码：</p><p>​    set character_set_client=’utf8’;<br>​    set character_set_connection=’utf8’;<br>​    set character_set_results=’utf8’;</p><p>设置数据库的编码：</p><p>​<br>​    alter database db character set utf8;</p><p>设置表的编码：</p><p>​<br>​    alter table t character set utf8;</p><h4 id="18-InnoDB-为什么要使用-B-树，而不是-B-树、Hash、红黑树或二叉树？"><a href="#18-InnoDB-为什么要使用-B-树，而不是-B-树、Hash、红黑树或二叉树？" class="headerlink" title="18.InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？"></a>18.InnoDB 为什么要使用 B+ 树，而不是 B 树、Hash、红黑树或二叉树？</h4><p>答：因为 B 树、Hash、红黑树或二叉树存在以下问题。</p><ul><li>B 树：不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少（有些资料也称为扇出），指针少的情况下要保存大量数据，只能增加树的高度，导致 IO 操作变多，查询性能变低。</li><li>Hash：虽然可以快速定位，但是没有顺序，IO 复杂度高。</li><li>二叉树：树的高度不均匀，不能自平衡，查找效率跟数据有关（树的高度），并且 IO 代价高。</li><li>红黑树：树的高度随着数据量增加而增加，IO 代价高。</li></ul><h4 id="19-MySQL-是如何处理死锁？"><a href="#19-MySQL-是如何处理死锁？" class="headerlink" title="19.MySQL 是如何处理死锁？"></a>19.MySQL 是如何处理死锁？</h4><p>答：MySQL 对待死锁常见的两种策略：</p><ul><li>通过 innodb_lock_wait_timeout 来设置超时时间，一直等待直到超时；</li><li>发起死锁检测，发现死锁之后，主动回滚死锁中的某一个事务，让其他事务继续执行。</li></ul><h4 id="20-什么是全局锁？它的应用场景有哪些？"><a href="#20-什么是全局锁？它的应用场景有哪些？" class="headerlink" title="20.什么是全局锁？它的应用场景有哪些？"></a>20.什么是全局锁？它的应用场景有哪些？</h4><p>答：全局锁就是对整个数据库实例加锁，它的典型使用场景就是做全量逻辑备份，这个时候整个库会处于完全的只读状态。</p><h4 id="21-使用全局锁会导致什么问题？"><a href="#21-使用全局锁会导致什么问题？" class="headerlink" title="21.使用全局锁会导致什么问题？"></a>21.使用全局锁会导致什么问题？</h4><p>答：使用全局锁会使整个系统不能执行更新操作，所有的更新业务会出于等待状态；如果你是在从库进行备份，则会导致主从同步严重延迟。</p><h4 id="22-InnoDB-存储引擎有几种锁算法？"><a href="#22-InnoDB-存储引擎有几种锁算法？" class="headerlink" title="22.InnoDB 存储引擎有几种锁算法？"></a>22.InnoDB 存储引擎有几种锁算法？</h4><p>答：InnoDB 的锁算法包括以下三种：</p><ul><li>Record Lock — 单个行记录上的锁；</li><li>Gap Lock — 间隙锁，锁定一个范围，不包括记录本身；</li><li>Next-Key Lock — 锁定一个范围，包括记录本身。</li></ul><h4 id="23-InnoDB-如何实现行锁？"><a href="#23-InnoDB-如何实现行锁？" class="headerlink" title="23.InnoDB 如何实现行锁？"></a>23.InnoDB 如何实现行锁？</h4><p>答：只有通过索引条件检索数据，InnoDB 才使用行级锁，否则 InnoDB 将使用表锁。使用 for update 来实现行锁，具体脚本如下：</p><blockquote><p>select * from t where id=1 for update</p></blockquote><p>其中 id 字段必须有索引。</p><h4 id="24-MySQL-性能指标都有哪些？如何得到这些指标？"><a href="#24-MySQL-性能指标都有哪些？如何得到这些指标？" class="headerlink" title="24.MySQL 性能指标都有哪些？如何得到这些指标？"></a>24.MySQL 性能指标都有哪些？如何得到这些指标？</h4><p>答：MySQL 最重要的性能指标有以下两个：</p><ul><li>QPS（Queries Per Second），每秒查询数，一台数据库每秒能够处理的查询次数；</li><li>TPS（Transactions Per Second），每秒处理事务数。</li></ul><p>这些性能指标可以通过 show status 来查询当前数据库状态的结果信息中估算出来，show status 会有 300<br>多条状态信息记录，其中以下这些信息 QPS 和 TPS 有关系：</p><ul><li>Uptime，服务器已经运行的时间，单位秒；</li><li>Questions，已经发送给数据库查询数；</li><li>Com_select，查询次数，实际查询次数；</li><li>Com_insert，插入次数；</li><li>Com_delete，删除次数；</li><li>Com_update，更新次数；</li><li>Com_commit，事务次数；</li><li>Com_rollback，回滚次数。</li></ul><h4 id="25-MySQL-中的重要日志分为哪几个？"><a href="#25-MySQL-中的重要日志分为哪几个？" class="headerlink" title="25.MySQL 中的重要日志分为哪几个？"></a>25.MySQL 中的重要日志分为哪几个？</h4><p><strong>① 错误日志</strong> ：用来记录 MySQL 服务器运行过程中的错误信息，比如，无法加载 MySQL数据库的数据文件，或权限不正确等都会被记录在此，还有复制环境下，从服务器进程的信息也会被记录进错误日志。默认情况下，错误日志是开启的，且无法被禁止。默认情况下，错误日志是存储在数据库的数据文件目录中，名称为hostname.err，其中 hostname 为服务器主机名。在 MySQL 5.5.7之前，数据库管理员可以删除很长时间之前的错误日志，以节省服务器上的硬盘空间， MySQL 5.5.7之后，服务器将关闭此项功能，只能使用重命名原来的错误日志文件，手动冲洗日志创建一个新的，命令为：</p><blockquote><p>mv hostname.err hostname.err.old</p></blockquote><blockquote></blockquote><blockquote><p>mysqladmin flush-logs</p></blockquote><p><strong>② 查询日志</strong> ：查询日志在 MySQL 中被称为 general log（通用日志），查询日志里的内容不要被“查询日志”误导，认为里面只存储<br>select 语句，其实不然，查询日志里面记录了数据库执行的所有命令，不管语句是否正确，都会被记录，具体原因如下:</p><ul><li>insert 查询为了避免数据冲突，如果此前插入过数据，则当前插入的数据如果跟主键或唯一键的数据重复那肯定会报错；</li><li>update 时也会查询因为更新的时候很可能会更新某一块数据；</li><li>delete 查询，只删除符合条件的数据；</li></ul><p>因此都会产生日志，在并发操作非常多的场景下，查询信息会非常多，那么如果都记录下来会导致 IO 非常大，影响 MySQL性能。因此如果不是在调试环境下，是不建议开启查询日志功能的。</p><p>查询日志的开启有助于帮助我们分析哪些语句执行密集，执行密集的 select语句对应的数据是否能够被缓存，同时也可以帮助我们分析问题，因此，可以根据自己的实际情况来决定是否开启查询日志。</p><p>查询日志模式是关闭的，可以通过以下命令开启查询日志：</p><blockquote><p>set global general_log=1</p></blockquote><blockquote></blockquote><blockquote><p>set global log_output=’table’;</p></blockquote><p>general_log=1 为开启查询日志，0 为关闭查询日志，这个设置命令即时生效，不用重启 MySQL 服务器。</p><p><strong>③ 慢日志</strong> ：慢查询会导致 CPU、IOPS、内存消耗过高，当数据库遇到性能瓶颈时，大部分时间都是由于慢查询导致的。开启慢查询日志，可以让MySQL记录下查询超过指定时间的语句，之后运维人员通过定位分析，能够很好的优化数据库性能。默认情况下，慢查询日志是不开启的，只有手动开启了，慢查询才会被记录到慢查询日志中。使用如下命令记录当前数据库的慢查询语句：</p><blockquote><p>set global slow_query_log=’ON’;</p></blockquote><p>使用 set global slow_query_log=’ON’ 开启慢查询日志，只是对当前数据库有效，如果 MySQL数据库重启后就会失效。因此如果要永久生效，就要修改配置文件 my.cnf，设置 slow_query_log=1 并重启 MySQL 服务器。</p><p><strong>④ redo log（重做日志）</strong> ：为了最大程度的避免数据写入时，因为 IO 瓶颈造成的性能问题，MySQL采用了这样一种缓存机制，先将数据写入内存中，再批量把内存中的数据统一刷回磁盘。为了避免将数据刷回磁盘过程中，因为掉电或系统故障带来的数据丢失问题，InnoDB采用 redo log 来解决此问题。</p><p><strong>⑤ undo log（回滚日志）</strong> ：用于存储日志被修改前的值，从而保证如果修改出现异常，可以使用 undo log 日志来实现回滚操作。</p><p>undo log 和 redo log 记录物理日志不一样，它是逻辑日志，可以认为当 delete 一条记录时，undo log 中会记录一条对应的<br>insert 记录，反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录，当执行 rollback 时，就可以从 undo<br>log 中的逻辑记录读取到相应的内容并进行回滚。undo log 默认存放在共享表空间中，在 MySQL 5.6 中，undo log的存放位置还可以通过变量 innodb_undo_directory 来自定义存放目录，默认值为“.”表示 datadir 目录。</p><p><strong>⑥ bin log（二进制日志）</strong> ：是一个二进制文件，主要记录所有数据库表结构变更，比如，CREATE、ALTER TABLE等，以及表数据修改，比如，INSERT、UPDATE、DELETE 的所有操作，bin log 中记录了对 MySQL数据库执行更改的所有操作，并且记录了语句发生时间、执行时长、操作数据等其他额外信息，但是它不记录 SELECT、SHOW 等那些不修改数据的 SQL 语句。<br>binlog 的作用如下：</p><ul><li>恢复（recovery）：某些数据的恢复需要二进制日志。比如，在一个数据库全备文件恢复后，用户可以通过二进制日志进行 point-in-time 的恢复；</li><li>复制（replication）：其原理与恢复类似，通过复制和执行二进制日志使一台远程的 MySQL 数据库（一般称为 slave 或者standby）与一台 MySQL 数据库（一般称为 master 或者 primary）进行实时同步；</li><li>审计（audit）：用户可以通过二进制日志中的信息来进行审计，判断是否有对数据库进行注入攻击。</li></ul><p>除了上面介绍的几个作用外，binlog 对于事务存储引擎的崩溃恢复也有非常重要的作用，在开启 binlog 的情况下，为了保证 binlog 与 redo的一致性，MySQL 将采用事务的两阶段提交协议。当 MySQL 系统发生崩溃时，事务在存储引擎内部的状态可能为 prepared（准备状态）和commit（提交状态）两种，对于 prepared 状态的事务，是进行提交操作还是进行回滚操作，这时需要参考 binlog，如果事务在 binlog中存在，那么将其提交；如果不在 binlog 中存在，那么将其回滚，这样就保证了数据在主库和从库之间的一致性。</p><p>binlog 默认是关闭状态，可以在 MySQL 配置文件（my.cnf）中通过配置参数 log-bin = [base-name] 开启记录 binlog日志，如果不指定 base-name，则默认二进制日志文件名为主机名，并以自增的数字作为后缀，比如：mysql-bin.000001，所在目录为数据库所在目录（datadir）。</p><p>通过以下命令来查询 binlog 是否开启：</p><blockquote><p>show variables like ‘log_%’;</p></blockquote><p><img src="https://images.gitbook.cn/48857550-df7e-11e9-9b80-07a210d8c96e" alt="1"></p><p>binlog 格式分为 STATEMENT、ROW 和 MIXED 三种。</p><ul><li>STATEMENT 格式的 binlog 记录的是数据库上执行的原生 SQL 语句。这种格式的优点是简单，简单地记录和执行这些语句，能够让主备保持同步，在主服务器上执行的 SQL 语句，在从服务器上执行同样的语句。另一个好处是二进制日志里的时间更加紧凑，因此相对而言，基于语句的复制模式不会使用太多带宽，同时也节约磁盘空间，并且通过 mysqlbinlog 工具容易读懂其中的内容。缺点就是同一条 SQL 在主库和从库上执行的时间可能稍微或很大不相同，因此在传输的二进制日志中，除了查询语句，还包括了一些元数据信息，如当前的时间戳。即便如此，还存在着一些无法被正确复制的 SQL，比如，使用 INSERT INTO TB1 VALUE(CUURENT_DATE()) 这一条使用函数的语句插入的数据复制到当前从服务器上来就会发生变化，存储过程和触发器在使用基于语句的复制模式时也可能存在问题；另外一个问题就是基于语句的复制必须是串行化的，比如，InnoDB 的 next-key 锁等，并不是所有的存储引擎都支持基于语句的复制。</li><li>ROW 格式是从 MySQL 5.1 开始支持基于行的复制，也就是基于数据的复制，基于行的更改。这种方式会将实际数据记录在二进制日志中，它有其自身的一些优点和缺点，最大的好处是可以正确地复制每一行数据，一些语句可以被更加有效地复制，另外就是几乎没有基于行的复制模式无法处理的场景，对于所有的 SQL 构造、触发器、存储过程等都能正确执行；它的缺点就是二进制日志可能会很大，而且不直观，因此，你不能使用 mysqlbinlog 来查看二进制日志，也无法通过看二进制日志判断当前执行到那一条 SQL 语句。现在对于 ROW 格式的二进制日志基本是标配了，主要是因为它的优势远远大于缺点，并且由于 ROW 格式记录行数据，因此可以基于这种模式做一些 DBA 工具，比如数据恢复，不同数据库之间数据同步等。</li><li>MIXED 也是 MySQL 默认使用的二进制日志记录方式，但 MIXED 格式默认采用基于语句的复制，一旦发现基于语句的无法精确的复制时，就会采用基于行的复制。比如用到 UUID()、USER()、CURRENT_USER()、ROW_COUNT() 等无法确定的函数。</li></ul><h4 id="26-redo-log-和-binlog-有什么区别？"><a href="#26-redo-log-和-binlog-有什么区别？" class="headerlink" title="26.redo log 和 binlog 有什么区别？"></a>26.redo log 和 binlog 有什么区别？</h4><p>redo log（重做日志）和 binlog（归档日志）都是 MySQL 的重要的日志，它们的区别如下：</p><ul><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；</li><li>binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”；</li><li>redo log 是 InnoDB 引擎特有的，binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用；</li><li>redo log 是循环写的，空间固定会用完，binlog 是可以追加写入的，“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ul><p>最开始 MySQL 里并没有 InnoDB 引擎，MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe能力的，因此 InnoDB 使用另外一套日志系统，也就是 redo log 来实现 crash-safe 能力。</p><h4 id="27-慢查询日志的获取方式有哪些？"><a href="#27-慢查询日志的获取方式有哪些？" class="headerlink" title="27.慢查询日志的获取方式有哪些？"></a>27.慢查询日志的获取方式有哪些？</h4><p>答：慢查询日志的常见获取方式如下。</p><ul><li>使用 MySQL 自带功能，开启慢查询日志，在 MySQL 的安装目录下找到 my.cnf 文件设置 <code>slow-query-log=On</code> 开启慢查询，慢查询默认时长为 10s，默认存储文件名为 host_name-slow.log。</li><li>使用三方开源方案 zabbix，zabbix 是一个基于 Web 界面的提供分布式系统监视以及网络监视功能的企业级的开源解决方案，能监视各种网络参数，保证服务器系统的安全运营；并提供灵活的通知机制以让系统管理员快速定位/解决存在的各种问题。</li></ul><h4 id="28-如何定位慢查询？"><a href="#28-如何定位慢查询？" class="headerlink" title="28.如何定位慢查询？"></a>28.如何定位慢查询？</h4><p>答：使用 MySQL 中的 explain 分析执行语句，比如：</p><blockquote><p>explain select * from t where id=5;</p></blockquote><p>如下图所示：</p><p><img src="https://images.gitbook.cn/5ec8ebd0-df7e-11e9-9b80-07a210d8c96e" alt="2"></p><p>其中：</p><ul><li>id — 选择标识符，id 越大优先级越高，越先被执行</li><li>select_type — 表示查询的类型。</li><li>table — 输出结果集的表</li><li>partitions — 匹配的分区</li><li>type — 表示表的连接类型</li><li>possible_keys — 表示查询时，可能使用的索引</li><li>key — 表示实际使用的索引</li><li>key_len — 索引字段的长度</li><li>ref— 列与索引的比较</li><li>rows — 大概估算的行数</li><li>filtered — 按表条件过滤的行百分比</li><li>Extra — 执行情况的描述和说明</li></ul><p>其中最重要的就是 type 字段，type 值类型如下：</p><ul><li>all — 扫描全表数据</li><li>index — 遍历索引</li><li>range — 索引范围查找</li><li>index_subquery — 在子查询中使用 ref</li><li>unique_subquery — 在子查询中使用 eq_ref</li><li>ref_or_null — 对 null 进行索引的优化的 ref</li><li>fulltext — 使用全文索引</li><li>ref — 使用非唯一索引查找数据</li><li>eq_ref — 在 join 查询中使用主键或唯一索引关联</li><li>const — 将一个主键放置到 where 后面作为条件查询， MySQL 优化器就能把这次查询优化转化为一个常量，如何转化以及何时转化，这个取决于优化器，这个比 eq_ref 效率高一点</li></ul><h4 id="29-MySQL-中常见的读写分离方案有哪些？"><a href="#29-MySQL-中常见的读写分离方案有哪些？" class="headerlink" title="29.MySQL 中常见的读写分离方案有哪些？"></a>29.MySQL 中常见的读写分离方案有哪些？</h4><p>答：MySQL 中常见的读写分离方案通常为以下两种：</p><ul><li>使用 MySQL 官方提供的数据库代理产品 MySql ProxySQL 搭建自动分配的数据库读写分离环境；</li><li>在程序层面配置多数据源使用代码实现读写分离。</li></ul><h4 id="30-怎样保证主备数据库无延迟？"><a href="#30-怎样保证主备数据库无延迟？" class="headerlink" title="30.怎样保证主备数据库无延迟？"></a>30.怎样保证主备数据库无延迟？</h4><p>答：通常保证主备数据库无延迟有以下三种方法。</p><ul><li>每次从库执行查询请求前，先判断 seconds_behind_master 是否已经等于 0。如果还不等于 0 ，那就必须等到这个参数变为 0 才能执行查询请求，seconds_behind_master 参数是用来衡量主备延迟时间的长短。</li><li>对比位点确保主备无延迟。Master_Log_File 和 Read_Master_Log_Pos，表示的是读到的主库的最新位点，Relay_Master_Log_File 和 Exec_Master_Log_Pos，表示的是备库执行的最新位点。</li><li>对比 GTID 集合确保主备无延迟。Auto_Position=1 ，表示这对主备关系使用了 GTID 协议。Retrieved_Gtid_Set，是备库收到的所有日志的 GTID 集合；Executed_Gtid_Set，是备库所有已经执行完成的 GTID 集合。</li></ul><h4 id="31-什么是-MySQL-多实例，如何配置-MySQL-多实例？"><a href="#31-什么是-MySQL-多实例，如何配置-MySQL-多实例？" class="headerlink" title="31.什么是 MySQL 多实例，如何配置 MySQL 多实例？"></a>31.什么是 MySQL 多实例，如何配置 MySQL 多实例？</h4><p>答：MySQL 多实例就是在同一台服务器上启用多个 MySQL服务，它们监听不同的端口，运行多个服务进程，它们相互独立，互不影响的对外提供服务，便于节约服务器资源与后期架构扩展。 多实例的配置方法有两种：</p><ul><li>一个实例一个配置文件，不同端口；</li><li>同一配置文件（my.cnf）下配置不同实例，基于 MySQL 的 d_multi 工具。</li></ul><h4 id="32-表的优化策略有哪些？"><a href="#32-表的优化策略有哪些？" class="headerlink" title="32.表的优化策略有哪些？"></a>32.表的优化策略有哪些？</h4><p>「参考答案」常见的大表优化策略如下。</p><ul><li>读写分离，主库负责写，从库负责读。</li><li>垂直分区，根据数据属性单独拆表甚至单独拆库。</li><li>水平分区，保持表结构不变，根据策略存储数据分片，这样每一片数据被分散到不同的表或者库中。水平拆分只是解决了单一表数据过大的问题，表数据还在同一台机器上，对于并发能力没有什么意义，因此水平拆分最好分库。另外分片事务难以解决，跨节点 join 性能较差。</li></ul><h4 id="33-数据库分片方案有哪些？"><a href="#33-数据库分片方案有哪些？" class="headerlink" title="33.数据库分片方案有哪些？"></a>33.数据库分片方案有哪些？</h4><p>「参考答案」数据库分片方案有哪些？ 答：数据库创建的分片方案有两种方式：客户端代理方式和中间件代理方式。</p><ul><li>客户端代理 — 分片逻辑在应用端，封装在 jar 包中，通过修改或者封装 JDBC 层来实现，比如 Sharding-JDBC、阿里 TDDL 等。</li><li>中间件代理 — 在应用层和数据层中间加了一个代理层。分片逻辑统一维护在中间件服务中，比如 MyCat、网易的 DDB 都是中间件代理的典型代表。</li></ul><h4 id="34-查询语句的优化方案有哪些？"><a href="#34-查询语句的优化方案有哪些？" class="headerlink" title="34.查询语句的优化方案有哪些？"></a>34.查询语句的优化方案有哪些？</h4><p>「参考答案」常见优化方案如下：</p><ul><li>不做列运算，把计算都放入各个业务系统实现；</li><li>查询语句尽可能简单，大语句拆小语句，减少锁时间；</li><li>不使用 select * 查询；</li><li>or 查询改写成 in 查询；</li><li>不用函数和触发器；</li><li>避免 %xx 查询；</li><li>少用 join 查询；</li><li>使用同类型比较，比如 ‘123’ 和 ‘123’、123 和 123；</li><li>尽量避免在 where 子句中使用 != 或者 &lt;&gt; 操作符，查询引用会放弃索引而进行全表扫描；</li><li>列表数据使用分页查询，每页数据量不要太大。</li></ul><h4 id="35-MySQL-毫无规律的异常重启，可能产生的原因是什么？该如何解决？"><a href="#35-MySQL-毫无规律的异常重启，可能产生的原因是什么？该如何解决？" class="headerlink" title="35.MySQL 毫无规律的异常重启，可能产生的原因是什么？该如何解决？"></a>35.MySQL 毫无规律的异常重启，可能产生的原因是什么？该如何解决？</h4><p>「参考答案」可能是积累的长连接导致内存占用太多，被系统强行杀掉导致的异常重启，因为在 MySQL中长连接在执行过程中使用的临时内存对象，只有在连接断开的时候才会释放，这就会导致内存不断飙升，解决方案如下：</p><ul><li>定期断开空闲的长连接；</li><li>如果是用的是 MySQL 5.7 以上的版本，可以定期执行 mysql_reset_connection 重新初始化连接资源，这个过程会释放之前使用的内存资源，恢复到连接刚初始化的状态。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java面试全解析核心知识点与典型面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>019--线程池之 ThreadPoolExecutor + 面试题</title>
    <link href="/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/019--%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BThreadPoolExecutor+%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/019--%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B9%8BThreadPoolExecutor+%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="线程池介绍"><a href="#线程池介绍" class="headerlink" title="线程池介绍"></a>线程池介绍</h3><p>线程池（Thread Pool）：把一个或多个线程通过统一的方式进行调度和重复使用的技术，避免了因为线程过多而带来使用上的开销。</p><h4 id="为什么要使用线程池？"><a href="#为什么要使用线程池？" class="headerlink" title="为什么要使用线程池？"></a>为什么要使用线程池？</h4><ul><li>可重复使用已有线程，避免对象创建、消亡和过度切换的性能开销。</li><li>避免创建大量同类线程所导致的资源过度竞争和内存溢出的问题。</li><li>支持更多功能，比如延迟任务线程池（newScheduledThreadPool）和缓存线程池（newCachedThreadPool）等。</li></ul><h3 id="线程池使用"><a href="#线程池使用" class="headerlink" title="线程池使用"></a>线程池使用</h3><p>创建线程池有两种方式：ThreadPoolExecutor 和 Executors，其中 Executors 又可以创建 6<br>种不同的线程池类型，会在下节讲，本节重点来看看 ThreadPoolExecutor 的使用。</p><h4 id="ThreadPoolExecutor-的使用"><a href="#ThreadPoolExecutor-的使用" class="headerlink" title="ThreadPoolExecutor 的使用"></a>ThreadPoolExecutor 的使用</h4><p>线程池使用代码如下：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPoolExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10L</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>(<span class="hljs-number">100</span>));<br>threadPoolExecutor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 执行线程池</span><br>        System.out.println(<span class="hljs-string">&quot;Hello, Java.&quot;</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>Hello, Java.</p></blockquote><h4 id="ThreadPoolExecutor-参数说明"><a href="#ThreadPoolExecutor-参数说明" class="headerlink" title="ThreadPoolExecutor 参数说明"></a>ThreadPoolExecutor 参数说明</h4><p>ThreadPoolExecutor 构造方法有以下四个，如下图所示：</p><p><img src="https://images.gitbook.cn/ce89fc40-d2d4-11e9-b6c4-07be7ef1cd0f" alt="enter image descriptionhere"></p><p>其中最后一个构造方法有 7 个构造参数，包含了前三个方法的构造参数，这 7 个参数名称如下所示：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span> &#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>其代表的含义如下：</p><h5 id="①-corePoolSize"><a href="#①-corePoolSize" class="headerlink" title="① corePoolSize"></a>① corePoolSize</h5><p>线程池中的核心线程数，默认情况下核心线程一直存活在线程池中，如果将 ThreadPoolExecutor 的 allowCoreThreadTimeOut<br>属性设为 true，如果线程池一直闲置并超过了 keepAliveTime 所指定的时间，核心线程就会被终止。</p><h5 id="②-maximumPoolSize"><a href="#②-maximumPoolSize" class="headerlink" title="② maximumPoolSize"></a>② maximumPoolSize</h5><p>线程池中最大线程数，如果活动的线程达到这个数值以后，后续的新任务将会被阻塞（放入任务队列）。</p><h5 id="③-keepAliveTime"><a href="#③-keepAliveTime" class="headerlink" title="③ keepAliveTime"></a>③ keepAliveTime</h5><p>线程池的闲置超时时间，默认情况下对非核心线程生效，如果闲置时间超过这个时间，非核心线程就会被回收。如果 ThreadPoolExecutor 的<br>allowCoreThreadTimeOut 设为 true 的时候，核心线程如果超过闲置时长也会被回收。</p><h5 id="④-unit"><a href="#④-unit" class="headerlink" title="④ unit"></a>④ unit</h5><p>配合 keepAliveTime 使用，用来标识 keepAliveTime 的时间单位。</p><h5 id="⑤-workQueue"><a href="#⑤-workQueue" class="headerlink" title="⑤ workQueue"></a>⑤ workQueue</h5><p>线程池中的任务队列，使用 execute() 或 submit() 方法提交的任务都会存储在此队列中。</p><h5 id="⑥-threadFactory"><a href="#⑥-threadFactory" class="headerlink" title="⑥ threadFactory"></a>⑥ threadFactory</h5><p>为线程池提供创建新线程的线程工厂。</p><h5 id="⑦-rejectedExecutionHandler"><a href="#⑦-rejectedExecutionHandler" class="headerlink" title="⑦ rejectedExecutionHandler"></a>⑦ rejectedExecutionHandler</h5><p>线程池任务队列超过最大值之后的拒绝策略，RejectedExecutionHandler 是一个接口，里面只有一个 rejectedExecution<br>方法，可在此方法内添加任务超出最大值的事件处理。ThreadPoolExecutor 也提供了 4 种默认的拒绝策略：</p><ul><li>new ThreadPoolExecutor.DiscardPolicy()：丢弃掉该任务，不进行处理</li><li>new ThreadPoolExecutor.DiscardOldestPolicy()：丢弃队列里最近的一个任务，并执行当前任务</li><li>new ThreadPoolExecutor.AbortPolicy()：直接抛出 RejectedExecutionException 异常</li><li>new ThreadPoolExecutor.CallerRunsPolicy()：既不抛弃任务也不抛出异常，直接使用主线程来执行此任务</li></ul><p>包含所有参数的 ThreadPoolExecutor 使用代码：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExecutorTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                <span class="hljs-number">10L</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="hljs-number">2</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThreadFactory</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<br>        threadPool.allowCoreThreadTimeOut(<span class="hljs-literal">true</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            threadPool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    System.out.println(Thread.currentThread().getName());<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">2000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MyThread&quot;</span> + count.addAndGet(<span class="hljs-number">1</span>);<br>        t.setName(threadName);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="线程池执行方法-execute-VS-submit"><a href="#线程池执行方法-execute-VS-submit" class="headerlink" title="线程池执行方法 execute() VS submit()"></a>线程池执行方法 execute() VS submit()</h4><p>execute() 和 submit() 都是用来执行线程池的，区别在于 submit() 方法可以接收线程池执行的返回值。</p><p>下面分别来看两个方法的具体使用和区别：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建线程池</span><br><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPoolExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10L</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>(<span class="hljs-number">100</span>));<br><span class="hljs-comment">// execute 使用</span><br>threadPoolExecutor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, Java.&quot;</span>);<br>    &#125;<br>&#125;);<br><span class="hljs-comment">// submit 使用</span><br>Future&lt;String&gt; future = threadPoolExecutor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, 老王.&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Success&quot;</span>;<br>    &#125;<br>&#125;);<br>System.out.println(future.get());<br></code></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>Hello, Java.</p></blockquote><blockquote></blockquote><blockquote><p>Hello, 老王.</p></blockquote><blockquote></blockquote><blockquote><p>Success</p></blockquote><h4 id="线程池关闭"><a href="#线程池关闭" class="headerlink" title="线程池关闭"></a>线程池关闭</h4><p>线程池关闭，可以使用 shutdown() 或 shutdownNow() 方法，它们的区别是：</p><ul><li>shutdown()：不会立即终止线程池，而是要等所有任务队列中的任务都执行完后才会终止。执行完 shutdown 方法之后，线程池就不会再接受新任务了。</li><li>shutdownNow()：执行该方法，线程池的状态立刻变成 STOP 状态，并试图停止所有正在执行的线程，不再处理还在池队列中等待的任务，执行此方法会返回未执行的任务。</li></ul><p>下面用代码来模拟 shutdown() 之后，给线程池添加任务，代码如下：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">threadPoolExecutor.execute(() -&gt; &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>        System.out.println(<span class="hljs-string">&quot;I&#x27;m &quot;</span> + i);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            System.out.println(e.getMessage());<br>        &#125;<br>    &#125;<br>&#125;);<br>threadPoolExecutor.shutdown();<br>threadPoolExecutor.execute(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;I&#x27;m Java.&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>以上程序执行结果如下：</p><blockquote><p>I’m 0</p></blockquote><blockquote></blockquote><blockquote><p>Exception in thread “main” java.util.concurrent.RejectedExecutionException:<br>Task com.interview.chapter5.Section2<code>$$Lambda$2</code>/1828972342@568db2f2 rejected<br>from java.util.concurrent.ThreadPoolExecutor@378bf509[Shutting down, pool size<br>= 1, active threads = 1, queued tasks = 0, completed tasks = 0]</p></blockquote><blockquote></blockquote><blockquote><p>I’m 1</p></blockquote><p>可以看出，shutdown() 之后就不会再接受新的任务了，不过之前的任务会被执行完成。</p><h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="1-ThreadPoolExecutor-有哪些常用的方法？"><a href="#1-ThreadPoolExecutor-有哪些常用的方法？" class="headerlink" title="1.ThreadPoolExecutor 有哪些常用的方法？"></a>1.ThreadPoolExecutor 有哪些常用的方法？</h4><p>答：常用方法如下所示：</p><ul><li>submit()/execute()：执行线程池</li><li>shutdown()/shutdownNow()：终止线程池</li><li>isShutdown()：判断线程是否终止</li><li>getActiveCount()：正在运行的线程数</li><li>getCorePoolSize()：获取核心线程数</li><li>getMaximumPoolSize()：获取最大线程数</li><li>getQueue()：获取线程池中的任务队列</li><li>allowCoreThreadTimeOut(boolean)：设置空闲时是否回收核心线程</li></ul><h4 id="2-以下程序执行的结果是什么？"><a href="#2-以下程序执行的结果是什么？" class="headerlink" title="2.以下程序执行的结果是什么？"></a>2.以下程序执行的结果是什么？</h4><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPoolExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10L</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>());<br>threadPoolExecutor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;I：&quot;</span> + i);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;);<br>threadPoolExecutor.shutdownNow();<br>System.out.println(<span class="hljs-string">&quot;Java&quot;</span>);<br></code></pre></td></tr></table></figure><p>答：程序执行的结果是：</p><blockquote><p>I：0</p></blockquote><blockquote></blockquote><blockquote><p>Java</p></blockquote><blockquote></blockquote><blockquote><p>java.lang.InterruptedException: sleep interrupted（报错信息）</p></blockquote><blockquote></blockquote><blockquote><p>I：1</p></blockquote><p>题目解析：因为程序中使用了 <code>shutdownNow()</code> 会导致程序执行一次之后报错，抛出 <code>sleep interrupted</code> 异常，又因为本身有<br>try/catch，所以程序会继续执行打印 <code>I：1</code> 。</p><h4 id="3-在-ThreadPool-中-submit-和-execute-有什么区别？"><a href="#3-在-ThreadPool-中-submit-和-execute-有什么区别？" class="headerlink" title="3.在 ThreadPool 中 submit() 和 execute() 有什么区别？"></a>3.在 ThreadPool 中 submit() 和 execute() 有什么区别？</h4><p>答：submit() 和 execute() 都是用来执行线程池的，只不过使用 execute() 执行线程池不能有返回方法，而使用 submit()<br>可以使用 Future 接收线程池执行的返回值。</p><p>submit() 方法源码（JDK 8）如下：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br></code></pre></td></tr></table></figure><p>execute() 源码（JDK 8）如下：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">//..... 其他</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-说一下-ThreadPoolExecutor-都需要哪些参数？"><a href="#4-说一下-ThreadPoolExecutor-都需要哪些参数？" class="headerlink" title="4.说一下 ThreadPoolExecutor 都需要哪些参数？"></a>4.说一下 ThreadPoolExecutor 都需要哪些参数？</h4><p>答：ThreadPoolExecutor 最多包含以下七个参数：</p><ul><li>corePoolSize：线程池中的核心线程数</li><li>maximumPoolSize：线程池中最大线程数</li><li>keepAliveTime：闲置超时时间</li><li>unit：keepAliveTime 超时时间的单位（时/分/秒等）</li><li>workQueue：线程池中的任务队列</li><li>threadFactory：为线程池提供创建新线程的线程工厂</li><li>rejectedExecutionHandler：线程池任务队列超过最大值之后的拒绝策略</li></ul><h4 id="5-在线程池中-shutdownNow-和-shutdown-有什么区别？"><a href="#5-在线程池中-shutdownNow-和-shutdown-有什么区别？" class="headerlink" title="5.在线程池中 shutdownNow() 和 shutdown() 有什么区别？"></a>5.在线程池中 shutdownNow() 和 shutdown() 有什么区别？</h4><p>答：shutdownNow() 和 shutdown() 都是用来终止线程池的，它们的区别是，使用 shutdown()<br>程序不会报错，也不会立即终止线程，它会等待线程池中的缓存任务执行完之后再退出，执行了 shutdown()<br>之后就不能给线程池添加新任务了；shutdownNow() 会试图立马停止任务，如果线程池中还有缓存任务正在执行，则会抛出<br>java.lang.InterruptedException: sleep interrupted 异常。</p><h4 id="6-说一说线程池的工作原理？"><a href="#6-说一说线程池的工作原理？" class="headerlink" title="6.说一说线程池的工作原理？"></a>6.说一说线程池的工作原理？</h4><p>答：当线程池中有任务需要执行时，线程池会判断如果线程数量没有超过核心数量就会新建线程池进行任务执行，如果线程池中的线程数量已经超过核心线程数，这时候任务就会被放入任务队列中排队等待执行；如果任务队列超过最大队列数，并且线程池没有达到最大线程数，就会新建线程来执行任务；如果超过了最大线程数，就会执行拒绝执行策略。</p><h4 id="7-以下线程名称被打印了几次？"><a href="#7-以下线程名称被打印了几次？" class="headerlink" title="7.以下线程名称被打印了几次？"></a>7.以下线程名称被打印了几次？</h4><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">threadPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                <span class="hljs-number">10L</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="hljs-number">2</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.DiscardPolicy());<br>threadPool.allowCoreThreadTimeOut(<span class="hljs-literal">true</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    threadPool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 打印线程名称</span><br>            System.out.println(Thread.currentThread().getName());<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure><p>答：线程名被打印了 3 次。<br>题目解析：线程池第 1 次执行任务时，会新创建任务并执行；第 2 次执行任务时，因为没有空闲线程所以会把任务放入队列；第 3<br>次同样把任务放入队列，因为队列最多可以放两条数据，所以第 4 次之后的执行都会被舍弃（没有定义拒绝策略），于是就打印了 3 次线程名称。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ThreadPoolExecutor<br>是创建线程池最传统和最推荐使用的方式，创建时要设置线程池的核心线程数和最大线程数还有任务队列集合，如果任务量大于队列的最大长度，线程池会先判断当前线程数量是否已经到达最大线程数，如果没有达到最大线程数就新建线程来执行任务，如果已经达到最大线程数，就会执行拒绝策略（拒绝策略可自行定义）。线程池可通过<br>submit() 来调用执行，从而获得线程执行的结果，也可以通过 shutdown() 来终止线程池。</p><blockquote><p>[点击此处下载本文源码](<a href="https://github.com/vipstone/java-">https://github.com/vipstone/java-</a><br>interview/tree/master/interview-code/src/main/java/com/interview)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java面试全解析核心知识点与典型面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>001--Java程序是如何执行的</title>
    <link href="/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/001--Java%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/"/>
    <url>/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/001--Java%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h2 id="Java-程序是如何执行的"><a href="#Java-程序是如何执行的" class="headerlink" title="Java 程序是如何执行的"></a>Java 程序是如何执行的</h2><p>了解任何一门语言的精髓都是先俯览其全貌，从宏观的视角把握全局，然后再深入每个知识点逐个击破，这样就可以深入而快速的掌握一项技能。同样学习 Java 也是如此，本节就让我们先从整体来看一下 Java 中的精髓。</p><h3 id="Java-介绍"><a href="#Java-介绍" class="headerlink" title="Java 介绍"></a>Java 介绍</h3><p>Java 诞生于 1991 年，Java 的前身叫做 Oak（橡树），但在注册商标的时候，发现这个名字已经被人注册了，后来团队的人就在咖啡馆讨论这件事该怎么办，有人灵机一动说叫 Java 如何，因为当时他们正在喝着一款叫做 Java 的咖啡。就这样，这个后来家喻户晓的名字，竟以这种“随意”的方式诞生了，并一直沿用至今。</p><p>Java 发展历程：</p><ul><li>1990，Sun 成立了“Green Team”项目小组</li><li>1991，Java 语言前身 Oak（橡树）诞生</li><li>1995，Oak 语言更名为 Java</li><li>1996，Java 1.0 发布</li><li>1997，Java 1.1 发布</li><li>1998，Java 1.2 发布</li><li>2000，Java 1.3 发布</li><li>2000，Java 1.4 发布</li><li>2004，Java 5 发布</li><li>2006，Java 6 发布</li><li>2011，Java 7 发布</li><li>2014，Java 8 发布</li><li>2017，Java 9（非长期支持版）发布</li><li>2018.03，Java 10（非长期支持版） 发布</li><li>2018.09，Java 11（长期支持版）发布</li><li>2019.03，Java  12</li><li>2019.09，Java  13</li><li>2020.03，Java  14</li><li>2020.09，Java  15</li><li>2021.03，Java  16</li><li>2021.09，Java  17</li><li>2022.03，Java  18</li></ul><p>注：长期支持版指的是官方发布版本后的一段时间内，通常以“年”为计数单位，会对此版本进行持续维护和升级。</p><p><strong>版本发布时间</strong></p><p>Java 10 之后，官方表示每半年推出一个大版本，长期支持版本（LTS）每三年发布一次。</p><h3 id="Java-和-JDK-的关系"><a href="#Java-和-JDK-的关系" class="headerlink" title="Java 和 JDK 的关系"></a>Java 和 JDK 的关系</h3><p>JDK（Java Development Kit）Java 开发工具包，它包括：编译器、Java 运行环境（JRE，Java Runtime<br>Environment）、JVM（Java 虚拟机）监控和诊断工具等，而 Java 则表示一种开发语言。</p><h3 id="Java-程序是怎么执行的？"><a href="#Java-程序是怎么执行的？" class="headerlink" title="Java 程序是怎么执行的？"></a>Java 程序是怎么执行的？</h3><p>我们日常的工作中都使用开发工具（IntelliJ IDEA 或 Eclipse 等）可以很方便的调试程序，或者是通过打包工具把项目打包成 jar 包或者<br>war 包，放入 Tomcat 等 Web 容器中就可以正常运行了，但你有没有想过 Java 程序内部是如何执行的？</p><p>其实不论是在开发工具中运行还是在 Tomcat 中运行，Java 程序的执行流程基本都是相同的，它的执行流程如下：</p><ol><li>先把 Java 代码编译成字节码，也就是把 .java 类型的文件编译成 .class 类型的文件。这个过程的大致执行流程：Java 源代码 -&gt; 词法分析器 -&gt; 语法分析器 -&gt; 语义分析器 -&gt; 字节码生成器 -&gt; 最终生成字节码，其中任何一个节点执行失败就会造成编译失败；</li><li>把 class 文件放置到 Java 虚拟机，这个虚拟机通常指的是 Oracle 官方自带的 Hotspot JVM；</li><li>Java 虚拟机使用类加载器（Class Loader）装载 class 文件；</li><li>类加载完成之后，会进行字节码校验，字节码校验通过之后 JVM 解释器会把字节码翻译成机器码交由操作系统执行。但不是所有代码都是解释执行的，JVM 对此做了优化，比如，以 Hotspot 虚拟机来说，它本身提供了 JIT（Just In Time）也就是我们通常所说的动态编译器，它能够在运行时将热点代码编译为机器码，这个时候字节码就变成了编译执行。</li></ol><p>Java 程序执行流程图如下：</p><p><img src="https://images.gitbook.cn/FvSP3G2xXR676FoIvsz-0naYLP2I" alt="avatar"></p><h3 id="Java-虚拟机是如何判定热点代码的？"><a href="#Java-虚拟机是如何判定热点代码的？" class="headerlink" title="Java 虚拟机是如何判定热点代码的？"></a>Java 虚拟机是如何判定热点代码的？</h3><p>Java 虚拟机判定热点代码的方式有两种：</p><ul><li>基于采样的热点判定</li></ul><p>主要是虚拟机会周期性的检查各个线程的栈顶，若某个或某些方法经常出现在栈顶，那这个方法就是“热点方法”。这种判定方式的优点是实现简单；缺点是很难精确一个方法的热度，容易受到线程阻塞或外界因素的影响。</p><ul><li>基于计数器的热点判定</li></ul><p>主要就是虚拟机给每一个方法甚至代码块建立了一个计数器，统计方法的执行次数，超过一定的阀值则标记为此方法为热点方法。</p><p>Hotspot 虚拟机使用的基于计数器的热点探测方法。它使用了两类计数器：方法调用计数器和回边计数器，当到达一定的阀值是就会触发 JIT 编译。</p><p>方法调用计数器：在 client 模式下的阀值是 1500 次，Server 是 10000 次，可以通过虚拟机参数：<br><code>-XX:CompileThreshold=N</code> 对其进行设置。但是JVM还存在热度衰减，时间段内调用方法的次数较少，计数器就减小。</p><p>回边计数器：主要统计的是方法中循环体代码执行的次数。</p><p>由上面的知识我们可以看出， <strong>要想做到对 Java 了如指掌，必须要好好学习 Java 虚拟机</strong> ，那除了 Java<br>虚拟机外，还有哪些知识是面试必考，也是 Java 工程师必须掌握的知识呢？</p><h4 id="1-Java-基础中的核心内容"><a href="#1-Java-基础中的核心内容" class="headerlink" title="1. Java 基础中的核心内容"></a>1. Java 基础中的核心内容</h4><p>字符串和字符串常量池的深入理解、Array 的操作和排序算法、深克隆和浅克隆、各种 IO 操作、反射和动态代理（JDK 自身动态代理和 CGLIB）等。</p><h4 id="2-集合"><a href="#2-集合" class="headerlink" title="2. 集合"></a>2. 集合</h4><p>集合和 String<br>是编程中最常用的数据类型，关于集合的知识也是面试备考的内容，它包含：链表（LinkedList）、TreeSet、栈（Stack）、队列（双端、阻塞、非阻塞队列、延迟队列）、HashMap、TreeMap<br>等，它们的使用和底层存储数据结构都是热门的面试内容。</p><h4 id="3-多线程"><a href="#3-多线程" class="headerlink" title="3. 多线程"></a>3. 多线程</h4><p>多线程使用和线程安全的知识也是必考的面试题目，它包括：死锁、6<br>种线程池的使用与差异、ThreadLocal、synchronized、Lock、JUC（java.util.concurrent包）、CAS（Compare<br>and Swap）、ABA 问题等。</p><h4 id="4-热门框架"><a href="#4-热门框架" class="headerlink" title="4. 热门框架"></a>4. 热门框架</h4><p>Spring、Spring MVC、MyBatis、SpringBoot</p><h4 id="5-分布式编程"><a href="#5-分布式编程" class="headerlink" title="5. 分布式编程"></a>5. 分布式编程</h4><p>消息队列（RabbitMQ、Kafka）、Dubbo、Zookeeper、SpringCloud 等。</p><h4 id="6-数据库"><a href="#6-数据库" class="headerlink" title="6. 数据库"></a>6. 数据库</h4><p>MySQL 常用引擎的掌握、MySQL 前缀索引、回表查询、数据存储结构、最左匹配原则、MySQL 的问题分析和排除方案、MySQL 读写分离的实现原理以及<br>MySQL 的常见优化方案等。 Redis 的使用场景、缓存雪崩和缓存穿透的解决方案、Redis 过期淘汰策略和主从复制的实现方案等。</p><h4 id="7-Java-虚拟机"><a href="#7-Java-虚拟机" class="headerlink" title="7. Java 虚拟机"></a>7. Java 虚拟机</h4><p>虚拟机的组成、垃圾回收算法、各种垃圾回收器的区别、Java 虚拟机分析工具的掌握、垃圾回收器的常用调优参数等。</p><h4 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a>8. 其他</h4><p>常用算法的掌握、设计模式的理解、网络知识和常见 Linux 命令的掌握等。</p><p>值得庆幸的是以上所有内容都包含在本专栏中，接下来就让我们一起学习，一起构建 Java 的认知体系吧!</p><h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="1-Java-语言都有哪些特点？"><a href="#1-Java-语言都有哪些特点？" class="headerlink" title="1. Java 语言都有哪些特点？"></a>1. Java 语言都有哪些特点？</h4><p>答：Java 语言包含以下特点。</p><ul><li>面向对象，程序容易理解、开发简单、方便；</li><li>跨平台，可运行在不同服务器类型上，比如：Linux、Windows、Mac 等；</li><li>执行性能好，运行效率高；</li><li>提供大量的 API 扩展，语言强大；</li><li>有多线程支持，增加了响应和实时交互的能力；</li><li>安全性好，自带验证机制，确保程序的可靠性和安全性。</li></ul><h4 id="2-Java-跨平台实现的原理是什么？"><a href="#2-Java-跨平台实现的原理是什么？" class="headerlink" title="2. Java 跨平台实现的原理是什么？"></a>2. Java 跨平台实现的原理是什么？</h4><p>答：要了解 Java 跨平台实现原理之前，必须先要了解 Java 的执行过程，Java 的执行过程如下：</p><p><img src="https://images.gitbook.cn/bb3215b0-baa6-11e9-8bd3-43e1fddff917" alt="执行过程"></p><p>Java 执行流程：Java 源代码（.java）-&gt; 编译 -&gt; Java 字节码（.class） -&gt;通过 JVM（Java 虚拟机）运行 Java<br>程序。每种类型的服务器都会运行一个 JVM，Java 程序只需要生成 JVM 可以执行的代码即可，JVM<br>底层屏蔽了不同服务器类型之间的差异，从而可以在不同类型的服务器上运行一套 Java 程序。</p><h4 id="3-JDK、JRE、JVM-有哪些区别？"><a href="#3-JDK、JRE、JVM-有哪些区别？" class="headerlink" title="3. JDK、JRE、JVM 有哪些区别？"></a>3. JDK、JRE、JVM 有哪些区别？</h4><p>答：了解了 JDK、JRE、JVM 的定义也就明白了它们之间的区别，如下所述。</p><ul><li>JDK：Java Development Kit（Java 开发工具包）的简称，提供了 Java 的开发环境和运行环境；</li><li>JRE：Java Runtime Environment（Java 运行环境）的简称，为 Java 的运行提供了所需环境；</li><li>JVM：Java Virtual Machine（Java虚拟机）的简称，是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的，简单来说就是所有的 Java 程序都是运行在 JVM（Java 虚拟机）上的。</li></ul><p>总体来说，JDK 提供了一整套的 Java 运行和开发环境，通常使用对象为 Java 的开发者，当然 JDK 也包含了 JRE；而 JRE 为 Java<br>运行的最小运行单元，一般安装在 Java 服务器上，所以 JDK 和 JRE 可以从用途上进行理解和区分。JVM 不同于 JDK 和 JRE，JVM 是<br>Java 程序运行的载体，Java 程序只有通过 JVM 才能正常的运行。</p><h4 id="4-Java-中如何获取明天此刻的时间？"><a href="#4-Java-中如何获取明天此刻的时间？" class="headerlink" title="4. Java 中如何获取明天此刻的时间？"></a>4. Java 中如何获取明天此刻的时间？</h4><p>答：JDK 8 之前使用 <code>Calendar.add()</code> 方法获取，代码如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">Calendar</span> <span class="hljs-string">calendar</span> <span class="hljs-string">=</span> <span class="hljs-string">Calendar.getInstance();</span><br><span class="hljs-string">calendar.add(Calendar.DATE,</span> <span class="hljs-number">1</span><span class="hljs-string">);</span><br><span class="hljs-string">System.out.println(calendar.getTime());</span><br></code></pre></td></tr></table></figure><p>JDK 8 有两种获取明天时间的方法。</p><p>方法一，使用 <code>LocalDateTime.plusDays()</code> 方法获取，代码如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">LocalDateTime</span> <span class="hljs-string">today</span> <span class="hljs-string">=</span> <span class="hljs-string">LocalDateTime.now();</span><br><span class="hljs-string">LocalDateTime</span> <span class="hljs-string">tomorrow</span> <span class="hljs-string">=</span> <span class="hljs-string">today.plusDays(1);</span><br><span class="hljs-string">System.out.println(tomorrow);</span><br></code></pre></td></tr></table></figure><p>方法二，使用 <code>LocalDateTime.minusDays()</code> 方法获取，代码如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">LocalDateTime</span> <span class="hljs-string">today</span> <span class="hljs-string">=</span> <span class="hljs-string">LocalDateTime.now();</span><br><span class="hljs-string">LocalDateTime</span> <span class="hljs-string">tomorrow</span> <span class="hljs-string">=</span> <span class="hljs-string">today.minusDays(-1);</span><br><span class="hljs-string">System.out.println(tomorrow);</span><br></code></pre></td></tr></table></figure><p><code>minusDays()</code> 方法为当前时间减去 n 天，传负值就相当于当前时间加 n 天。</p><h4 id="5-Java-中如何跳出多重嵌套循环？"><a href="#5-Java-中如何跳出多重嵌套循环？" class="headerlink" title="5. Java 中如何跳出多重嵌套循环？"></a>5. Java 中如何跳出多重嵌套循环？</h4><p>答：Java 中跳出多重嵌套循环的两种方式。</p><ul><li>方法一：定义一个标号，使用 break 加标号的方式</li><li>方法二：使用全局变量终止循环</li></ul><h4 id="6-char-变量能不能存贮一个中文汉字？为什么？"><a href="#6-char-变量能不能存贮一个中文汉字？为什么？" class="headerlink" title="6. char 变量能不能存贮一个中文汉字？为什么？"></a>6. char 变量能不能存贮一个中文汉字？为什么？</h4><p>英文字母和中文汉字在不同字符集编码下的字节数</p><p>英文字母：</p><p>字节数 : 1;编码：GB2312</p><p>字节数 : 1;编码：GBK</p><p>字节数 : 1;编码：GB18030</p><p>字节数 : 1;编码：ISO-8859-1</p><p>字节数 : 1;编码：UTF-8</p><p>字节数 : 4;编码：UTF-16</p><p>字节数 : 2;编码：UTF-16BE</p><p>字节数 : 2;编码：UTF-16LE</p><p>中文汉字：</p><p>字节数 : 2;编码：GB2312</p><p>字节数 : 2;编码：GBK</p><p>字节数 : 2;编码：GB18030</p><p>字节数 : 1;编码：ISO-8859-1</p><p>字节数 : 3;编码：UTF-8</p><p>字节数 : 4;编码：UTF-16</p><p>字节数 : 2;编码：UTF-16BE</p><p>字节数 : 2;编码：UTF-16LE</p><h4 id="7-Java-中会存在内存泄漏吗？请简单描述一下。"><a href="#7-Java-中会存在内存泄漏吗？请简单描述一下。" class="headerlink" title="7. Java 中会存在内存泄漏吗？请简单描述一下。"></a>7. Java 中会存在内存泄漏吗？请简单描述一下。</h4><p>答：一个不再被程序使用的对象或变量一直被占据在内存中就造成了内存泄漏。</p><p>Java 中的内存泄漏的常见情景如下：</p><ul><li>长生命周期对象持有短生命的引用，比如，缓存系统，我们加载了一个对象放在缓存中，然后一直不使用这个缓存，由于缓存的对象一直被缓存引用得不到释放，就造成了内存泄漏；</li><li>各种连接未调用关闭方法，比如，数据库 Connection 连接，未显性地关闭，就会造成内存泄漏；</li><li>内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露；</li><li>改变哈希值，当一个对象被存储进 HashSet 集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则对象修改后的哈希值与最初存储进 HashSet 集合中时的哈希值就不同了，在这种情况下，即使在 contains 方法使用该对象的当前引用作为的参数去 HashSet 集合中检索对象，也将返回找不到对象的结果，这也会导致无法从 HashSet 集合中单独删除当前对象，造成内存泄露。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java面试全解析核心知识点与典型面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>015--数据结构之队列的使用 + 面试题</title>
    <link href="/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/015--%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8+%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/09/13/Java%E9%9D%A2%E8%AF%95%E5%85%A8%E8%A7%A3%E6%9E%90%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%8E%E5%85%B8%E5%9E%8B%E9%9D%A2%E8%AF%95%E9%A2%98/015--%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8+%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>队列（Queue）：与栈相对的一种数据结构，<br>集合（Collection）的一个子类。队列允许在一端进行插入操作，而在另一端进行删除操作的线性表，栈的特点是后进先出，而队列的特点是先进先出。队列的用处很大，比如实现消息队列。</p><p>Queue 类关系图，如下图所示：</p><p><img src="https://images.gitbook.cn/64fedb10-cebf-11e9-956a-e59402c7f15a" alt="enter image descriptionhere"></p><p>注：为了让读者更直观地理解，上图为精简版的 Queue 类关系图。本文如无特殊说明，内容都是基于 Java 1.8 版本。</p><h3 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h3><h4 id="1）Queue-分类"><a href="#1）Queue-分类" class="headerlink" title="1）Queue 分类"></a>1）Queue 分类</h4><p>从上图可以看出 Queue 大体可分为以下三类。</p><ul><li>双端队列：双端队列（Deque）是 Queue 的子类也是 Queue 的补充类，头部和尾部都支持元素插入和获取。</li><li>阻塞队列：阻塞队列指的是在元素操作时（添加或删除），如果没有成功，会阻塞等待执行。例如，当添加元素时，如果队列元素已满，队列会阻塞等待直到有空位时再插入。</li><li>非阻塞队列：非阻塞队列和阻塞队列相反，会直接返回操作的结果，而非阻塞等待。双端队列也属于非阻塞队列。</li></ul><h4 id="2）Queue-方法说明"><a href="#2）Queue-方法说明" class="headerlink" title="2）Queue 方法说明"></a>2）Queue 方法说明</h4><p>Queue 常用方法，如下图所示：</p><p><img src="https://images.gitbook.cn/78539610-cebf-11e9-956a-e59402c7f15a" alt="enter image descriptionhere"></p><p>方法说明：</p><ul><li>add(E)：添加元素到队列尾部，成功返回 true，队列超出时抛出异常；</li><li>offer(E)：添加元素到队列尾部，成功返回 true，队列超出时返回 false；</li><li>remove()：删除元素，成功返回 true，失败返回 false；</li><li>poll()：获取并移除此队列的第一个元素，若队列为空，则返回 null；</li><li>peek()：获取但不移除此队列的第一个元素，若队列为空，则返回 null；</li><li>element()：获取但不移除此队列的第一个元素，若队列为空，则抛异常。</li></ul><h4 id="3）Queue-使用实例"><a href="#3）Queue-使用实例" class="headerlink" title="3）Queue 使用实例"></a>3）Queue 使用实例</h4><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;String&gt; linkedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>linkedList.add(<span class="hljs-string">&quot;Dog&quot;</span>);<br>linkedList.add(<span class="hljs-string">&quot;Camel&quot;</span>);<br>linkedList.add(<span class="hljs-string">&quot;Cat&quot;</span>);<br><span class="hljs-keyword">while</span> (!linkedList.isEmpty()) &#123;<br>    System.out.println(linkedList.poll());<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行结果：</p><blockquote><p>Dog</p></blockquote><blockquote></blockquote><blockquote><p>Camel</p></blockquote><blockquote></blockquote><blockquote><p>Cat</p></blockquote><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><h4 id="1）BlockingQueue"><a href="#1）BlockingQueue" class="headerlink" title="1）BlockingQueue"></a>1）BlockingQueue</h4><p>BlockingQueue 在 java.util.concurrent 包下，其他阻塞类都实现自 BlockingQueue接口，BlockingQueue提供了线程安全的队列访问方式，当向队列中插入数据时，如果队列已满，线程则会阻塞等待队列中元素被取出后再插入；当从队列中取数据时，如果队列为空，则线程会阻塞等待队列中有新元素再获取。</p><p>BlockingQueue 核心方法</p><p>插入方法：</p><ul><li>add(E)：添加元素到队列尾部，成功返回 true，队列超出时抛出异常；</li><li>offer(E)：添加元素到队列尾部，成功返回 true，队列超出时返回 false ；</li><li>put(E)：将元素插入到队列的尾部，如果该队列已满，则一直阻塞。 删除方法：</li><li>remove(Object)：移除指定元素，成功返回 true，失败返回 false；</li><li>poll()： 获取并移除队列的第一个元素，如果队列为空，则返回 null；</li><li>take()：获取并移除队列第一个元素，如果没有元素则一直阻塞。 检查方法：</li><li>peek()：获取但不移除队列的第一个元素，若队列为空，则返回 null。</li></ul><h4 id="2）LinkedBlockingQueue"><a href="#2）LinkedBlockingQueue" class="headerlink" title="2）LinkedBlockingQueue"></a>2）LinkedBlockingQueue</h4><p>LinkedBlockingQueue 是一个由链表实现的有界阻塞队列，容量默认值为Integer.MAX_VALUE，也可以自定义容量，建议指定容量大小，默认大小在添加速度大于删除速度情况下有造成内存溢出的风险，LinkedBlockingQueue是先进先出的方式存储元素。</p><h4 id="3）ArrayBlockingQueue"><a href="#3）ArrayBlockingQueue" class="headerlink" title="3）ArrayBlockingQueue"></a>3）ArrayBlockingQueue</h4><p>ArrayBlockingQueue是一个有边界的阻塞队列，它的内部实现是一个数组。它的容量是有限的，我们必须在其初始化的时候指定它的容量大小，容量大小一旦指定就不可改变。</p><p>ArrayBlockingQueue 也是先进先出的方式存储数据，ArrayBlockingQueue 内部的阻塞队列是通过重入锁 ReenterLock和 Condition 条件队列实现的，因此 ArrayBlockingQueue中的元素存在公平访问与非公平访问的区别，对于公平访问队列，被阻塞的线程可以按照阻塞的先后顺序访问队列，即先阻塞的线程先访问队列。而非公平队列，当队列可用时，阻塞的线程将进入争夺访问资源的竞争中，也就是说谁先抢到谁就执行，没有固定的先后顺序。</p><p>示例代码如下：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认非公平阻塞队列</span><br><span class="hljs-type">ArrayBlockingQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>(<span class="hljs-number">6</span>);<br><span class="hljs-comment">// 公平阻塞队列</span><br><span class="hljs-type">ArrayBlockingQueue</span> <span class="hljs-variable">queue2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>(<span class="hljs-number">6</span>,<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// ArrayBlockingQueue 源码展示</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>    <span class="hljs-built_in">this</span>(capacity, <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ArrayBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity, <span class="hljs-type">boolean</span> fair)</span> &#123;<br>    <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-built_in">this</span>.items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[capacity];<br>    lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(fair);<br>    notEmpty = lock.newCondition();<br>    notFull =  lock.newCondition();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4）DelayQueue"><a href="#4）DelayQueue" class="headerlink" title="4）DelayQueue"></a>4）DelayQueue</h4><p>DelayQueue 是一个支持延时获取元素的无界阻塞队列，队列中的元素必须实现 Delayed接口，在创建元素时可以指定延迟时间，只有到达了延迟的时间之后，才能获取到该元素。</p><p>实现了 Delayed 接口必须重写两个方法 ，getDelay(TimeUnit) 和 compareTo(Delayed)，如下代码所示：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayElement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Delayed</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-comment">// 获取剩余时间</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> &#123;<br>            <span class="hljs-comment">// do something</span><br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-comment">// 队列里元素的排序依据</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed o)</span> &#123;<br>            <span class="hljs-comment">// do something</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p><strong>DelayQueue 使用的完整示例</strong> ，请参考以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">DelayQueue</span> <span class="hljs-variable">delayQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayQueue</span>();<br>        delayQueue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayElement</span>(<span class="hljs-number">1000</span>));<br>        delayQueue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayElement</span>(<span class="hljs-number">3000</span>));<br>        delayQueue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayElement</span>(<span class="hljs-number">5000</span>));<br>        System.out.println(<span class="hljs-string">&quot;开始时间：&quot;</span> +  DateFormat.getDateTimeInstance().format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));<br>        <span class="hljs-keyword">while</span> (!delayQueue.isEmpty())&#123;<br>            System.out.println(delayQueue.take());<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;结束时间：&quot;</span> +  DateFormat.getDateTimeInstance().format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()));<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayElement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Delayed</span> &#123;<br>        <span class="hljs-comment">// 延迟截止时间（单面：毫秒）</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">delayTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DelayElement</span><span class="hljs-params">(<span class="hljs-type">long</span> delayTime)</span> &#123;<br>            <span class="hljs-built_in">this</span>.delayTime = (<span class="hljs-built_in">this</span>.delayTime + delayTime);<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-comment">// 获取剩余时间</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> &#123;<br>            <span class="hljs-keyword">return</span> unit.convert(delayTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-comment">// 队列里元素的排序依据</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed o)</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS)) &#123;<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> DateFormat.getDateTimeInstance().format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(delayTime));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行结果：</p><blockquote><p>开始时间：2019-6-13 20:40:38</p></blockquote><blockquote></blockquote><blockquote><p>2019-6-13 20:40:39</p></blockquote><blockquote></blockquote><blockquote><p>2019-6-13 20:40:41</p></blockquote><blockquote></blockquote><blockquote><p>2019-6-13 20:40:43</p></blockquote><blockquote></blockquote><blockquote><p>结束时间：2019-6-13 20:40:43</p></blockquote><h3 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h3><p><strong>ConcurrentLinkedQueue</strong><br>是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部；当我们获取一个元素时，它会返回队列头部的元素。</p><p>它的入队和出队操作均利用 CAS（Compare And Set）更新，这样允许多个线程并发执行，并且不会因为加锁而阻塞线程，使得并发性能更好。</p><p>ConcurrentLinkedQueue 使用示例：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ConcurrentLinkedQueue</span> <span class="hljs-variable">concurrentLinkedQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>();<br>concurrentLinkedQueue.add(<span class="hljs-string">&quot;Dog&quot;</span>);<br>concurrentLinkedQueue.add(<span class="hljs-string">&quot;Cat&quot;</span>);<br><span class="hljs-keyword">while</span> (!concurrentLinkedQueue.isEmpty()) &#123;<br>    System.out.println(concurrentLinkedQueue.poll());<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><blockquote><p>Dog</p></blockquote><blockquote></blockquote><blockquote><p>Cat</p></blockquote><p>可以看出不管是阻塞队列还是非阻塞队列，使用方法都是类似的，区别是底层的实现方式。</p><h3 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h3><p><strong>PriorityQueue</strong> 一个基于优先级堆的无界优先级队列。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator进行排序，具体取决于所使用的构造方法。优先级队列不允许使用 null 元素。</p><p><strong>PriorityQueue 代码使用示例</strong> ：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;Integer&gt; priorityQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Comparator</span>&lt;Integer&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> &#123;<br>        <span class="hljs-comment">// 非自然排序，数字倒序</span><br>        <span class="hljs-keyword">return</span> o2 - o1;<br>    &#125;<br>&#125;);<br>priorityQueue.add(<span class="hljs-number">3</span>);<br>priorityQueue.add(<span class="hljs-number">1</span>);<br>priorityQueue.add(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">while</span> (!priorityQueue.isEmpty()) &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> priorityQueue.poll();<br>    System.out.println(i);<br>&#125;<br></code></pre></td></tr></table></figure><p>程序执行的结果是：</p><blockquote><p>3</p></blockquote><blockquote></blockquote><blockquote><p>2</p></blockquote><blockquote></blockquote><blockquote><p>1</p></blockquote><p><strong>PriorityQueue 注意的点</strong> ：</p><ul><li>PriorityQueue 是非线程安全的，在多线程情况下可使用 PriorityBlockingQueue 类替代；</li><li>PriorityQueue 不允许插入 null 元素。</li></ul><h3 id="相关面试题"><a href="#相关面试题" class="headerlink" title="相关面试题"></a>相关面试题</h3><h4 id="1-ArrayBlockingQueue-和-LinkedBlockingQueue-的区别是什么？"><a href="#1-ArrayBlockingQueue-和-LinkedBlockingQueue-的区别是什么？" class="headerlink" title="1.ArrayBlockingQueue 和 LinkedBlockingQueue 的区别是什么？"></a>1.ArrayBlockingQueue 和 LinkedBlockingQueue 的区别是什么？</h4><p>答：ArrayBlockingQueue 和 LinkedBlockingQueue 都实现自阻塞队列BlockingQueue，它们的区别主要体现在以下几个方面：</p><ul><li>ArrayBlockingQueue 使用时必须指定容量值，LinkedBlockingQueue 可以不用指定；</li><li>ArrayBlockingQueue 的最大容量值是使用时指定的，并且指定之后就不允许修改；而 LinkedBlockingQueue 最大的容量为 Integer.MAX_VALUE；</li><li>ArrayBlockingQueue 数据存储容器是采用数组存储的；而 LinkedBlockingQueue 采用的是 Node 节点存储的。</li></ul><h4 id="2-LinkedList-中-add-和-offer-有什么关系？"><a href="#2-LinkedList-中-add-和-offer-有什么关系？" class="headerlink" title="2.LinkedList 中 add() 和 offer() 有什么关系？"></a>2.LinkedList 中 add() 和 offer() 有什么关系？</h4><p>答：add() 和 offer() 都是添加元素到队列尾部。offer 方法是基于 add 方法实现的，Offer 的源码如下：</p><p>​<br>    public boolean offer(E e) {<br>        return add(e);<br>    }</p><h4 id="3-Queue-和-Deque-有什么区别？"><a href="#3-Queue-和-Deque-有什么区别？" class="headerlink" title="3.Queue 和 Deque 有什么区别？"></a>3.Queue 和 Deque 有什么区别？</h4><p>答：Queue 属于一般队列，Deque 属于双端队列。一般队列是先进先出，也就是只有先进的才能先出；而双端队列则是两端都能插入和删除元素。</p><h4 id="4-LinkedList-属于一般队列还是双端队列？"><a href="#4-LinkedList-属于一般队列还是双端队列？" class="headerlink" title="4.LinkedList 属于一般队列还是双端队列？"></a>4.LinkedList 属于一般队列还是双端队列？</h4><p>答：LinkedList 实现了 Deque 属于双端队列，因此拥有 addFirst(E)、addLast(E)、getFirst()、getLast()等方法。</p><h4 id="5-以下说法错误的是？"><a href="#5-以下说法错误的是？" class="headerlink" title="5.以下说法错误的是？"></a>5.以下说法错误的是？</h4><p>A：DelayQueue 内部是基于 PriorityQueue 实现的<br>B：PriorityBlockingQueue 不是先进先出的数据存储方式<br>C：LinkedBlockingQueue 默认容量是无限大的<br>D：ArrayBlockingQueue 内部的存储单元是数组，初始化时必须指定队列容量</p><p>答：C</p><p>题目解析：LinkedBlockingQueue 默认容量是 Integer.MAX_VALUE，并不是无限大的。</p><h4 id="6-关于-ArrayBlockingQueue-说法不正确的是？"><a href="#6-关于-ArrayBlockingQueue-说法不正确的是？" class="headerlink" title="6.关于 ArrayBlockingQueue 说法不正确的是？"></a>6.关于 ArrayBlockingQueue 说法不正确的是？</h4><p>A：ArrayBlockingQueue 是线程安全的<br>B：ArrayBlockingQueue 元素允许为 null<br>C：ArrayBlockingQueue 主要应用场景是“生产者-消费者”模型<br>D：ArrayBlockingQueue 必须显示地设置容量</p><p>答：B</p><p>题目解析：ArrayBlockingQueue 不允许元素为 null，如果添加一个 null 元素，会抛 NullPointerException 异常。</p><h4 id="7-以下程序执行的结果是什么？"><a href="#7-以下程序执行的结果是什么？" class="headerlink" title="7.以下程序执行的结果是什么？"></a>7.以下程序执行的结果是什么？</h4><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">PriorityQueue</span> <span class="hljs-variable">priorityQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>();<br>priorityQueue.add(<span class="hljs-literal">null</span>);<br>System.out.println(priorityQueue.size());<br></code></pre></td></tr></table></figure><p>答：程序执行报错，PriorityQueue 不能插入 null。</p><h4 id="8-Java-中常见的阻塞队列有哪些？"><a href="#8-Java-中常见的阻塞队列有哪些？" class="headerlink" title="8.Java 中常见的阻塞队列有哪些？"></a>8.Java 中常见的阻塞队列有哪些？</h4><p>答：Java 中常见的阻塞队列如下：</p><ul><li>ArrayBlockingQueue，由数组结构组成的有界阻塞队列；</li><li>PriorityBlockingQueue，支持优先级排序的无界阻塞队列；</li><li>SynchronousQueue，是一个不存储元素的阻塞队列，会直接将任务交给消费者，必须等队列中的添加元素被消费后才能继续添加新的元素；</li><li>LinkedBlockingQueue，由链表结构组成的阻塞队列；</li><li>DelayQueue，支持延时获取元素的无界阻塞队列。</li></ul><h4 id="9-有界队列和无界队列有哪些区别？"><a href="#9-有界队列和无界队列有哪些区别？" class="headerlink" title="9.有界队列和无界队列有哪些区别？"></a>9.有界队列和无界队列有哪些区别？</h4><p>答：有界队列和无界队列的区别如下。</p><ul><li>有界队列：有固定大小的队列叫做有界队列，比如：new ArrayBlockingQueue(6)，6 就是队列的大小。</li><li>无界队列：指的是没有设置固定大小的队列，这些队列的特点是可以直接入列，直到溢出。它们并不是真的无界，它们最大值通常为 Integer.MAX_VALUE，只是平常很少能用到这么大的容量（超过 Integer.MAX_VALUE），因此从使用者的体验上，就相当于 “无界”。</li></ul><h4 id="10-如何手动实现一个延迟消息队列？"><a href="#10-如何手动实现一个延迟消息队列？" class="headerlink" title="10.如何手动实现一个延迟消息队列？"></a>10.如何手动实现一个延迟消息队列？</h4><p>答：说到延迟消息队列，我们应该可以第一时间想到要使用 DelayQueue延迟队列来解决这个问题。实现思路，消息队列分为生产者和消费者，生产者用于增加消息，消费者用于获取并消费消息，我们只需要生产者把消息放入到DelayQueue 队列并设置延迟时间，消费者循环使用 take() 阻塞获取消息即可。完整的实现代码如下：</p><p>​    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomDelayQueue</span> &#123;<br>    <span class="hljs-comment">// 消息编号</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">MESSAGENO</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        DelayQueue&lt;DelayedElement&gt; delayQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayQueue</span>&lt;&gt;();<br>        <span class="hljs-comment">// 生产者1</span><br>        producer(delayQueue, <span class="hljs-string">&quot;生产者1&quot;</span>);<br>        <span class="hljs-comment">// 生产者2</span><br>        producer(delayQueue, <span class="hljs-string">&quot;生产者2&quot;</span>);<br>        <span class="hljs-comment">// 消费者</span><br>        consumer(delayQueue);<br>    &#125;<br><br>    <span class="hljs-comment">//生产者</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">producer</span><span class="hljs-params">(DelayQueue&lt;DelayedElement&gt; delayQueue, String name)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-comment">// 产生 1~5 秒的随机数</span><br>                    <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000L</span> * (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">5</span>) + <span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(time);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    <span class="hljs-comment">// 组合消息体</span><br>                    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s，消息编号：%s 发送时间：%s 延迟：%s 秒&quot;</span>,<br>                            name, MESSAGENO.getAndIncrement(), DateFormat.getDateTimeInstance().format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()), time / <span class="hljs-number">1000</span>);<br>                    <span class="hljs-comment">// 生产消息</span><br>                    delayQueue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedElement</span>(message, time));<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br><br>    <span class="hljs-comment">//消费者</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consumer</span><span class="hljs-params">(DelayQueue&lt;DelayedElement&gt; delayQueue)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-type">DelayedElement</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 消费消息</span><br>                        element = delayQueue.take();<br>                        System.out.println(element);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;).start();<br>    &#125;<br><br>    <span class="hljs-comment">// 延迟队列对象</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayedElement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Delayed</span> &#123;<br>        <span class="hljs-comment">// 过期时间（单位：毫秒）</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">time</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-comment">// 消息体</span><br>        String message;<br>        <span class="hljs-comment">// 参数：delayTime 延迟时间（单位毫秒）</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DelayedElement</span><span class="hljs-params">(String message, <span class="hljs-type">long</span> delayTime)</span> &#123;<br>            <span class="hljs-built_in">this</span>.time += delayTime;<br>            <span class="hljs-built_in">this</span>.message = message;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-comment">// 获取过期时间</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> &#123;<br>            <span class="hljs-keyword">return</span> unit.convert(time - System.currentTimeMillis(), TimeUnit.MILLISECONDS);<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-comment">// 队列元素排序</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed o)</span> &#123;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS))<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS))<br>                <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 打印消息</span><br>            <span class="hljs-keyword">return</span> message + <span class="hljs-string">&quot; |执行时间：&quot;</span> + DateFormat.getDateTimeInstance().format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上程序支持多生产者，执行的结果如下：</p><blockquote><p>生产者1，消息编号：1 发送时间：2019-6-12 20:38:37 延迟：2 秒 |执行时间：2019-6-12 20:38:39</p></blockquote><blockquote></blockquote><blockquote><p>生产者2，消息编号：2 发送时间：2019-6-12 20:38:37 延迟：2 秒 |执行时间：2019-6-12 20:38:39</p></blockquote><blockquote></blockquote><blockquote><p>生产者1，消息编号：3 发送时间：2019-6-12 20:38:41 延迟：4 秒 |执行时间：2019-6-12 20:38:45</p></blockquote><blockquote></blockquote><blockquote><p>生产者1，消息编号：5 发送时间：2019-6-12 20:38:43 延迟：2 秒 |执行时间：2019-6-12 20:38:45</p></blockquote><blockquote></blockquote><blockquote><p>……</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>队列（Queue）按照是否阻塞可分为：阻塞队列 BlockingQueue 和 非阻塞队列。其中，双端队列 Deque也属于非阻塞队列，双端队列除了拥有队列的先进先出的方法之外，还拥有自己独有的方法，如addFirst()、addLast()、getFirst()、getLast() 等，支持首未插入和删除元素。</p><p>队列中比较常用的两个队列还有PriorityQueue（优先级队列）和DelayQueue（延迟队列），可使用延迟队列来实现延迟消息队列，这也是面试中比较常考的问题之一。需要面试朋友对延迟队列一定要做到心中有数，动手写一个消息队列也是非常有必要的。</p><blockquote><p>[点击此处下载本文源码](<a href="https://github.com/vipstone/java-">https://github.com/vipstone/java-</a><br>interview/tree/master/interview-code/src/main/java/com/interview)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java面试全解析核心知识点与典型面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>win10终端设置代理</title>
    <link href="/2022/06/06/windows/win10%E7%BB%88%E7%AB%AF%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/"/>
    <url>/2022/06/06/windows/win10%E7%BB%88%E7%AB%AF%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="走代理前"><a href="#走代理前" class="headerlink" title="走代理前"></a>走代理前</h3><p><img src="1.png"></p><h3 id="走代理后"><a href="#走代理后" class="headerlink" title="走代理后"></a>走代理后</h3><p><img src="2.png"></p><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p><em>窗口一旦关闭,代理会失效,如需长期使用则考虑配置环境变量</em></p><h4 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> <span class="hljs-attribute">http_proxy</span>=http://172.16.11.39:7890<br><span class="hljs-built_in">set</span> <span class="hljs-attribute">https_proxy</span>=http://172.16.11.39:7890<br></code></pre></td></tr></table></figure><h4 id="powershell"><a href="#powershell" class="headerlink" title="powershell"></a>powershell</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">Env:http_proxy=<span class="hljs-string">&quot;http://127.0.0.1:7890&quot;</span>;<span class="hljs-variable">$Env</span>:https_proxy=<span class="hljs-string">&quot;http://127.0.0.1:7890&quot;</span></span><br><br></code></pre></td></tr></table></figure><h4 id="git-bash"><a href="#git-bash" class="headerlink" title="git bash"></a>git bash</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export http_proxy=http://172.16.11.39:7890<br>export https_proxy=http://172.16.11.39:7890<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>代理</tag>
      
      <tag>windows</tag>
      
      <tag>命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Oh My Posh插件美化PowerShell</title>
    <link href="/2022/06/04/%E4%BD%BF%E7%94%A8Oh%20My%20Posh%E6%8F%92%E4%BB%B6%E7%BE%8E%E5%8C%96PowerShell/"/>
    <url>/2022/06/04/%E4%BD%BF%E7%94%A8Oh%20My%20Posh%E6%8F%92%E4%BB%B6%E7%BE%8E%E5%8C%96PowerShell/</url>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>PowerShell 输入以下命令进行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">winget install oh-my-posh<br></code></pre></td></tr></table></figure><h4 id="设置自动启动初始化oh-my-posh"><a href="#设置自动启动初始化oh-my-posh" class="headerlink" title="设置自动启动初始化oh-my-posh"></a>设置自动启动初始化oh-my-posh</h4><p>安装完成后，为了使每次启动PowerShell后自动初始化oh-my-posh,继续在当前命令输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">notepad <span class="hljs-variable">$Profile</span><br></code></pre></td></tr></table></figure><p>添加以下内容至打开的记事本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">oh-my-posh init pwsh --config <span class="hljs-string">&quot;<span class="hljs-variable">$env</span>:POSH_THEMES_PATH\jandedobbeleer.omp.json&quot;</span> | Invoke-Expression<br></code></pre></td></tr></table></figure><h3 id="切换主题"><a href="#切换主题" class="headerlink" title="切换主题"></a>切换主题</h3><p>输入以下命令查看主题列表:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Get-PoshThemes<br></code></pre></td></tr></table></figure><p>在PowerShell终端下使用 notepad $Profile 命令打开记事本,修改完主题名称后<br>继续在当前目录 执行 .$Profile 命令 使之生效<br><img src="2.png"></p><h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><h4 id="ZLocation"><a href="#ZLocation" class="headerlink" title="ZLocation"></a>ZLocation</h4><p>使用ZLocation命令可以用关键字直接跳到想去的資料夾,比使用 cd 更快速</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Install-Module ZLocation -Scope CurrentUser<br></code></pre></td></tr></table></figure><h4 id="PSReadLine"><a href="#PSReadLine" class="headerlink" title="PSReadLine"></a>PSReadLine</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Install-Module PSReadLine<br></code></pre></td></tr></table></figure><h4 id="TERMINAL-ICONS"><a href="#TERMINAL-ICONS" class="headerlink" title="TERMINAL-ICONS"></a>TERMINAL-ICONS</h4><p>使输出的目录或文件带颜色</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Install-Module -Name Terminal-Icons -Repository PSGallery<br></code></pre></td></tr></table></figure><p>安装完以上插件后修改配置文件使之生效:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Set-PSReadLineOption -PredictionSource History # 设置预测文本来源为历史记录<br><br>Import-Module -Name Terminal-Icons<br><br>Import-Module ZLocation<br></code></pre></td></tr></table></figure><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><h4 id="1-PowerShell显示图标会乱码"><a href="#1-PowerShell显示图标会乱码" class="headerlink" title="1.PowerShell显示图标会乱码"></a>1.PowerShell显示图标会乱码</h4><p>安裝Patched字体</p><ul><li><a href="https://github.com/romkatv/dotfiles-public/raw/master/.local/share/fonts/NerdFonts/MesloLGS%20NF%20Regular.ttf">MesloLGS NF Regular.ttf</a></li><li><a href="https://github.com/romkatv/dotfiles-public/raw/master/.local/share/fonts/NerdFonts/MesloLGS%20NF%20Bold.ttf">MesloLGS NF Bold.ttf</a></li><li><a href="https://github.com/romkatv/dotfiles-public/raw/master/.local/share/fonts/NerdFonts/MesloLGS%20NF%20Italic.ttf">MesloLGS NF Italic.ttf</a></li><li><a href="https://github.com/romkatv/dotfiles-public/raw/master/.local/share/fonts/NerdFonts/MesloLGS%20NF%20Bold%20Italic.ttf">MesloLGS NF Bold Italic.ttf</a></li></ul><p>修改PowerShell的字体为刚安装的字体(MesloLGS NF),使字体生效<br><img src="1.png"></p><h4 id="2-出现以下信息显示模块安装的oh-my-posh不再支持"><a href="#2-出现以下信息显示模块安装的oh-my-posh不再支持" class="headerlink" title="2.出现以下信息显示模块安装的oh-my-posh不再支持"></a>2.出现以下信息显示模块安装的oh-my-posh不再支持</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">Hey friend<br>In an effort to grow oh-my-posh, the decision was made to no<br>longer support the PowerShell module. Over the past year, the<br>added benefit of the module disappeared, while the burden of<br>maintaining it increased.<br>However, this doesn&#x27;t mean oh-my-posh disappears from your<br>terminal, it just means that you&#x27;ll have to use a different<br>tool to install it.<br>All you need to do, is follow the migration guide here:<br>https://ohmyposh.dev/docs/migrating<br></code></pre></td></tr></table></figure><p>表示你过去是用 Install-Module 的方式安裝 Oh My Posh<br>根据迁移建议，彻底卸载，然后使用官方建议安装方式安装<br>卸载命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Uninstall-Module oh-my-posh -AllVersions<br></code></pre></td></tr></table></figure><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://ohmyposh.dev/docs/installation/windows">Install Oh My Posh on Windows</a></li><li><a href="https://www.kwchang0831.dev/dev-env/pwsh/oh-my-posh">安裝新版 Oh My Posh 與插件來美化 PowerShell</a></li><li><a href="https://www.hanselman.com/blog/my-ultimate-powershell-prompt-with-oh-my-posh-and-the-windows-terminal">My Ultimate PowerShell prompt with Oh My Posh and the Windows Terminal</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Posh</tag>
      
      <tag>PowerShell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s重启pod方式</title>
    <link href="/2022/06/04/k8s/k8s%E9%87%8D%E5%90%AFpod%E6%96%B9%E5%BC%8F/"/>
    <url>/2022/06/04/k8s/k8s%E9%87%8D%E5%90%AFpod%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="Rolling-Restart-Method"><a href="#Rolling-Restart-Method" class="headerlink" title="Rolling Restart Method"></a>Rolling Restart Method</h3><p>Kubernetes now allows you to execute a rolling restart of your deployment as of version 1.15. This is the quickest restart mechanism in Kubernetes, as it is a new addition. The command given above shuts down and restarts each container in your deployment one by one. Because most of the containers are still functioning, your app will be accessible.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl rollout restart deployment nginx-deploy<br></code></pre></td></tr></table></figure><h3 id="Environment-Variable-Method"><a href="#Environment-Variable-Method" class="headerlink" title="Environment Variable Method"></a>Environment Variable Method</h3><p>Another option is to force pods to restart and sync with your changes by setting or changing an environment variable. You can, for instance, alter the date of container deployment:</p><p>In the scenario above, set env modifies the environment variables, deployment [deployment name] selects your deployment, and DEPLOY DATE=”$(date)” modifies the deployment date and causes the pod to resume.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl set env deployment nginx-deploy DEPLOY_DATE=&quot;$(date)&quot;<br></code></pre></td></tr></table></figure><h3 id="Scale-Command-to-Change-Replicas"><a href="#Scale-Command-to-Change-Replicas" class="headerlink" title="Scale Command to Change Replicas"></a>Scale Command to Change Replicas</h3><p>You can modify the number of clones of the defective pod by using the scale command. When you set this value to 0, the pod is effectively turned off:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl scale --replicas=0 deployment nginx-deploy<br></code></pre></td></tr></table></figure><p>To restart the pod, provide the following command with a number of replicas greater than zero:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl scale --replicas=N deployment nginx-deploy<br></code></pre></td></tr></table></figure><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://linuxhint.com/kubectl-rollout-restart/">What is Kubectl Rollout Restart?</a></li><li><a href="https://vqiu.cn/kubectl-rollout-restart/">如何使用Kubectl 滚动重启应用</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>k8s</tag>
      
      <tag>pod</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BeanFactory</title>
    <link href="/2022/06/03/spring/BeanFactory/"/>
    <url>/2022/06/03/spring/BeanFactory/</url>
    
    <content type="html"><![CDATA[<p><img src="beanFactory.png"></p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>BeanFactory interface provides a simple, yet flexible configuration mechanism to manage objects of any nature via the Spring IoC container.</p><h3 id="The-BeanFactory-Interface"><a href="#The-BeanFactory-Interface" class="headerlink" title="The BeanFactory Interface"></a>The BeanFactory Interface</h3><p>It’s interesting to start by having a look at the <a href="https://github.com/spring-projects/spring-framework/blob/main/spring-beans/src/main/java/org/springframework/beans/factory/BeanFactory.java">interface definition</a> in org.springframework.beans.factory package and discuss some of its important APIs here.</p><h4 id="The-getBean-APIs"><a href="#The-getBean-APIs" class="headerlink" title="The getBean() APIs"></a>The getBean() APIs</h4><p>Various versions of <a href="https://docs.spring.io/spring-framework/docs/5.0.x/javadoc-api/org/springframework/beans/factory/BeanFactory.html#getBean-java.lang.String-">getBean()</a> method return an instance of the specified bean, which may be shared or independent across the application.</p><h4 id="The-containsBean-API"><a href="#The-containsBean-API" class="headerlink" title="The containsBean() API"></a>The containsBean() API</h4><p>This method confirms if this bean factory contains a bean with the given name. More specifically, it confirms if the <a href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/beans/factory/BeanFactory.html#getBean-java.lang.String-">getBean(java.lang.String)</a> able to obtain a bean instance with the given name.</p><h4 id="The-isSingleton-API"><a href="#The-isSingleton-API" class="headerlink" title="The isSingleton() API"></a>The isSingleton() API</h4><p>The isSingleton API can be used to query if this bean is a shared singleton. That is if <a href="https://docs.spring.io/spring-framework/docs/5.0.x/javadoc-api/org/springframework/beans/factory/BeanFactory.html#getBean-java.lang.String-">getBean(java.lang.String)</a> will always return the same instance.</p><h4 id="The-isPrototype-API"><a href="#The-isPrototype-API" class="headerlink" title="The isPrototype() API"></a>The isPrototype() API</h4><p>This API will confirm if <a href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/beans/factory/BeanFactory.html#getBean-java.lang.String-">getBean(java.lang.String)</a> returns independent instances – meaning a bean configured with the prototype scope, or not.</p><p>The important thing to note is this method returning false does not clearly indicate a singleton object. It indicates non-independent instances, which may correspond to other scopes as well.</p><p>We need to use the <a href="https://docs.spring.io/spring/docs/5.0.x/javadoc-api/org/springframework/beans/factory/BeanFactory.html#isSingleton-java.lang.String-">isSingleton(java.lang.String)</a> operation to explicitly check for a shared singleton instance.</p><h4 id="Other-APIs"><a href="#Other-APIs" class="headerlink" title="Other APIs"></a>Other APIs</h4><p>While the isTypeMatch(String name, Class targetType) method checks whether the bean with the given name matches the specified type, getType(String name) is useful in identifying the type of the bean with the given name.</p><p>Finally, getAliases(String name) return the aliases for the given bean name, if any.</p><h3 id="BeanFactory-API"><a href="#BeanFactory-API" class="headerlink" title="BeanFactory API"></a>BeanFactory API</h3><p>BeanFactory holds bean definitions and instantiates them whenever asked for by the client application – which means:</p><ul><li>It takes care of the lifecycle of a bean by instantiating it and calling appropriate destruction methods</li><li>It is capable of creating associations between dependent object while instantiating them</li><li>It is important to point that BeanFactory does not support the Annotation-based dependency Injection whereas ApplicationContext, a superset of BeanFactory does</li></ul><p>Do have a read on <a href="https://docs.spring.io/spring-framework/docs/3.0.0.M3/reference/html/ch04s08.html">Application Context</a> to find out what it can do extra.</p><h3 id="Defining-the-Bean"><a href="#Defining-the-Bean" class="headerlink" title="Defining the Bean"></a>Defining the Bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br>    <br>    <span class="hljs-comment">// standard constructors, getters and setters</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Configuring-the-BeanFactory-with-XML"><a href="#Configuring-the-BeanFactory-with-XML" class="headerlink" title="Configuring the BeanFactory with XML"></a>Configuring the BeanFactory with XML</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;employee&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.baeldung.beanfactory.Employee&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Hello! My name is Java&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span>    <br><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;employee&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;empalias&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h3 id="BeanFactory-with-ClassPathResource"><a href="#BeanFactory-with-ClassPathResource" class="headerlink" title="BeanFactory with ClassPathResource"></a>BeanFactory with ClassPathResource</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeanFactoryWithClassPathResourceTest</span> &#123;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createBeanFactoryAndCheckEmployeeBean</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Resource</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;beanfactory-example.xml&quot;</span>);<br>        <span class="hljs-type">BeanFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">XmlBeanFactory</span>(res);<br>        <span class="hljs-type">Employee</span> <span class="hljs-variable">emp</span> <span class="hljs-operator">=</span> (Employee) factory.getBean(<span class="hljs-string">&quot;employee&quot;</span>);<br><br>        assertTrue(factory.isSingleton(<span class="hljs-string">&quot;employee&quot;</span>));<br>        assertTrue(factory.getBean(<span class="hljs-string">&quot;employee&quot;</span>) <span class="hljs-keyword">instanceof</span> Employee);<br>        assertTrue(factory.isTypeMatch(<span class="hljs-string">&quot;employee&quot;</span>, Employee.class));<br>        assertTrue(factory.getAliases(<span class="hljs-string">&quot;employee&quot;</span>).length &gt; <span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><ul><li><a href="https://www.baeldung.com/spring-beanfactory">Guide to the Spring BeanFactory</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>BeanFactory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git高阶用法</title>
    <link href="/2022/06/02/git/git%E9%AB%98%E9%98%B6%E7%94%A8%E6%B3%95/"/>
    <url>/2022/06/02/git/git%E9%AB%98%E9%98%B6%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="1.jpg"></p><h3 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h3><h4 id="常用功能"><a href="#常用功能" class="headerlink" title="常用功能:"></a>常用功能:</h4><ul><li>从上游分支获取最新commit信息，并有机的将当前分支和上游分支进行合并</li><li>对当前分支的历史commit进行修改，合并，删除等操作</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>你的分支和master冲突<ul><li>如果你git merge master就会留下一个merge的commit。在这种情况下，我们推荐使用git rebase master，就能不留commit将当前分支和master有机的合并。</li></ul></li><li>之前某次提交，改错了一个变量<ul><li>如果你修改那个变量然后再提交一个commit，这显然不是最优的。如果能将某次的提交挑出来修改就好了。</li><li>当然git提供了这个功能，你可以使用git rebase -i [git-hash| head~n],其中git-hash是你要开始进行rebase的commit的hash，而head~n则是从HEAD向前推n个commit.</li></ul></li></ul><h3 id="stash"><a href="#stash" class="headerlink" title="stash"></a>stash</h3><h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><p>暂存当前没有提交的更改</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">save</span> <span class="hljs-string">保存当前更改</span><br><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">保存当前更改</span><br><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">pop</span> <span class="hljs-string">推出之前stash的内容更改</span><br><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">apply</span> <span class="hljs-string">推出之前stash的内容更改</span><br><br><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">save</span> <span class="hljs-string">--keep-index</span> <span class="hljs-string">只stash没有被add的内容</span><br><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">save</span> <span class="hljs-string">--include-untracked</span> <span class="hljs-string">stash还未加入git记录的文件</span><br><br><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">list</span> <span class="hljs-string">--stat</span> <span class="hljs-string">显示stash堆栈</span><br><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">show</span> <span class="hljs-string">stash@&#123;0&#125;</span> <span class="hljs-string">显示第x次的更改</span><br><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">show</span> <span class="hljs-string">显示最近一次stash的更改</span><br><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">show</span> <span class="hljs-string">--patch</span> <span class="hljs-string">显示最近一次stash的详细更改</span><br><br><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">save</span> <span class="hljs-string">&quot;stash msg&quot;</span><br><br><span class="hljs-string">git</span> <span class="hljs-string">stash</span> <span class="hljs-string">branch</span> <span class="hljs-string">new_brach</span> <span class="hljs-string">stash@&#123;0&#125;</span><br></code></pre></td></tr></table></figure><h4 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h4><p>当做了更改之后没有编辑完，这个时候发现线上有个bug，你需要停下当前分支去修bug，这个时候你可以提一个commit到当前分支，或则使用git stash</p><h3 id="filter-branch"><a href="#filter-branch" class="headerlink" title="filter-branch"></a>filter-branch</h3><h4 id="主要功能-1"><a href="#主要功能-1" class="headerlink" title="主要功能"></a>主要功能</h4><p>过滤所有提交记录，进行相应的操作</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">git</span> <span class="hljs-string">filter-branch</span> <span class="hljs-string">--tree-filter</span> <span class="hljs-string">&#x27;rm -rf .vscode&#x27;</span> <span class="hljs-string">删除所有分支的.vscode文件夹</span><br><span class="hljs-string">git</span> <span class="hljs-string">filter-branch</span> <span class="hljs-string">--tree-filter</span> <span class="hljs-string">&#x27;rm -f xxx&#x27;</span> <span class="hljs-string">xxx不存在，不报错</span><br><span class="hljs-string">git</span> <span class="hljs-string">filter-branch</span> <span class="hljs-string">--tree-filter</span> <span class="hljs-string">&#x27;rm -rf .vscoe&#x27;</span> <span class="hljs-string">--</span> <span class="hljs-string">--all(所有分支所有提交)</span><br><br><span class="hljs-string">git</span> <span class="hljs-string">filter-branch</span> <span class="hljs-string">--index-filter</span> <span class="hljs-string">&#x27;git rm --cached --ignore-unmatch password.txt&#x27;</span> <span class="hljs-string">(只检查password.txt</span> <span class="hljs-string">一个文件)</span><br><span class="hljs-string">git</span> <span class="hljs-string">filter-branch</span> <span class="hljs-string">-f</span> <span class="hljs-string">--prune-empty</span> <span class="hljs-string">--</span> <span class="hljs-string">--all</span><br></code></pre></td></tr></table></figure><h4 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h4><p>当发现你错误的将一个不应该提交的文件提交，然后已经过了很久，已经累计了无数次提交。<br>这个时候就可以使用git filter-branch将所有提交全部过滤一遍删除掉那个不应该提交的文件</p><h3 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h3><h4 id="主要功能-2"><a href="#主要功能-2" class="headerlink" title="主要功能"></a>主要功能</h4><p>从任何分支，抽取提交到当前分支</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">git</span> <span class="hljs-string">cherry-pick</span> <span class="hljs-string">git-hash</span> <br><br><span class="hljs-string">git</span> <span class="hljs-string">cherry-pick</span> <span class="hljs-string">--edit</span> <span class="hljs-string">git-hash</span><br><br><span class="hljs-string">pick</span> <span class="hljs-string">多个</span><br><span class="hljs-string">git</span> <span class="hljs-string">cherry-pick</span> <span class="hljs-string">--no-commit</span> <span class="hljs-string">git-hash</span> <span class="hljs-string">git-hash</span><br><br><span class="hljs-string">git</span> <span class="hljs-string">cherry-pick</span> <span class="hljs-string">-x</span> <span class="hljs-string">git-hash</span> <span class="hljs-string">(添加cherry</span> <span class="hljs-string">pick</span> <span class="hljs-string">from</span> <span class="hljs-string">那个branch)</span><br><span class="hljs-string">git</span> <span class="hljs-string">cherry-pick</span> <span class="hljs-string">--signoff</span> <span class="hljs-string">git-hash不修改author</span><br></code></pre></td></tr></table></figure><h4 id="使用场景-3"><a href="#使用场景-3" class="headerlink" title="使用场景"></a>使用场景</h4><p>当需要将多个分支上的提交合在一个分支合并到master的时候，显然如果这3个分支有关联，一次合并更为合理。<br>这个时候就可以使用git cherry-pick进行精细化的commit的操作。</p><h3 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h3><p>☐ submodule<br>☐ reflog </p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="http://hiluluke.cn/2017/07/23/git-senior/">git 高阶用法</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker网络模式</title>
    <link href="/2022/06/02/docker/docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/06/02/docker/docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="Bridge模式"><a href="#Bridge模式" class="headerlink" title="Bridge模式"></a>Bridge模式</h3><p>当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。<br>虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。<br>从docker0子网中分配一个 IP 给容器使用，并设置 docker0 的 IP 地址为容器的默认网关。<br>在主机上创建一对虚拟网卡veth pair设备，Docker 将 veth pair 设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到 docker0 网桥中。<br>bridge模式是 docker 的默认网络模式，不写–net参数，就是bridge模式。使用docker run -p时，docker 实际是在iptables做了DNAT规则，实现端口转发功能。</p><p>bridge模式如下图所示：<br><img src="1.png"></p><h3 id="Host-模式"><a href="#Host-模式" class="headerlink" title="Host 模式"></a>Host 模式</h3><p>如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个 Network Namespace。<br>容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p><p>Host模式如下图所示：<br><img src="2.png"></p><h3 id="Container-模式"><a href="#Container-模式" class="headerlink" title="Container 模式"></a>Container 模式</h3><p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p><p>Container模式示意图：<br><img src="3.png"></p><h3 id="None模式"><a href="#None模式" class="headerlink" title="None模式"></a>None模式</h3><p>使用none模式，Docker 容器拥有自己的 Network Namespace，但是，并不为Docker 容器进行任何网络配置。也就是说，这个 Docker 容器没有网卡、IP、路由等信息。需要我们自己为 Docker 容器添加网卡、配置 IP 等。</p><p>None模式示意图:<br><img src="4.png"></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://www.qikqiak.com/k8s-book/docs/7.Docker%E7%9A%84%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F.html">Docker 的网络模式</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>docker网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql索引</title>
    <link href="/2022/06/01/mysql/mysql%E7%B4%A2%E5%BC%95/"/>
    <url>/2022/06/01/mysql/mysql%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>通过使用索引(非主键索引)查询到数据后,仍需通过主键id在主键索引上查询数据的过程,称为回表</p><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>通过使用索引(非主键索引)查询到数据后,不需通过主键id在主键索引上查询数据,索引已经“覆盖了”我们的查询需求,我们称为覆盖索引<br><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段</strong></p><h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>按照最左匹配原则进行判断是否使用索引<br>创建索引（name）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">select * from user where name like &#x27;张%&#x27;; # 使用索引<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">select * from user where name like &#x27;%张&#x27;; # 未使用索引<br></code></pre></td></tr></table></figure><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>创建联合索引（name, age）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angular2html">select * from user where name like &#x27;张%&#x27; and age=10 and isMale=1;<br></code></pre></td></tr></table></figure><p>在 MySQL 5.6 之前，待找到第一个符合张前缀的用户后开始一个个回表。到主键索引上找出数据行，再对比字段值<br><img src="1.jpg"><br>而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数<br><img src="2.jpg"></p><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li>MySQL实战45讲</li><li><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">Data Structure Visualizations</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mockito 指南</title>
    <link href="/2022/05/31/Mockito-%E6%8C%87%E5%8D%97/"/>
    <url>/2022/05/31/Mockito-%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>Mockito 是一个模拟测试框架，主要功能是在单元测试中模拟类/对象的行为。</p><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://www.letianbiji.com/java-mockito/">Mockito 指南</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>IT</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mockito</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
